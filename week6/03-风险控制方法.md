---
layout: default
section: Week6
title: 03-风险控制方法
---

# 03. 风险控制方法 🛡️

> "风控做得好，睡觉没烦恼" ~ 某位幸存的量化老司机

前两节课我们学会了如何**训练和更新模型**，但是...

**模型预测准 ≠ 赚钱** 💰

如果只追求预测精度而忽视风险控制，最终可能：

- 爆仓 💥
- 回撤过大 📉
- 心态崩溃 😭
- 离开市场 👋

所以，**风险控制是量化交易的灵魂**！

---

## 🎚️ 仓位管理 (Position Sizing)

仓位管理是风险控制的第一道防线。

### 为什么需要仓位管理？

```python
# 😱 全仓梭哈的后果
def all_in_trading():
    capital = 1_000_000  # 100万
    position = capital   # 全仓买入
    
    # 市场下跌10%
    market_drop = -0.10
    new_value = position * (1 + market_drop)
    
    loss = capital - new_value
    print(f"亏损: {loss:,} 元 ({abs(market_drop)*100}%)")
    
    # 如果下跌50%，本金损失一半！
    if market_drop <= -0.50:
        print("💀 本金腰斩，翻倍需要涨100%！")
```

### 常见仓位管理方法

#### 1. 等权重 (Equal Weight)

```python
def equal_weight_allocation(n_stocks=10):
    """
    等权重分配 - 简单粗暴
    
    优点:
        ✅ 简单易懂
        ✅ 分散风险
        ✅ 避免过度集中
        
    缺点:
        ❌ 忽略个股差异
        ❌ 可能持有太多小市值股票
    """
    # 每个股票权重相同
    weight = 1.0 / n_stocks
    
    print(f"🎯 等权重分配: 每个股票 {weight*100:.1f}%")
    return {f'stock_{i}': weight for i in range(n_stocks)}
```

#### 2. 风险平价 (Risk Parity)

```python
import numpy as np
import pandas as pd

def risk_parity_allocation(returns, target_risk=0.15):
    """
    风险平价分配 - 让每个股票贡献相同的风险
    
    核心思想:
        - 不是按市值分配
        - 不是等权重分配
        - 而是按风险贡献分配
    
    数学原理:
        $w_i \cdot \sigma_i \cdot \sum w_j \sigma_{ij} = \text{constant}$
    """
    # 计算协方差矩阵
    cov_matrix = returns.cov()
    
    # 初始权重（等权重）
    n_assets = len(returns.columns)
    weights = np.ones(n_assets) / n_assets
    
    # 迭代优化
    for _ in range(100):
        # 计算每个资产的风险贡献
        portfolio_vol = np.sqrt(weights.T @ cov_matrix @ weights)
        marginal_contrib = cov_matrix @ weights
        contrib = weights * marginal_contrib / portfolio_vol
        
        # 调整权重，使风险贡献相等
        weights_new = 1.0 / contrib
        weights = weights_new / weights_new.sum()
    
    # 计算实际风险
    actual_risk = np.sqrt(weights.T @ cov_matrix @ weights)
    
    # 调整到目标风险
    weights = weights * (target_risk / actual_risk)
    
    # 返回权重字典
    weight_dict = dict(zip(returns.columns, weights))
    
    print(f"🎯 风险平价分配:")
    print(f"  目标风险: {target_risk:.2%}")
    print(f"  实际风险: {actual_risk:.2%}")
    print(f"  前5大权重:")
    top_weights = sorted(weight_dict.items(), key=lambda x: x[1], reverse=True)[:5]
    for stock, w in top_weights:
        print(f"    {stock}: {w*100:.2f}%")
    
    return weight_dict
```

#### 3. 价值加权 (Value Weighted)

```python
def value_weighted_allocation(prices, market_caps):
    """
    价值加权分配 - 按市值分配权重
    
    优点:
        ✅ 反映市场结构
        ✅ 减少小市值股票的流动性风险
        
    缺点:
        ❌ 大市值股票权重过高
        ❌ 可能错过小市值股票的机会
    """
    # 计算权重
    total_cap = market_caps.sum()
    weights = market_caps / total_cap
    
    # 返回权重字典
    weight_dict = dict(zip(prices.columns, weights))
    
    print(f"🎯 价值加权分配:")
    print(f"  前5大权重:")
    top_weights = sorted(weight_dict.items(), key=lambda x: x[1], reverse=True)[:5]
    for stock, w in top_weights:
        cap = market_caps[stock]
        print(f"    {stock}: {w*100:.2f}% (市值: {cap/1e9:.1f}亿)")
    
    return weight_dict
```

#### 4. Kelly公式 (Kelly Criterion)

```python
def kelly_allocation(win_rate, avg_win, avg_loss, leverage=1.0):
    """
    Kelly公式分配 - 根据历史表现分配仓位
    
    核心公式:
        $$ f^* = \frac{p}{q} - \frac{q}{b} $$
        
    其中:
        - f*: 最优仓位比例
        - p: 胜率
        - q: 败率 (1-p)
        - b: 盈亏比 (平均盈利 / 平均亏损)
    """
    p = win_rate
    q = 1 - p
    b = avg_win / abs(avg_loss)
    
    # Kelly公式
    f_star = p - q / b
    
    # 限制杠杆
    f_star = min(f_star, leverage)
    
    print(f"🎯 Kelly公式分配:")
    print(f"  胜率: {p:.2%}")
    print(f"  盈亏比: {b:.2f}")
    print(f"  最优仓位: {f_star:.2%}")
    
    return f_star

# 使用示例
win_rate = 0.55
avg_win = 0.05
avg_loss = -0.04

optimal_position = kelly_allocation(win_rate, avg_win, avg_loss)
```

### 仓位管理最佳实践

```python
class PositionManager:
    """仓位管理器 - 你的风险管理专家 👨‍💼"""
    
    def __init__(self, max_position=0.1, max_total=1.0, method='equal_weight'):
        """
        初始化仓位管理器
        
        Args:
            max_position: 单只股票最大仓位
            max_total: 总仓位上限
            method: 分配方法
        """
        self.max_position = max_position
        self.max_total = max_total
        self.method = method
        
    def calculate_weights(self, predictions, prices=None, market_caps=None):
        """
        计算权重
        
        Args:
            predictions: 预测分数
            prices: 价格数据（某些方法需要）
            market_caps: 市值数据（某些方法需要）
            
        Returns:
            权重字典
        """
        if self.method == 'equal_weight':
            weights = self._equal_weight(len(predictions))
        
        elif self.method == 'risk_parity':
            weights = self._risk_parity(predictions)
        
        elif self.method == 'value_weight':
            if market_caps is None:
                raise ValueError("价值加权需要市值数据")
            weights = self._value_weight(predictions, market_caps)
        
        elif self.method == 'score_weight':
            weights = self._score_weight(predictions)
        
        else:
            raise ValueError(f"未知的分配方法: {self.method}")
        
        # 应用限制
        weights = self._apply_constraints(weights)
        
        return weights
    
    def _equal_weight(self, n_stocks):
        """等权重"""
        weight = min(1.0 / n_stocks, self.max_position)
        weights = {f'stock_{i}': weight for i in range(n_stocks)}
        return weights
    
    def _score_weight(self, predictions):
        """根据预测分数分配权重"""
        # 将预测分数归一化到正数
        predictions = predictions - predictions.min()
        predictions = predictions / predictions.sum()
        
        # 转换为字典
        weights = dict(zip(predictions.index, predictions.values))
        return weights
    
    def _apply_constraints(self, weights):
        """应用仓位限制"""
        # 限制单只股票最大仓位
        weights = {k: min(v, self.max_position) for k, v in weights.items()}
        
        # 如果总仓位超过上限，按比例缩减
        total = sum(weights.values())
        if total > self.max_total:
            scale = self.max_total / total
            weights = {k: v * scale for k, v in weights.items()}
        
        return weights
```

---

## 🛑 止损策略 (Stop Loss)

止损是防止大额亏损的重要工具。

### 止损类型

#### 1. 固定止损 (Fixed Stop Loss)

```python
def fixed_stop_loss(entry_price, current_price, stop_loss_percent=0.05):
    """
    固定止损 - 简单直接
    
    设置固定比例的止损点
    """
    # 计算止损价
    stop_loss_price = entry_price * (1 - stop_loss_percent)
    
    # 判断是否触发止损
    should_exit = current_price <= stop_loss_price
    
    if should_exit:
        loss = (current_price - entry_price) / entry_price
        print(f"🚨 触发固定止损!")
        print(f"  入场价: {entry_price:.2f}")
        print(f"  止损价: {stop_loss_price:.2f}")
        print(f"  当前价: {current_price:.2f}")
        print(f"  亏损: {loss:.2%}")
    
    return should_exit
```

#### 2. 追踪止损 (Trailing Stop Loss)

```python
def trailing_stop_loss(prices, trailing_percent=0.10):
    """
    追踪止损 - 锁定利润
    
    止损价随着价格上涨而上移
    但不会随着价格下跌而下调
    """
    stop_loss_price = prices[0] * (1 - trailing_percent)
    max_price = prices[0]
    
    for i, price in enumerate(prices[1:], 1):
        # 更新最高价
        max_price = max(max_price, price)
        
        # 更新止损价（只向上移）
        stop_loss_price = max(stop_loss_price, max_price * (1 - trailing_percent))
        
        # 判断是否触发止损
        if price <= stop_loss_price:
            print(f"🚨 触发追踪止损!")
            print(f"  最高价: {max_price:.2f}")
            print(f"  止损价: {stop_loss_price:.2f}")
            print(f"  当前价: {price:.2f}")
            print(f"  利润: {(price - prices[0]) / prices[0]:.2%}")
            return True, i
    
    return False, len(prices)
```

#### 3. 动态止损 (Dynamic Stop Loss)

```python
def dynamic_stop_loss(entry_price, current_price, volatility, 
                      multiplier=2.0):
    """
    动态止损 - 根据波动率调整
    
    波动率大时，止损幅度大
    波动率小时，止损幅度小
    """
    # 根据波动率计算止损幅度
    stop_loss_percent = volatility * multiplier
    
    # 计算止损价
    stop_loss_price = entry_price * (1 - stop_loss_percent)
    
    # 判断是否触发止损
    should_exit = current_price <= stop_loss_price
    
    if should_exit:
        loss = (current_price - entry_price) / entry_price
        print(f"🚨 触发动态止损!")
        print(f"  入场价: {entry_price:.2f}")
        print(f"  波动率: {volatility:.2%}")
        print(f"  止损价: {stop_loss_price:.2f}")
        print(f"  当前价: {current_price:.2f}")
        print(f"  亏损: {loss:.2%}")
    
    return should_exit
```

### 止损策略管理器

```python
class StopLossManager:
    """止损管理器 - 你的止损管家 🛡️"""
    
    def __init__(self, stop_loss_type='fixed', stop_loss_percent=0.05, 
                 trailing_percent=0.10):
        """
        初始化止损管理器
        
        Args:
            stop_loss_type: 止损类型 ('fixed', 'trailing', 'dynamic')
            stop_loss_percent: 固定止损比例
            trailing_percent: 追踪止损比例
        """
        self.stop_loss_type = stop_loss_type
        self.stop_loss_percent = stop_loss_percent
        self.trailing_percent = trailing_percent
        self.positions = {}
        
    def open_position(self, symbol, entry_price):
        """开仓"""
        self.positions[symbol] = {
            'entry_price': entry_price,
            'max_price': entry_price,
            'stop_loss_price': entry_price * (1 - self.stop_loss_percent)
        }
        print(f"📥 开仓: {symbol} @ {entry_price:.2f}")
    
    def check_stop_loss(self, symbol, current_price, volatility=None):
        """
        检查是否触发止损
        
        Returns:
            True: 触发止损
            False: 未触发止损
        """
        if symbol not in self.positions:
            return False
        
        position = self.positions[symbol]
        
        # 更新最高价
        position['max_price'] = max(position['max_price'], current_price)
        
        if self.stop_loss_type == 'fixed':
            # 固定止损
            should_exit = current_price <= position['stop_loss_price']
        
        elif self.stop_loss_type == 'trailing':
            # 追踪止损
            new_stop_loss = position['max_price'] * (1 - self.trailing_percent)
            position['stop_loss_price'] = max(position['stop_loss_price'], new_stop_loss)
            should_exit = current_price <= position['stop_loss_price']
        
        elif self.stop_loss_type == 'dynamic':
            # 动态止损
            if volatility is None:
                raise ValueError("动态止损需要波动率数据")
            stop_loss_percent = volatility * 2.0
            position['stop_loss_price'] = position['entry_price'] * (1 - stop_loss_percent)
            should_exit = current_price <= position['stop_loss_price']
        
        else:
            raise ValueError(f"未知的止损类型: {self.stop_loss_type}")
        
        if should_exit:
            self._log_stop_loss(symbol, position, current_price)
            self.close_position(symbol)
        
        return should_exit
    
    def _log_stop_loss(self, symbol, position, current_price):
        """记录止损信息"""
        entry_price = position['entry_price']
        loss = (current_price - entry_price) / entry_price
        
        print(f"🚨 触发止损: {symbol}")
        print(f"  入场价: {entry_price:.2f}")
        print(f"  止损价: {position['stop_loss_price']:.2f}")
        print(f"  当前价: {current_price:.2f}")
        print(f"  亏损: {loss:.2%}")
    
    def close_position(self, symbol):
        """平仓"""
        if symbol in self.positions:
            del self.positions[symbol]
            print(f"📤 平仓: {symbol}")
    
    def get_positions(self):
        """获取当前持仓"""
        return self.positions.copy()
```

---

## ⚖️ 行业中性化 (Industry Neutralization)

行业中性化是防止行业暴露过大的重要手段。

### 为什么需要行业中性化？

```python
# 🤔 问题场景
def industry_exposure_problem():
    """行业暴露过大的问题"""
    
    portfolio = {
        '科技股': 0.60,  # 60%仓位
        '消费股': 0.20,  # 20%仓位
        '金融股': 0.15,  # 15%仓位
        '其他': 0.05     # 5%仓位
    }
    
    # 假设市场权重
    market_weights = {
        '科技股': 0.30,  # 市场30%
        '消费股': 0.25,  # 市场25%
        '金融股': 0.20,  # 市场20%
        '其他': 0.25     # 市场25%
    }
    
    # 计算行业暴露
    exposure = {}
    for industry in portfolio:
        exposure[industry] = portfolio[industry] - market_weights[industry]
    
    print("📊 行业暴露分析:")
    for industry, exp in exposure.items():
        if exp > 0.10:
            print(f"  ⚠️ {industry}: 超配 {exp:.1%} (风险过高！)")
        elif exp < -0.10:
            print(f"  ⚠️ {industry}: 低配 {exp:.1%} (可能错过机会)")
        else:
            print(f"  ✅ {industry}: 暴露 {exp:.1%} (正常)")
```

### 行业中性化实现

```python
import pandas as pd

def industry_neutralize(predictions, industry_mapping, method='simple'):
    """
    行业中性化
    
    Args:
        predictions: 原始预测分数 (Series, index为股票代码)
        industry_mapping: 行业映射字典 {股票代码: 行业}
        method: 中性化方法 ('simple', 'regression')
        
    Returns:
        中性化后的预测分数
    """
    if method == 'simple':
        # 方法1: 简单减去行业均值
        industry_demeaned = predictions.copy()
        
        for industry in set(industry_mapping.values()):
            # 获取该行业的股票
            industry_stocks = [stock for stock, ind in industry_mapping.items() 
                              if ind == industry and stock in predictions.index]
            
            if len(industry_stocks) > 0:
                # 计算行业均值
                industry_mean = predictions[industry_stocks].mean()
                
                # 减去行业均值
                industry_demeaned[industry_stocks] -= industry_mean
        
        return industry_demeaned
    
    elif method == 'regression':
        # 方法2: 回归残差法
        from sklearn.linear_model import LinearRegression
        
        # 创建行业哑变量
        industries = list(set(industry_mapping.values()))
        industry_dummies = pd.DataFrame(0, index=predictions.index, columns=industries)
        
        for stock, industry in industry_mapping.items():
            if stock in predictions.index:
                industry_dummies.loc[stock, industry] = 1
        
        # 线性回归
        X = industry_dummies.values
        y = predictions.values
        
        model = LinearRegression()
        model.fit(X, y)
        
        # 计算残差
        residuals = y - model.predict(X)
        
        neutralized = pd.Series(residuals, index=predictions.index)
        
        return neutralized
    
    else:
        raise ValueError(f"未知的中性化方法: {method}")
```

### 行业中性化实战

```python
class IndustryNeutralizer:
    """行业中性化器"""
    
    def __init__(self, industry_mapping):
        """
        初始化
        
        Args:
            industry_mapping: 行业映射 {股票代码: 行业}
        """
        self.industry_mapping = industry_mapping
        self.industries = list(set(industry_mapping.values()))
        
    def neutralize(self, predictions, target_weights=None):
        """
        中性化预测分数
        
        Args:
            predictions: 预测分数
            target_weights: 目标行业权重（如果None，则等权重）
            
        Returns:
            中性化后的分数
        """
        # 如果没有指定目标权重，使用等权重
        if target_weights is None:
            target_weights = {ind: 1.0/len(self.industries) 
                              for ind in self.industries}
        
        # 计算当前行业权重
        current_weights = {}
        for industry in self.industries:
            industry_stocks = [stock for stock, ind in self.industry_mapping.items() 
                              if ind == industry and stock in predictions.index]
            
            if len(industry_stocks) > 0:
                current_weights[industry] = predictions[industry_stocks].sum()
            else:
                current_weights[industry] = 0
        
        # 归一化
        total = sum(current_weights.values())
        if total > 0:
            current_weights = {k: v/total for k, v in current_weights.items()}
        
        # 调整权重
        neutralized = predictions.copy()
        for industry in self.industries:
            industry_stocks = [stock for stock, ind in self.industry_mapping.items() 
                              if ind == industry and stock in predictions.index]
            
            if len(industry_stocks) > 0:
                # 计算调整因子
                adjustment = (target_weights[industry] - current_weights[industry]) / len(industry_stocks)
                
                # 应用调整
                neutralized[industry_stocks] += adjustment
        
        # 确保非负
        neutralized = neutralized.clip(lower=0)
        
        # 归一化
        neutralized = neutralized / neutralized.sum()
        
        return neutralized
    
    def get_industry_exposure(self, weights):
        """获取行业暴露"""
        exposure = {}
        
        for industry in self.industries:
            industry_stocks = [stock for stock, ind in self.industry_mapping.items() 
                              if ind == industry and stock in weights.index]
            
            if len(industry_stocks) > 0:
                exposure[industry] = weights[industry_stocks].sum()
            else:
                exposure[industry] = 0
        
        return exposure
```

---

## 🎯 分散化投资 (Diversification)

分散化是降低风险的终极武器。

### 分散化原理

```python
# 分散化的数学原理
import numpy as np

def diversification_benefit():
    """分散化效益演示"""
    
    # 单个资产的波动率
    vol_a = 0.20  # 20%
    vol_b = 0.20  # 20%
    
    # 不同相关性的组合波动率
    correlations = [-1.0, -0.5, 0.0, 0.5, 1.0]
    
    print("📊 分散化效益:")
    print(f"  资产A波动率: {vol_a:.1%}")
    print(f"  资产B波动率: {vol_b:.1%}")
    print(f"  等权重组合波动率:\n")
    
    for corr in correlations:
        # 组合波动率公式
        # σ_p = sqrt(w_a^2 * σ_a^2 + w_b^2 * σ_b^2 + 2 * w_a * w_b * ρ * σ_a * σ_b)
        w_a = w_b = 0.5
        vol_p = np.sqrt(w_a**2 * vol_a**2 + w_b**2 * vol_b**2 + 
                       2 * w_a * w_b * corr * vol_a * vol_b)
        
        reduction = 1 - vol_p / vol_a
        
        print(f"    相关性 {corr:+4.1f}: {vol_p:.1%} (降低 {reduction:.1%})")

diversification_benefit()
```

### 分散化策略

#### 1. 资产分散化

```python
def asset_diversification(returns, max_allocation=0.30):
    """
    资产分散化
    
    限制单一资产的最大权重
    """
    # 计算等权重
    n_assets = len(returns.columns)
    weights = np.ones(n_assets) / n_assets
    
    # 限制最大权重
    weights = np.minimum(weights, max_allocation)
    
    # 重新归一化
    weights = weights / weights.sum()
    
    return dict(zip(returns.columns, weights))
```

#### 2. 行业分散化

```python
def industry_diversification(stocks, industry_mapping, max_per_industry=0.30):
    """
    行业分散化
    
    限制单一行业的最大权重
    """
    # 初始化权重
    weights = np.ones(len(stocks)) / len(stocks)
    
    # 计算每个行业的权重
    industry_weights = {}
    for industry in set(industry_mapping.values()):
        industry_stocks = [i for i, stock in enumerate(stocks) 
                          if industry_mapping.get(stock) == industry]
        
        if industry_stocks:
            industry_weights[industry] = sum(weights[i] for i in industry_stocks)
    
    # 调整权重
    for industry, weight in industry_weights.items():
        if weight > max_per_industry:
            # 按比例缩减
            scale = max_per_industry / weight
            
            industry_stocks = [i for i, stock in enumerate(stocks) 
                             if industry_mapping.get(stock) == industry]
            for i in industry_stocks:
                weights[i] *= scale
    
    # 重新归一化
    weights = weights / weights.sum()
    
    return dict(zip(stocks, weights))
```

#### 3. 分批建仓 (Staged Entry)

```python
def staged_entry(total_position, n_stages=5, days=5):
    """
    分批建仓
    
    将总仓位分多天逐步建仓
    """
    # 计算每批大小
    stage_size = total_position / n_stages
    
    # 建仓计划
    entry_plan = {}
    for i in range(n_stages):
        day = i * days
        entry_plan[f'Day_{day}'] = stage_size
    
    print(f"📅 分批建仓计划:")
    print(f"  总仓位: {total_position:.1%}")
    print(f"  分 {n_stages} 批，每 {days} 天一批")
    print(f"  每批大小: {stage_size:.1%}\n")
    
    for day, size in entry_plan.items():
        print(f"    {day}: {size:.1%}")
    
    return entry_plan
```

---

## 🎬 综合风控系统

把所有风控手段整合起来！

```python
class RiskControlSystem:
    """综合风控系统 - 你的风险防御堡垒 🏰"""
    
    def __init__(self, position_manager, stop_loss_manager, 
                 industry_neutralizer=None):
        """
        初始化风控系统
        
        Args:
            position_manager: 仓位管理器
            stop_loss_manager: 止损管理器
            industry_neutralizer: 行业中性化器（可选）
        """
        self.position_manager = position_manager
        self.stop_loss_manager = stop_loss_manager
        self.industry_neutralizer = industry_neutralizer
        
    def generate_portfolio(self, predictions, prices, market_caps=None, 
                         volatilities=None, industry_mapping=None):
        """
        生成投资组合
        
        Args:
            predictions: 预测分数
            prices: 价格数据
            market_caps: 市值数据（可选）
            volatilities: 波动率数据（可选）
            industry_mapping: 行业映射（可选）
            
        Returns:
            投资组合权重
        """
        print("\n🛡️ 开始风控分析...")
        
        # 1. 计算初始权重
        print("\n[步骤1/5] 计算初始权重...")
        initial_weights = self.position_manager.calculate_weights(
            predictions,
            prices=prices,
            market_caps=market_caps
        )
        
        # 2. 行业中性化
        if self.industry_neutralizer is not None and industry_mapping is not None:
            print("\n[步骤2/5] 行业中性化...")
            weights = self.industry_neutralizer.neutralize(
                pd.Series(initial_weights),
                industry_mapping=industry_mapping
            )
        else:
            weights = pd.Series(initial_weights)
        
        # 3. 分散化检查
        print("\n[步骤3/5] 分散化检查...")
        top_weight = weights.max()
        if top_weight > 0.15:
            print(f"  ⚠️ 最大权重 {top_weight:.1%}，建议分散")
        else:
            print(f"  ✅ 最大权重 {top_weight:.1%}，分散度良好")
        
        # 4. 风险评估
        print("\n[步骤4/5] 风险评估...")
        n_stocks = (weights > 0).sum()
        print(f"  持股数量: {n_stocks}")
        
        if n_stocks < 10:
            print(f"  ⚠️ 持股数量较少，建议增加分散")
        else:
            print(f"  ✅ 持股数量合理")
        
        # 5. 返回结果
        print("\n[步骤5/5] 完成！")
        return weights
    
    def monitor_positions(self, current_prices, volatilities=None):
        """
        监控持仓，检查是否触发止损
        
        Args:
            current_prices: 当前价格
            volatilities: 当前波动率（可选）
        """
        print("\n👁️ 监控持仓...")
        
        positions = self.stop_loss_manager.get_positions()
        
        if not positions:
            print("  ✅ 无持仓")
            return
        
        for symbol in positions:
            if symbol in current_prices:
                price = current_prices[symbol]
                vol = volatilities.get(symbol) if volatilities else None
                
                # 检查止损
                should_exit = self.stop_loss_manager.check_stop_loss(
                    symbol, price, vol
                )
                
                if should_exit:
                    print(f"  🚨 {symbol} 触发止损！")
                else:
                    print(f"  ✅ {symbol} 正常")
```

---

## 📝 本节小结

**核心要点**：

1. ✅ 仓位管理是风控的第一道防线
2. ✅ 止损是防止大额亏损的重要工具
3. ✅ 行业中性化防止行业暴露过大
4. ✅ 分散化是降低风险的终极武器
5. ✅ 综合运用多种风控手段

**风控三原则**：

```python
risk_principles = {
    "原则1": "不要把鸡蛋放在一个篮子里",  # 分散化
    "原则2": "小亏不怕，大亏要命",         # 止损
    "原则3": "活着比赚钱重要"             # 生存第一
}
```

**下一步**：学会了风控，如何**集成多个模型**来提升效果呢？

[→ 前往 04-集成策略原理](04-集成策略原理.md)

---

**🛡️ 记住：风控做得好，睡觉没烦恼！下节课学习集成策略，让效果更上一层楼！**
