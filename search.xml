<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>死磕以太坊源码|以太坊启动流程</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码|以太坊启动流程</p>
<p>文章以及资料（开源）：<a href="https://github.com/mindcarver/blockchain_guide">github地址</a>  </p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6tgnjvkhj20jg0c6mxi.jpg" alt="9ff239564d5d1129fa544f25d95c7468"></p>
<h1 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h1><p>以太坊是如何启动一个网络节点的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./geth --datadir &quot;../data0&quot; --nodekeyhex &quot;27aa615f5fa5430845e4e97229def5f23e9525a20640cc49304f40f3b43824dc&quot; --bootnodes $enodeid --mine --debug --metrics --syncmode=&quot;full&quot; --gcmode=archive  --gasprice 0 --port 30303 --rpc --rpcaddr &quot;0.0.0.0&quot; --rpcport 8545 --rpcapi &quot;db,eth,net,web3,personal&quot; --nat any --allow-insecure-unlock  2&gt;&gt;log 1&gt;&gt;log 0&gt;&gt;log &gt;&gt;log &amp;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>geth : 编译好的geth程序，可以起别名</li>
<li>datadir：数据库和keystore密钥的数据目录</li>
<li>nodekeyhex: 十六进制的P2P节点密钥</li>
<li>bootnodes:用于P2P发现引导的enode urls</li>
<li>mine：打开挖矿</li>
<li>debug:突出显示调用位置日志(文件名及行号)</li>
<li>metrics: 启用metrics收集和报告</li>
<li>syncmode:同步模式 (“fast”, “full”, or “light”)</li>
<li>gcmode:表示即时将内存中的数据写入到文件中，否则重启节点可能会导致区块高度归零而丢失数据</li>
<li>gasprice:挖矿接受交易的最低gas价格</li>
<li>port:网卡监听端口(默认值:30303)</li>
<li>rpc:启用HTTP-RPC服务器</li>
<li>rpcaddr:HTTP-RPC服务器接口地址(默认值:“localhost”)</li>
<li>rpcport:HTTP-RPC服务器监听端口(默认值:8545)</li>
<li>rpcapi:基于HTTP-RPC接口提供的API</li>
<li>nat: NAT端口映射机制 (any|none|upnp|pmp|extip:<IP>) (默认: “any”)</li>
<li>allow-insecure-unlock:用于解锁账户</li>
</ul>
<p>详细的以太坊启动参数可以参考我的以太坊理论系列，里面有对参数的详细解释。</p>
<hr>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>geth</code>位于<code>cmd/geth/main.go</code>文件中，入口如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmkul302pj31gu0mcnd2.jpg" alt="image-20201012152238541"></p>
<p>我们通过这张图可以看出来：main()并不是真正意义上的入口，在初始化完常量和变量以后，会先调用模块的init()函数，然后才是main()函数。所以初始化的工作是在init()函数里完成的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize the CLI app and start Geth</span></span><br><span class="line">	app.Action = geth</span><br><span class="line">	app.HideVersion = <span class="literal">true</span> <span class="comment">// we have a command to print the version</span></span><br><span class="line">	app.Copyright = <span class="string">&quot;Copyright 2013-2019 The go-ethereum Authors&quot;</span></span><br><span class="line">	app.Commands = []cli.Command&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从这我们找到了入口函数geth:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<ol>
<li>准备操作内存缓存配额并设置度量系统</li>
<li>加载配置和注册服务</li>
<li>启动节点</li>
<li>守护当前线程</li>
</ol>
<h2 id="加载配置和注册服务"><a href="#加载配置和注册服务" class="headerlink" title="加载配置和注册服务"></a>加载配置和注册服务</h2><p>makeFullNode</p>
<h3 id="1-加载配置"><a href="#1-加载配置" class="headerlink" title="1.加载配置"></a>1.加载配置</h3><p>makeConfigNode</p>
<p>首先加载默认配置(作为主网节点启动)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := gethConfig&#123;</span><br><span class="line">		Eth:  eth.DefaultConfig,</span><br><span class="line">		Shh:  whisper.DefaultConfig,</span><br><span class="line">		Node: defaultNodeConfig(),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>eth.DefaultConfig</strong> : 以太坊节点的主要参数配置。主要包括: 同步模式(fast)、chainid、交易池配置、gasprice、挖矿配置等；</li>
<li><strong>whisper.DefaultConfig</strong> : 主要用于配置网络间通讯；</li>
<li><strong>defaultNodeConfig()</strong> : 主要用于配置对外提供的RPC节点服务；</li>
<li><strong>dashboard.DefaultConfig</strong> : 主要用于对外提供看板数据访问服务。</li>
</ul>
<p>接着加载自定义配置（适用私有链）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> file := ctx.GlobalString(configFileFlag.Name); file != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := loadConfig(file, &amp;cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后加载命令窗口参数（开发阶段）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">utils.SetNodeConfig(ctx, &amp;cfg.Node) <span class="comment">// 本地节点配置</span></span><br><span class="line">utils.SetEthConfig(ctx, stack, &amp;cfg.Eth)<span class="comment">// 以太坊配置</span></span><br><span class="line">utils.SetShhConfig(ctx, stack, &amp;cfg.Shh)<span class="comment">// whisper配置</span></span><br></pre></td></tr></table></figure>

<h3 id="2-RegisterEthService"><a href="#2-RegisterEthService" class="headerlink" title="2.RegisterEthService"></a>2.RegisterEthService</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterEthService</span><span class="params">(stack *node.Node, cfg *eth.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> cfg.SyncMode == downloader.LightSync &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			fullNode, err := eth.New(ctx, cfg)</span><br><span class="line">			<span class="keyword">if</span> fullNode != <span class="literal">nil</span> &amp;&amp; cfg.LightServ &gt; <span class="number">0</span> &#123;</span><br><span class="line">				ls, _ := les.NewLesServer(fullNode, cfg)</span><br><span class="line">				fullNode.AddLesServer(ls)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fullNode, err</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">&quot;Failed to register the Ethereum service: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了两个新类型：ServiceContext和Service。</p>
<p>先看一下ServiceContext的定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         *Config</span><br><span class="line">	services       <span class="keyword">map</span>[reflect.Type]Service <span class="comment">// Index of the already constructed services</span></span><br><span class="line">	EventMux       *event.TypeMux           <span class="comment">// Event multiplexer used for decoupled notifications</span></span><br><span class="line">	AccountManager *accounts.Manager        <span class="comment">// Account manager created by the node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceContext主要是存储了一些从结点（或者叫协议栈）那里继承过来的、和具体Service无关的一些信息，比如结点config、account manager等。其中有一个services字段保存了当前正在运行的所有Service.</p>
<p>接下来看一下Service的定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Protocols retrieves the P2P protocols the service wishes to start.</span></span><br><span class="line">	<span class="comment">// 协议检索服务希望启动的P2P协议</span></span><br><span class="line">	Protocols() []p2p.Protocol</span><br><span class="line"></span><br><span class="line">	<span class="comment">// APIs retrieves the list of RPC descriptors the service provides</span></span><br><span class="line">	<span class="comment">// API检索服务提供的RPC描述符列表</span></span><br><span class="line">	APIs() []rpc.API</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start is called after all services have been constructed and the networking</span></span><br><span class="line">	<span class="comment">// layer was also initialized to spawn any goroutines required by the service.</span></span><br><span class="line">	<span class="comment">//在所有服务都已构建完毕并且网络层也已初始化以生成服务所需的所有goroutine之后，将调用start。</span></span><br><span class="line">	Start(server *p2p.Server) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop terminates all goroutines belonging to the service, blocking until they</span></span><br><span class="line">	<span class="comment">// are all terminated.</span></span><br><span class="line">	<span class="comment">//Stop终止属于该服务的所有goroutine，直到它们全部终止为止一直阻塞。</span></span><br><span class="line">	Stop() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务注册过程中，主要注册四个服务：EthService、DashboardService、ShhService、EthStatsService，这四种服务类均扩展自Service接口。其中，EthService根据同步模式的不同，分为两种实现：</p>
<ul>
<li>LightEthereum，支持LightSync模式</li>
<li>Ethereum，支持FullSync、FastSync模式</li>
</ul>
<p>LightEthereum作为轻客户端，与Ethereum区别在于，它只需要更新区块头。当需要查询区块体数据时，需要通过调用其他全节点的les服务进行查询；另外，轻客户端本身是不能进行挖矿的。</p>
<p>回到RegisterEthService代码，分两个来讲：</p>
<p>LightSync同步：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx *node.ServiceContext, config *eth.Config)</span></span> (*LightEthereum, <span class="type">error</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="number">1.</span>ctx.OpenDatabase <span class="comment">// 创建leveldb数据库</span></span><br><span class="line">  <span class="number">2.</span>core.SetupGenesisBlockWithOverride<span class="comment">// 根据创世配置初始化链数据目录</span></span><br><span class="line">  <span class="number">3.</span>实例化本地链id、共识引擎、注册peer节点、帐户管理器以及布隆过滤器的初始化</span><br><span class="line">  <span class="number">4.</span>light.NewLightChain<span class="comment">// 使用数据库中可用的信息返回完全初始化的轻链。它初始化默认的以太坊头</span></span><br><span class="line">  <span class="number">5.</span>light.NewTxPool <span class="comment">// 实例化交易池NewTxPool</span></span><br><span class="line">  <span class="number">6.</span>leth.ApiBackend = &amp;LesApiBackend&#123;ctx.ExtRPCEnabled(), leth, <span class="literal">nil</span>&#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FullSync&#x2F;Fast同步：</p>
<ol>
<li><p>参数校验</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> config.SyncMode == downloader.LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> !config.SyncMode.IsValid() &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.Miner.GasPrice == <span class="literal">nil</span> || config.Miner.GasPrice.Cmp(common.Big0) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.NoPruning &amp;&amp; config.TrieDirtyCache &gt; <span class="number">0</span> &#123;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>打开数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx.OpenDatabaseWithFreezer</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据创世配置初始化链数据目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.SetupGenesisBlockWithOverride</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化Ethereum对象</p>
</li>
<li><p>创建BlockChain实例对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.NewBlockChain</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.NewTxPool</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化协议管理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">NewProtocolManager(...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化对外API服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;EthAPIBackend&#123;ctx.ExtRPCEnabled(), eth, <span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-RegisterShhService"><a href="#3-RegisterShhService" class="headerlink" title="3.RegisterShhService"></a>3.RegisterShhService</h3><p>注册Whisper服务，用于p2p网络间加密通信。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">whisper.New(cfg), <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RegisterEthStatsService"><a href="#4-RegisterEthStatsService" class="headerlink" title="4.RegisterEthStatsService"></a>4.RegisterEthStatsService</h3><p>注册状态推送服务,将当前以太坊网络状态推送至指定URL地址.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ethstats.New(url, ethServ, lesServ)</span><br></pre></td></tr></table></figure>

<h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><p>启动本地节点以及启动所有注册的服务。</p>
<h3 id="1-启动节点"><a href="#1-启动节点" class="headerlink" title="1.启动节点"></a>1.启动节点</h3><p>startNode</p>
<h4 id="1-1-stack-Start"><a href="#1-1-stack-Start" class="headerlink" title="1.1 stack.Start()"></a>1.1 stack.Start()</h4><ol>
<li><p>实例化p2p.Server对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为注册的服务创建上下文</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">  ctx := &amp;ServiceContext&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收集协议并启动新组装的p2p server</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">  <span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后启动配置的RPC接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n.startRPC(services)</span><br></pre></td></tr></table></figure>

<ul>
<li>startInProc (启动进程内通讯服务)</li>
<li>startIPC （启动IPC RPC端点）</li>
<li>startHTTP（启动HTTP RPC端点）</li>
<li>startWS （启动websocket RPC端点）</li>
</ul>
</li>
</ol>
<h3 id="2-解锁账户"><a href="#2-解锁账户" class="headerlink" title="2.解锁账户"></a>2.解锁账户</h3><p>unlockAccounts</p>
<p>在datadir&#x2F;keystore目录主要用于记录在当前节点创建的帐户keystore文件。如果你的keystore文件不在本地是无法进行解锁的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解锁datadir/keystore目录中帐户</span></span><br><span class="line">ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</span><br><span class="line">	passwords := utils.MakePasswordList(ctx)</span><br><span class="line">	<span class="keyword">for</span> i, account := <span class="keyword">range</span> unlocks &#123;</span><br><span class="line">		unlockAccount(ks, account, i, passwords)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注册钱包事件"><a href="#3-注册钱包事件" class="headerlink" title="3.注册钱包事件"></a>3.注册钱包事件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> accounts.WalletEvent, <span class="number">16</span>)</span><br><span class="line">stack.AccountManager().Subscribe(events)</span><br></pre></td></tr></table></figure>

<h3 id="4-监听钱包事件"><a href="#4-监听钱包事件" class="headerlink" title="4.监听钱包事件"></a>4.监听钱包事件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		<span class="keyword">switch</span> event.Kind &#123;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletArrived:</span><br><span class="line">			<span class="keyword">if</span> err := event.Wallet.Open(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Warn(<span class="string">&quot;New wallet appeared, failed to open&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletOpened:</span><br><span class="line">			status, _ := event.Wallet.Status()</span><br><span class="line">			log.Info(<span class="string">&quot;New wallet appeared&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;status&quot;</span>, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> derivationPaths []accounts.DerivationPath</span><br><span class="line">			<span class="keyword">if</span> event.Wallet.URL().Scheme == <span class="string">&quot;ledger&quot;</span> &#123;</span><br><span class="line">				derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.LegacyLedgerBaseDerivationPath)</span><br><span class="line">			&#125;</span><br><span class="line">			derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.DefaultBaseDerivationPath)</span><br><span class="line"></span><br><span class="line">			event.Wallet.SelfDerive(derivationPaths, ethClient)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> accounts.WalletDropped:</span><br><span class="line">			log.Info(<span class="string">&quot;Old wallet dropped&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL())</span><br><span class="line">			event.Wallet.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="5-启动挖矿"><a href="#5-启动挖矿" class="headerlink" title="5.启动挖矿"></a>5.启动挖矿</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ethereum.StartMining(threads)</span><br></pre></td></tr></table></figure>

<h2 id="启动守护线程"><a href="#启动守护线程" class="headerlink" title="启动守护线程"></a>启动守护线程</h2><p>stop通道阻塞当前线程，直到节点被停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">node.Wait()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以太坊启动主要就做了3件事，包括加载配置注册服务、启动节点相关服务以及启动守护线程。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM介绍</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM介绍</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote>
<p>|-opcodes.go 具体指令集的含义</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM动态数据类型</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM动态数据类型</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm9mzi9m8j314y0u07wl.jpg" alt="image-20210113185500297"></p>
<p>Solidity提供了在其他编程语言常见的数据类型。除了简单的值类型比如数字和结构体，还有一些其他数据类型，随着数据的增加可以进行动态扩展的动态类型。动态类型的3大类：</p>
<ul>
<li>映射(Mappings)：<code>mapping(bytes32 =&gt; uint256)</code>， <code>mapping(address =&gt; string)</code>等等</li>
<li>数组(Arrays)：<code>[]uint256</code>，<code>[]byte</code>等等</li>
<li>字节数组(Byte arrays)：只有两种类型：<code>string</code>，<code>bytes</code></li>
</ul>
<p>在本系列的第二篇文章中我们看见了固定大小的简单类型在内存中的表示方式。</p>
<ul>
<li>基本数值：<code>uint256</code>，<code>byte</code>等等</li>
<li>定长数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code></li>
<li>组合了上面类型的结构体</li>
</ul>
<p>固定大小的存储变量都是尽可能的打包成32字节的块然后依次存放在存储器中的。（如果这看起来很陌生，请阅读本系列的第二篇文章： <a href="https://www.jianshu.com/p/9df8d15418ed">固定长度数据类型的表示方法</a></p>
<p>在本文中我们将会研究Solidity是如何支持更加复杂的数据结构的。在表面上看可能Solidity中的数组和映射比较熟悉，但是从它们的实现方式来看在本质上却有着不同的性能特征。</p>
<p>我们会从映射开始，这是三者当中最简单的。数组和字节数组其实就是拥有更加高级特征的映射。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>让我们存储一个数值在<code>uint256 =&gt; uint256</code>映射中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xC0FEFE</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize c-mapping.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 不做任何事情，应该会被优化掉</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  swap1</span><br><span class="line">  dup2</span><br><span class="line">  mstore</span><br><span class="line">  <span class="number">0x20</span></span><br><span class="line">  mstore</span><br><span class="line">  <span class="comment">// 将0x42 存储在地址0x798...187c上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line"> <span class="number">0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>我们可以将EVM想成一个键-值( key-value)数据库，不过每个key都限制为32字节。与其直接使用key<code>0xC0FEFE</code>，不如使用key的哈希值<code>0x798...187c</code>，并且<code>0x42</code>存储在这里。哈希函数使用的是<code>keccak256</code>(SHA256)函数。</p>
<p>在这个例子中我们没有看见<code>keccak256</code>指令本身，因为优化器已经提前计算了结果并內联到了字节码中。在没什么作用的<code>mstore</code>指令中，我们依然可以看到计算的痕迹。</p>
<h2 id="计算地址"><a href="#计算地址" class="headerlink" title="计算地址"></a>计算地址</h2><p>使用一些Python代码来把<code>0xC0FEFE</code>哈希成<code>0x798...187c</code>。如果你想要跟着做下去，你需要安装Python 3.6，或者安装<a href="https://link.jianshu.com/?t=https://pypi.python.org/pypi/pysha3">pysha3</a> 来获得<code>keccak_256</code>哈希函数。</p>
<p>定义两个协助函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="comment">#将数值转换成32字节数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytes32</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(<span class="string">&#x27;%064x&#x27;</span> % i)</span><br><span class="line"><span class="comment"># 计算32字节数组的 keccak256 哈希值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keccak256</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sha3.keccak_256(x).hexdigest()</span><br></pre></td></tr></table></figure>

<p>将数值转换成32个字节：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&#x27;</span></span><br><span class="line">&gt;&gt;&gt; bytes32(<span class="number">0xC0FEFE</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>+</code>操作符，将两个字节数组连接起来：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>) + bytes32(<span class="number">2</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02&#x27;</span></span><br></pre></td></tr></table></figure>

<p>计算一些字节的 keccak256 哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; keccak256(bytes(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以计算<code>0x798...187c</code>了。</p>
<p>存储变量<code>items</code>的位置是<code>0x0</code>（因为它是第一个存储变量）。连接key<code>0xc0fefe</code>和<code>items</code>的位置来获取地址：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xC0FEFE, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xC0FEFE</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为key计算存储地址的公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(bytes32(key) + bytes32(position))</span><br></pre></td></tr></table></figure>

<h2 id="两个映射"><a href="#两个映射" class="headerlink" title="两个映射"></a>两个映射</h2><p>我们先把公式放在这里，后面数值存储时需要计算会用到该公式。</p>
<p>假设我们的合约有两个映射：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsA;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsB;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      itemsA[<span class="number">0xAAAA</span>] = <span class="number">0xAAAA</span>;</span><br><span class="line">      itemsB[<span class="number">0xBBBB</span>] = <span class="number">0xBBBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsA</code>的位置是<code>0</code>，key为<code>0xAAAA</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xAAAA, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xAAAA</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsB</code>的位置为<code>1</code>，key为<code>0xBBBB</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xBBBB, position = 1</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xBBBB</span>) + bytes32(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用编译器来验证一下这些计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping<span class="number">-2.</span>sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ... 忽略可能会被优化掉的内存操作</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="number">0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0xbbbb</span></span><br><span class="line">  <span class="number">0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>跟期望的结果一样。</p>
<h2 id="汇编代码中的KECCAK256"><a href="#汇编代码中的KECCAK256" class="headerlink" title="汇编代码中的KECCAK256"></a>汇编代码中的KECCAK256</h2><p>编译器可以提前计算key的地址是因为相关的值是常量。如果key使用的是变量，那么哈希就必须要在汇编代码中完成。现在我们无效化优化器，来看看在汇编代码中哈希是如何完成的。</p>
<p>事实证明很容易就能让优化器无效，只要引入一个间接的虚变量<code>i</code>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="comment">//这个变量会造成常量的优化失败</span></span><br><span class="line">    uint256 i = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[i] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<code>items</code>的位置依然是<code>0x0</code>，所以我们应该期待地址与之前是一样的。</p>
<p>加上优化选项进行编译，但是这次不会提前计算哈希值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping--no-constant-folding.sol</span><br></pre></td></tr></table></figure>

<p>注释的汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 加载`i` 到栈中</span></span><br><span class="line">  sload(<span class="number">0x1</span>)</span><br><span class="line">    [<span class="meta">0xC0FEFE</span>]</span><br><span class="line">  <span class="comment">// 将key`0xC0FEFE`存放在内存中的0x0位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0xC0FEFE 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将位置 `0x0` 存储在内存中的 0x20 (32)位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x20</span> <span class="comment">// 32</span></span><br><span class="line">    [<span class="meta">0x20 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0x20 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x20 0x0 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">      <span class="number">0x20</span> =&gt; <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从第0个字节开始，哈希在内存中接下来的0x40(64)个字节</span></span><br><span class="line">  <span class="number">0x40</span> <span class="comment">// 64</span></span><br><span class="line">    [<span class="meta">0x40 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x0 0x40</span>]</span><br><span class="line">  keccak256</span><br><span class="line">    [<span class="meta">0x798...187c</span>]</span><br><span class="line">  <span class="comment">// 将0x42 存储在计算的地址上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">    [<span class="meta">0x42 0x798...187c</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x798...187c 0x42</span>]</span><br><span class="line">  sstore</span><br><span class="line">    store: &#123;</span><br><span class="line">      <span class="number">0x798</span>..<span class="number">.187</span>c =&gt; <span class="number">0x42</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>mstore</code>指令写入32个字节到内存中。内存操作便宜很多，只需要3 gas就可以读取和写入。前半部分的汇编代码就是通过将key和位置加载到相邻的内存块中来进行“连接”的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">31</span>  <span class="number">32</span>                 <span class="number">63</span></span><br><span class="line"><span class="punctuation">[</span>    key (<span class="number">32</span> bytes)    <span class="punctuation">]</span><span class="punctuation">[</span> position (<span class="number">32</span> bytes) <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>然后<code>keccak256</code>指令哈希内存中的数据。成本取决于被哈希的数据有多少：</p>
<ul>
<li>每个SHA3操作需要支付 30 gas</li>
<li>每个32字节的字需要支付 6 gas</li>
</ul>
<p>对于一个<code>uint256</code>类型key，gas的成本是42：<code>30 + 6 * 2</code>。</p>
<h2 id="映射大数值"><a href="#映射大数值" class="headerlink" title="映射大数值"></a>映射大数值</h2><p>每个存储槽只能存储32字节。如果我们尝试存储一个更大一点的结构体会怎么样？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> <span class="title class_">Tuple</span>) tuples;</span><br><span class="line">    struct <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">a</span> = <span class="number">0x1A</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">b</span> = <span class="number">0x1B</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">c</span> = <span class="number">0x1C</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，你会看见3个<code>sstore</code>指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">//忽略未优化的代码</span></span><br><span class="line">  <span class="number">0x1a</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1b</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1c</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意计算的地址除了最后一个数字其他都是一样的。<code>Tulp</code>结构体成员是依次排列的(..7d, ..7e, ..7f)。</p>
<h2 id="映射不会打包"><a href="#映射不会打包" class="headerlink" title="映射不会打包"></a>映射不会打包</h2><p>考虑到映射的设计方式，每项需要的最小存储空间是32字节，即使你实际只需要存储1个字节：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint8) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xA</span>] = <span class="number">0xAA</span>;</span><br><span class="line">      items[<span class="number">0xB</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个数值大于32字节，那么你需要的存储空间会以32字节依次增加。</p>
<h2 id="动态数组是映射的升级"><a href="#动态数组是映射的升级" class="headerlink" title="动态数组是映射的升级"></a>动态数组是映射的升级</h2><p>在典型语言中，数组只是连续存储在内存中一系列相同类型的元素。假设你有一个包含100个<code>uint8</code>类型的元素数组，那么这就会占用100个字节的内存。这种模式的话，将整个数组加载到CPU的缓存中然后循环遍历每个元素会便宜一点。</p>
<p>对于大多数语言而言，数组比映射都会便宜一些。不过在Solidity中，数组是更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br></pre></td></tr></table></figure>

<p>但是请记住，对于这些存储槽的每次访问实际上就像数据库中的key-value的查找一样。访问一个数组的元素跟访问一个映射的元素是没什么区别的。</p>
<p>思考一下<code>[]uint256</code>类型，它本质上与<code>mapping(uint256 =&gt; uint256)</code>是一样的，只不过后者多了一点特征，让它看起去就像数组一样。</p>
<ul>
<li><code>length</code>表示一共有多少个元素</li>
<li>边界检查。当读取或写入时索引值大于<code>length</code>就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小时，自动清除未使用的存储槽</li>
<li><code>bytes</code>和<code>string</code>的特殊优化让短数组(小于32字节)存储更加高效</li>
</ul>
<h2 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h2><p>看一下保存3个元素的数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-darray.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组访问的汇编代码难以追踪，使用<a href="https://link.jianshu.com/?t=https://remix.ethereum.org/">Remix</a>调试器来运行合约：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8388873-3f80ed93b21b374a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>模拟的最后，我们可以看到有4个存储槽被使用了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000bb</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p><code>chunks</code>变量的位置是<code>0x0</code>，用来存储数组的长度（<code>0x3</code>），哈希变量的位置来找到存储数组数据的地址：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个地址上数组的每个元素依次排列（<code>0x29..63</code>，<code>0x29..64</code>，<code>0x29..65</code>）。</p>
<h2 id="动态数据打包"><a href="#动态数据打包" class="headerlink" title="动态数据打包"></a>动态数据打包</h2><p>所有重要的打包行为是什么样的？数组与映射比较，数组的一个优势就是打包。拥有4个元素的<code>uint128[]</code>数组元素刚刚好需要2个存储槽（再加1个存储槽用来存储长度）。</p>
<p>思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行这个代码，存储器的最后看起来像这样：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000bb000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000dd000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p>只有三个存储槽被使用了，跟预料的一样。长度再次存储在存储变量的<code>0x0</code>位置上。4个元素被打包放入两个独立的存储槽中。该数组的开始地址是变量位置的哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在的地址是每两个数组元素增加一次，看起来很好！</p>
<p>但是汇编代码本身优化的并不好。因为使用了两个存储槽，所以我们会希望优化器使用两个<code>sstore</code>指令来完成任务。不幸的是，由于边界检查(和一些其他因素)，所以没有办法将<code>sstore</code>指令优化掉。</p>
<p>使用4个<code>sstore</code>指令才能完成任务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:105:116  s[0] = 0xAA */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:126:137  s[1] = 0xBB */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:147:158  s[2] = 0xCC */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:168:179  s[3] = 0xDD */</span><br><span class="line">sstore</span><br></pre></td></tr></table></figure>

<h3 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h3><p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度小于31字节，只需要1个存储槽来存储整个数组。长一点的字节数组跟正常数组的表示方式差不多。</p>
<p>看看短一点的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组只有3个字节（小于31字节），所以它只占用1个存储槽。在Remix中运行，存储看起来如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0xaabbcc0000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<p>数据<code>0xaabbcc...</code>从左到右的进行存储。后面的0是空数据。最后的<code>0x06</code>字节是数组的编码长度。公式是<code>长度=编码长度/2</code>，在这个例子中实际长度是<code>6/2=3</code>。</p>
<p><code>string</code>与<code>bytes</code>的原理一模一样。</p>
<h2 id="长字节数组"><a href="#长字节数组" class="headerlink" title="长字节数组"></a>长字节数组</h2><p>如果数据的长度大于31字节，字节数组就跟<code>[]byte</code>一样。来看一下长度为128字节的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行，可以看见使用了4个存储槽：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>x0000...<span class="number">0000</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0101</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0001</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0002</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0003</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0004</span></span><br></pre></td></tr></table></figure>

<p><code>0x0</code>的存储槽不再用来存储数据，整个存储槽现在存储编码的数组长度。要获得实际长度，使用<code>长度=（编码长度-1）/2</code>公式。在这个例子中长度是<code>（0x101 - 1）/2=128</code>。实际的字节被保存在<code>0x290d...e563</code>，并且存储槽是连续的。</p>
<p>字节数组的汇编代码相当多。除了正常的边界检查和数组恢复大小等，它还需要对长度进行编码&#x2F;解码，以及注意长字节数组和短字节数组之间的转换。</p>
<blockquote>
<p>为什么要编码长度？因为编码之后，可以很容易的测试出来字节数组是长还是短。注意对于长数组而言编码长度总是奇数，而短数组的编码长度总是偶数。汇编代码只需要查看一下最后一位是否为0，为0就是偶数（短数组），非0就是奇数（长数组）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查看Solidity编译器的内部工作，可以看见熟悉的数据结构例如映射和数组与传统编程语言完全不同。</p>
<p>概括：</p>
<ul>
<li>数组跟映射一样，非高效</li>
<li>比映射的汇编代码更加复杂</li>
<li>小类型(<code>byte</code>，<code>uint8</code>，<code>string</code>)时存储比映射高效</li>
<li>汇编代码优化的不是很好。即使是打包，每个任务都会有一个<code>sstore</code>指令</li>
</ul>
<p>EVM的存储器就是一个键值数据库，跟git很像。如果你改变了任一东西，根节点的校验和也会改变。如果两个根节点拥有相同的校验和，存储的数据就能保证是一样的。</p>
<p>为了体会Solidity和EVM的奇特，可以想象一下在git仓库里数组里面的每个元素都是它自己的文件。当你改变数组里一个元素的值，实际上就相当于创建了一个提交。当你迭代一个数组时，你不能一次性的加载整个数组，你必须要到仓库中进行查找并分别找到每个文件。</p>
<p>不仅仅这样，每个文件都限制到32字节！因为我们需要将数据结构都分割成32字节的块，Solidity编译器的所有逻辑和优化都是很负责的，全部在汇编的时候完成。</p>
<p>不过32字节的限制是完全任意的。支持键值存储的可以使用key来存储任意类型的数值。也许未来我们添加新的EVM指令使用key来存储任意的字节数组。</p>
<p>不过现在，EVM存储器就是一个伪装成32字节数组的键值数据库。</p>
<blockquote>
<p>可以看看<a href="https://link.jianshu.com/?t=https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624">ArrayUtils::resizeDynamicArray</a> 来了解一下当恢复数组大小时编译器的动作。正常情况下数据结构都会作为语言的标准库来完成的，但是在Solidity中嵌入到了编译器里面。</p>
</blockquote>
<blockquote>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM固定长度数据类型表示</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM固定长度数据类型表示</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
<p>我们先看一个简单的<code>Solidity</code>合约的汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该合约归结于<code>sstore</code>指令的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0x0</span>, <span class="number">0x1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>EVM将<code>0x1</code>数值存储在<code>0x0</code>的位置上</li>
<li>每个存储槽可以存储正好<strong>32</strong>字节(或<strong>256</strong>位)</li>
</ul>
<p>在本文中我们将会开始研究<code>Solidity</code>如何使用<code>32</code>字节的块来表示更加复杂的数据类型如结构体和数组。我们也将会看到存储是如何被优化的，以及优化是如何失败的。</p>
<p>在典型编程语言中理解数据类型在底层是如何表示的没有太大的作用。但是在<code>Solidity</code>(或其他的EVM语言)中，这个知识点是非常重要的，因为存储的访问是非常昂贵的：</p>
<ul>
<li><code>sstore</code>指令成本是20000 gas，或比基本的算术指令要贵~5000x</li>
<li><code>sload</code>指令成本是 200 gas，或比基本的算术指令要贵~100x</li>
</ul>
<p>这里说的成本，就是真正的金钱，而不仅仅是毫秒级别的性能。运行和使用合约的成本基本上是由<code>sstore</code>指令和<code>sload</code>指令来主导的！</p>
<h2 id="Parsecs磁带上的Parsecs"><a href="#Parsecs磁带上的Parsecs" class="headerlink" title="Parsecs磁带上的Parsecs"></a>Parsecs磁带上的Parsecs</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm7k9gjm5j31e80mqh7z.jpg" alt="image-20210113174357355"></p>
<p>构建一个通用计算机器需要两个基本要素：</p>
<ul>
<li>一种循环的方式，无论是跳转还是递归</li>
<li>无限量的内存</li>
</ul>
<p><code>EVM</code>的汇编代码有跳转，<code>EVM</code>的存储器提供无限的内存。这对于一切就已经足够了，包括模拟一个运行以太坊的世界，这个世界本身就是一个模拟运行以太坊的世界………</p>
<p>EVM的存储器对于合约来说就像一个无限的自动收报机磁带，磁带上的每个槽都能存储32个字节，就像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span>...</span><br></pre></td></tr></table></figure>

<p>我们将会看到数据是如何在无限的磁带中生存的。</p>
<blockquote>
<p>磁带的长度是2²⁵⁶，或者每个合约~10⁷⁷存储槽。可观测的宇宙粒子数是10⁸⁰。大概1000个合约就可以容纳所有的质子、中子和电子。不要相信营销炒作，因为它比无穷大要短的多。</p>
</blockquote>
<h2 id="空磁带"><a href="#空磁带" class="headerlink" title="空磁带"></a>空磁带</h2><p>存储器初始的时候是空白的，默认是0。拥有无限的磁带不需要任何的成本。</p>
<p>以一个简单的合约来演示一下0值的行为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    uint256 c;</span><br><span class="line">    uint256 d;</span><br><span class="line">    uint256 e;</span><br><span class="line">    uint256 f;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      f = <span class="number">0xc0fefe</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局很简单。</p>
<ul>
<li>变量<code>a</code>在<code>0x0</code>的位置上</li>
<li>变量<code>b</code>在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>关键问题是：如果我们只使用<code>f</code>，我们需要为<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>支付多少成本？</p>
<p>编译一下再看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sstore(0x5, 0xc0fefe)</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>所以一个存储变量的声明不需要任何成本，因为没有初始化的必要。Solidity为存储变量保留了位置，但是只有当你存储数据进去的时候才需要进行付费。</p>
<p>这样的话，我们只需要为存储<code>0x5</code>进行付费。</p>
<p>如果我们手动编写汇编代码的话，我们可以选择任意的存储位置，而用不着”扩展”存储器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个任意的存储位置</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0xc0fefe</span>, <span class="number">0x42</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取零"><a href="#读取零" class="headerlink" title="读取零"></a>读取零</h2><p>你不仅可以写在存储器的任意位置，你还可以立刻读取任意的位置。从一个未初始化的位置读取只会返回<code>0x0</code>。</p>
<p>让我们看看一个合约从一个未初始化的位置<code>a</code>读取数据：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-zero-value.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// sload(0x0) returning 0x0</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">  <span class="comment">// a + 1; where a == 0</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// sstore(0x0, a + 1)</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意生成从一个未初始化的位置<code>sload</code>的代码是无效的。</p>
<p>然而，我们可以比Solidity编译器聪明。既然我们知道<code>tag_2</code>是构造器，而且<code>a</code>从未被写入过数据，那么我们可以用<code>0x0</code>替换掉<code>sload</code>，以此节省5000 gas。</p>
<h2 id="结构体的表示"><a href="#结构体的表示" class="headerlink" title="结构体的表示"></a>结构体的表示</h2><p>来看一下我们的第一个复杂数据类型，一个拥有 6 个域的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t;</span><br><span class="line">    <span class="function">function <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局和状态变量是一样的：</p>
<ul>
<li><code>t.a</code>域在<code>0x0</code>的位置上</li>
<li><code>t.b</code>域在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>就像之前一样，我们可以直接写入<code>t.f</code>而不用为初始化付费。</p>
<p>编译一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">struct</span>-fields.sol</span><br></pre></td></tr></table></figure>

<p>然后我们看见一模一样的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h3 id="固定长度数组"><a href="#固定长度数组" class="headerlink" title="固定长度数组"></a>固定长度数组</h3><p>让我们来声明一个定长数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器知道这里到底有几个<code>uint256</code>(32字节)类型的数值，所以它可以很容易让数组里面的元素依次存储起来，就像它存储变量和结构体一样。</p>
<p>在这个合约中，我们再次存储到<code>0x5</code>的位置上。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">tag_4:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>这个稍微长一点，但是如果你仔细一点，你会看见它们其实是一样的。我们手动的来优化一下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="comment">// 0+5. 替换为0x5</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// 压入栈中然后立刻出栈。没有作用，只是移除</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>移除掉标记和伪指令之后，我们再次得到相同的字节码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h2 id="数组边界检查"><a href="#数组边界检查" class="headerlink" title="数组边界检查"></a>数组边界检查</h2><p>我们看到了定长数组、结构体和状态变量在存储器中的布局是一样的，但是产生的汇编代码是不同的。这是因为<code>Solidity</code>为数组的访问产生了边界检查代码。</p>
<p>让我们再次编译数组合约，这次去掉优化的选项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码在下面已经注释了，并且打印出每条指令的机器状态：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">    [<span class="meta">0xc0fefe</span>]</span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  dup1</span><br><span class="line">  <span class="comment">/* 数组边界检查代码 */</span></span><br><span class="line">  <span class="comment">// 5 &lt; 6</span></span><br><span class="line">  <span class="number">0x6</span></span><br><span class="line">    [<span class="meta">0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x5 0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  lt</span><br><span class="line">    [<span class="meta">0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  <span class="comment">// bound_check_ok = 1 (TRUE)</span></span><br><span class="line">  <span class="comment">// if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125;</span></span><br><span class="line">  tag_5</span><br><span class="line">    [<span class="meta">tag_5 0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  jumpi</span><br><span class="line">    <span class="comment">// 测试条件为真，跳转到 tag_5.</span></span><br><span class="line">    <span class="comment">//  `jumpi` 从栈中消耗两项数据</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  invalid</span><br><span class="line"><span class="comment">// 数据访问有效，继续执行</span></span><br><span class="line"><span class="comment">// stack: [0x5 0xc0fefe]</span></span><br><span class="line">tag_5:</span><br><span class="line">  sstore</span><br><span class="line">    []</span><br><span class="line">    storage: &#123; <span class="number">0x5</span> =&gt; <span class="number">0xc0fefe</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在已经看见了边界检查代码。我们也看见了编译器可以对这类东西进行一些优化，但是不是非常完美。</p>
<p>在本文的后面我们将会看到数组的边界检查是如何干扰编译器优化的，比起存储变量和结构体，定长数组的效率更低。</p>
<h2 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h2><p>存储是非常昂贵的。一个关键的优化就是尽可能的将数据打包成一个32字节数值。</p>
<p>考虑一个有 4 个存储变量的合约，每个变量都是 64 位，全部加起来就是 256 位（32字节）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="type">uint64</span> a;</span><br><span class="line">    <span class="type">uint64</span> b;</span><br><span class="line">    <span class="type">uint64</span> c;</span><br><span class="line">    <span class="type">uint64</span> d;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望（希望）编译器使用一个<code>sstore</code>指令将这些数据存放到同一个存储槽中。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:122  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:125:131  0xaaaa */</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="built_in">not</span>(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  <span class="function">swap1</span></span><br><span class="line"><span class="function">  swap2</span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0x80</span>), exp(<span class="number">0x2</span>, <span class="number">0x40</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:139:149  b = 0xbbbb */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xbbbb0000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), exp(<span class="number">0x2</span>, <span class="number">0x80</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:157:167  c = 0xcccc */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xcccc00000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">sub</span><span class="params">(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), <span class="number">0x1</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:175:185  d = 0xdddd */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xdddd000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  swap1</span></span><br><span class="line"><span class="function">  sstore</span></span><br></pre></td></tr></table></figure>

<p>这里还是有很多的位转移我没能弄明白，但是无所谓。最关键事情是这里只有一个<code>sstore</code>指令。</p>
<p>这样优化就成功！</p>
<h2 id="干扰优化器"><a href="#干扰优化器" class="headerlink" title="干扰优化器"></a>干扰优化器</h2><p>优化器并不能一直工作的这么好。让我们来干扰一下优化器。唯一的改变就是使用协助函数来设置存储变量：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    uint64 b;</span><br><span class="line">    uint64 c;</span><br><span class="line">    uint64 d;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setAB</span>();</span><br><span class="line">      <span class="title function_">setCD</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setAB</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setCD</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing-helpers.sol</span><br></pre></td></tr></table></figure>

<p>输出的汇编代码太多了，我们忽略了大多数的细节，只关注结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 通过跳到tag_5来调用setAB()</span></span><br><span class="line">  jump</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//通过跳到tag_7来调用setCD() </span></span><br><span class="line">  jump</span><br><span class="line"><span class="comment">// setAB()函数</span></span><br><span class="line">tag_5:</span><br><span class="line">  <span class="comment">// 进行位转移和设置a，b</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_9:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setAB()的地方</span></span><br><span class="line"><span class="comment">//setCD()函数</span></span><br><span class="line">tag_7:</span><br><span class="line">  <span class="comment">// 进行位转移和设置c，d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_10:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setCD()的地方</span></span><br></pre></td></tr></table></figure>

<p>现在这里有两个<code>sstore</code>指令而不是一个。Solidity编译器可以优化一个标签内的东西，但是无法优化跨标签的。</p>
<p>调用函数会让你消耗更多的成本，不是因为函数调用昂贵（他们只是一个跳转指令），而是因为<code>sstore</code>指令的优化可能会失败。</p>
<p>为了解决这个问题，Solidity编译器应该学会如何內联函数，本质上就是不用调用函数也能得到相同的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">0xaaaa</span>;</span><br><span class="line">b <span class="operator">=</span> <span class="number">0xbbbb</span>;</span><br><span class="line">c <span class="operator">=</span> <span class="number">0xcccc</span>;</span><br><span class="line">d <span class="operator">=</span> <span class="number">0xdddd</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们仔细阅读输出的完整汇编代码，我们会看见<code>setAB()</code>和<code>setCD()</code>函数的汇编代码被包含了两次，不仅使代码变得臃肿了，并且还需要花费额外的gas来部署合约。在学习合约的生命周期时我们再来谈谈这个问题。</p>
</blockquote>
<h2 id="为什么优化器会被干扰？"><a href="#为什么优化器会被干扰？" class="headerlink" title="为什么优化器会被干扰？"></a>为什么优化器会被干扰？</h2><p>因为优化器不会跨标签进行优化。思考一下”1+1”，在同一个标签下，它会被优化成<code>0x2</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化成功！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>但是如果指令被标签分开的话就不会被优化了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化失败！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>在0.4.13版本中上面的行为都是真实的。也许未来会改变。</p>
<h2 id="再次干扰优化器"><a href="#再次干扰优化器" class="headerlink" title="再次干扰优化器"></a>再次干扰优化器</h2><p>让我们看看优化器失败的另一种方式，打包适用于定长数组吗？思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再一次，这里有4个64位的数值我们希望能打包成一个32位的数值，只使用一个<code>sstore</code>指令。</p>
<p>编译的汇编代码太长了，我们就数数<code>sstore</code>和<code>sload</code>指令的条数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ solc --bin --asm --optimize c-<span class="built_in">static</span>-<span class="keyword">array</span>--packing.sol | grep -E <span class="string">&#x27;(sstore|sload)&#x27;</span></span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>哦，不！即使定长数组与等效的结构体和存储变量的存储布局是一样的，优化也失败了。现在需要4对<code>sload</code>和<code>sstore</code>指令。</p>
<p>快速的看一下汇编代码，可以发现每个数组的访问都有一个边界检查代码，它们在不同的标签下被组织起来。优化无法跨标签，所以优化失败。</p>
<p>不过有个小安慰。其他额外的3个<code>sstore</code>指令比第一个要便宜：</p>
<ul>
<li><code>sstore</code>指令第一次写入一个新位置需要花费 20000 gas</li>
<li><code>sstore</code>指令后续写入一个已存在的位置需要花费 5000 gas</li>
</ul>
<p>所以这个特殊的优化失败会花费我们35000 gas而不是20000 gas，多了额外的75%。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果Solidity编译器能弄清楚存储变量的大小，它就会将这些变量依次的放入存储器中。如果可能的话，编译器会将数据紧密的打包成32字节的块。</p>
<p>总结一下目前我们见到的打包行为：</p>
<ul>
<li>存储变量：打包</li>
<li>结构体：打包</li>
<li>定长数组：不打包。在理论上应该是打包的</li>
</ul>
<p>因为存储器访问的成本较高，所以你应该将存储变量作为自己的数据库模式。当写一个合约时，做一个小实验是比较有用的，检测汇编代码看看编译器是否进行了正确的优化。</p>
<p>我们可以肯定Solidity编译器在未来肯定会改良。对于现在而言，很不幸，我们不能盲目的相信它的优化器。</p>
<p>它需要你真正的理解存储变量。</p>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmma6b1e5zj312g0pmnpe.jpg" alt="image-20210113191423657"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>abi是什么？<br>前面我们认识到的是智能合约直接在EVM上的表示方式，但是，比如我想用java端程序去访问智能合约的某个方法，难道让java开发人员琢磨透汇编和二进制的表示，再去对接？<br>这明显是不可能的，为此abi产生了。这是一个通用可读的json格式的数据，任何别的客户端开发人员或者别的以太坊节点只要指定要调用的方法，通过abi将其解析为字节码并传递给evm，evm来计算处理该字节码并返回结果给前端。abi就起到这么一个作用，类似于传统的客户端和服务器端地址好交互规则，比如json格式的数据，然后进行交互。</p>
<p>在本系列的上一篇文章中我们看到了<code>Solidity</code>是如何在EVM存储器中表示复杂数据结构的。但是如果无法交互，数据就是没有意义的。智能合约就是数据和外界的中间体。</p>
<p>在这篇文章中我们将会看到<code>Solidity</code>和<code>EVM</code>可以让外部程序来调用合约的方法并改变它的状态。</p>
<p>“外部程序”不限于<code>DApp/JavaScript</code>。任何可以使用<code>HTTP RPC</code>与以太坊节点通信的程序，都可以通过创建一个交易与部署在区块链上的任何合约进行交互。</p>
<p>创建一个交易就像发送一个<code>HTTP</code>请求。<code>Web</code>的服务器会接收你的<code>HTTP</code>请求，然后改变数据库。交易会被网络接收，底层的区块链会扩展到包含改变的状态。</p>
<p>交易对于智能合约就像<code>HTTP</code>请求对于<code>Web</code>服务器。</p>
<h2 id="合约交易"><a href="#合约交易" class="headerlink" title="合约交易"></a>合约交易</h2><p>让我们来看一下将状态变量设置在<code>0x1</code>位置上的交易。我们想要交互的合约有一个对变量<code>a</code>的设置者和获取者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  function setA(uint256 _a) &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  function getA() returns(uint256) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约部署在Rinkeby测试网上。可以随意使用Etherscan，并搜索地址 <a href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2#code">0x62650ae5…</a>进行查看。</p>
<p>我创建了一个可以调用<code>setA(1)</code>的交易，可以在地址<a href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5">0x7db471e5…</a>上查看该交易。</p>
<p>交易的input data是：</p>
<blockquote>
<p>0xee919d500000000000000000000000000000000000000000000000000000000000000001</p>
</blockquote>
<p>对于EVM而言，这只是36字节的元数据。它对元数据不会进行处理，会直接将元数据作为<code>calldata</code>传递给智能合约。如果智能合约是个Solidity程序，那么它会将这些输入字节解释为方法调用，并为<code>setA(1)</code>执行适当的汇编代码。</p>
<p>输入数据可以分成两个子部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 方法选择器(<span class="number">4</span>字节)</span><br><span class="line"><span class="number">0xee919d5</span></span><br><span class="line">#第一个参数(<span class="number">32</span>字节)</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000001</span></span><br></pre></td></tr></table></figure>

<p>前面的4个字节是方法选择器，剩下的输入数据是方法的参数，32个字节的块。在这个例子中，只有一个参数，值是<code>0x1</code>。</p>
<p>方法选择器是方法签名的 kecccak256 哈希值。在这个例子中方法的签名是<code>setA(uint256)</code>，也就是方法名称和参数的类型。</p>
<p>让我们用Python来计算方法选择器。首先，哈希方法签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 安装pyethereum [https:<span class="comment">//github.com/ethereum/pyethereum/#installation](https://github.com/ethereum/pyethereum/#installation)&gt; from ethereum.utils import sha3&gt; sha3(&quot;setA(uint256)&quot;).hex()&#x27;ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后获取哈希值的前4字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; sha3(<span class="string">&quot;setA(uint256)&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;ee919d50&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="应用二进制接口（ABI）"><a href="#应用二进制接口（ABI）" class="headerlink" title="应用二进制接口（ABI）"></a>应用二进制接口（ABI）</h2><p>对于EVM而言，交易的输入数据(<code>calldata</code>)只是一个字节序列。EVM内部不支持调用方法。</p>
<p>智能合约可以选择通过以结构化的方式处理输入数据来模拟方法调用，就像前面所说的那样。</p>
<p>如果EVM上的所有语言都同意相同的方式解释输入数据，那么它们就可以很容易进行交互。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding">合约应用二进制接口</a>（ABI）指定了一个通用的编码模式。</p>
<p>我们已经看到了ABI是如何编码一个简单的方法调用，例如<code>SetA(1)</code>。在后面章节中我们将会看到方法调用和更复杂的参数是如何编码的。</p>
<h2 id="调用一个获取者"><a href="#调用一个获取者" class="headerlink" title="调用一个获取者"></a>调用一个获取者</h2><p>如果你调用的方法改变了状态，那么整个网络必须要同意。这就需要有交易，并消耗gas。</p>
<p>一个获取者如<code>getA()</code>不会改变任何东西。我们可以将方法调用发送到本地的以太坊节点，而不用请求整个网络来执行计算。一个<code>eth_call</code>RPC请求可以允许你在本地模拟交易。这对于只读方法或gas使用评估比较有帮助。</p>
<p>一个<code>eth_call</code>就像一个缓存的HTTP GET请求。</p>
<ul>
<li>它不改变全球的共识状态</li>
<li>本地区块链(“缓存”)可能会有点稍微过时</li>
</ul>
<p>制作一个<code>eth_call</code>来调用 <code>getA</code>方法，通过返回值来获取状态<code>a</code>。首先，计算方法选择器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sha3(<span class="string">&quot;getA()&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;d46300fd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于没有参数，输入数据就只有方法选择器了。我们可以发送一个<code>eth_call</code>请求给任意的以太坊节点。对于这个例子，我们依然将请求发送给 infura.io的公共以太坊节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ curl -X POST \-H <span class="string">&quot;Content-Type: application/json&quot;</span> \<span class="string">&quot;[https://rinkeby.infura.io/YOUR_INFURA_TOKEN](https://rinkeby.infura.io/YOUR_INFURA_TOKEN)&quot;</span> \--data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;id&quot;: 1,&quot;method&quot;: &quot;eth_call&quot;,&quot;params&quot;: [&#123;&quot;to&quot;: &quot;0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2&quot;,&quot;data&quot;: &quot;0xd46300fd&quot;&#125;,&quot;latest&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据ABI，该字节应该会解释为<code>0x1</code>数值。</p>
<h2 id="外部方法调用的汇编"><a href="#外部方法调用的汇编" class="headerlink" title="外部方法调用的汇编"></a>外部方法调用的汇编</h2><p>现在来看看编译的合约是如何处理源输入数据的，并以此来制作一个方法调用。思考一个定义了<code>setA(uint256)</code>的合约：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="comment">// 注意: `payable` 让汇编简单一点点</span></span><br><span class="line">  function setA(uint256 _a) payable &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">solc --bin --asm --optimize call.sol</span><br></pre></td></tr></table></figure>

<p>调用方法的汇编代码在合约内部，在<code>sub_0</code>标签下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sub_0: assembly &#123;</span><br><span class="line">    mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="number">0xee919d50</span></span><br><span class="line">    dup2</span><br><span class="line">    eq</span><br><span class="line">    tag_2</span><br><span class="line">    jumpi</span><br><span class="line">  tag_1:</span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">    dup1</span><br><span class="line">    revert</span><br><span class="line">  tag_2:</span><br><span class="line">    tag_3</span><br><span class="line">    calldataload(<span class="number">0x4</span>)</span><br><span class="line">    jump(tag_4)</span><br><span class="line">  tag_3:</span><br><span class="line">    stop</span><br><span class="line">  tag_4:</span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:96  a */</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:101  a = _a */</span></span><br><span class="line">    dup2</span><br><span class="line">    swap1</span><br><span class="line">    sstore</span><br><span class="line">  tag_5:</span><br><span class="line">    pop</span><br><span class="line">    jump <span class="comment">// 跳出</span></span><br><span class="line">auxdata: <span class="number">0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个样板代码与此讨论是无关的，但是仅供参考：</p>
<ul>
<li>最上面的<code>mstore(0x40, 0x60)</code>为sha3哈希保留了内存中的前64个字节。不管合约是否需要，这个都会存在的。</li>
<li>最下面的<code>auxdata</code>用来验证发布的源码与部署的字节码是否相同的。这个是可选择的，但是嵌入到了编译器中</li>
</ul>
<p>将剩下的汇编代码分成两个部分，这样容易分析一点：</p>
<ul>
<li>匹配选择器并跳掉方法处</li>
<li>加载参数、执行方法，并从方法返回</li>
</ul>
<p>首先，匹配选择器的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载前4个字节作为方法选择器</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">//  如果选择器匹配`0xee919d50`, 跳转到 setA</span></span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2</span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line"><span class="comment">// setA函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>除了开始从调用数据里面加载4字节时的位转移，其他的都是非常清晰明朗的。为了清晰可见，给出了汇编逻辑的低级伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// 跳转到setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<p>实际方法调用的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setA</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 方法调用之后跳转的地方</span></span><br><span class="line">  tag_3</span><br><span class="line">  <span class="comment">// 加载第一个参数(数值0x1).</span></span><br><span class="line">  calldataload(<span class="number">0x4</span>)</span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  jump(tag_4)</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// sstore(0x0, 0x1)</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  <span class="comment">//程序的结尾，将会跳转到 tag_3并停止</span></span><br><span class="line">  jump</span><br><span class="line">tag_3:</span><br><span class="line">  <span class="comment">// 程序结尾</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>在进入方法体之前，汇编代码做了两件事情：</p>
<ol>
<li>保存了一个位置，方法调用之后返回此位置</li>
<li>从调用数据里面加载参数到栈中</li>
</ol>
<p>低级的伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存位置，方法调用结束后返回此位置</span></span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA</span></span><br><span class="line">  <span class="comment">// 从调用数据里面加载参数到栈中</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">4</span>+<span class="number">32</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>将这两部分组合起来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// goto setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 无匹配方法。失败</span></span><br><span class="line">  revert</span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA(uint256 _a)</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">36</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有趣的小细节：<code>revert</code>的操作码是<code>fd</code>。但是在黄皮书中你不会找到它的详细说明，或者在代码中找到它的实现。实际上，<code>fd</code>不是确实存在的！这是个无效的操作。当EVM遇到了一个无效的操作，它会放弃并且会有还原状态的副作用。</p>
</blockquote>
<h2 id="处理多个方法"><a href="#处理多个方法" class="headerlink" title="处理多个方法"></a>处理多个方法</h2><p>Solidity编译器是如何为有多个方法的合约产生汇编代码的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    function setA(uint256 _a) &#123;</span><br><span class="line">      a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    function setB(uint256 _b) &#123;</span><br><span class="line">      b = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单，只要一些<code>if-else</code>分支就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// methodSelector = calldata[0:4]</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// if methodSelector == 0x9cdcf9b</span></span><br><span class="line"><span class="number">0x9cdcf9b</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2 <span class="comment">// SetB</span></span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// elsif methodSelector == 0xee919d50</span></span><br><span class="line">dup1</span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">eq</span><br><span class="line">tag_3 <span class="comment">// SetA</span></span><br><span class="line">jumpi</span><br></pre></td></tr></table></figure>

<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0x9cdcf9b&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2</span><br><span class="line">elsif methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// Cannot find a matching method. Fail.</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<h2 id="ABI为复杂方法调用进行编码"><a href="#ABI为复杂方法调用进行编码" class="headerlink" title="ABI为复杂方法调用进行编码"></a>ABI为复杂方法调用进行编码</h2><p>对于一个方法调用，交易输入数据的前4个字节总是方法选择器。跟在后面的32字节块就是方法参数。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI编码规范</a>显示了更加复杂的参数类型是如何被编码的，但是阅读起来非常的痛苦。</p>
<p>另一个学习ABI编码的方式是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py">pyethereum的ABI编码函数</a> 来研究不同数据类型是如何编码的。我们会从简单的例子开始，然后建立更复杂的类型。</p>
<p>首先，导出<code>encode_abi</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">from ethereum.abi <span class="keyword">import</span> encode_abi</span><br></pre></td></tr></table></figure>

<p>对于一个有3个<code>uint256</code>类型参数的方法（例如<code>foo(uint256 a, uint256 b, uint256 c)</code>），编码参数只是简单的依次对<code>uint256</code>数值进行编码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 第一个数组列出了参数的类型</span><br><span class="line"># 第二个数组列出了参数的值</span><br><span class="line">&gt; encode_abi([<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小于32字节的类型会被填充到32字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi([<span class="string">&quot;int8&quot;</span>, <span class="string">&quot;uint32&quot;</span>, <span class="string">&quot;uint64&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure>

<p>对于定长数组，元素还是32字节的块（如果必要的话会填充0），依次排列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">   [<span class="string">&quot;int8[3]&quot;</span>, <span class="string">&quot;int256[3]&quot;</span>],</span><br><span class="line">   [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// int8[3]. Zero-padded to 32 bytes.</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="comment">// int256[3].</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000005</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<h2 id="ABI为动态数组编码"><a href="#ABI为动态数组编码" class="headerlink" title="ABI为动态数组编码"></a>ABI为动态数组编码</h2><p>ABI介绍了一种间接的编码动态数组的方法，遵循一个叫做<a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741">头尾编码</a>的模式。</p>
<p>该模式其实就是动态数组的元素被打包到交易的调用数据尾部，参数(“头”)会被引用到调用数据里，这里就是数组元素。</p>
<p>如果我们调用的方法有3个动态数组，参数的编码就会像这样（添加注释和换行为了更加的清晰）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>],</span><br><span class="line">  [[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1: 数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：数组数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 参数3： 数组数据在0x160位置 </span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">/************* TAIL (128**3 bytes) *************/</span></span><br><span class="line"><span class="comment">//  0x60位置。参数1的数据</span></span><br><span class="line"><span class="comment">// 长度后跟这元素</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// 0xe0位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">//0x160位置。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<p><code>HEAD</code>部分有32字节参数，指出<code>TAIL</code>部分的位置，<code>TAIL</code>部分包含了3个动态数组的实际数据。</p>
<p>举个例子，第一个参数是<code>0x60</code>，指出调用数据的第96个(<code>0x60</code>)字节。如果你看一下第96个字节，它是数组的开始地方。前32字节是长度，后面跟着的是3个元素。</p>
<p>混合动态和静态参数是可能的。这里有个(<code>static</code>，<code>dynamic</code>，<code>static</code>)参数。静态参数按原样编码，而第二个动态数组的数据放到了尾部：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256&quot;</span>],</span><br><span class="line">  [<span class="number">0xaaaa</span>, [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], <span class="number">0xbbbb</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1： 0xaaaa</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>aaaa</span><br><span class="line"><span class="comment">// 参数2：数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数3： 0xbbbb</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>bbbb</span><br><span class="line"><span class="comment">/************* TAIL (128 bytes) *************/</span></span><br><span class="line"><span class="comment">// 0x60位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br></pre></td></tr></table></figure>

<h2 id="编码字节数组"><a href="#编码字节数组" class="headerlink" title="编码字节数组"></a>编码字节数组</h2><p>字符串和字节数组同样是头尾编码。唯一的区别是字节数组会被紧密的打包成一个32字节的块，就像：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// 参数1： 字符串数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：字符串数据在0xa0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a0</span><br><span class="line"><span class="comment">// 参数3：字符串数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 0x60 (96)。 参数1的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6161616100000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xa0 (160)。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6262626200000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xe0 (224)。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6363636300000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>对于每个字符串&#x2F;字节数组，前面的32字节是编码长度，后面跟着才是字符串&#x2F;字节数组的内容。</p>
<p>如果字符串大于32字节，那么多个32字节块就会被使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码字符串的48字节</span></span><br><span class="line">ethereum.abi.encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;a&quot;</span> * (<span class="number">32</span>+<span class="number">16</span>)]</span><br><span class="line">).hex()</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">//字符串的长度为0x30 (48)</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000030</span></span><br><span class="line"><span class="number">6161616161616161616161616161616161616161616161616161616161616161</span></span><br><span class="line"><span class="number">6161616161616161616161616161616100000000000000000000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>嵌套数组中每个嵌套有一个间接寻址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[][]&quot;</span>],</span><br><span class="line">  [[[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">//参数1：外层数组在0x20位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">// 0x20。每个元素都是里层数组的位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">// array[0]在0x60位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// array[1] 在0xe0位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">// array[2]在0x160位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<h2 id="Gas成本和ABI编码设计"><a href="#Gas成本和ABI编码设计" class="headerlink" title="Gas成本和ABI编码设计"></a>Gas成本和ABI编码设计</h2><p>为什么ABI将方法选择器截断到4个字节？如果我们不使用sha256的整个32字节，会不会不幸的碰到不同方法发生冲突的情况？ 如果这个截断是为了节省成本，那么为什么在用更多的0来进行填充时，而仅仅只为了节省方法选择器中的28字节而截断呢？</p>
<p>这种设计看起来互相矛盾……直到我们考虑到一个交易的gas成本。</p>
<ul>
<li>每笔交易需要支付 21000 gas</li>
<li>每笔交易的0字节或代码需要支付 4 gas</li>
<li>每笔交易的非0字节或代码需要支付 68 gas</li>
</ul>
<p>啊哈！0要便宜17倍，0填充现在看起来没有那么不合理了。</p>
<p>方法选择器是一个加密哈希值，是个伪随机。一个随机的字符串倾向于拥有很多的非0字节，因为每个字节只有0.3%（1&#x2F;255）的概率是0。</p>
<ul>
<li><code>0x1</code>填充到32字节成本是192 gas<br>4*31 (0字节) + 68 (1个非0字节)</li>
<li>sha256可能有32个非0字节，成本大概2176 gas<br>32 * 68</li>
<li>sha256截断到4字节，成本大概272 gas<br>32*4</li>
</ul>
<p>ABI展示了另外一个底层设计的奇特例子，通过gas成本结构进行激励。</p>
<blockquote>
<h3 id="负整数…"><a href="#负整数…" class="headerlink" title="负整数…."></a>负整数….</h3></blockquote>
<p>一般使用叫做 <a href="https://en.wikipedia.org/wiki/Two's_complement">补码</a>的方式来表达负整数。<code>int8</code>类型<code>-1</code>的数值编码会都是1。<code>1111 1111</code>。</p>
<p>ABI用1来填充负整数，所以<code>-1</code>会被填充为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure>

<p>越大的负整数（<code>-1</code>大于<code>-2</code>）1越多，会花费相当多的gas。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与智能合约交互，你需要发送原始字节。它会进行一些计算，可能会改变自己的状态，然后会返回给你原始字节。方法调用实际上不存在，这是ABI创造的集体假象。</p>
<p>ABI被指定为一个低级格式，但是在功能上更像一个跨语言RPC框架的序列化格式。</p>
<p>我们可以在DApp和Web App的架构层面之间进行类比：</p>
<ul>
<li>区块链就是一个备份数据库</li>
<li>合约就像web服务器</li>
<li>交易就像请求</li>
<li>ABI是数据交换格式，就像<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protocol Buffer</a>。</li>
</ul>
<blockquote>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EthDB</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EthDB</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-leveldb.go</span><br><span class="line">|-memorydb.go</span><br><span class="line">|-batch.go</span><br><span class="line">|-database.go</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://www.jianshu.com/nb/9496943">https://www.jianshu.com/nb/9496943</a> （levelDB源码）</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM指令集</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM指令集</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>以下指令集持续更新，最新文章请参考上面</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn1z0rqeqaj31c00u0k20.jpg" alt="f4a720afd869d70c3d1d2149980ba0e9"></p>
<h2 id="EVM-指令集概念"><a href="#EVM-指令集概念" class="headerlink" title="EVM 指令集概念"></a>EVM 指令集概念</h2><p><strong>EVM执行的是字节码</strong>。由于操作码被限制在一个字节以内，所以EVM指令集最多只能容纳<strong>256</strong>条指令。目前EVM已经定义了<code>100</code>多条指令，还有<strong>100</strong>多条指令可供以后扩展。<strong>这100多条指令包括算术运算指令，比较操作指令，按位运算指令，密码学计算指令，栈、memory、storage操作指令，跳转指令，区块、智能合约相关指令等</strong>。</p>
<h2 id="EVM指令集"><a href="#EVM指令集" class="headerlink" title="EVM指令集"></a>EVM指令集</h2><h3 id="算数运算指令集"><a href="#算数运算指令集" class="headerlink" title="算数运算指令集"></a>算数运算指令集</h3><blockquote>
<p><em>0x0</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOP:       &quot;STOP&quot;,</span><br><span class="line">ADD:        &quot;ADD&quot;, //加法运算</span><br><span class="line">MUL:        &quot;MUL&quot;, //乘法运算</span><br><span class="line">SUB:        &quot;SUB&quot;, //减法运算</span><br><span class="line">DIV:        &quot;DIV&quot;, //无符号整除运算</span><br><span class="line">SDIV:       &quot;SDIV&quot;, //有符号整除运算</span><br><span class="line">MOD:        &quot;MOD&quot;, //无符号取模运算</span><br><span class="line">SMOD:       &quot;SMOD&quot;, //有符号取模运算</span><br><span class="line">EXP:        &quot;EXP&quot;,  //指数运算</span><br><span class="line">NOT:        &quot;NOT&quot;,</span><br><span class="line"></span><br><span class="line">//从栈顶弹出两个元素，进行比较，</span><br><span class="line">//然后把结果（1表示true，0表示false）推入栈顶。</span><br><span class="line">//其中LT和GT把弹出的元素解释为无符号整数进行比较，</span><br><span class="line">//SLT和SGT把弹出的元素解释为有符号数进行比较，EQ不关心符号</span><br><span class="line">LT:         &quot;LT&quot;,  //无符号小于比较</span><br><span class="line">GT:         &quot;GT&quot;, //无符号大于比较</span><br><span class="line">SLT:        &quot;SLT&quot;, //有符号小于比较</span><br><span class="line">SGT:        &quot;SGT&quot;, //有符号大于比较</span><br><span class="line">EQ:         &quot;EQ&quot;,  // 等于比较</span><br><span class="line"></span><br><span class="line">//SZERO指令从栈顶弹出一个元素，判断它是否为0，如果是，则把1推入栈顶，否则把0推入栈顶</span><br><span class="line">ISZERO:     &quot;ISZERO&quot;, //布尔取反</span><br><span class="line"></span><br><span class="line">//SIGNEXTEND指令从栈顶依次弹出k和x，并</span><br><span class="line">//把x解释为k+1（0 &lt;= k &lt;= 31）字节有符号整数，然</span><br><span class="line">//后把x符号扩展至32字节。比如x是二进制10000000，k是0，</span><br><span class="line">//则符号扩展之后，结果为二进制1111…10000000（共249个1）</span><br><span class="line">SIGNEXTEND: &quot;SIGNEXTEND&quot; //符号位扩展</span><br></pre></td></tr></table></figure>



<h3 id="位运算指令集"><a href="#位运算指令集" class="headerlink" title="位运算指令集"></a>位运算指令集</h3><blockquote>
<p><em>0x10</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//AND、OR、XOR指令从栈顶弹出两个元素，进行按位运算，然后把结果推入栈顶</span><br><span class="line">AND:    &quot;AND&quot;,</span><br><span class="line">OR:     &quot;OR&quot;,</span><br><span class="line">XOR:    &quot;XOR&quot;,</span><br><span class="line"></span><br><span class="line">//BYTE指令先后从栈顶弹出n和x，取x的第n个字节并推入栈顶。</span><br><span class="line">//由于EVM的字长是32个字节，所以n在[0, 31]区间内才有意义，</span><br><span class="line">//否则BYTE的运算结果就是0。另外，字节是从左到右数的，因此第0个字节占据字的最高位8个比特</span><br><span class="line">BYTE:   &quot;BYTE&quot;, </span><br><span class="line"></span><br><span class="line">//这三条指令都是先后从栈顶弹出两个数n和x，</span><br><span class="line">//其中x是要进行位移操作顶数，n是位移比特数，然后把结果推入栈顶</span><br><span class="line">SHL:    &quot;SHL&quot;,</span><br><span class="line">//SHR和SAR的区别在于，前者执行逻辑右移（空缺补0），后者执行算术右移（空缺补符号位）</span><br><span class="line">SHR:    &quot;SHR&quot;,</span><br><span class="line">SAR:    &quot;SAR&quot;,</span><br><span class="line"></span><br><span class="line">ADDMOD: &quot;ADDMOD&quot;,</span><br><span class="line"></span><br><span class="line">//MULMOD指令依次从栈顶弹出x、y、z三个数，</span><br><span class="line">//先计算x和y的乘积（不受溢出限制），再计算乘积和z的模，最后把结果推入栈顶</span><br><span class="line">//假定乘积不会溢出，那么MULMOD(x, y, z)等价于x * y % z</span><br><span class="line">MULMOD: &quot;MULMOD&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="加密指令集"><a href="#加密指令集" class="headerlink" title="加密指令集"></a>加密指令集</h3><blockquote>
<p><em>0x20</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA3: &quot;SHA3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="关闭状态指令集"><a href="#关闭状态指令集" class="headerlink" title="关闭状态指令集"></a>关闭状态指令集</h3><blockquote>
<p><em>0x30</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ADDRESS:        &quot;ADDRESS&quot;,</span><br><span class="line">BALANCE:        &quot;BALANCE&quot;,</span><br><span class="line">ORIGIN:         &quot;ORIGIN&quot;,</span><br><span class="line">CALLER:         &quot;CALLER&quot;,</span><br><span class="line">CALLVALUE:      &quot;CALLVALUE&quot;,</span><br><span class="line">CALLDATALOAD:   &quot;CALLDATALOAD&quot;,</span><br><span class="line">CALLDATASIZE:   &quot;CALLDATASIZE&quot;,</span><br><span class="line">CALLDATACOPY:   &quot;CALLDATACOPY&quot;,</span><br><span class="line">CODESIZE:       &quot;CODESIZE&quot;,</span><br><span class="line">CODECOPY:       &quot;CODECOPY&quot;,</span><br><span class="line">GASPRICE:       &quot;GASPRICE&quot;,</span><br><span class="line">EXTCODESIZE:    &quot;EXTCODESIZE&quot;,</span><br><span class="line">EXTCODECOPY:    &quot;EXTCODECOPY&quot;,</span><br><span class="line">RETURNDATASIZE: &quot;RETURNDATASIZE&quot;,</span><br><span class="line">RETURNDATACOPY: &quot;RETURNDATACOPY&quot;,</span><br><span class="line">EXTCODEHASH:    &quot;EXTCODEHASH&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="块操作指令集"><a href="#块操作指令集" class="headerlink" title="块操作指令集"></a>块操作指令集</h3><blockquote>
<p><em>0x40</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BLOCKHASH:   &quot;BLOCKHASH&quot;,</span><br><span class="line">COINBASE:    &quot;COINBASE&quot;,</span><br><span class="line">TIMESTAMP:   &quot;TIMESTAMP&quot;,</span><br><span class="line">NUMBER:      &quot;NUMBER&quot;,</span><br><span class="line">DIFFICULTY:  &quot;DIFFICULTY&quot;,</span><br><span class="line">GASLIMIT:    &quot;GASLIMIT&quot;,</span><br><span class="line">CHAINID:     &quot;CHAINID&quot;,</span><br><span class="line">SELFBALANCE: &quot;SELFBALANCE&quot;</span><br></pre></td></tr></table></figure>



<h3 id="存储和执行指令集"><a href="#存储和执行指令集" class="headerlink" title="存储和执行指令集"></a>存储和执行指令集</h3><blockquote>
<p><em>0x50</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP: &quot;POP&quot;,  // 栈顶弹出元素</span><br><span class="line">MLOAD:    &quot;MLOAD&quot;,</span><br><span class="line">MSTORE:   &quot;MSTORE&quot;,</span><br><span class="line">MSTORE8:  &quot;MSTORE8&quot;,</span><br><span class="line">SLOAD:    &quot;SLOAD&quot;, //先取出栈顶元素x，然后在storage中取以x为键的值（storage[x]）存入栈顶</span><br><span class="line">SSTORE:   &quot;SSTORE&quot;, //存储storage是一个键值存储，可将256位字映射到256位字</span><br><span class="line">JUMP:     &quot;JUMP&quot;,</span><br><span class="line">JUMPI:    &quot;JUMPI&quot;,</span><br><span class="line">PC:       &quot;PC&quot;,</span><br><span class="line">MSIZE:    &quot;MSIZE&quot;,</span><br><span class="line">GAS:      &quot;GAS&quot;,</span><br><span class="line">JUMPDEST: &quot;JUMPDEST&quot;</span><br></pre></td></tr></table></figure>



<h3 id="Push指令集"><a href="#Push指令集" class="headerlink" title="Push指令集"></a>Push指令集</h3><blockquote>
<p><em>0x60</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// PUSH系列指令把紧跟在指令后面的N（1 ～ 32）字节元素推入栈顶</span><br><span class="line">PUSH1:  &quot;PUSH1&quot;,</span><br><span class="line">...</span><br><span class="line">PUSH32: &quot;PUSH32&quot;,</span><br><span class="line"></span><br><span class="line">   //DUP系列指令复制从栈顶开始数的第N（1 ～ 16）个元素，并把复制后的元素推入栈顶</span><br><span class="line">DUP1:  &quot;DUP1&quot;,</span><br><span class="line">DUP2:  &quot;DUP2&quot;,</span><br><span class="line">...</span><br><span class="line">DUP16: &quot;DUP16&quot;,</span><br><span class="line"></span><br><span class="line">//SWAP系列指令把栈顶元素和从栈顶开始数的第N（1 ～ 16）+ 1 个元素进行交换。</span><br><span class="line">SWAP1:  &quot;SWAP1&quot;,</span><br><span class="line">...</span><br><span class="line">SWAP16: &quot;SWAP16&quot;,</span><br><span class="line"></span><br><span class="line">LOG0:   &quot;LOG0&quot;,</span><br><span class="line">...</span><br><span class="line">LOG4:   &quot;LOG4&quot;,</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Ethash共识算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Ethash共识算法</p>
<p>代码分支：<a href="https://github.com/ethereum/go-ethereum/tree/v1.9.9">https://github.com/ethereum/go-ethereum/tree/v1.9.9</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>目前以太坊中有两个共识算法的实现：<code>clique</code>和<code>ethash</code>。而<code>ethash</code>是目前以太坊主网（<code>Homestead</code>版本）的<code>POW</code>共识算法。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><code>ethash</code>模块位于以太坊项目目录下的<code>consensus/ethash</code>目录下。</p>
<ul>
<li><strong>algorithm.go</strong><br>实现了<code>Dagger-Hashimoto</code>算法的所有功能，比如生成<code>cache</code>和<code>dataset</code>、根据<code>Header</code>和<code>Nonce</code>计算挖矿哈希等。</li>
<li><strong>api.go</strong><br>实现了供<code>RPC</code>使用的<code>api</code>方法。</li>
<li><strong>consensus.go</strong><br>实现了以太坊共识接口的部分方法，包括<code>Verify</code>系列方法（<code>VerifyHeader</code>、<code>VerifySeal</code>等）、<code>Prepare</code>和<code>Finalize</code>、<code>CalcDifficulty</code>、<code>Author</code>、<code>SealHash</code>。</li>
<li><strong>ethash.go</strong><br>实现了<code>cache</code>结构体和<code>dataset</code>结构体及它们各自的方法、<code>MakeCache</code>&#x2F;<code>MakeDataset</code>函数、<code>Ethash</code>对象的<code>New</code>函数，和<code>Ethash</code>的内部方法。</li>
<li><strong>sealer.go</strong><br>实现了共识接口的<code>Seal</code>方法，和<code>Ethash</code>的内部方法<code>mine</code>。这些方法实现了<code>ethash</code>的挖矿功能。</li>
</ul>
<h2 id="Ethash-设计原理"><a href="#Ethash-设计原理" class="headerlink" title="Ethash 设计原理"></a>Ethash 设计原理</h2><h3 id="Ethash设计目标"><a href="#Ethash设计目标" class="headerlink" title="Ethash设计目标"></a>Ethash设计目标</h3><p>以太坊设计共识算法时，期望达到三个目的：</p>
<ol>
<li>抗<code>ASIC</code>性：为算法创建专用硬件的优势应尽可能小，让普通计算机用户也能使用CPU进行开采。<ul>
<li>通过内存限制来抵制（<code>ASIC</code>使用矿机内存昂贵）</li>
<li>大量随机读取内存数据时计算速度就不仅仅受限于计算单元，更受限于内存的读出速度。</li>
</ul>
</li>
<li>轻客户端可验证性: 一个区块应能被轻客户端快速有效校验。</li>
<li>矿工应该要求存储完整的区块链状态。</li>
</ol>
<h3 id="哈希数据集"><a href="#哈希数据集" class="headerlink" title="哈希数据集"></a>哈希数据集</h3><p><code>ethash</code>要计算哈希，需要先有一块数据集。这块数据集较大，初始大小大约有<code>1G</code>，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。计算哈希的数据源就是从这块数据集中来的；而决定使用数据集中的哪些数据进行哈希计算的，才是<code>header</code>的数据和<code>Nonce</code>字段。这部分是由<code>Dagger</code>算法实现的。</p>
<h4 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h4><p><code>Dagger</code>算法是用来生成数据集<code>Dataset</code>的，核心的部分就是<code>Dataset</code>的生成方式和组织结构。</p>
<p>可以把<code>Dataset</code>想成多个<code>item</code>（<strong>dataItem</strong>）组成的数组，每个<code>item</code>是<code>64</code>字节的byte数组（一条哈希）。<code>dataset</code>的初始大小约为<code>1G</code>，每隔3万个区块（一个<code>epoch</code>区间）就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。</p>
<p><code>Dataset</code>的每个<code>item</code>是由一个缓存块（<code>cache</code>）生成的，缓存块也可以看做多个<code>item</code>（<strong>cacheItem</strong>）组成，缓存块占用的内存要比<code>dataset</code>小得多，它的初始大小约为<code>16M</code>。同<code>dataset</code>类似，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>128K</code>左右。</p>
<p>生成一条<code>dataItem</code>的程是：从缓存块中“随机”（这里的“随机”不是真的随机数，而是指事前不能确定，但每次计算得到的都是一样的值）选择一个<code>cacheItem</code>进行计算，得的结果参与下次计算，这个过程会循环 256 次。</p>
<p>缓存块是由<code>seed</code>生成的，而<code>seed</code>的值与块的高度有关。所以生成<code>dataset</code>的过程如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm8arq9t7j30x80eytji.jpg" alt="image-20201213144908721"></p>
<p><code>Dagger</code>还有一个关键的地方，就是确定性。即同一个<code>epoch</code>内，每次计算出来的<code>seed</code>、缓存、<code>dataset</code>都是相同的。否则对于同一个区块，挖矿的人和验证的人使用不同的<code>dataset</code>，就没法进行验证了。</p>
<hr>
<h3 id="Hashimoto算法"><a href="#Hashimoto算法" class="headerlink" title="Hashimoto算法"></a>Hashimoto算法</h3><p>是<code>Thaddeus Dryja</code>创造的。旨在通过<code>IO</code>限制来抵制矿机。在挖矿过程中，使内存读取限制条件，由于内存设备本身会比计算设备更加便宜以及普遍，在内存升级优化方面，全世界的大公司也都投入巨大，以使内存能够适应各种用户场景，所以有了随机访问内存的概念<code>RAM</code>，因此,现有的内存可能会比较接近最优的评估算法。<code>Hashimoto</code>算法使用区块链作为源数据，满足了上面的 1 和 3 的要求。</p>
<p>它的作用就是使用区块Header的哈希和Nonce字段、利用dataset数据，生成一个最终的哈希值。</p>
<hr>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="生成哈希数据集"><a href="#生成哈希数据集" class="headerlink" title="生成哈希数据集"></a>生成哈希数据集</h3><p><code>generate</code>函数位于<code>ethash.go</code>文件中，主要是为了生成<code>dataset</code>,其中包扩以下内容。</p>
<h4 id="生成cache-size"><a href="#生成cache-size" class="headerlink" title="生成cache size"></a>生成cache size</h4><p><code>cache size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> *，   <code>epochLength</code> 为 30000，如果<code>epoch</code> 小于 2048，则从已知的<code>epoch</code>返回相应的<code>cache size</code>，否则重新计算<code>epoch</code> </p>
<p><code>cache</code>的大小是线性增长的，<code>size</code>的值等于(2^24^ + 2^17^ * epoch - 64)，用这个值除以 64 看结果是否是一个质数，如果不是，减去128 再重新计算，直到找到最大的质数为止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">csize := cacheSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> cacheSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcCacheSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCacheSize</span><span class="params">(epoch <span class="type">int</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	size := cacheInitBytes + cacheGrowthBytes*<span class="type">uint64</span>(epoch) - hashBytes</span><br><span class="line">	<span class="keyword">for</span> !<span class="built_in">new</span>(big.Int).SetUint64(size / hashBytes).ProbablyPrime(<span class="number">1</span>) &#123; <span class="comment">// Always accurate for n &lt; 2^64</span></span><br><span class="line">		size -= <span class="number">2</span> * hashBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成dataset-size"><a href="#生成dataset-size" class="headerlink" title="生成dataset size"></a>生成dataset size</h4><p><code>dataset Size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> , 类似上面生成<code>cache size</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dsize := datasetSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">datasetSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> datasetSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcDatasetSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-seed-种子"><a href="#生成-seed-种子" class="headerlink" title="生成 seed 种子"></a>生成 seed 种子</h4><p><em>seedHash是用于生成验证缓存和挖掘数据集的种子。</em>长度为 32。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seed := seedHash(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">seedHash</span><span class="params">(block <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> block &lt; epochLength &#123;</span><br><span class="line">		<span class="keyword">return</span> seed</span><br><span class="line">	&#125;</span><br><span class="line">	keccak256 := makeHasher(sha3.NewLegacyKeccak256())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(block/epochLength); i++ &#123;</span><br><span class="line">		keccak256(seed, seed)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成cache"><a href="#生成cache" class="headerlink" title="生成cache"></a>生成cache</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">generateCache(cache, d.epoch, seed)</span><br></pre></td></tr></table></figure>

<p>接下来分析<code>generateCache</code>的关键代码：</p>
<p>先了解一下<strong>hashBytes</strong>，在下面的计算中都是以此为单位，它的值为 64 ，相当于一个<code>keccak512</code>哈希的长度,下文以<strong>item</strong>称呼<code>[hashBytes]byte</code>。</p>
<p>①：初始化<code>cache</code></p>
<p>此循环用来初始化<code>cache</code>：先将<code>seed</code>的哈希填入<code>cache</code>的第一个<code>item</code>,随后使用前一个<code>item</code>的哈希，填充后一个<code>item</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> offset := <span class="type">uint64</span>(hashBytes); offset &lt; size; offset += hashBytes &#123;</span><br><span class="line">		keccak512(cache[offset:], cache[offset-hashBytes:offset])</span><br><span class="line">		atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：对cache中数据按规则做异或</p>
<p>为对于每一个<code>item</code>（<code>srcOff</code>），“随机”选一个<code>item</code>（<code>xorOff</code>）与其进行异或运算；将运算结果的哈希写入<code>dstOff</code>中。这个运算逻辑将进行<code>cacheRounds</code>次。</p>
<p>两个需要注意的地方：</p>
<ul>
<li>一是<code>srcOff</code>是从尾部向头部变化的，而<code>dstOff</code>是从头部向尾部变化的。并且它俩是对应的，即当<code>srcOff</code>代表倒数第x个item时，<code>dstOff</code>则代表正数第x个item。</li>
<li>二是<code>xorOff</code>的选取。注意我们刚才的“随机”是打了引号的。<code>xorOff</code>的值看似随机，因为在给出<code>seed</code>之前，你无法知道xorOff的值是多少；但一旦<code>seed</code>的值确定了，那么每一次<code>xorOff</code>的值都是确定的。而seed的值是由区块的高度决定的。这也是同一个<code>epoch</code>内总是能得到相同<code>cache</code>数据的原因。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cacheRounds; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; rows; j++ &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				srcOff = ((j - <span class="number">1</span> + rows) % rows) * hashBytes</span><br><span class="line">				dstOff = j * hashBytes</span><br><span class="line">				xorOff = (binary.LittleEndian.Uint32(cache[dstOff:]) % <span class="type">uint32</span>(rows)) * hashBytes</span><br><span class="line">			)</span><br><span class="line">			bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBytes], cache[xorOff:xorOff+hashBytes])</span><br><span class="line">			keccak512(cache[dstOff:], temp)</span><br><span class="line"></span><br><span class="line">			atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="生成dataset"><a href="#生成dataset" class="headerlink" title="生成dataset"></a>生成dataset</h4><p><code>dataset</code>大小的计算和<code>cache</code>类似，量级不同：2^30^ + 2^23^ * epoch - 128，然后每次减256寻找最大质数。</p>
<p>生成数据是一个循环，每次生成64个字节，主要的函数是<code>generateDatasetItem</code>：</p>
<p><code>generateDatasetItem</code>的数据来源就是<code>cache</code>数据，而最终的dataset值会存储在mix变量中。整个过程也是由多个循环构成。 </p>
<p>①：初始化<code>mix</code>变量</p>
<p>根据cache值对<code>mix</code>变量进行初始化。其中<code>hashWords</code>代表的是一个<code>hash</code>里有多少个<code>word</code>值：一个<code>hash</code>的长度为<code>hashBytes</code>即64字节，一个<code>word</code>（uint32类型）的长度为 4 字节，因此<code>hashWords</code>值为 16。选取<code>cache</code>中的哪一项数据是由参数<code>index</code>和<code>i</code>变量决定的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">byte</span>, hashBytes)</span><br><span class="line">binary.LittleEndian.PutUint32(mix, cache[(index%rows)*hashWords]^index)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; hashWords; i++ &#123;</span><br><span class="line">	binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], cache[(index%rows)*hashWords+<span class="type">uint32</span>(i)])</span><br><span class="line">&#125;</span><br><span class="line">keccak512(mix, mix)</span><br></pre></td></tr></table></figure>

<p>②：将<code>mix</code>转换成<code>[]uint32</code>类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">intMix := <span class="built_in">make</span>([]<span class="type">uint32</span>, hashWords)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intMix); i++ &#123;</span><br><span class="line">		intMix[i] = binary.LittleEndian.Uint32(mix[i*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：将<code>cache</code>数据聚合进<code>intmix</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; datasetParents; i++ &#123;</span><br><span class="line">		parent := fnv(index^i, intMix[i%<span class="number">16</span>]) % rows</span><br><span class="line">		fnvHash(intMix, cache[parent*hashWords:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>FNV</code>哈希算法，是一种不需要使用密钥的哈希算法。</p>
<p>这个算法很简单：a乘以FNV质数0x01000193，然后再和b异或。</p>
<p>首先用这个算法算出一个索引值，利用这个索引从<code>cache</code>中选出一个值（<code>data</code>），然后对<code>mix</code>中的每个字节都计算一次<code>FNV</code>，得到最终的哈希值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnv</span><span class="params">(a, b <span class="type">uint32</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">0x01000193</span> ^ b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnvHash</span><span class="params">(mix []<span class="type">uint32</span>, data []<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">        mix[i] = mix[i]*<span class="number">0x01000193</span> ^ data[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>④：将<code>intMix</code>又恢复成<code>mix</code>并计算<code>mix</code>的哈希返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> intMix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	keccak512(mix, mix)</span><br><span class="line">	<span class="keyword">return</span> mix</span><br></pre></td></tr></table></figure>

<p><code>generateCache</code>和<code>generateDataset</code>是实现<code>Dagger</code>算法的核心函数，到此整个生成哈希数据集的的过程结束。</p>
<hr>
<h3 id="共识引擎核心函数"><a href="#共识引擎核心函数" class="headerlink" title="共识引擎核心函数"></a>共识引擎核心函数</h3><p>代码位于<code>consensus.go</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glnee6vhalj31py0lkgq4.jpg" alt="image-20201214150532321"></p>
<p>①：<code>Author</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回coinbase, coinbase是打包第一笔交易的矿工的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Author(header *types.Header) (common.Address, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> header.Coinbase, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<code>VerifyHeader</code></p>
<p>主要有两步检查，第一步检查<strong>header是否已知</strong>或者<strong>是未知的祖先</strong>，第二步是<code>ethash</code>的检查：</p>
<p>2.1 header.Extra 不能超过32字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(<span class="built_in">len</span>(header.Extra)) &gt; params.MaximumExtraDataSize &#123;  <span class="comment">// 不超过32字节</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;extra-data too long: %d &gt; %d&quot;</span>, <span class="built_in">len</span>(header.Extra), params.MaximumExtraDataSize)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 时间戳不能超过15秒，15秒以后的就被认定为未来的块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !uncle &#123;</span><br><span class="line">		<span class="keyword">if</span> header.Time &gt; <span class="type">uint64</span>(time.Now().Add(allowedFutureBlockTime).Unix()) &#123;</span><br><span class="line">			<span class="keyword">return</span> consensus.ErrFutureBlock</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 当前header的时间戳小于父块的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.Time &lt;= parent.Time &#123; <span class="comment">// 当前header的时间小于等于父块的</span></span><br><span class="line">		<span class="keyword">return</span> errZeroBlockTime</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 根据时间戳和父块的难度来验证块的难度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">expected := ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.5验证<code>gas limit</code>小于2^63^ -1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cap</span> := <span class="type">uint64</span>(<span class="number">0x7fffffffffffffff</span>)</span><br><span class="line">	<span class="keyword">if</span> header.GasLimit &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasLimit: have %v, max %v&quot;</span>, header.GasLimit, <span class="built_in">cap</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 确认<code>gasUsed</code>为&lt;&#x3D; <code>gasLimit</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.GasUsed &gt; header.GasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasUsed: have %d, gasLimit %d&quot;</span>, header.GasUsed, header.GasLimit)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 验证块号是父块加1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> diff := <span class="built_in">new</span>(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(<span class="number">1</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrInvalidNumber</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.8检查给定的块是否满足pow难度要求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seal &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.VerifySeal(chain, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：<code>VerifyUncles</code></p>
<p>3.1叔叔块最多两个 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(block.Uncles()) &gt; maxUncles &#123;</span><br><span class="line">		<span class="keyword">return</span> errTooManyUncles</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.2收集叔叔块和祖先块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">number, parent := block.NumberU64()<span class="number">-1</span>, block.ParentHash()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">		ancestor := chain.GetBlock(parent, number)</span><br><span class="line">		<span class="keyword">if</span> ancestor == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ancestors[ancestor.Hash()] = ancestor.Header()</span><br><span class="line">		<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> ancestor.Uncles() &#123;</span><br><span class="line">			uncles.Add(uncle.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		parent, number = ancestor.ParentHash(), number<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ancestors[block.Hash()] = block.Header()</span><br><span class="line">	uncles.Add(block.Hash())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.3 确保叔块只被奖励一次且叔块有个有效的祖先</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, uncle := <span class="keyword">range</span> block.Uncles() &#123;</span><br><span class="line">		<span class="comment">// Make sure every uncle is rewarded only once</span></span><br><span class="line">		hash := uncle.Hash()</span><br><span class="line">		<span class="keyword">if</span> uncles.Contains(hash) &#123;</span><br><span class="line">			<span class="keyword">return</span> errDuplicateUncle</span><br><span class="line">		&#125;</span><br><span class="line">		uncles.Add(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure the uncle has a valid ancestry</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[hash] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errUncleIsAncestor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ancestors[uncle.ParentHash] == <span class="literal">nil</span> || uncle.ParentHash == block.ParentHash() &#123;</span><br><span class="line">			<span class="keyword">return</span> errDanglingUncle</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], <span class="literal">true</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：<code>Prepare</code></p>
<blockquote>
<p>初始化<code>header</code>的<code>Difficulty</code>字段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	header.Difficulty = ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>⑤：<code>Finalize</code>会执行交易后的所有状态修改（例如，区块奖励），但<strong>不会组装</strong>该区块。</p>
<p>5.1累积任何块和叔块的奖励</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">accumulateRewards(chain.Config(), state, header, uncles)</span><br></pre></td></tr></table></figure>

<p>5.2计算状态树的根哈希并提交到<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br></pre></td></tr></table></figure>

<p>⑥：<code>FinalizeAndAssemble</code> 运行任何交易后状态修改（例如，块奖励），并组装最终块。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> FinalizeAndAssemble(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, <span class="type">error</span>) &#123;</span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, uncles, receipts), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显就是比<code>Finalize</code>多了 <code>types.NewBlock</code></p>
<p>⑦：<code>SealHash</code>返回在<code>seal</code>之前块的哈希（会跟<code>seal</code>之后的块哈希不同）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> SealHash(header *types.Header) (hash common.Hash) &#123;</span><br><span class="line">	hasher := sha3.NewLegacyKeccak256()</span><br><span class="line"></span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra,</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑧：<code>Seal</code>给定的输入块生成一个新的密封请求（<strong>挖矿</strong>），并将结果推送到给定的通道中。</p>
<p>注意，该方法将立即返回并将异步发送结果。 根据共识算法，可能还会返回多个结果。这部分会在下面的挖矿中具体分析，这里跳过。</p>
<hr>
<h3 id="挖矿细节"><a href="#挖矿细节" class="headerlink" title="挖矿细节"></a>挖矿细节</h3><blockquote>
<p>大家在阅读本文时有任何疑问均可留言给我，我一定会及时回复。如果觉得写得不错可以关注最下方<strong>参考</strong>的 <code>github项目</code>，可以第一时间关注作者文章动态。</p>
</blockquote>
<p>挖矿的核心接口定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Seal(chain ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>进入到<code>seal</code>函数：</p>
<p>①：如果运行错误的<code>POW</code>，直接返回空的<code>nonce</code>和<code>MixDigest</code>，同时块也是空块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		header := block.Header()</span><br><span class="line">		header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> results &lt;- block.WithSeal(header):</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;fake&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：共享<code>pow</code>的话，则转到它的共享对象执行<code>Seal</code>操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.shared.Seal(chain, block, results, stop)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：获取种子源，并根据其生成<code>ethash</code>需要的种子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f ethash.rand == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 获得种子</span></span><br><span class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ethash.lock.Unlock()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">// 给rand赋值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：挖矿的核心工作交给<code>mine</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line">		pend.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>, nonce <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()</span><br><span class="line">			ethash.mine(block, id, nonce, abort, locals) <span class="comment">// 真正执行挖矿的动作</span></span><br><span class="line">		&#125;(i, <span class="type">uint64</span>(ethash.rand.Int63()))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：处理挖矿的结果</p>
<ul>
<li>外部意外中止，停止所有挖矿线程</li>
<li>其中一个线程挖到正确块，中止其他所有线程</li>
<li>ethash对象发生改变，停止当前所有操作，重启当前方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> result *types.Block</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> result = &lt;-locals:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> results &lt;- result: <span class="comment">//其中一个线程挖到正确块，中止其他所有线程</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ethash.update:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">			<span class="keyword">if</span> err := ethash.Seal(chain, block, results, stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				ethash.config.Log.Error(<span class="string">&quot;Failed to restart sealing after update&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以知道<code>seal</code>的核心工作是由<code>mine</code>函数完成的，重点介绍一下。</p>
<p><code>mine</code>函数其实也比较简单，它是<em>真正的<code>pow</code>矿工，用来搜索一个<code>nonce</code>值，<code>nonce</code>值开始于<code>seed</code>值，<code>seed</code>值是能最终产生正确的可匹配可验证的区块难度</em></p>
<p>①：从区块头中提取相关数据，放在全局变量域中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		header  = block.Header()</span><br><span class="line">		hash    = ethash.SealHash(header).Bytes()</span><br><span class="line">		target  = <span class="built_in">new</span>(big.Int).Div(two256, header.Difficulty) <span class="comment">// 这是用来验证的target</span></span><br><span class="line">		number  = header.Number.Uint64()</span><br><span class="line">		dataset = ethash.dataset(number, <span class="literal">false</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>②：开始产生随机<code>nonce</code>，直到我们中止或找到一个好的<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		attempts = <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">		nonce    = seed</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>③： 聚集完整的<code>dataset</code>数据，为特定的header和nonce产生最终哈希值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoFull</span><span class="params">(dataset []<span class="type">uint32</span>, hash []<span class="type">byte</span>, nonce <span class="type">uint64</span>)</span></span> ([]<span class="type">byte</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line">  <span class="comment">//定义一个lookup函数，用于在数据集中查找数据</span></span><br><span class="line">	lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">uint32</span>)</span></span> []<span class="type">uint32</span> &#123;</span><br><span class="line">		offset := index * hashWords <span class="comment">//hashWords是上面定义的常量值= 16</span></span><br><span class="line">		<span class="keyword">return</span> dataset[offset : offset+hashWords]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hashimoto(hash, nonce, <span class="type">uint64</span>(<span class="built_in">len</span>(dataset))*<span class="number">4</span>, lookup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现实际上<code>hashimotoFull</code>函数做的工作就是将原始数据集进行了读取分割，然后传给<code>hashimoto</code>函数。接下来重点分析<code>hashimoto</code>函数：</p>
<p>3.1根据seed获取区块头</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows := <span class="type">uint32</span>(size / mixBytes) ①</span><br><span class="line">seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">40</span>) ②</span><br><span class="line"><span class="built_in">copy</span>(seed, hash) ③</span><br><span class="line">binary.LittleEndian.PutUint64(seed[<span class="number">32</span>:], nonce)④</span><br><span class="line">seed = crypto.Keccak512(seed)⑤</span><br><span class="line">seedHead := binary.LittleEndian.Uint32(seed)⑥</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数据集的行数</li>
<li>合并<code>header+nonce</code>到一个 40 字节的<code>seed</code></li>
<li>将区块头的<code>hash</code>拷贝到<code>seed</code>中</li>
<li>将<code>nonce</code>值填入<code>seed</code>的后（40-32&#x3D;8）字节中去，（nonce本身就是<code>uint64</code>类型，是 64 位，对应 8 字节大小），正好把<code>hash</code>和<code>nonce</code>完整的填满了 40 字节的 seed </li>
<li><code>Keccak512</code>加密<code>seed</code></li>
<li>从<code>seed</code>中获取区块头</li>
</ol>
<p>3.2 从复制的种子开始混合</p>
<ul>
<li><code>mixBytes</code>常量&#x3D; 128，<code>mix</code>的长度为 32，元素为<code>uint32</code>，是 32位，对应为 4 字节大小。所以<code>mix</code>总共大小为 4*32&#x3D;128 字节大小</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">uint32</span>, mixBytes/<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">		mix[i] = binary.LittleEndian.Uint32(seed[i%<span class="number">16</span>*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 混合随机数据集节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">temp := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="built_in">len</span>(mix))<span class="comment">//与mix结构相同，长度相同</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; loopAccesses; i++ &#123;</span><br><span class="line">		parent := fnv(<span class="type">uint32</span>(i)^seedHead, mix[i%<span class="built_in">len</span>(mix)]) % rows</span><br><span class="line">		<span class="keyword">for</span> j := <span class="type">uint32</span>(<span class="number">0</span>); j &lt; mixBytes/hashBytes; j++ &#123;</span><br><span class="line">			<span class="built_in">copy</span>(temp[j*hashWords:], lookup(<span class="number">2</span>*parent+j))</span><br><span class="line">		&#125;</span><br><span class="line">		fnvHash(mix, temp)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 压缩混合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i += <span class="number">4</span> &#123;</span><br><span class="line">		mix[i/<span class="number">4</span>] = fnv(fnv(fnv(mix[i], mix[i+<span class="number">1</span>]), mix[i+<span class="number">2</span>]), mix[i+<span class="number">3</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	mix = mix[:<span class="built_in">len</span>(mix)/<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	digest := <span class="built_in">make</span>([]<span class="type">byte</span>, common.HashLength)</span><br><span class="line">	<span class="keyword">for</span> i, val := <span class="keyword">range</span> mix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(digest[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digest, crypto.Keccak256(<span class="built_in">append</span>(seed, digest...))</span><br></pre></td></tr></table></figure>

<p>最终返回的是<code>digest</code>和<code>digest</code>与<code>seed</code>的哈希；而<code>digest</code>其实就是<code>mix</code>的<code>[]byte</code>形式。在前面<code>Ethash.mine</code>的代码中我们已经看到使用第二个返回值与<code>target</code>变量进行比较，以确定这是否是一个有效的哈希值。</p>
<hr>
<h3 id="验证pow"><a href="#验证pow" class="headerlink" title="验证pow"></a>验证pow</h3><p>挖矿信息的验证有两部分：</p>
<ol>
<li>验证<code>Header.Difficulty</code>是否正确</li>
<li>验证<code>Header.MixDigest</code>和<code>Header.Nonce</code>是否正确</li>
</ol>
<p>①：验证<code>Header.Difficulty</code>的代码主要在<code>Ethash.verifyHeader</code>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeader(chain consensus.ChainReader, header, parent *types.Header, uncle <span class="type">bool</span>, seal <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过区块高度和时间差作为参数来计算<code>Difficulty</code>值，然后与待验证的区块的<code>Header.Difficulty</code>字段进行比较，如果相等则认为是正确的。</p>
<p>②：<code>MixDigest</code>和<code>Nonce</code>的验证主要是在<code>Header.verifySeal</code>中：</p>
<p>验证的方式:使用<code>Header.Nonce</code>和头部哈希通过<code>hashimoto</code>重新计算一遍<code>MixDigest</code>和<code>result</code>哈希值,并且验证的节点是不需要dataset数据的。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> </p>
<p>公众号：区块链技术栈  （推荐哦）</p>
<p><a href="https://eth.wiki/concepts/ethash/design-rationale">https://eth.wiki/concepts/ethash/design-rationale</a></p>
<p><a href="https://eth.wiki/concepts/ethash/dag">https://eth.wiki/concepts/ethash/dag</a></p>
<p><a href="https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/">https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Fetcher同步</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BFetcher%E5%90%8C%E6%AD%A5-6/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Fetcher同步</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> (文章资料在此，给个Star哦)</p>
</blockquote>
<h2 id="Fetcher-功能概述"><a href="#Fetcher-功能概述" class="headerlink" title="Fetcher 功能概述"></a>Fetcher 功能概述</h2><p>区块数据同步分为被动同步和主动同步:</p>
<ul>
<li><p>被动同步是指本地节点收到其他节点的一些<strong>广播</strong>的消息，然后请求区块信息。</p>
</li>
<li><p>主动同步是指节点主动向其他节点请求区块数据，比如geth刚启动时的syning，以及运行时定时和相邻节点同步</p>
</li>
</ul>
<p><code>Fetcher</code>负责被动同步，主要做以下事情：</p>
<ul>
<li>收到完整的block广播消息(NewBlockMsg)</li>
<li>收到blockhash广播消息(NewBlockHashesMsg)</li>
</ul>
<p>这两个消息又是分别由 <code>peer.AsyncSendNewBlockHash</code> 和 <code>peer.AsyncSendNewBlock</code> 两个方法发出的，这两个方法只有在矿工挖到新的区块时才会被调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅本地挖到新的区块的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> minedBroadcastLoop() &#123;</span><br><span class="line">    <span class="keyword">for</span> obj := <span class="keyword">range</span> pm.minedBlockSub.Chan() &#123;</span><br><span class="line">        <span class="keyword">if</span> ev, ok := obj.Data.(core.NewMinedBlockEvent); ok &#123;</span><br><span class="line">            pm.BroadcastBlock(ev.Block, <span class="literal">true</span>)  <span class="comment">// First propagate block to peers</span></span><br><span class="line">            pm.BroadcastBlock(ev.Block, <span class="literal">false</span>) <span class="comment">// Only then announce to the rest</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> BroadcastBlock(block *types.Block, propagate <span class="type">bool</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> propagate &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">            peer.AsyncSendNewBlock(block, td) <span class="comment">//发送区块数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pm.blockchain.HasBlock(hash, block.NumberU64()) &#123;</span><br><span class="line">        <span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">            peer.AsyncSendNewBlockHash(block) <span class="comment">//发送区块哈希</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当某个矿工产生了新的区块、并将这个新区块广播给其它节点，而<strong>其它远程节点</strong>收到广播的消息时，才会用到 <code>fetcher</code> 模块去同步这些区块。</p>
<hr>
<h2 id="fetcher的状态字段"><a href="#fetcher的状态字段" class="headerlink" title="fetcher的状态字段"></a>fetcher的状态字段</h2><p>在 <code>Fetcher</code> 内部对区块进行同步时，会被分成如下几个阶段，并且每个阶段都有一个状态字段与之对应，用来记录这个阶段的数据：</p>
<ul>
<li><code>Fetcher.announced</code>:此阶段代表节点宣称产生了新的区块（这个新产生的区块不一定是自己产生的，也可能是同步了其它节点新产生的区块），<code>Fetcher</code> 对象将相关信息放到 <code>Fetcher.announced</code> 中，等待下载。</li>
<li><code>Fetcher.fetching</code>：此阶段代表之前「announced」的区块正在被下载。</li>
<li><code>Fetcher.fetched</code>：代表区块的 <code>header</code> 已下载成功，现在等待下载 <code>body</code>。</li>
<li><code>Fetcher.completing</code>：代表 <code>body</code> 已经发起了下载，正在等待 <code>body</code> 下载成功。</li>
<li><code>Fetcher.queued</code>:代表 <code>body</code> 已经下载成功。因此一个区块的数据：<code>header</code> 和 body 都已下载完成，此区块正在等待写入本地数据库。</li>
</ul>
<h2 id="Fetcher-同步区块哈希"><a href="#Fetcher-同步区块哈希" class="headerlink" title="Fetcher 同步区块哈希"></a>Fetcher 同步区块哈希</h2><p>而新产生区块时，会使用消息 <code>NewBlockHashesMsg</code> 和 <code>NewBlockMsg</code> 对其进行传播。因此 <code>Fetcher</code> 对象也是从这两个消息处发现新的区块信息的。先来看同步区块哈希的过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == NewBlockHashesMsg:</span><br><span class="line">		<span class="keyword">var</span> announces newBlockHashesData</span><br><span class="line">		<span class="keyword">if</span> err := msg.Decode(&amp;announces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;%v: %v&quot;</span>, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Mark the hashes as present at the remote node</span></span><br><span class="line">		<span class="comment">// 将hash 标记存在于远程节点上</span></span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">			p.MarkBlock(block.Hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Schedule all the unknown hashes for retrieval 检索所有未知哈希</span></span><br><span class="line">		unknown := <span class="built_in">make</span>(newBlockHashesData, <span class="number">0</span>, <span class="built_in">len</span>(announces))</span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">			<span class="keyword">if</span> !pm.blockchain.HasBlock(block.Hash, block.Number) &#123;</span><br><span class="line">				unknown = <span class="built_in">append</span>(unknown, block) <span class="comment">// 本地不存在的话就扔到unkonwn里面</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> unknown &#123;</span><br><span class="line">			pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>先将接收的哈希标记在远程节点上，然后去本地检索是否有这个哈希，如果本地数据库不存在的话，就放到<code>unknown</code>里面，然后通知本地的<code>fetcher</code>模块再去远程节点上请求此区块的<code>header</code>和<code>body</code>。 接下来进入到<code>fetcher.Notify</code>方法中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span></span> Notify(peer <span class="type">string</span>, hash common.Hash, number <span class="type">uint64</span>, time time.Time,</span><br><span class="line">	headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) <span class="type">error</span> &#123;</span><br><span class="line">	block := &amp;announce&#123;</span><br><span class="line">		hash:        hash,</span><br><span class="line">		number:      number,</span><br><span class="line">		time:        time,</span><br><span class="line">		origin:      peer,</span><br><span class="line">		fetchHeader: headerFetcher,</span><br><span class="line">		fetchBodies: bodyFetcher,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.notify &lt;- block:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>它构造了一个 <code>announce</code> 结构，并将其发送给了 <code>Fetcher.notify</code> 这个 channel。注意 <code>announce</code> 这个结构里带着下载 header 和 body 的方法： <code>fetchHeader</code> 和 <code>fetchBodies</code> 。这两个方法在下面的过程中会讲到。 接下来我们进入到<code>fetcher.go</code>的loop函数中，找到<code>notify</code>，分以下几个内容：</p>
<p>①：校验防止Dos攻击(限制为256个)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := f.announces[notification.origin] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> count &gt; hashLimit &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Peer exceeded outstanding announces&quot;</span>, <span class="string">&quot;peer&quot;</span>, notification.origin, <span class="string">&quot;limit&quot;</span>, hashLimit)</span><br><span class="line">				propAnnounceDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②：新来的块号必须满足 $chainHeight - blockno &lt; 7$ 或者 $blockno - chainHeight &lt; 32$ </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> notification.number &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> dist := <span class="type">int64</span>(notification.number) - <span class="type">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">			...			&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>③：准备下载<code>header</code>的<code>fetching</code>中存在此哈希则跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.fetching[notification.hash]; ok &#123; </span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>④：准备下载<code>body</code>的<code>completing</code>中存在此哈希也跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.completing[notification.hash]; ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：当确定<code>fetching</code>和<code>completing</code>不存在此区块哈希时，则把此区块哈希放入到<code>announced</code>中，准备拉取<code>header</code>和<code>body</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f.announced[notification.hash] = <span class="built_in">append</span>(f.announced[notification.hash], notification)</span><br></pre></td></tr></table></figure>

<p>⑥：如果 <code>Fetcher.announced</code> 中只有刚才新加入的这一个区块哈希，那么调用 <code>Fetcher.rescheduleFetch</code> 重新设置变量 <code>fetchTimer</code> 的周期</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f.announced) == <span class="number">1</span> &#123;</span><br><span class="line">				f.rescheduleFetch(fetchTimer)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拉取header"><a href="#拉取header" class="headerlink" title="拉取header"></a>拉取header</h3><p>接下来就是到<code>fetchTimer.C</code>函数中：进行拉取header的操作了,具体步骤如下：</p>
<p>①：选择要下载的区块，从 <code>announced</code> 转移到 <code>fetching</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.announced &#123;</span><br><span class="line">				<span class="keyword">if</span> time.Since(announces[<span class="number">0</span>].time) &gt; arriveTimeout-gatherSlack &#123;</span><br><span class="line">				<span class="comment">// 随机挑一个进行fetching</span></span><br><span class="line">					announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">					f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">					<span class="comment">// If the block still didn&#x27;t arrive, queue for fetching</span></span><br><span class="line">					<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">						f.fetching[hash] = announce <span class="comment">//</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②：发送下载 <code>header</code> 的请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送所有的header请求</span></span><br><span class="line">			<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Fetching scheduled headers&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;list&quot;</span>, hashes)</span><br><span class="line">				fetchHeader, hashes := f.fetching[hashes[<span class="number">0</span>]].fetchHeader, hashes</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="keyword">if</span> f.fetchingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">						f.fetchingHook(hashes)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> _, hash := <span class="keyword">range</span> hashes &#123;</span><br><span class="line">						headerFetchMeter.Mark(<span class="number">1</span>)</span><br><span class="line">						fetchHeader(hash) </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;()</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们再回到<code>f.notify</code>函数中，找到<code>p.RequestOneHeader</code>，发送<code>GetBlockHeadersMsg</code>给远程节点，然后远程节点再通过<code>case msg.Code == GetBlockHeadersMsg</code>进行处理，本地区块链会返回headers，然后再发送回去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)</span><br><span class="line">...</span><br><span class="line">p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p>这时候我们请求的<code>headers</code>被远程节点给发送回来了，又是通过新的消息<code>BlockHeadersMsg</code>来传递的,当请求的 <code>header</code> 到来时，会通过两种方式来过滤header ：</p>
<ol>
<li><code>Fetcher.FilterHeaders</code> 通知 <code>Fetcher</code> 对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == BlockHeadersMsg:</span><br><span class="line">....</span><br><span class="line">filter := <span class="built_in">len</span>(headers) == <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> filter &#123;</span><br><span class="line">  headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<code>downloader.DeliverHeaders</code> 通知<code>downloader</code>对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">			err := pm.downloader.DeliverHeaders(p.id, headers)</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><code>downloader</code>相关的放在接下的文章探讨。继续看<code>FilterHeaders</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *headerFilterTask)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.headerFilter &lt;- filter: ①</span><br><span class="line">....</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;peer: peer, headers: headers, time: time&#125;: ②</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter: ③</span><br><span class="line">		<span class="keyword">return</span> task.headers</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要分为3个步骤：</p>
<ol>
<li>先发一个通信用的 <code>channel</code> 给 <code>headerFilter</code></li>
<li>将要过滤的 <code>headerFilterTask</code> 发送给 <code>filter</code></li>
<li>检索过滤后剩余的标题</li>
</ol>
<p>主要的处理步骤还是在<code>loop</code>函数中的<code>filter := &lt;-f.headerFilter</code>，在探讨处理前，先了解三个参数的含义：</p>
<ul>
<li><code>unknown：</code>未知的header</li>
<li><code>incomplete：</code><strong>header</strong>拉取完成，但是<strong>body</strong>还没有拉取</li>
<li><code>complete：</code><strong>header</strong>和<strong>body</strong>都拉取完成，一个完整的块，可导入到数据库</li>
</ul>
<p>接下来正式进入到<code>for _, header := range task.headers &#123;&#125;</code>循环中: <strong>这是第一段重要的循环</strong></p>
<p>①：判断是否是在<code>fetching</code>中的header，并且不是其他同步算法的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> announce := f.fetching[hash]; announce != <span class="literal">nil</span> &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == <span class="literal">nil</span> &amp;&amp; f.completing[hash] == <span class="literal">nil</span> &amp;&amp; f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果传递的<code>header</code>与承诺的<code>number</code>不匹配，删除<code>peer</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.Number.Uint64() != announce.number &#123;</span><br><span class="line">  f.dropPeer(announce.origin)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：判断此区块在本地是否已存在,如果不存在且只有<code>header</code>（空块），直接放入<code>complete</code>以及<code>f.completing</code>中，否则就放入到<code>incomplete</code>中等待同步<code>body</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						announce.header = header</span><br><span class="line">						announce.time = task.time</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> header.TxHash == types.DeriveSha(types.Transactions&#123;&#125;) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header&#123;&#125;) &#123;</span><br><span class="line">				...</span><br><span class="line">							block := types.NewBlockWithHeader(header)</span><br><span class="line">							block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">							complete = <span class="built_in">append</span>(complete, block)</span><br><span class="line">							f.completing[hash] = announce</span><br><span class="line">							<span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">						incomplete = <span class="built_in">append</span>(incomplete, announce) <span class="comment">// 否则添加到需要完成拉取body的列表中</span></span><br></pre></td></tr></table></figure>

<p>④：如果<code>f.fetching</code>中不存在此哈希，就放入到<code>unkown</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// Fetcher doesn&#x27;t know about it, add to the return list |fetcher 不认识的放到unkown中</span></span><br><span class="line">					unknown = <span class="built_in">append</span>(unknown, header)</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：之后再把<code>Unknown</code>的<code>header</code>再通知fetcher继续过滤</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;headers: unknown, time: task.time&#125;:</span><br><span class="line">			<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是<strong>进入到第二个循环</strong>，要准备拿出incomplete里的哈希，进行同步body的同步</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, announce := <span class="keyword">range</span> incomplete &#123;</span><br><span class="line">				hash := announce.header.Hash()</span><br><span class="line">				<span class="keyword">if</span> _, ok := f.completing[hash]; ok &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				f.fetched[hash] = <span class="built_in">append</span>(f.fetched[hash], announce)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(f.fetched) == <span class="number">1</span> &#123;</span><br><span class="line">					f.rescheduleComplete(completeTimer)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>f.completing</code>中存在，就表明已经在开始同步<code>body</code>了，直接跳过，否则把这个哈希放入到<code>f.fetched</code>，表示<code>header</code>同步完毕，准备<code>body</code>同步，由<code>f.rescheduleComplete(completeTimer)</code>完成。最后是安排只有<code>header</code>的区块进行导入操作.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> complete &#123;</span><br><span class="line">				<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.enqueue(announce.origin, block)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析<code>completeTimer.C</code>，同步<code>body</code>的操作，这步完成就是要准备区块导入到数据库流程了。</p>
<h3 id="拉取body"><a href="#拉取body" class="headerlink" title="拉取body"></a>拉取body</h3><p>进入<code>completeTimer.C</code>，从f.fetched获取哈希，如果本地区块链查不到的话就把这个哈希放入到<code>f.completing</code>中，再循环进行<code>fetchBodies</code>，整个流程就结束了，代码大致如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-completeTimer.C:</span><br><span class="line">...</span><br><span class="line">			<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.fetched &#123;</span><br><span class="line">		....</span><br><span class="line">				<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">					request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">					f.completing[hash] = announce</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">        ...</span><br><span class="line">				<span class="keyword">go</span> f.completing[hashes[<span class="number">0</span>]].fetchBodies(hashes)</span><br><span class="line">			&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关键的拉取<code>body</code>函数： <code>p.RequestBodies</code>，发送<code>GetBlockBodiesMsg</code>消息同步<code>body</code>。回到<code>handler</code>里面去查看对应的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == GetBlockBodiesMsg:</span><br><span class="line">		<span class="comment">// Decode the retrieval message</span></span><br><span class="line">		msgStream := rlp.NewStream(msg.Payload, <span class="type">uint64</span>(msg.Size))</span><br><span class="line">		<span class="keyword">if</span> _, err := msgStream.List(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			hash   common.Hash</span><br><span class="line">			bytes  <span class="type">int</span></span><br><span class="line">			bodies []rlp.RawValue</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">for</span> bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(bodies) &lt; downloader.MaxBlockFetch &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> data := pm.blockchain.GetBodyRLP(hash); <span class="built_in">len</span>(data) != <span class="number">0</span> &#123;</span><br><span class="line">				bodies = <span class="built_in">append</span>(bodies, data)</span><br><span class="line">				bytes += <span class="built_in">len</span>(data)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p.SendBlockBodiesRLP(bodies)</span><br></pre></td></tr></table></figure>

<p><code>softResponseLimit</code>返回的<code>body</code>大小最大为$2 * 1024 * 1024$,<code>MaxBlockFetch</code>表示每个请求最多128个<code>body</code>。</p>
<p>之后直接通过<code>GetBodyRLP</code>返回数据通过<code>SendBlockBodiesRLP</code>发回给节点。</p>
<p>节点将会接收到新消息：<code>BlockBodiesMsg</code>，进入查看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤掉filter请求的body 同步，其他的都交给downloader</span></span><br><span class="line">		filter := <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> filter &#123;</span><br><span class="line">			transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">			err := pm.downloader.DeliverBodies(p.id, transactions, uncles)</span><br><span class="line">...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>过滤掉<code>filter</code>请求的<code>body</code> 同步，其他的都交给<code>downloader</code>，<code>downloader</code>部分之后的篇章讲。进入到<code>FilterBodies</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *bodyFilterTask)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.bodyFilter &lt;- filter:  ①</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the body list</span></span><br><span class="line">	<span class="comment">// 请求过滤body 列表</span></span><br><span class="line">	<span class="keyword">select</span> &#123; ②</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;bodyFilterTask&#123;peer: peer, transactions: transactions, uncles: uncles, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the bodies remaining after filtering</span></span><br><span class="line">	<span class="keyword">select</span> &#123; ③：</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.transactions, task.uncles</span><br></pre></td></tr></table></figure>

<p>主要分为3个步骤：</p>
<ol>
<li>先发一个通信用的 <code>channel</code> 给 <code>bodyFilter</code></li>
<li>将要过滤的 <code>bodyFilterTask</code> 发送给 <code>filter</code></li>
<li>检索过滤后剩余的<code>body</code></li>
</ol>
<p>现在进入到<code>case filter := &lt;-f.bodyFilter</code>里面，大致做了以下几件事：</p>
<p>①：首先从f.completing中获取要同步body的哈希</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(task.transactions) &amp;&amp; i &lt; <span class="built_in">len</span>(task.uncles); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.completing &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>②：然后从f.queued去查这个哈希是不是已经获取了body，如果没有并满足条件就创建一个完整block </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">						txnHash := types.DeriveSha(types.Transactions(task.transactions[i]))</span><br><span class="line">						uncleHash := types.CalcUncleHash(task.uncles[i])</span><br><span class="line">  <span class="keyword">if</span> txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer &#123;</span><br><span class="line">							matched = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">								block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i])</span><br><span class="line">								block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">                blocks = <span class="built_in">append</span>(blocks, block)</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>③：最后对完整的块进行导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">				<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.enqueue(announce.origin, block)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>最后用一张粗略的图来大概的描述一下整个同步区块哈希的流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glae3zccpdj30wm0t6q67.jpg" alt="image-20201203090304059"></p>
<hr>
<p>同步区块哈希的最终会走到<code>f.enqueue</code>里面，这个也是<strong>同步区块</strong>最重要的要做的一件事，下文就会讲到。</p>
<h2 id="Fetcher-同步区块"><a href="#Fetcher-同步区块" class="headerlink" title="Fetcher 同步区块"></a>Fetcher 同步区块</h2><p>分析完上面比较复杂的同步区块哈希过程，接下来就要分析比较简单的同步区块过程。从<code>NewBlockMsg</code>开始：</p>
<p>主要做两件事：</p>
<p>①：<code>fetcher</code>模块导入远程节点发过来的区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.fetcher.Enqueue(p.id, request.Block)</span><br></pre></td></tr></table></figure>

<p>②：<strong>主动同步</strong>远程节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, td := p.Head(); trueTD.Cmp(td) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			p.SetHead(trueHead, trueTD)</span><br><span class="line">			currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">			<span class="keyword">if</span> trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> pm.synchronise(p)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>主动同步由<code>Downloader</code>去处理，我们这篇只讨论<code>fetcher</code>相关。</p>
<h3 id="区块入队列"><a href="#区块入队列" class="headerlink" title="区块入队列"></a>区块入队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.fetcher.Enqueue(p.id, request.Block)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> op := &lt;-f.inject:</span><br><span class="line">			propBroadcastInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			f.enqueue(op.origin, op.block)</span><br></pre></td></tr></table></figure>

<p>正式进入将区块送进<code>queue</code>中，主要做了以下几件事：</p>
<p>①： 确保新加<code>peer</code>没有导致<code>DOS</code>攻击</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := f.queues[peer] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; blockLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Discarded propagated block, exceeded allowance&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;limit&quot;</span>, blockLimit)</span><br><span class="line">		propBroadcastDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：丢弃掉过去的和比较老的区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dist := <span class="type">int64</span>(block.NumberU64()) - <span class="type">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">  f.forgetHash(hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：安排区块导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.queued[hash]; !ok &#123;</span><br><span class="line">	op := &amp;inject&#123;</span><br><span class="line">		origin: peer,</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	f.queues[peer] = count</span><br><span class="line">	f.queued[hash] = op</span><br><span class="line">	f.queue.Push(op, -<span class="type">int64</span>(block.NumberU64()))</span><br><span class="line">	<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">		f.queueChangeHook(op.block.Hash(), <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Debug(<span class="string">&quot;Queued propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;queued&quot;</span>, f.queue.Size())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，已经将区块送入到<code>queue</code>中，接下来就是要回到<code>loop</code>函数中去处理<code>queue</code>中的区块。</p>
<h3 id="区块入库"><a href="#区块入库" class="headerlink" title="区块入库"></a>区块入库</h3><p>loop函数在处理队列中的区块主要做了以下事情：</p>
<ol>
<li>判断队列是否为空</li>
<li>取出区块哈希，并且和本地链进行比较，如果太高的话，就暂时不导入</li>
<li>最后通过f.insert将区块插入到数据库。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">height := f.chainHeight()</span><br><span class="line">		<span class="keyword">for</span> !f.queue.Empty() &#123;</span><br><span class="line">			op := f.queue.PopItem().(*inject)</span><br><span class="line">			hash := op.block.Hash()</span><br><span class="line">		...</span><br><span class="line">			number := op.block.NumberU64()</span><br><span class="line">			<span class="keyword">if</span> number &gt; height+<span class="number">1</span> &#123;</span><br><span class="line">				f.queue.Push(op, -<span class="type">int64</span>(number))</span><br><span class="line">	...</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> number+maxUncleDist &lt; height || f.getBlock(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.forgetBlock(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			f.insert(op.origin, op.block) <span class="comment">//导入块</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>f.insert</code>中，主要做了以下几件事：</p>
<p>①：判断区块的父块是否存在，不存在则中断插入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := f.getBlock(block.ParentHash())</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Debug(<span class="string">&quot;Unknown parent of propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;parent&quot;</span>, block.ParentHash())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②： 快速验证header，<strong>并在传递时广播该块</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := f.verifyHeader(block.Header()); err &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			propBroadcastOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">			<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>③：运行真正的插入逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Propagated block import failed&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：导入成功广播此块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>真正做区块入库的是f.insertChain，这里会调用blockchain模块去操作，具体细节会后续文章讲述，到此为止Fether模块的同步就到此结束了，下面是同步区块的流程图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glae40anr7j30ps0mkn0t.jpg" alt="image-20201203090327173"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a> </p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Kademlia算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BKademlia%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Kademlia算法</p>
</blockquote>
<h2 id="KAD-算法概述"><a href="#KAD-算法概述" class="headerlink" title="KAD 算法概述"></a>KAD 算法概述</h2><p>Kademlia是一种点对点分布式哈希表（DHT），它在容易出错的环境中也具有可证明的一致性和性能。使用一种基于异或指标的拓扑结构来路由查询和定位节点，这简化了算法并有助于证明。该拓扑结构有一个特点：<strong>每次消息交换都能够传递或强化有效信息</strong>。系统利用这些信息进行并发的异步查询，可以容忍节点故障，并且故障不会导致用户超时。</p>
<h2 id="KAD算法要处理的问题"><a href="#KAD算法要处理的问题" class="headerlink" title="KAD算法要处理的问题"></a>KAD算法要处理的问题</h2><ol>
<li>如何分配存储内容到各个节点，新增&#x2F;删除内容如何处理</li>
<li>如何找到存储文件的节点&#x2F;地址&#x2F;路径</li>
</ol>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>节点的基本属性包括如下：</p>
<blockquote>
<ul>
<li>节点ID，Node ID</li>
<li>节点IP地址与端口号</li>
</ul>
</blockquote>
<p>在 Kad 网络中，所有节点都被当作一颗二叉树的叶子，并且每一个节点的位置都由其 ID 值的最短前缀唯一的确定。</p>
<p>对于任意一个节点，都可以把这颗二叉树分解为一系列连续的，不包含自己的子树。最高层的子树，由整颗树不包含自己的树的另一半组成；下一层子树由剩下部分不包含自己的一半组成；依此类推，直到分割完整颗树。图 1 就展示了节点0011如何进行子树的划分：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxt4yerlnj313e0ckgpk.jpg" alt="image-20201122115058412"></p>
<p>虚线包含的部分就是各子树，由上到下各层的前缀分别为0，01，000，0010。</p>
<p>Kad 协议确保每个节点知道其各子树的至少一个节点，只要这些子树非空。在这个前提下，每个节点都可以通过ID值来找到任何一个节点。这个路由的过程是通过所谓的 XOR（异或）距离得到的。</p>
<p>图 2 就演示了节点0011如何通过连续查询来找到节点1110的。节点0011通过在逐步底层的子树间不断学习并查询最佳节点，获得了越来越接近的节点，最终收敛到目标节点上。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxt81k4ltj314o0u0ti5.jpg" alt="image-20201122115359426"></p>
<p>需要说明的是:<strong>只有第一步查询的节点101，是节点0011已经知道的，后面各步查询的节点，都是由上一步查询返回的更接近目标的节点，这是一个递归操作的过程</strong>。</p>
<hr>
<h2 id="节点距离"><a href="#节点距离" class="headerlink" title="节点距离"></a>节点距离</h2><p>Kad 网络中每个节点都有一个 160 bit 的 ID 值作为标志符，Key 也是一个 160 bit 的标志符，每一个加入 Kad 网络的计算机都会在 160 bit 的 key 空间被分配一个节点 ID（node ID）值（可以认为 ID 是随机产生的）， <code>&lt;key,value&gt;</code> 对的数据就存放在 ID 值“最”接近 key 值的节点上。</p>
<p>判断两个节点 x,y 的距离远近是基于数学上的异或的二进制运算， d(x,y)&#x3D;x⊕y ，既对应位相同时结果为0，不同时结果为1。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    010101</span><br><span class="line">XOR 110001</span><br><span class="line">----------</span><br><span class="line">    100100</span><br></pre></td></tr></table></figure>

<p>则这两个节点的距离为 32+4&#x3D;36 。</p>
<p>显然，高位上数值的差异对结果的影响更大。</p>
<p>对于异或操作，有如下一些数学性质：</p>
<ul>
<li>两个节点间的距离是随机的</li>
<li>节点与自身的距离是0</li>
<li>对称性。A 到 B 的距离和 B 到 A 的距离相等</li>
<li>三角不等。distance(A,B)+distance(B,C) &lt;&#x3D; distance(A,C)</li>
</ul>
<p>对于任意给定的节点 x 和距离 Δ≥0 ，总会存在一个精确的节点 y ，使得 d(x,y)&#x3D;Δ 。另外，单向性也确保了对于同一个 key 值的所有查询都会逐步收敛到同一个路径上，而不管查询的起始节点位置如何。这样，只要沿着查询路径上的节点都缓存这个 <code>&lt;key,value&gt;</code> 对，就可以减轻存放热门 key 值节点的压力，同时也能够加快查询响应速度。</p>
<h2 id="K桶"><a href="#K桶" class="headerlink" title="K桶"></a>K桶</h2><h3 id="K-桶的概念"><a href="#K-桶的概念" class="headerlink" title="K 桶的概念"></a>K 桶的概念</h3><p>Kad 的路由表是通过一些称之为 K 桶的表格构造起来的。</p>
<p>对每一个 0≤i≤160 ，每个节点都保存有一些和自己距离范围在区间 [2^i^,2^i+1^) 内的一些节点信息，这些信息由一些 (IP address,UDP port,Node ID) 数据列表构成（Kad 网络是靠 UDP 协议交换信息的）。每一个这样的列表都称之为一个 K 桶，并且每个 K 桶内部信息存放位置是根据上次看到的时间顺序排列，最近（ least-recently）看到的放在头部，最后（most-recently）看到的放在尾部。每个桶都有不超过 k 个的数据项。</p>
<p>一个节点的全部 K 桶列表如下图 所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxxsik21cj30qs0eidhw.jpg" alt="image-20201122143202816"></p>
<p>当 i 值很小时，K 桶通常是空的（也就是说没有足够多的节点，比如当 i &#x3D; 0 时，就最多可能只有1项）；而当 i 值很大时，其对应 K 桶的项数又很可能会超过 k 个（当然，覆盖距离范围越广，存在较多节点的可能性也就越大），这里 k 是为平衡系统性能和网络负载而设置的一个常数，但必须是偶数，比如 k &#x3D; 20。在 BitTorrent 的实现中，取值为 k &#x3D; 8。</p>
<p>由于每个 K 桶覆盖距离的范围呈指数关系增长，这就形成了离自己近的节点的信息多，离自己远的节点的信息少，从而可以保证路由查询过程是收敛。因为是用指数方式划分区间，经过证明，对于一个有 N 个节点的 Kad 网络，最多只需要经过 logN 步查询，就可以准确定位到目标节点。</p>
<h3 id="K桶更新机制"><a href="#K桶更新机制" class="headerlink" title="K桶更新机制"></a>K桶更新机制</h3><p>当节点 x 收到一个 PRC 消息时，发送者 y 的 IP 地址就被用来更新对应的 K 桶，具体步骤如下：</p>
<ol>
<li>计算自己和发送者的距离： d(x,y)&#x3D;x⊕y ，注意：x 和 y 是 ID 值，不是 IP 地址</li>
<li>通过距离 d 选择对应的 K 桶进行更新操作</li>
<li>如果 y 的 IP 地址已经存在于这个 K 桶中，则把对应项移到该该 K 桶的尾部</li>
<li>如果 y 的 IP 地址没有记录在该 K 桶中<ol>
<li>如果该 K 桶的记录项小于 k 个，则直接把 y 的 (IP address, UDP port, Node ID) 信息插入队列尾部</li>
<li>如果该 K 桶的记录项大于 k 个，则选择头部的记录项（假如是节点 z）进行 RPC_PING 操作<ol>
<li>如果 z 没有响应，则从 K 桶中移除 z 的信息，并把 y 的信息插入队列尾部</li>
<li>如果 z 有响应，则把 z 的信息移到队列尾部，同时忽略 y 的信息</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>K 桶的更新机制非常高效的实现了一种把<strong>最近看到的节点更新</strong>的策略，除非在线节点一直未从 K 桶中移出过。也就是说在线时间长的节点具有较高的可能性继续保留在 K 桶列表中。</p>
<p>所以，通过把在线时间长的节点留在 K 桶里，Kad 就明显增加 K 桶中的节点在下一时间段仍然在线的概率，这<strong>对应 Kad 网络的稳定性和减少网络维护成本（不需要频繁构建节点的路由表）</strong>带来很大好处。</p>
<p>这种机制的另一个好处是能在<strong>一定程度上防御 DOS 攻击</strong>，因为只有当老节点失效后，Kad 才会更新 K 桶的信息，这就避免了通过新节点的加入来泛洪路由信息。</p>
<p>为了防止 K 桶老化，所有在一定时间之内无更新操作的 K 桶，都会分别从自己的 K 桶中随机选择一些节点执行 RPC_PING 操作。</p>
<p>上述这些 K 桶机制使 Kad 缓和了流量瓶颈（所有节点不会同时进行大量的更新操作），同时也能对节点的失效进行迅速响应。</p>
<hr>
<h2 id="协议消息"><a href="#协议消息" class="headerlink" title="协议消息"></a>协议消息</h2><p>Kademlia 协议包括四种远程 RPC 操作：PING、STORE、FIND_NODE、FIND_VALUE。</p>
<ol>
<li><p>PING 操作的作用是探测一个节点，用以判断其是否仍然在线。</p>
</li>
<li><p>STORE 操作的作用是通知一个节点存储一个 <code>&lt;key,value&gt;</code> 对，以便以后查询需要。</p>
</li>
<li><p>FIND_NODE 操作使用一个 160 bit 的 ID 作为参数。本操作的接受者返回它所知道的更接近目标 ID 的 K 个节点的 (IP address, UDP port, Node ID) 信息。</p>
<p>这些节点的信息可以是从一个单独的 K 桶获得，也可以从多个 K 桶获得（如果最接近目标 ID 的 K 桶未满）。不管是哪种情况，接受者都将返回 K 个节点的信息给操作发起者。但如果接受者所有 K 桶的节点信息加起来也没有 K 个，则它会返回全部节点的信息给发起者。</p>
</li>
<li><p>FIND_VALUE 操作和 FIND_NODE 操作类似，不同的是它只需要返回一个节点的 (IP address, UDP port, Node ID) 信息。如果本操作的接受者收到同一个 key 的 STORE 操作，则会直接返回存储的 value 值。</p>
<p>注：在 Kad 网络中，系统存储的数据以 <code>&lt;key,value&gt;</code> 对形式存放。根据笔者的分析，在 BitSpirit 的 DHT 实现中，其 key 值为 torrent 文件的 info_hash 串，其 value 值则和 torrent 文件有密切关系。</p>
</li>
</ol>
<p>为了防止伪造地址，在所有 RPC 操作中，接受者都需要响应一个随机的 160 bit 的 ID 值。另外，为了确信发送者的网络地址，PING 操作还可以附带在接受者的 RPC 回复信息中（<strong>在上述 4种操作中 接受者回复 发送者时，可以携带上 接受者对 发送者的 PING, 以此校验 发送者是否还健在</strong>）。</p>
<hr>
<h2 id="路由查找"><a href="#路由查找" class="headerlink" title="路由查找"></a>路由查找</h2><p>Kad 技术的最大特点之一就是能够提供快速的节点查找机制，并且还可以通过参数进行查找速度的调节。</p>
<p>假如节点 x 要查找 ID 值为 t 的节点，Kad 按照如下递归操作步骤进行路由查找：</p>
<ol>
<li>计算到 t 的距离： d(x,y)&#x3D;x⊕y</li>
<li>从 x 的第 [logd] 个 K 桶中取出 α 个节点的信息（“[”“]”是取整符号），同时进行 FIND_NODE 操作。如果这个 K 桶中的信息少于 α 个，则从附近多个桶中选择距离最接近 d 的总共 α 个节点。</li>
<li>对接受到查询操作的每个节点，如果发现自己就是 t，则回答自己是最接近 t 的；否则测量自己和 t 的距离，并从自己对应的 K 桶中选择 α 个节点的信息给 x。</li>
<li>X 对新接受到的每个节点都再次执行 FIND_NODE 操作，此过程不断重复执行，直到每一个分支都有节点响应自己是最接近 t 的。</li>
<li>通过上述查找操作，x 得到了 k 个最接近 t 的节点信息。</li>
</ol>
<p>注意：这里用“最接近”这个说法，是因为 ID 值为 t 的节点不一定存在网络中，也就是说 t 没有分配给任何一台电脑。</p>
<p>这里 α 也是为系统优化而设立的一个参数，就像 K 一样。在 BitTorrent 实现中，取值为 α&#x3D;3 。</p>
<p>当 α&#x3D;1 时，查询过程就类似于 Chord 的逐跳查询过程，如图 4。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxw58zgnyj30ym0u0ast.jpg" alt="image-20201122133505567"></p>
<p>整个路由查询过程是递归操作的，其过程可用数学公式表示为：</p>
<blockquote>
<p>N0&#x3D;x (即查询操作的发起者)</p>
<p>N1&#x3D;find ⎯noden0(t)</p>
<p>N2&#x3D;find ⎯noden1(t)</p>
<p>… …</p>
<p>Nl&#x3D;find ⎯nodenl−1(t)</p>
</blockquote>
<p>这个递归过程一直持续到 Nl&#x3D;t ，或者 Nl 的路由表中没有任何关于 t 的信息，即查询失败。</p>
<p>由于每次查询都能从更接近 t 的 K 桶中获取信息，这样的机制保证了每一次递归操作都能够至少获得距离减半（或距离减少 1 bit）的效果，从而保证整个查询过程的收敛速度为 O(logN) ，这里 N 为网络全部节点的数量。</p>
<p>当节点 x 要查询 <code>&lt;key,value&gt;</code> 对时，和查找节点的操作类似，x 选择 k 个 ID 值最接近 key 值的节点，执行 FIND_VALUE 操作，并对每一个返回的新节点重复执行 FIND_VALUE 操作，直到某个节点返回 value 值。</p>
<p>一旦 FIND_VALUE 操作成功执行，则 <code>&lt;key,value&gt;</code> 对数据会缓存在没有返回 value 值的最接近的节点上。这样下一次查询相同的 key 时就会更加快速的得到结果。通过这样的方式，热门 <code>&lt;key,value&gt;</code> 对数据的缓存范围就逐步扩大，使系统具有极佳的响应速度( <strong>cache 为存活24小时</strong>，但是目标节点上的内容时<strong>每1小时</strong>向其他最近节点重新发布&lt;key, value&gt;使得数据的超时时间得以刷新，而远离目标节点的节点的数据存活时间当然就可能不会被重新发布到，所以也就是数据缓存的超时时间和节点的距离成反比)</p>
<hr>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>存放 <code>&lt;key,value&gt;</code> 对数据的过程为：</p>
<ol>
<li>发起者首先定位 k 个 ID 值最接近 key 的节点</li>
<li>发起者对这 k 个节点发起 STORE 操作</li>
<li>执行 STORE 操作的 k 个节点每小时重发布自己所有的 <code>&lt;key,value&gt;</code> 对数据</li>
<li>为了限制失效信息，所有 <code>&lt;key,value&gt;</code> 对数据在初始发布24小时后过期</li>
</ol>
<p>另外，为了保证数据发布、搜寻的一致性，规定在任何时候，当节点 w 发现新节点 u 比 w 上的某些 <code>&lt;key,value&gt;</code> 对数据更接近，则 w 把这些 <code>&lt;key,value&gt;</code> 对数据复制到 u 上，但是并不会从 w 上删除。</p>
<hr>
<h2 id="节点的加入和离开"><a href="#节点的加入和离开" class="headerlink" title="节点的加入和离开"></a>节点的加入和离开</h2><p>如果节点 u 要想加入 Kad 网络，它必须要和一个已经在 Kad 网络的节点，比如 w，取得联系。</p>
<p>u 首先把 w 插入自己适当的 K 桶中，然后对自己的节点 ID 执行一次 FIND_NODE 操作 (向 w 发布 查找 u 的 FIND_NODE 请求)，然后根据接收到的信息更新自己的 K 桶内容。通过对自己邻近节点由近及远的逐步查询，u 完成了仍然是空的 K 桶信息的构建，同时也把自己的信息发布到其他节点的 K 桶中。</p>
<p>节点 u 为例，其路由表的生成过程为：</p>
<ol>
<li>最初，u 的路由表为一个单个的 K 桶，覆盖了整个 160 bit ID 空间，如图 6 最上面的路由表；</li>
<li>当学习到新的节点信息后，则 u 会尝试把新节点的信息，根据其前缀值插入到对应的 K 桶中：<ol>
<li>如果该 K 桶没有满，则新节点直接插入到这个 K 桶中；</li>
<li>如果该 K 桶已经满了，<ol>
<li>如果该 K 桶覆盖范围包含了节点 u 的 ID，则把该 K 桶分裂为两个大小相同的新 K 桶，并对原 K 桶内的节点信息按照新的 K 桶前缀值进行重新分配</li>
<li>如果该 K 桶覆盖范围没有包节点 u 的 ID，则直接丢弃该新节点信息</li>
</ol>
</li>
</ol>
</li>
<li>上述过程不断重复，最终会形成表 1 结构的路由表。达到距离近的节点的信息多，距离远的节点的信息少的结果，保证了路由查询过程能快速收敛。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxyh70im3j30vu0my40e.jpg" alt="image-20201122145547341"></p>
<p>在图 7 中，演示了当覆盖范围包含自己 ID 值的 K 桶是如何逐步分裂的。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxyhl2k3bj30vk0pgq7o.jpg" alt="image-20201122145609681"></p>
<p>当 K 桶 010 满了之后，由于其覆盖范围包含了节点 0100 的 ID，故该 K 桶分裂为两个新的 K 桶：0101 和 0100，原 K 桶 010 的信息会根据其其前缀值重新分布到这两个新的 K 桶中。注意，这里并没有使用 160 bit 的 ID 值表示法，只是为了方便原理的演示，实际 Kad 网络中的 ID 值都是 160 bit 的。</p>
<p><strong>节点离开 Kad 网络不需要发布任何信息</strong>，Kademlia 协议的目标之一就是能够弹性工作在任意节点随时失效的情况下。为此，Kad 要求每个节点必须周期性 【一般是： 每小时】 的发布全部自己存放的 &lt;key,value&gt; 对数据，并把这些数据缓存在自己的 k 个最近邻居处，这样存放在失效节点的数据会很快被更新到其他新节点上。所以有节点离开了，那么就离开了，而且节点中的k-桶刷新机制也能保证会把已经不在线的节点信息从自己本地k-桶中移除</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>公众号：区块链技术栈</p>
<p>文章及所有资料：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之MPT树-上</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之MPT树-上</p>
</blockquote>
<h2 id="前缀树Trie"><a href="#前缀树Trie" class="headerlink" title="前缀树Trie"></a>前缀树Trie</h2><p>前缀树（又称字典树），通常来说，一个前缀树是用来<code>存储字符串</code>的。前缀树的每一个节点代表一个<code>字符串</code>（<code>前缀</code>）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>组成的。如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm73i6xursj31820qq789.jpg" alt="image-20201231160000592"></p>
<p>Trie的结点看上去是这样子的：</p>
<blockquote>
<p>[ [Ia, Ib, … I*], value]</p>
</blockquote>
<p>其中 <code>[Ia, Ib, ... I*]</code> 在本文中我们将其称为结点的 <em>索引数组</em> ，它以 key 中的下一个字符为索引，每个元素<code>I*</code>指向对应的子结点。 <code>value</code> 则代表从根节点到当前结点的路径组成的key所对应的值。如果不存在这样一个 key，则 value 的值为空。</p>
<p>前缀树的性质：</p>
<ol>
<li><p>每一层节点上面的值都不相同；</p>
</li>
<li><p>根节点不存储值；除根节点外每一个节点都<strong>只包含一个字符</strong>，代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>。</p>
</li>
<li><p>前缀树的查找效率是$O(m)$，$m$为所查找节点的长度，而哈希表的查找效率为$O(1)$。且一次查找会有 m 次 <code>IO</code>开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
</li>
<li><p>当存在一个节点，其内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
</li>
</ol>
<h2 id="压缩前缀树Patricia-Tree"><a href="#压缩前缀树Patricia-Tree" class="headerlink" title="压缩前缀树Patricia Tree"></a>压缩前缀树Patricia Tree</h2><p><strong>基数树</strong>（也叫<strong>基数特里树</strong>或<strong>压缩前缀树</strong>）是一种数据结构，是一种更节省空间的<strong>前缀树</strong>，其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数 <em>r</em> ，其中 <em>r</em> 为正整数， <em>x</em> 为 2 的幂， <em>x</em>≥1 ，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70dwcmgdj31780kkqae.jpg" alt="image-20201231133805927"></p>
<p>图中可以很容易看出数中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<h2 id="默克尔树Merkle-Tree"><a href="#默克尔树Merkle-Tree" class="headerlink" title="默克尔树Merkle Tree"></a>默克尔树Merkle Tree</h2><p>Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm69qu5vh8j31ba0ragpn.jpg" alt="image-20201230225028932"></p>
<p>在构造<code>Merkle</code>树时，首先要计算数据块的哈希值，通常，选用<code>SHA-256</code>等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如<code>CRC</code>。然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希，再重复这个步骤，一直到计算出根哈希值。</p>
<p>所以我们可以简单总结出<strong>merkle Tree</strong> 有以下几个性质：</p>
<ul>
<li>校验整体数据的正确性</li>
<li>快速定位错误</li>
<li>快速校验部分数据是否在原始的数据中</li>
<li>存储空间开销大（<strong>大量中间哈希</strong>）</li>
</ul>
<h2 id="以太坊的改进方案"><a href="#以太坊的改进方案" class="headerlink" title="以太坊的改进方案"></a>以太坊的改进方案</h2><h3 id="使用-byte作为key类型"><a href="#使用-byte作为key类型" class="headerlink" title="使用[]byte作为key类型"></a>使用[]byte作为key类型</h3><p>在以太坊的Trie模块中，key和value都是[]byte类型。如果要使用其它类型，需要将其转换成[]byte类型（比如使用<strong>rlp</strong>进行转换）。</p>
<p><strong>Nibble</strong> ：是 key 的基本单元，是一个四元组（四个 bit 位的组合例如二进制表达的 0010 就是一个四元组）</p>
<p>在Trie模块对外提供的接口中，key类型是[]byte。但在内部实现里，将key中的每个字节按高4位和低4位拆分成了两个字节。比如你传入的key是：</p>
<blockquote>
<p>[0x1a, 0x2b, 0x3c, 0x4d]</p>
</blockquote>
<p>Trie内部将这个key拆分成：</p>
<blockquote>
<p>[0x1, 0xa, 0x2, 0xb, 0x3, 0xc, 0x4, 0xd]</p>
</blockquote>
<p>Trie内部的编码中将拆分后的<strong>每一个字节</strong>称为 <strong>nibble</strong></p>
<p>如果使用一个完整的 byte 作为 key 的最小单位，那么前文提到的索引数组的大小应该是 256（byte作为数组的索引，最大值为255，最小值为0）。而索引数组的每个元素都是一个 32 字节的哈希,这样每个结点要占用大量的空间。并且索引数组中的元素多数情况下是空的，不指向任何结点。因此这种实现方法占用大量空间而不使用。以太坊的改进方法，可以将索引数组的大小降为 16（4个bit的最大值为0xF，最小值为 0），因此大大减少空间的浪费。</p>
<h3 id="新增类型节点"><a href="#新增类型节点" class="headerlink" title="新增类型节点"></a>新增类型节点</h3><p>前缀树和<code>merkle</code>树存在明显的局限性，所以以太坊为<code>MPT</code>树新增了几种不同类型的树节点，通过针对不同节点不同操作来解决效率以及存储上的问题。</p>
<ol>
<li><strong>shortNode</strong>: 叶子节点或者扩展节点，当 <code>shortNode.Key</code>的末尾字节是终止符 <code>16</code> 时表示为叶子节点。当 <code>shortNode</code> 是叶子节点是，<code>Val</code> 是 valueNode。</li>
<li><strong>fullNode</strong>:  分支节点，<code>fullNode[16]</code>的类型是 <code>valueNode</code>。前 16 个元素对应键中可能存在的一个十六进制字符。如果键<code>[key,value]</code>在对应的分支处结束，则在列表末尾存储 <code>value</code> 。</li>
<li><strong>hashNode</strong>: 应该取名为 <code>collapsedNode</code> 折叠节点更合适些，但因为其值是一个哈希值当做指针使用，所以取名 <code>hashNode</code>。使用这个哈希值可以从数据库读取节点数据展开节点。</li>
<li><strong>valueNode</strong>: 数据节点，实际的业务数据值，严格来说他不属于树中的节点，它只存在于 <code>fullNode.Children</code> 或者 shortNode.Val 中。</li>
</ol>
<p>简单先看个例子，假设有3个键值对，看一下在以太坊中是怎么以MPT的形式存储的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg6d40u15j31hu0o0jzy.jpg" alt="image-20210108122909361"></p>
<h3 id="以太坊中使用到的MPT树结构"><a href="#以太坊中使用到的MPT树结构" class="headerlink" title="以太坊中使用到的MPT树结构"></a>以太坊中使用到的MPT树结构</h3><ul>
<li><code>State Trie</code> 区块头中的状态树<ul>
<li>key &#x3D;&gt; sha3(以太坊账户地址 address)</li>
<li>value &#x3D;&gt; rlp(账号内容信息 account)</li>
</ul>
</li>
<li>Transactions Trie 区块头中的交易树<ul>
<li>key &#x3D;&gt; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Receipts Trie</code> 区块头中的收据树<ul>
<li>key &#x3D; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Storage Trie</code> 存储树<ul>
<li>存储只能合约状态</li>
<li>每个账号有自己的 Storage Trie</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70f77s2dj319g0lymyz.jpg" alt="image-20201231141329137"></p>
<p>这两个区块头中，<code>state root</code>、<code>tx root</code>、 <code>receipt root</code>分别存储了这三棵树的树根，第二个区块显示了当账号 17 5的数据变更(<strong>27 -&gt; 45</strong>)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。</p>
<h3 id="key编码规则"><a href="#key编码规则" class="headerlink" title="key编码规则"></a>key编码规则</h3><p>三种编码方式分别为：</p>
<ol>
<li><strong>Raw</strong>编码（原生的字符）；</li>
<li><strong>Hex</strong>编码（扩展的16进制编码）；</li>
<li><strong>Hex-Prefix</strong>编码（16进制前缀编码）；</li>
</ol>
<p><strong>Raw编码</strong></p>
<p><strong>Raw</strong>编码就是原生的<strong>key</strong>值，不做任何改变。这种编码方式的<strong>key</strong>，<em>是<strong>MPT</strong>对外提供接口的默认编码方式</em>。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<p><strong>Hex编码</strong></p>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em>.</p>
<p>为了减少分支节点孩子的个数，将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p>
<blockquote>
<p>半字节，在计算机中，通常将8位二进制数称为字节，而把4位二进制数称为半字节。 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。</p>
</blockquote>
<p>从<strong>Raw</strong>编码向<strong>Hex</strong>编码的转换规则是：</p>
<ul>
<li><strong>Raw</strong>编码输入的每个字符分解为高 4 位和低 4 位</li>
<li>如果是叶子节点，则在最后加上<strong>Hex</strong>值<code>0x10</code>表示结束</li>
<li>如果是分支节点不附加任何<strong>Hex</strong>值</li>
</ul>
<p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p>
<table>
<thead>
<tr>
<th align="left">i</th>
<th align="left">key[i]</th>
<th align="left">key[i]二进制</th>
<th align="left">nibbles[i*2]&#x3D;高四位</th>
<th align="left">nibbles[i*2+1]&#x3D;低四位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">114</td>
<td align="left">01110010</td>
<td align="left">0111&#x3D; 7</td>
<td align="left">0010&#x3D; 2</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">111</td>
<td align="left">01101111</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1111&#x3D;15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">109</td>
<td align="left">01101101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1101&#x3D;13</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">97</td>
<td align="left">01100001</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0001&#x3D;1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">110</td>
<td align="left">01101110</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1110&#x3D;14</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">01100101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0101&#x3D;5</td>
</tr>
</tbody></table>
<p>最终得到 Hex(“romane”) &#x3D; <code>[7 2 6 15 6 13 6 1 6 14 6 5 16]</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="type">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span>   <span class="comment">// 高四位</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span> <span class="comment">// 低四位</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span> <span class="comment">// 最后一位存入标示符 代表是hex编码</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Hex-Prefix</strong>编码</p>
<p><strong>数学公式定义：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm75cvok4yj318s07iwfg.jpg" alt="image-20201231170415071"></p>
<p>Hex-Prefix 编码是一种任意量的半字节转换为数组的有效方式，还可以在存入一个标识符来区分不同节点类型。 因此 HP 编码是在由一个标识符前缀和半字节转换为数组的两部分组成。存入到数据库中存在节点 Key 的只有扩展节点和叶子节点，因此 HP 只用于区分扩展节点和叶子节点，不涉及无节点 key 的分支节点。其编码规则如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm74pxxc7yj31ju0cm41o.jpg" alt="image-20201231164209626"></p>
<p>前缀标识符由两部分组成：节点类型和奇偶标识，并存储在编码后字节的第一个半字节中。 0 表示扩展节点类型，1 表示叶子节点，偶为 0，奇为 1。最终可以得到唯一标识的前缀标识：</p>
<ul>
<li>0：偶长度的扩展节点</li>
<li>1：奇长度的扩展节点</li>
<li>2：偶长度的叶子节点</li>
<li>3：奇长度的叶子节点</li>
</ul>
<p>当偶长度时，第一个字节的低四位用<code>0</code>填充，当是奇长度时，则将 key[0] 存放在第一个字节的低四位中，这样 HP 编码结果始终是偶长度。 这里为什么要区分节点 key 长度的奇偶呢？这是因为，半字节 <code>1</code> 和 <code>01</code> 在转换为 bytes 格式时都成为<code>&lt;01&gt;</code>，无法区分两者。</p>
<p>例如，上图 “以太坊 MPT 树的哈希计算”中的控制节点1的key 为 <code>[ 7 2 6 f 6 d]</code>，因为是偶长度，则 HP[0]&#x3D; (00000000) &#x3D;0，H[1:]&#x3D; 解码半字节(key)。 而节点 3 的 key 为 <code>[1 6 e 6 5]</code>，为奇长度，则 HP[0]&#x3D; (0001 0001)&#x3D;17。</p>
<p><strong>HP</strong>编码的规则如下：</p>
<ul>
<li>key结尾为<strong>0x10</strong>，则去掉这个终止符</li>
<li>key之前补一个四元组这个Byte第0位区分奇偶信息，第 1 位区分节点类型</li>
<li>如果输入<strong>key</strong>的长度是偶数，则再添加一个四元组0x0在flag四元组后</li>
<li>将原来的key内容压缩，将分离的两个byte以高四位低四位进行合并</li>
</ul>
<blockquote>
<p>十六进制前缀编码相当于一个逆向的过程，比如输入的是[6 2 6 15 6 2 16]，</p>
<p>根据第一个规则去掉终止符16。根据第二个规则key前补一个四元组，从右往左第一位为1表示叶子节点，</p>
<p>从右往左第0位如果后面key的长度为偶数设置为0，奇数长度设置为1，那么四元组0010就是2。</p>
<p>根据第三个规则，添加一个全0的补在后面，那么就是20.根据第三个规则内容压缩合并，那么结果就是[0x20 0x62 0x6f 0x62]</p>
</blockquote>
<p> <strong>HP 编码源码实现:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	terminator := <span class="type">byte</span>(<span class="number">0</span>) <span class="comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span></span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123;     <span class="comment">//验证hex有后缀编码，</span></span><br><span class="line">		terminator = <span class="number">1</span>         <span class="comment">//hex编码有后缀，则t=1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//此处只是去掉后缀部分的hex编码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">////这一阶段的buf[0]可以理解为公式中的16*f(t)</span></span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// the flag byte</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;     <span class="comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span></span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">////这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// first nibble is contained in the first byte</span></span><br><span class="line">		hex = hex[<span class="number">1</span>:]    <span class="comment">//此时获取的hex编码无前缀无后缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:]) <span class="comment">//将hex编码映射到compact编码中</span></span><br><span class="line">	<span class="keyword">return</span> buf                  <span class="comment">//返回compact编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71rsyyekj319w05ygml.jpg" alt="image-20201231150011417"></p>
<p>以上介绍的MPT树，可以用来存储内容为任何长度的<code>key-value</code>数据项。倘若数据项的<code>key</code>长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：</p>
<ul>
<li>查询一个节点可能会需要许多次 IO 读取，效率低下；</li>
<li>系统易遭受 Dos 攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用<code>SLOAD</code>指令读取该树节点的内容，造成系统执行效率极度下降；</li>
<li>所有的 key 其实是一种明文的形式进行存储；</li>
</ul>
<p>为了解决以上问题，以太坊对<strong>MPT</strong>再进行了一次封装，对数据项的<strong>key</strong>进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是<code>(sha3(key), value)</code></p>
<p><strong>优势</strong>：</p>
<ul>
<li>传入MPT接口的 key 是固定长度的（32字节），可以避免出现树中出现长度很长的路径；</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>每次树操作需要增加一次哈希计算；</li>
<li>需要在数据库中存储额外的<code>sha3(key)</code>与<code>key</code>之间的对应关系；</li>
</ul>
<p>完整的编码流程如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71x5i5djj31by07275g.jpg" alt="image-20201231150520220"></p>
<h2 id="MPT轻节点"><a href="#MPT轻节点" class="headerlink" title="MPT轻节点"></a>MPT轻节点</h2><p>上面的MPT树，有两个问题：</p>
<ul>
<li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li>
<li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制，大体如下：</p>
<ul>
<li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li>
<li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li>
</ul>
<h4 id="轻节点中添加数据"><a href="#轻节点中添加数据" class="headerlink" title="轻节点中添加数据"></a>轻节点中添加数据</h4><p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm8hgf9f3ij319a0pcgqh.jpg" alt="image-20210101204824090"></p>
<p>到此以太坊的MPT树的基础讲解结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> 文章及视频学习资料</p>
<p><a href="https://eth.wiki/en/fundamentals/patricia-tree">https://eth.wiki/en/fundamentals/patricia-tree</a></p>
<p><a href="https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D">https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D</a></p>
<p><a href="https://ethfans.org/toya/articles/588">https://ethfans.org/toya/articles/588</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
<p><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/">https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/</a></p>
<p><a href="https://arxiv.org/pdf/1909.11590.pdf">https://arxiv.org/pdf/1909.11590.pdf</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之MPT树-下</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之MPT树-下</p>
<p>文章以及资料请查看：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<p><a href="https://github.com/blockchainGuide/">上篇</a>主要介绍了以太坊中的MPT树的原理，这篇主要会对MPT树涉及的源码进行拆解分析。<code>trie</code>模块主要有以下几个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">|-encoding.<span class="keyword">go</span> 主要讲编码之间的转换</span><br><span class="line">|-hasher.<span class="keyword">go</span> 实现了从某个结点开始计算子树的哈希的功能</span><br><span class="line">|-node.<span class="keyword">go</span> 定义了一个Trie树中所有结点的类型和解析的代码</span><br><span class="line">|-sync.<span class="keyword">go</span> 实现了SyncTrie对象的定义和所有方法</span><br><span class="line">|-iterator.<span class="keyword">go</span> 定义了所有枚举相关接口和实现</span><br><span class="line">|-secure_trie.<span class="keyword">go</span> 实现了SecureTrie对象</span><br><span class="line">|-proof.<span class="keyword">go</span> 为key构造一个merkle证明</span><br><span class="line">|-trie.<span class="keyword">go</span> Trie树的增删改查</span><br><span class="line">|-database.<span class="keyword">go</span> 对内存中的trie树节点进行引用计数</span><br></pre></td></tr></table></figure>



<h2 id="实现概览"><a href="#实现概览" class="headerlink" title="实现概览"></a>实现概览</h2><h3 id="encoding-go"><a href="#encoding-go" class="headerlink" title="encoding.go"></a>encoding.go</h3><p>这个主要是讲三种编码（<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>）的实现与转换，<code>trie</code>中全程都需要用到这些，该文件中主要实现了如下功能：</p>
<ol>
<li>hex编码转换为Compact编码：<code>hexToCompact()</code></li>
<li>Compact编码转换为hex编码：<code>compactToHex()</code></li>
<li>keybytes编码转换为Hex编码：<code>keybytesToHex()</code></li>
<li>hex编码转换为keybytes编码：<code>hexToKeybytes()</code></li>
<li>获取两个字节数组的公共前缀的长度：<code>prefixLen()</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    terminator := <span class="type">byte</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123; <span class="comment">//检查是否有结尾为0x10 =&gt; 16</span></span><br><span class="line">        terminator = <span class="number">1</span> <span class="comment">//有结束标记16说明是叶子节点</span></span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//去除尾部标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>) <span class="comment">// 字节数组</span></span><br><span class="line">    </span><br><span class="line">    buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// 标志byte为00000000或者00100000</span></span><br><span class="line">    <span class="comment">//如果长度为奇数，添加奇数位标志1，并把第一个nibble字节放入buf[0]的低四位</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">// 奇数标志 00110000</span></span><br><span class="line">        buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// 第一个nibble包含在第一个字节中 0011xxxx</span></span><br><span class="line">        hex = hex[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将两个nibble字节合并成一个字节</span></span><br><span class="line">    decodeNibbles(hex, buf[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将十六进制的bibbles转成key bytes，这只能用于偶数长度的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToKeybytes</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123;</span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can&#x27;t convert hex key of odd length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    key := <span class="built_in">make</span>([]<span class="type">byte</span>, (<span class="built_in">len</span>(hex)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    decodeNibbles(hex, key)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回a和b的公共前缀的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixLen</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, length = <span class="number">0</span>, <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; length &#123;</span><br><span class="line">        length = <span class="built_in">len</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i] != b[i] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="node-go"><a href="#node-go" class="headerlink" title="node.go"></a>node.go</h3><h4 id="四种节点"><a href="#四种节点" class="headerlink" title="四种节点"></a>四种节点</h4><p>node 接口分四种实现: fullNode，shortNode，valueNode，hashNode，其中只有 fullNode 和 shortNode 可以带有子节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123;</span><br><span class="line">		Children [<span class="number">17</span>]node <span class="comment">// 分支节点</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123; <span class="comment">//扩展节点</span></span><br><span class="line">		Key   []<span class="type">byte</span></span><br><span class="line">		Val   node <span class="comment">//可能指向叶子节点，也可能指向分支节点。</span></span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="type">byte</span></span><br><span class="line">	valueNode []<span class="type">byte</span> <span class="comment">// 叶子节点值，但是该叶子节点最终还是会包装在shortNode中</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="trie-go"><a href="#trie-go" class="headerlink" title="trie.go"></a>trie.go</h3><p>Trie对象实现了MPT树的所有功能，包括(key, value)对的增删改查、计算默克尔哈希，以及将整个树写入数据库中。</p>
<h3 id="iterator-go"><a href="#iterator-go" class="headerlink" title="iterator.go"></a>iterator.go</h3><p><code>nodeIterator</code>提供了遍历树内部所有结点的功能。其结构如下：此结构体是在<code>trie.go</code>定义的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	trie.NodeIterator</span><br><span class="line">	t   *odrTrie</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面包含了一个接口<code>NodeIterator</code>，它的实现则是由<code>iterator.go</code>来提供的，其方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Next(descend <span class="type">bool</span>) <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Hash() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Parent() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Leaf() <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafKey() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafBlob() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafProof() [][]<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Path() []<span class="type">byte</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> seek(prefix []<span class="type">byte</span>) <span class="type">error</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> peek(descend <span class="type">bool</span>) (*nodeIteratorState, *<span class="type">int</span>, []<span class="type">byte</span>, <span class="type">error</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> nextChild(parent *nodeIteratorState, ancestor common.Hash) (*nodeIteratorState, []<span class="type">byte</span>, <span class="type">bool</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> push(state *nodeIteratorState, parentIndex *<span class="type">int</span>, path []<span class="type">byte</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> pop() </span><br></pre></td></tr></table></figure>

<p><code>NodeIterator</code>的核心是<code>Next</code>方法，每调用一次这个方法，NodeIterator对象代表的当前节点就会更新至下一个节点，当所有结点遍历结束，<code>Next</code>方法返回<code>false</code>。</p>
<p>生成NodeIterator结口的方法有以下3种：</p>
<p><strong>①：Trie.NodeIterator(start []byte)</strong></p>
<p>通过<code>start</code>参数指定从哪个路径开始遍历，如果为<code>nil</code>则从头到尾按顺序遍历。</p>
<p><strong>②：NewDifferenceIterator(a, b NodeIterator)</strong></p>
<p>当调用<code>NewDifferenceIterator(a, b NodeIterator)</code>后，生成的<code>NodeIterator</code>只遍历存在于 b 但不存在于 a 中的结点。</p>
<p><strong>③：NewUnionIterator(iters []NodeIterator)</strong></p>
<p>当调用<code>NewUnionIterator(its []NodeIterator)</code>后，生成的<code>NodeIterator</code>遍历的结点是所有传入的结点的合集。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><p><code>Database</code>是<code>trie</code>模块对真正数据库的缓存层，其目的是对缓存的节点进行引用计数，从而实现区块的修剪功能。主要方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(diskdb ethdb.KeyValueStore)</span></span> *Database</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabaseWithCache</span><span class="params">(diskdb ethdb.KeyValueStore, cache <span class="type">int</span>)</span></span> *Database </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> DiskDB() ethdb.KeyValueReader</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> InsertBlob(hash common.Hash, blob []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insert(hash common.Hash, blob []<span class="type">byte</span>, node node)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insertPreimage(hash common.Hash, preimage []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> node(hash common.Hash) node</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Node(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> preimage(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> secureKey(key []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Nodes() []common.Hash</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Reference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Dereference(root common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> dereference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Cap(limit common.StorageSize) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Commit(node common.Hash, report <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h3 id="security-trie-go"><a href="#security-trie-go" class="headerlink" title="security_trie.go"></a>security_trie.go</h3><p>可以理解为加密了的<code>trie</code>的实现，<code>ecurity_trie</code>包装了一下<code>trie</code>树， 所有的<code>key</code>都转换成<code>keccak256</code>算法计算的<code>hash</code>值。同时在数据库里面存储<code>hash</code>值对应的原始的<code>key</code>。<br>但是官方在代码里也注释了，这个代码不稳定，除了测试用例，别的地方并没有使用该代码。</p>
<h3 id="proof-go"><a href="#proof-go" class="headerlink" title="proof.go"></a>proof.go</h3><ul>
<li>Prove()：根据给定的<code>key</code>，在<code>trie</code>中，将满足<code>key</code>中最大长度前缀的路径上的节点都加入到<code>proofDb</code>（队列中每个元素满足：未编码的hash以及对应<code>rlp</code>编码后的节点）</li>
<li>VerifyProof()：验证<code>proffDb</code>中是否存在满足输入的<code>hash</code>，和对应key的节点，如果满足，则返回<code>rlp</code>解码后的该节点。</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Trie对象的增删改查"><a href="#Trie对象的增删改查" class="headerlink" title="Trie对象的增删改查"></a>Trie对象的增删改查</h3><p>①：<strong>Trie树的初始化</strong></p>
<p>如果<code>root</code>不为空，就通过<code>resolveHash</code>来加载整个<code>Trie</code>树，如果为空，就新建一个<code>Trie</code>树。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span></span> (*Trie, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db: db,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root != (common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<strong>Trie树的插入</strong></p>
<p>首先Trie树的插入是个递归调用的过程，它会从根开始找，一直找到合适的位置插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>n: 当前要插入的节点</li>
<li>prefix: 当前已经处理完的<strong>key</strong>(节点共有的前缀)</li>
<li>key: 未处理完的部分<strong>key</strong>，完整的<code>key = prefix + key</code></li>
<li>value：需要插入的值</li>
</ul>
<p>返回值说明：</p>
<ul>
<li>bool : 操作是否改变了<strong>Trie</strong>树(<strong>dirty</strong>)</li>
<li>Node :插入完成后的子树的根节点</li>
</ul>
<p>接下来就是分别对<code>shortNode</code>、<code>fullNode</code>、<code>hashNode</code>、<code>nil</code> 几种情况进行说明。</p>
<p><strong>2.1：节点为nil</strong></p>
<p>空树直接返回<code>shortNode</code>， 此时整颗树的根就含有了一个<code>shortNode</code>节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2 ：节点为shortNode</strong></p>
<ul>
<li><p>首先计算公共前缀，如果公共前缀就等于<code>key</code>，那么说明这两个<code>key</code>是一样的，如果<code>value</code>也一样的(<code>dirty == false</code>)，那么返回错误。</p>
</li>
<li><p>如果没有错误就更新<code>shortNode</code>的值然后返回</p>
</li>
<li><p>如果公共前缀不完全匹配，那么就需要把公共前缀提取出来形成一个独立的节点(扩展节点),扩展节点后面连接一个<code>branch</code>节点，<code>branch</code>节点后面看情况连接两个<code>short</code>节点。</p>
</li>
<li><p>首先构建一个branch节点(branch :&#x3D; &amp;fullNode{flags: t.newFlag()}),然后再branch节点的Children位置调用t.insert插入剩下的两个short节点</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">matchlen := prefixLen(key, n.Key)</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</span><br><span class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.3: 节点为fullNode</strong></p>
<p>节点是<code>fullNode</code>(也就是分支节点)，那么直接往对应的孩子节点调用<code>insert</code>方法,然后把对应的孩子节点指向新生成的节点。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">		&#125;</span><br><span class="line">		n = n.<span class="built_in">copy</span>()</span><br><span class="line">		n.flags = t.newFlag()</span><br><span class="line">		n.Children[key[<span class="number">0</span>]] = nn</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.4: 节点为hashnode</strong></p>
<p>暂时还在数据库中的节点，先调用 <code>t.resolveHash(n, prefix)</code>来加载到内存，然后调用<code>insert</code>方法来插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rn, err := t.resolveHash(n, prefix)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<strong>Trie树查询值</strong></p>
<p>其实就是根据输入的<code>hash</code>，找到对应的叶子节点的数据。主要看<code>TryGet</code>方法。</p>
<p>参数：</p>
<ul>
<li><code>origNode</code>：当前查找的起始<strong>node</strong>位置</li>
<li><code>key</code>：输入要查找的数据的<strong>hash</strong></li>
<li><code>pos</code>：当前<strong>hash</strong>匹配到第几位</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> tryGet(origNode node, key []<span class="type">byte</span>, pos <span class="type">int</span>) (value []<span class="type">byte</span>, newnode node, didResolve <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//表示当前trie是空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> valueNode: <span class="comment">////这就是我们要查找的叶子节点对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> *shortNode: <span class="comment">////在叶子节点或者扩展节点匹配</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Val = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> *fullNode:<span class="comment">//在分支节点匹配</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Children[key[pos]] = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//说明当前节点是轻节点，需要从db中获取</span></span><br><span class="line">		child, err := t.resolveHash(n, key[:pos])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</span><br><span class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>didResolve</code>用于判断<code>trie</code>树是否会发生变化，<code>tryGet()</code>只是用来获取数据的，当<code>hashNode</code>去<code>db</code>中获取该<code>node</code>值后需要更新现有的trie，<code>didResolve</code>就会发生变化。其他就是基本的递归查找树操作。</p>
<p>④：<strong>Trie树更新值</strong></p>
<p>更新值，其实就是调用insert方法进行操作。</p>
<p>到此Trie树的增删改查就讲解的差不多了。</p>
<h3 id="将节点写入到Trie的内存数据库"><a href="#将节点写入到Trie的内存数据库" class="headerlink" title="将节点写入到Trie的内存数据库"></a>将节点写入到Trie的内存数据库</h3><p>如果要把节点写入到内存数据库，需要序列化，可以先去了解下以太坊的Rlp编码。这部分工作由<code>trie.Commit()</code>完成，当<code>trie.Commit(nil)</code>，会执行序列化和缓存等操作，序列化之后是使用的<code>Compact Encoding</code>进行编码，从而达到节省空间的目的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;commit called on trie with nil database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.root = cached</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大概讲了这些：</p>
<ul>
<li>每次执行<code>Commit()</code>，该trie的<code>cachegen</code>就会加 1</li>
<li><code>Commit()</code>方法返回的是<code>trie.root</code>所指向的<code>node</code>的<code>hash</code>（未编码）</li>
<li>其中的<code>hashRoot()</code>方法目的是<code>返回trie.root所指向的node的hash</code>以及<code>每个节点都带有各自hash的trie树的root</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为每个node生成一个hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> hashRoot(db *Database, onleaf LeafCallback) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	h := newHasher(onleaf)</span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</span><br><span class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>) <span class="comment">//为每个节点生成一个未编码的hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>hashRoot</code>的核心方法就是 <code>h.hash</code>，它返回了头节点的<code>hash</code>以及每个子节点都带有<code>hash</code>的头节点（Trie.root指向它），大致做了以下几件事：</p>
<p>①：<em>如果我们不存储节点，而只是哈希，则从缓存中获取数据</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dirty &#123;</span><br><span class="line">			<span class="keyword">switch</span> n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *fullNode, *shortNode:</span><br><span class="line">				<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>递归调用<code>h.hashChildren</code>，求出所有的子节点的<code>hash</code>值，再把原有的子节点替换成现在子节点的<code>hash</code>值</em></p>
<p><strong>2.1:如果节点是<code>shortNode</code></strong></p>
<p>首先把<code>collapsed.Key从Hex Encoding</code> 替换成 <code>Compact Encoding</code>, 然后递归调用<code>hash</code>方法计算子节点的<code>hash</code>和<code>cache</code>，从而把子节点替换成了子节点的<code>hash</code>值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line">		collapsed.Key = hexToCompact(n.Key)</span><br><span class="line">		cached.Key = common.CopyBytes(n.Key)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</span><br><span class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> original, original, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2:节点是fullNode</strong></p>
<p> 遍历每个子节点，把子节点替换成子节点的<code>Hash</code>值，否则的化这个节点没有<code>children</code>。直接返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">		collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> original, original, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</span><br><span class="line"><span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<em>存储节点n的哈希值，如果我们指定了存储层，它会写对应的键&#x2F;值对</em></p>
<p>store()方法主要就做了两件事：</p>
<ul>
<li><code>rlp</code>序列化<code>collapsed</code>节点并将其插入db磁盘中</li>
<li>生成当前节点的<code>hash</code></li>
<li>将节点哈希插入<code>db</code></li>
</ul>
<p><strong>3.1：空数据或者hashNode，则不处理</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2:生成节点的RLP编码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.tmp.Reset()                                 <span class="comment">// 缓存初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := rlp.Encode(&amp;h.tmp, n); err != <span class="literal">nil</span> &#123; <span class="comment">//将当前node序列化</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;encode error: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.tmp) &lt; <span class="number">32</span> &amp;&amp; !force &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">// Nodes smaller than 32 bytes are stored inside their parent 编码后的node长度小于32，若force为true，则可确保所有节点都被编码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//长度过大的，则都将被新计算出来的hash取代</span></span><br><span class="line">	hash, _ := n.cache() <span class="comment">//取出当前节点的hash</span></span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		hash = h.makeHashNode(h.tmp) <span class="comment">//生成哈希node</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3:将Trie节点合并到中间内存缓存中</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := common.BytesToHash(hash)</span><br><span class="line">		db.lock.Lock()</span><br><span class="line">		db.insert(hash, h.tmp, n)</span><br><span class="line">		db.lock.Unlock()</span><br><span class="line">		<span class="comment">// Track external references from account-&gt;storage trie</span></span><br><span class="line">		<span class="comment">//跟踪帐户-&gt;存储Trie中的外部引用</span></span><br><span class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *shortNode:</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok &#123;  <span class="comment">//指向的是分支节点</span></span><br><span class="line">					h.onleaf(child, hash) <span class="comment">//用于统计当前节点的信息，比如当前节点有几个子节点，当前有效的节点数</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> *fullNode:</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</span><br><span class="line">						h.onleaf(child, hash)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止将节点写入到<code>Trie</code>的内存数据库就已经完成了。</p>
<p><em>如果觉得文章不错可以关注公众号：<strong>区块链技术栈</strong>，详细的所有以太坊源码分析文章内容以及代码资料都在其中。</em></p>
<h3 id="Trie树缓存机制"><a href="#Trie树缓存机制" class="headerlink" title="Trie树缓存机制"></a>Trie树缓存机制</h3><p><code>Trie</code>树的结构里面有两个参数， 一个是<code>cachegen</code>,一个是<code>cachelimit</code>。这两个参数就是<code>cache</code>控制的参数。 <code>Trie</code>树每一次调用<code>Commit</code>方法，会导致当前的<code>cachegen</code>增加1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">    t.cachegen++</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>Trie</code>树插入的时候，会把当前的<code>cachegen</code>存放到节点中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> newFlag() nodeFlag &#123;</span><br><span class="line">    <span class="keyword">return</span> nodeFlag&#123;dirty: <span class="literal">true</span>, gen: t.cachegen&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>trie.cachegen - node.cachegen &gt; cachelimit</code>，就可以把节点从内存里面拿掉。 也就是说节点经过几次<code>Commit</code>，都没有修改，那么就把节点从内存里面干掉。 只要<code>trie</code>路径上新增或者删除一个节点，整个路径的节点都需要重新实例化，也就是节点中的<code>nodeFlag</code>被初始化了。都需要重新更新到<code>db</code>磁盘。</p>
<p>拿掉节点过程在 <code>hasher.hash</code>方法中， 这个方法是在<code>commit</code>的时候调用。如果方法的<code>canUnload</code>方法调用返回真，那么就拿掉节点，如果只返回了<code>hash</code>节点，而没有返回<code>node</code>节点，这样节点就没有引用，不久就会被gc清除掉。 节点被拿掉之后，会用一个<code>hashNode</code>节点来表示这个节点以及其子节点。 如果后续需要使用，可以通过方法把这个节点加载到内存里面来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> hash(n node, db *Database, force <span class="type">bool</span>) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">   	....</span><br><span class="line">       <span class="comment">// 从缓存中卸载节点。它的所有子节点将具有较低或相等的缓存世代号码。</span></span><br><span class="line">       cacheUnloadCounter.Inc(<span class="number">1</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考-总结"><a href="#参考-总结" class="headerlink" title="参考&amp;总结"></a>参考&amp;总结</h2><p>这部分重要的内容也就上面讲述的，主要集中在<code>Trie</code>上面，如果有不对的地方，可以及时指正哦。</p>
<blockquote>
<p><a href="https://mindcarver.cn/about/">https://mindcarver.cn/about/</a></p>
<p><a href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之downloader同步</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之downloader同步</p>
<p><strong>需要配合注释代码看</strong>：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> 给个star哦</p>
<p><em>这篇文章篇幅较长，能看下去的是条汉子，建议收藏</em></p>
<p>希望读者在阅读过程中，指出问题，给个关注，一起探讨。</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>downloader</code> 模块的代码位于 <code>eth/downloader</code> 目录下。主要的功能代码分别是：</p>
<ul>
<li><p><code>downloader.go</code> ：实现了区块同步逻辑</p>
</li>
<li><p><code>peer.go</code> ：对区块各个阶段的组装，下面的各个<code>FetchXXX</code> 就是很依赖这个模块。</p>
</li>
<li><p><code>queue.go</code> ：对<code>eth/peer.go</code>的封装</p>
</li>
<li><p><code>statesync.go</code> ：同步<code>state</code>对象</p>
</li>
</ul>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="full-sync"><a href="#full-sync" class="headerlink" title="full  sync"></a>full  sync</h3><p>full 模式会在数据库中保存所有区块数据，同步时从远程节点同步 header 和 body 数据，而state 和 receipt 数据则是在本地计算出来的。</p>
<p>在 full 模式下，downloader 会同步区块的 header 和 body 数据组成一个区块，然后通过 blockchain 模块的 <code>BlockChain.InsertChain</code> 向数据库中插入区块。在 <code>BlockChain.InsertChain</code> 中，会逐个计算和验证每个块的 <code>state</code> 和 <code>recepit</code> 等数据，如果一切正常就将区块数据以及自己计算得到的 <code>state</code>、<code>recepit</code> 数据一起写入到数据库中。</p>
<h3 id="fast-sync"><a href="#fast-sync" class="headerlink" title="fast sync"></a>fast sync</h3><p> <code>fast</code> 模式下，<code>recepit</code> 不再由本地计算，而是和区块数据一样，直接由 <code>downloader</code> 从其它节点中同步；<code>state</code> 数据并不会全部计算和下载，而是选一个较新的区块（称之为 <code>pivot</code>）的 <code>state</code> 进行下载，以这个区块为分界，之前的区块是没有 <code>state</code> 数据的，之后的区块会像 <code>full</code> 模式下一样在本地计算 <code>state</code>。因此在 <code>fast</code> 模式下，同步的数据除了 <code>header</code> 和 body，还有 <code>receipt</code>，以及 <code>pivot</code> 区块的 <code>state</code>。</p>
<p>因此 <code>fast</code> 模式忽略了大部分 <code>state</code> 数据，并且使用网络直接同步 <code>receipt</code> 数据的方式替换了 full 模式下的本地计算，所以比较快。</p>
<h3 id="light-sync"><a href="#light-sync" class="headerlink" title="light sync"></a>light sync</h3><p>light 模式也叫做轻模式，它只对区块头进行同步，而不同步其它的数据。</p>
<p>SyncMode:</p>
<ul>
<li>FullSync:从完整区块同步整个区块链历史</li>
<li>FastSync:快速下载标题，仅在链头处完全同步</li>
<li>LightSync:仅下载标题，然后终止</li>
</ul>
<h2 id="区块下载流程"><a href="#区块下载流程" class="headerlink" title="区块下载流程"></a>区块下载流程</h2><blockquote>
<p>图片只是大概的描述一下，实际还是要结合代码，<strong>所有区块链相关文章合集</strong>，<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>同时希望结识更多区块链圈子的人，可以star上面项目，持续更新</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glwzmv4zyej30zh0u0dps.jpg" alt="image-20201222221031797"></p>
<p>首先根据<code>Synchronise</code>开始区块同步，通过<code>findAncestor</code>找到指定节点的共同祖先，并在此高度进行同步，同时开启多个<code>goroutine</code>同步不同的数据：<code>header</code>、<code>receipt</code>、<code>body</code>。假如同步高度为 100 的区块，必须先<code>header</code>同步成功同步完成才可以唤醒<code>body</code>和<code>receipts</code>的同步。</p>
<p>而每个部分的同步大致都是由<code>FetchParts</code>来完成的，里面包含了各个<code>Chan</code>的配合，也会涉及不少的回调函数，总而言之多读几遍每次都会有不同的理解。接下来就逐步分析这些关键内容。</p>
<hr>
<h2 id="synchronise"><a href="#synchronise" class="headerlink" title="synchronise"></a>synchronise</h2><p>①：确保对方的TD高于我们自己的TD</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">	td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line">	pHead, pTd := peer.Head()</span><br><span class="line">	<span class="keyword">if</span> pTd.Cmp(td) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启<code>downloader</code>的同步</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.downloader.Synchronise(peer.id, pHead, pTd, mode)</span><br></pre></td></tr></table></figure>

<p>进入函数：主要做了以下几件事：</p>
<ol>
<li><code>d.synchronise(id, head, td, mode)</code> ：同步过程</li>
<li>错误日志输出， 并删除此<code>peer</code>。</li>
</ol>
<p>进入到<code>d.synchronise</code>，走到最后一步<code>d.syncWithPeer(p, hash, td)</code>真正开启同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> synchronise(id <span class="type">string</span>, hash common.Hash, td *big.Int, mode SyncMode) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> d.syncWithPeer(p, hash, td)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syncWithPeer大概做了以下几件事：</p>
<ol>
<li>查找祖先<code>findAncestor</code></li>
<li>开启单独<code>goroutine</code>分别运行以下几个函数：<ul>
<li>fetchHeaders</li>
<li>processHeaders</li>
<li>fetchbodies</li>
<li>fetchReceipts</li>
<li>processFastSyncContent</li>
<li>processFullSyncContent</li>
</ul>
</li>
</ol>
<p>接下来的文章，以及整个<code>Downloader</code>模块主要内容就是围绕这几个部分进行展开。</p>
<hr>
<h2 id="findAncestor"><a href="#findAncestor" class="headerlink" title="findAncestor"></a>findAncestor</h2><p>同步首要的是<strong>确定同步区块的区间</strong>：顶部为远程节点的最高区块，底部为两个节点都拥有的相同区块的最高高度（祖先区块）。<code>findAncestor</code>就是用来找祖先区块。函数分析如下：</p>
<p>①：确定本地高度和远程节点的最高高度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		floor        = <span class="type">int64</span>(<span class="number">-1</span>) <span class="comment">// 底部</span></span><br><span class="line">		localHeight  <span class="type">uint64</span>  <span class="comment">// 本地最高高度</span></span><br><span class="line">		remoteHeight = remoteHeader.Number.Uint64() <span class="comment">// 远程节点最高高度</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">switch</span> d.mode &#123;</span><br><span class="line">	<span class="keyword">case</span> FullSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentBlock().NumberU64()</span><br><span class="line">	<span class="keyword">case</span> FastSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentFastBlock().NumberU64()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		localHeight = d.lightchain.CurrentHeader().Number.Uint64()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：计算同步的高度区间和间隔</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">from, count, skip, max := calculateRequestSpan(remoteHeight, localHeight) </span><br></pre></td></tr></table></figure>

<ul>
<li><code>from</code>:：表示从哪个高度开始获取区块</li>
<li><code>count</code>：表示从远程节点获取多少个区块</li>
<li><code>skip</code>：表示间隔，比如<code>skip</code> 为 2 ，获取第一个高度为 5，则第二个就是 8</li>
<li><code>max</code>：表示最大高度</li>
</ul>
<p>③：发送获取<code>header</code>的请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> p.peer.RequestHeadersByNumber(<span class="type">uint64</span>(from), count, skip, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>④：处理上面请求接收到的<code>header</code>  :<code>case packet := &lt;-d.headerCh</code></p>
<ol>
<li>丢弃掉不是来自我们请求节的内容</li>
<li>确保返回的<code>header</code>数量不为空</li>
<li>验证返回的<code>headers</code>的高度是我们所请求的</li>
<li>检查是否找到共同祖先</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----①</span></span><br><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received headers from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----②</span></span><br><span class="line">headers := packet.(*headerPack).headers</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">				p.log.Warn(<span class="string">&quot;Empty head header set&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//-----③</span></span><br><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">				expectNumber := from + <span class="type">int64</span>(i)*<span class="type">int64</span>(skip+<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span> number := header.Number.Int64(); number != expectNumber &#123; <span class="comment">// 验证这些返回的header是否是我们上面请求的headers</span></span><br><span class="line">					p.log.Warn(<span class="string">&quot;Head headers broke chain ordering&quot;</span>, <span class="string">&quot;index&quot;</span>, i, <span class="string">&quot;requested&quot;</span>, expectNumber, <span class="string">&quot;received&quot;</span>, number)</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>, errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----④</span></span><br><span class="line"><span class="comment">// 检查是否找到共同祖先</span></span><br><span class="line">			finished = <span class="literal">true</span></span><br><span class="line">			<span class="comment">//注意这里是从headers最后一个元素开始查找，也就是高度最高的区块。</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="built_in">len</span>(headers) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">				<span class="comment">// 跳过不在我们请求的高度区间内的区块</span></span><br><span class="line">				<span class="keyword">if</span> headers[i].Number.Int64() &lt; from || headers[i].Number.Uint64() &gt; max &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// //检查我们本地是否已经有某个区块了，如果有就算是找到了共同祖先，</span></span><br><span class="line">				<span class="comment">//并将共同祖先的哈希和高度设置在number和hash变量中。</span></span><br><span class="line">				h := headers[i].Hash()</span><br><span class="line">				n := headers[i].Number.Uint64()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>⑤：如果通过固定间隔法找到了共同祖先则返回祖先，会对其高度与 <code>floor</code> 变量进行验证, <code>floor</code> 变量代表的是共同祖先的高度的最小值,如果找到共同祖先的高度比这个值还小，就认为是两个节点之间分叉太大了，不再允许进行同步。如果一切正常，就返回找到的共同祖先的高度 <code>number</code> 变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hash != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">int64</span>(number) &lt;= floor &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, errInvalidAncestor</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>⑥：如果固定间隔法没有找到祖先则通过二分法来查找祖先，这部分可以思想跟二分法算法类似，有兴趣的可以细看。</p>
<hr>
<h2 id="queue详解"><a href="#queue详解" class="headerlink" title="queue详解"></a>queue详解</h2><p><code>queue</code>对象和<code>Downloader</code>对象是相互作用的，<code>Downloader</code>的很多功能离不开他，接下来我们介绍一下这部分内容，但是本节，<strong>可以先行跳过</strong>，等到了阅读下面的关于<code>Queue</code>调用的一些函数部分再回过来阅读这部分讲解。</p>
<h3 id="queue结构体"><a href="#queue结构体" class="headerlink" title="queue结构体"></a>queue结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> queue <span class="keyword">struct</span> &#123;</span><br><span class="line">  mode SyncMode <span class="comment">// 同步模式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// header处理相关</span></span><br><span class="line">  headerHead      common.Hash   <span class="comment">//最后一个排队的标头的哈希值以验证顺序</span></span><br><span class="line">  headerTaskPool  <span class="keyword">map</span>[<span class="type">uint64</span>]*types.Header  <span class="comment">//待处理的标头检索任务，将起始索引映射到框架标头</span></span><br><span class="line">  headerTaskQueue *prque.Prque  <span class="comment">//骨架索引的优先级队列，以获取用于的填充标头</span></span><br><span class="line">  headerPeerMiss <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已知不可用的对等头批处理集</span></span><br><span class="line">  headerPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前挂起的头检索操作</span></span><br><span class="line">  headerResults []*types.Header <span class="comment">//结果缓存累积完成的头</span></span><br><span class="line">  headerProced <span class="type">int</span> <span class="comment">//从结果中拿出来已经处理的header</span></span><br><span class="line">  headerContCh <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">//header下载完成时通知的频道</span></span><br><span class="line">  </span><br><span class="line">  blockTaskPool  <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的块（body）检索任务，将哈希映射到header</span></span><br><span class="line">  blockTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取块（bodies）</span></span><br><span class="line">  blockPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的块（body)检索操作</span></span><br><span class="line">  blockDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的块（body)</span></span><br><span class="line">  </span><br><span class="line">	receiptTaskPool <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的收据检索任务，将哈希映射到header</span></span><br><span class="line">	receiptTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取收据</span></span><br><span class="line">	receiptPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的收据检索操作</span></span><br><span class="line">	receiptDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的收据</span></span><br><span class="line">	</span><br><span class="line">	resultCache []*fetchResult <span class="comment">//下载但尚未交付获取结果</span></span><br><span class="line">	resultOffset <span class="type">uint64</span> <span class="comment">//区块链中第一个缓存的获取结果的偏移量</span></span><br><span class="line">	resultSize common.StorageSize <span class="comment">// 块的近似大小</span></span><br><span class="line"></span><br><span class="line">	lock   *sync.Mutex</span><br><span class="line">	active *sync.Cond</span><br><span class="line">	closed <span class="type">bool</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要细分功能"><a href="#主要细分功能" class="headerlink" title="主要细分功能"></a>主要细分功能</h3><h4 id="数据下载开始安排任务"><a href="#数据下载开始安排任务" class="headerlink" title="数据下载开始安排任务"></a>数据下载开始安排任务</h4><ul>
<li><code>ScheduleSkeleton</code>:<em>将一批<code>header</code>检索任务添加到队列中，以填充已检索的<code>header skeleton</code></em></li>
<li><code>Schedule</code>:<em>用来准备对一些 <code>body</code> 和 <code>receipt</code> 数据的下载</em></li>
</ul>
<h4 id="数据下载中的各类状态"><a href="#数据下载中的各类状态" class="headerlink" title="数据下载中的各类状态"></a>数据下载中的各类状态</h4><ul>
<li><p><code>pending</code></p>
<p><code>pending</code>表示待检索的XXX请求的数量，包括了：<code>PendingHeaders</code>、<code>PendingBlocks</code>、<code>PendingReceipts</code>，分别都是对应取<code>XXXTaskQueue</code>的长度。</p>
</li>
<li><p><code>InFlight</code></p>
<p><code>InFlight</code>表示是否有正在获取XXX的请求，包括：<code>InFlightHeaders</code>、<code>InFlightBlocks</code>、<code>InFlightReceipts</code>，都是通过判断<code>len(q.receiptPendPool) &gt; 0</code> 来确认。</p>
</li>
<li><p><code>ShouldThrottle</code></p>
<p><code>ShouldThrottle</code>表示检查是否应该限制下载XXX，包括:<code>ShouldThrottleBlocks</code>、<code>ShouldThrottleReceipts</code>，主要是为了防止下载过程中本地内存占用过大。</p>
</li>
<li><p><code>Reserve</code></p>
<p><code>Reserve</code>通过构造一个 <code>fetchRequest</code> 结构并返回，向调用者提供指定数量的待下载的数据的信息（<code>queue</code> 内部会将这些数据标记为「正在下载」）。调用者使用返回的 <code>fetchRequest</code> 数据向远程节点发起新的获取数据的请求。包括：<code>ReserveHeaders</code>、<code>ReserveBodies</code>、<code>ReserveReceipts</code>。</p>
</li>
<li><p><code>Cancel</code></p>
<p><code>Cance</code>用来撤消对 <code>fetchRequest</code> 结构中的数据的下载（<code>queue</code> 内部会将这些数据重新从「正在下载」的状态更改为「等待下载」）。包括：<code>CancelHeaders</code>、<code>CancelBodies</code>、<code>CancelReceipts</code>。</p>
</li>
<li><p><code>expire</code></p>
<p><code>expire</code>检查正在执行中的请求是否超过了超时限制，包括：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>。</p>
</li>
<li><p><code>Deliver</code></p>
<p>当有数据下载成功时，调用者会使用 <code>deliver</code> 功能用来通知 <code>queue</code> 对象。包括：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。</p>
</li>
</ul>
<h4 id="数据下载完成获取区块数据"><a href="#数据下载完成获取区块数据" class="headerlink" title="数据下载完成获取区块数据"></a>数据下载完成获取区块数据</h4><ul>
<li><code>RetrieveHeaders</code><br>在填充 <code>skeleton</code> 完成后，<code>queue.RetrieveHeaders</code> 用来获取整个 <code>skeleton</code> 中的所有 <code>header</code>。</li>
<li><code>Results</code><br><code>queue.Results</code> 用来获取当前的 <code>header</code>、<code>body</code> 和 <code>receipt</code>（只在 <code>fast</code> 模式下） 都已下载成功的区块（并将这些区块从 <code>queue</code> 内部移除）</li>
</ul>
<hr>
<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><h4 id="ScheduleSkeleton"><a href="#ScheduleSkeleton" class="headerlink" title="ScheduleSkeleton"></a>ScheduleSkeleton</h4><p>queue.ScheduleSkeleton主要是为了填充skeleton，它的参数是要下载区块的起始高度和所有 <code>skeleton</code> 区块头，最核心的内容则是下面这段循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ScheduleSkeleton(from <span class="type">uint64</span>, skeleton []*types.Header) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> i, header := <span class="keyword">range</span> skeleton &#123;</span><br><span class="line">        index := from + <span class="type">uint64</span>(i*y)</span><br><span class="line">        q.headerTaskPool[index] = header</span><br><span class="line">        q.headerTaskQueue.Push(index, -<span class="type">int64</span>(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设已确定需要下载的区块高度区间是从 10 到 46，<code>MaxHeaderFetch</code> 的值为 10，那么这个高度区块就会被分成 3 组：10 - 19，20 - 29，30 - 39，而 skeleton 则分别由高度为 19、29、39 的区块头组成。循环中的 <code>index</code> 变量实际上是每一组区块中的第一个区块的高度（比如 10、20、30），<code>queue.headerTaskPool</code> 实际上是一个<strong>每一组区块中第一个区块的高度到最后一个区块的 header 的映射</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">headerTaskPool = &#123;</span><br><span class="line">  <span class="number">10</span>: headerOf_19,</span><br><span class="line">	<span class="number">20</span>: headerOf_20,</span><br><span class="line">	<span class="number">30</span>: headerOf_39,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ReserveHeaders"><a href="#ReserveHeaders" class="headerlink" title="ReserveHeaders"></a>ReserveHeaders</h4><p><code>reserve</code> 用来获取可下载的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reserve  = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, count <span class="type">int</span>)</span></span> (*fetchRequest, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> d.queue.ReserveHeaders(p, count), <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ReserveHeaders(p *peerConnection, count <span class="type">int</span>) *fetchRequest &#123;</span><br><span class="line">  <span class="keyword">if</span> _, ok := q.headerPendPool[p.id]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="comment">//①</span></span><br><span class="line">  ...</span><br><span class="line">  send, skip := <span class="type">uint64</span>(<span class="number">0</span>), []<span class="type">uint64</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> send == <span class="number">0</span> &amp;&amp; !q.headerTaskQueue.Empty() &#123;</span><br><span class="line">		from, _ := q.headerTaskQueue.Pop()</span><br><span class="line">		<span class="keyword">if</span> q.headerPeerMiss[p.id] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := q.headerPeerMiss[p.id][from.(<span class="type">uint64</span>)]; ok &#123;</span><br><span class="line">				skip = <span class="built_in">append</span>(skip, from.(<span class="type">uint64</span>))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		send = from.(<span class="type">uint64</span>) <span class="comment">// ②</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">for</span> _, from := <span class="keyword">range</span> skip &#123;</span><br><span class="line">		q.headerTaskQueue.Push(from, -<span class="type">int64</span>(from))</span><br><span class="line">	&#125; <span class="comment">// ③</span></span><br><span class="line">  ...</span><br><span class="line">  request := &amp;fetchRequest&#123;</span><br><span class="line">		Peer: p,</span><br><span class="line">		From: send,</span><br><span class="line">		Time: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	q.headerPendPool[p.id] = request <span class="comment">// ④</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①：根据<code>headerPendPool</code>来判断远程节点是否正在下载数据信息。</p>
<p>②：从<code>headerTaskQueue</code>取出值作为本次请求的起始高度，赋值给<code>send</code>变量，在这个过程中会排除headerPeerMiss所记录的节点下载数据失败的信息。</p>
<p>③：将失败的任务再重新写回<code>task queue</code></p>
<p>④：利用<code>send</code>变量构造<code>fetchRequest</code>结构，此结构是用来作为<code>FetchHeaders</code>来使用的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fetch = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, req *fetchRequest)</span></span> <span class="type">error</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> p.FetchHeaders(req.From, MaxHeaderFetch) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>ReserveHeaders</code>会从任务队列里选择最小的起始高度并构造<code>fetchRequest</code>传递给<code>fetch</code>获取数据。</p>
<hr>
<h4 id="DeliverHeaders"><a href="#DeliverHeaders" class="headerlink" title="DeliverHeaders"></a>DeliverHeaders</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">deliver = <span class="function"><span class="keyword">func</span><span class="params">(packet dataPack)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			pack := packet.(*headerPack)</span><br><span class="line">			<span class="keyword">return</span> d.queue.DeliverHeaders(pack.peerID, pack.headers, d.headerProcCh)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>①：如果发现下载数据的节点没有在 <code>queue.headerPendPool</code> 中，就直接返回错误；否则就继续处理，并将节点记录从 <code>queue.headerPendPool</code> 中删除。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">request := q.headerPendPool[id]</span><br><span class="line">	<span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errNoFetchesPending</span><br><span class="line">	&#125;</span><br><span class="line">	headerReqTimer.UpdateSince(request.Time)</span><br><span class="line">	<span class="built_in">delete</span>(q.headerPendPool, id)</span><br></pre></td></tr></table></figure>

<p>②：验证<code>headers</code> </p>
<p>包括三方面验证：</p>
<ol>
<li>检查起始区块的高度和哈希</li>
<li>检查高度的连接性</li>
<li>检查哈希的连接性</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="comment">//检查起始区块的高度和哈希</span></span><br><span class="line">		<span class="keyword">if</span> headers[<span class="number">0</span>].Number.Uint64() != request.From &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>].Hash() != target &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="keyword">for</span> i, header := <span class="keyword">range</span> headers[<span class="number">1</span>:] &#123;</span><br><span class="line">			hash := header.Hash() <span class="comment">// 检查高度的连接性</span></span><br><span class="line">			<span class="keyword">if</span> want := request.From + <span class="number">1</span> + <span class="type">uint64</span>(i); header.Number.Uint64() != want &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> headers[i].Hash() != header.ParentHash &#123; <span class="comment">// 检查哈希的连接性</span></span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③： 将无效数据存入<code>headerPeerMiss</code>，并将这组区块起始高度重新放入<code>headerTaskQueue</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !accepted &#123;</span><br><span class="line">	...</span><br><span class="line">		miss := q.headerPeerMiss[id]</span><br><span class="line">		<span class="keyword">if</span> miss == <span class="literal">nil</span> &#123;</span><br><span class="line">			q.headerPeerMiss[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			miss = q.headerPeerMiss[id]</span><br><span class="line">		&#125;</span><br><span class="line">		miss[request.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		q.headerTaskQueue.Push(request.From, -<span class="type">int64</span>(request.From))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;delivery not accepted&quot;</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：保存数据，并通知<code>headerProcCh</code>处理新的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ready &gt; <span class="number">0</span> &#123;</span><br><span class="line">		process := <span class="built_in">make</span>([]*types.Header, ready)</span><br><span class="line">		<span class="built_in">copy</span>(process, q.headerResults[q.headerProced:q.headerProced+ready])</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> headerProcCh &lt;- process:</span><br><span class="line">			q.headerProced += <span class="built_in">len</span>(process)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：发送消息给.<code>headerContCh</code>，通知<code>skeleton</code> 都被下载完了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">		q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>DeliverHeaders</code> 会对数据进行检验和保存，并发送 channel 消息给 <code>Downloader.processHeaders</code> 和 <code>Downloader.fetchParts</code>的 <code>wakeCh</code> 参数。</p>
<hr>
<h4 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h4><p><code>processHeaders</code>在处理<code>header</code>数据的时候，会调用<code>queue.Schedule</code> 为下载 <code>body</code> 和 <code>receipt</code> 作准备。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inserts := d.queue.Schedule(chunk, origin)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> Schedule(headers []*types.Header, from <span class="type">uint64</span>) []*types.Header &#123;</span><br><span class="line">	inserts := <span class="built_in">make</span>([]*types.Header, <span class="number">0</span>, <span class="built_in">len</span>(headers))</span><br><span class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    ...</span><br><span class="line">		q.blockTaskPool[hash] = header</span><br><span class="line">		q.blockTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">			q.receiptTaskPool[hash] = header</span><br><span class="line">			q.receiptTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">		inserts = <span class="built_in">append</span>(inserts, header)</span><br><span class="line">		q.headerHead = hash</span><br><span class="line">		from++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inserts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要就是将信息写入到body和receipt队列，等待调度。</p>
<hr>
<h4 id="ReserveBody-Receipt"><a href="#ReserveBody-Receipt" class="headerlink" title="ReserveBody&amp;Receipt"></a>ReserveBody&amp;Receipt</h4><p>在 <code>queue</code> 中准备好了 <strong>body</strong> 和 <strong>receipt</strong> 相关的数据， <code>processHeaders</code>最后一段，是唤醒下载Bodyies和Receipts的关键代码，会通知 <code>fetchBodies</code> 和 <code>fetchReceipts</code> 可以对各自的数据进行下载了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>fetchXXX</code> 会调用<code>fetchParts</code>，逻辑类似上面的的，<code>reserve</code>最终则会调用<code>reserveHeaders</code>，<code>deliver</code> 最终调用的是 <code>queue.deliver</code>.</p>
<p>先来分析<code>reserveHeaders</code>：</p>
<p>①：如果没有可处理的任务，直接返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> taskQueue.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②：如果参数给定的节点正在下载数据，返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := pendPool[p.id]; ok &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>③：计算 queue 对象中的缓存空间还可以容纳多少条数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">space := q.resultSlots(pendPool, donePool)</span><br></pre></td></tr></table></figure>

<p>④：从 「task queue」 中依次取出任务进行处理</p>
<p>主要实现以下功能：</p>
<ul>
<li>计算当前 header 在 <code>queue.resultCache</code> 中的位置，然后填充 <code>queue.resultCache</code> 中相应位置的元素</li>
<li>处理空区块的情况，若为空不下载。</li>
<li>处理远程节点缺少这个当前区块数据的情况，如果发现这个节点曾经下载当前数据失败过，就不再让它下载了。</li>
</ul>
<p>注意：<code>resultCache</code> 字段用来记录所有正在被处理的数据的处理结果，它的元素类型是 <code>fetchResult</code> 。它的 <code>Pending</code> 字段代表当前区块还有几类数据需要下载。这里需要下载的数据最多有两类：body 和 receipt，<code>full</code> 模式下只需要下载 <code>body</code> 数据，而 <code>fast</code> 模式要多下载一个 <code>receipt</code> 数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> proc := <span class="number">0</span>; proc &lt; space &amp;&amp; <span class="built_in">len</span>(send) &lt; count &amp;&amp; !taskQueue.Empty(); proc++ &#123;</span><br><span class="line">		header := taskQueue.PopItem().(*types.Header)</span><br><span class="line">		hash := header.Hash()</span><br><span class="line">		index := <span class="type">int</span>(header.Number.Int64() - <span class="type">int64</span>(q.resultOffset))</span><br><span class="line">		<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(q.resultCache) || index &lt; <span class="number">0</span> &#123;</span><br><span class="line">			....</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> q.resultCache[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">			components := <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">				components = <span class="number">2</span></span><br><span class="line">			&#125;</span><br><span class="line">			q.resultCache[index] = &amp;fetchResult&#123;</span><br><span class="line">				Pending: components,</span><br><span class="line">				Hash:    hash,</span><br><span class="line">				Header:  header,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> isNoop(header) &#123;</span><br><span class="line">			donePool[hash] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="built_in">delete</span>(taskPool, hash)</span><br><span class="line"></span><br><span class="line">			space, proc = space<span class="number">-1</span>, proc<span class="number">-1</span></span><br><span class="line">			q.resultCache[index].Pending--</span><br><span class="line">			progress = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.Lacks(hash) &#123;</span><br><span class="line">			skip = <span class="built_in">append</span>(skip, header)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			send = <span class="built_in">append</span>(send, header)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是构造 <code>fetchRequest</code> 结构并返回。</p>
<hr>
<h4 id="DeliverBodies-Receipts"><a href="#DeliverBodies-Receipts" class="headerlink" title="DeliverBodies&amp;Receipts"></a>DeliverBodies&amp;Receipts</h4><p><code>body</code> 或 <code>receipt</code> 数据都已经通过 <code>reserve</code> 操作构造了 <code>fetchRequest</code> 结构并传给 <code>fetch</code>，接下来就是等待数据的到达,数据下载成功后，会调用 <code>queue</code> 对象的 <code>deliver</code> 方法进行传递，包括 <code>queue.DeliverBodies</code> 和 <code>queue.DeliverReceipts</code>。这两个方法都以不同的参数调用了 <code>queue.deliver</code> 方法:</p>
<p>①：如果下载的数据数量为 0，则把所有此节点此次下载的数据标记为「缺失」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> results == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">			request.Peer.MarkLacking(header.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：循环处理数据，通过调用<code>reconstruct</code> 填充 <code>resultCache[index]</code> 中的相应的字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err := reconstruct(header, i, q.resultCache[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			failure = err</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：验证<code>resultCache</code> 中的数据，其对应的 <code>request.Headers</code> 中的 <code>header</code> 都应为 nil，若不是则说明验证未通过，需要假如到task queue重新下载</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">		<span class="keyword">if</span> header != <span class="literal">nil</span> &#123;</span><br><span class="line">			taskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果有数据被验证通过且写入 <code>queue.resultCache</code> 中了（<code>accepted</code> &gt; 0），发送 <code>queue.active</code> 消息。<code>Results</code> 会等待这这个信号。</p>
<hr>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h4><p>当(header、body、receipt)都下载完，就要将区块写入到数据库了，<code>queue.Results</code> 就是用来返回所有目前已经下载完成的数据，它在 <code>Downloader.processFullSyncContent</code> 和 <code>Downloader.processFastSyncContent</code> 中被调用。代码比较简单就不多说了。</p>
<p>到此为止<code>queue</code>对象就分析的差不多了。</p>
<hr>
<h2 id="同步headers"><a href="#同步headers" class="headerlink" title="同步headers"></a>同步headers</h2><p>继续回到<code>syncWithPeer</code>函数中，来讲下面比较关键的几个点。</p>
<h3 id="fetchHeaders"><a href="#fetchHeaders" class="headerlink" title="fetchHeaders"></a>fetchHeaders</h3><p>同步<code>headers</code> 是是由函数<code>fetchHeaders</code>来完成的。</p>
<p><code>fetchHeaders</code>的大致思想：</p>
<p> 同步<code>header</code>的数据会被填充到<code>skeleton</code>，每次从远程节点获取区块数据最大为<code>MaxHeaderFetch</code>（192），所以要获取的区块数据如果大于192 ，会被分成组，每组<code>MaxHeaderFetch</code>，剩余的不足192个的不会填充进<code>skeleton</code>，具体步骤如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glszpqzeuwj313u0msq73.jpg" alt="image-20201219111103965"></p>
<p>此种方式可以<strong>避免从同一节点下载过多错误数据</strong>，如果我们连接到了一个恶意节点，它可以创造一个链条很长且<code>TD</code>值也非常高的区块链数据。如果我们的区块从 0 开始全部从它那同步，也就下载了一些根本不被别人承认的数据。如果我只从它那同步 <code>MaxHeaderFetch</code> 个区块，然后发现这些区块无法正确填充我之前的 <code>skeleton</code>（可能是 <code>skeleton</code> 的数据错了，或者用来填充 <code>skeleton</code> 的数据错了），就会丢掉这些数据。</p>
<p>接下来查看下代码如何实现：</p>
<p>①：发起获取<code>header</code>的请求</p>
<p>如果是下载<code>skeleton</code>，则会从高度 <code>from+MaxHeaderFetch-1</code> 开始（包括），每隔 <code>MaxHeaderFetch-1</code> 的高度请求一个 <code>header</code>，最多请求 <code>MaxSkeletonSize</code> 个。如果不是的话，则要获取完整的<code>headers</code> 。</p>
<p>②：等待并处理<code>headerCh</code>中的<code>header</code>数据</p>
<p>2.1 确保远程节点正在返回我们需要填充<code>skeleton</code>所需的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received skeleton from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果<code>skeleton</code>已经下载完毕，则需要继续填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &amp;&amp; skeleton &#123;</span><br><span class="line">				skeleton = <span class="literal">false</span></span><br><span class="line">				getHeaders(from)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 整个<code>skeleton</code>填充完成，并且没有要获取的<code>header</code>了，要通知<code>headerProcCh</code>全部完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//下载pivot时不要中止标头的提取</span></span><br><span class="line">				<span class="keyword">if</span> atomic.LoadInt32(&amp;d.committed) == <span class="number">0</span> &amp;&amp; pivot &lt;= from &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;No headers, waiting for pivot commit&quot;</span>)</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">						getHeaders(from)</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">						<span class="keyword">return</span> errCanceled</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//完成Pivot操作（或不进行快速同步），并且没有头文件，终止该过程</span></span><br><span class="line">				p.log.Debug(<span class="string">&quot;No more headers available&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- <span class="literal">nil</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 当<code>header</code>有数据并且是在获取<code>skeleton</code>的时候，调用<code>fillHeaderSkeleton</code>填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> skeleton &#123;</span><br><span class="line">				filled, proced, err := d.fillHeaderSkeleton(from, headers)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;Skeleton chain invalid&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">				headers = filled[proced:]</span><br><span class="line">				from += <span class="type">uint64</span>(proced)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.5 如果当前处理的不是 <code>skeleton</code>，表明区块同步得差不多了，处理尾部的一些区块</p>
<p>判断本地的主链高度与新收到的 header 的最高高度的高度差是否在 <code>reorgProtThreshold</code> 以内，如果不是，就将高度最高的 <code>reorgProtHeaderDelay</code> 个 header 丢掉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> head+<span class="type">uint64</span>(reorgProtThreshold) &lt; headers[n<span class="number">-1</span>].Number.Uint64() &#123;</span><br><span class="line">						delay := reorgProtHeaderDelay</span><br><span class="line">						<span class="keyword">if</span> delay &gt; n &#123;</span><br><span class="line">							delay = n</span><br><span class="line">						&#125;</span><br><span class="line">						headers = headers[:n-delay]</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 如果还有 <code>header</code> 未处理，发给 <code>headerProcCh</code> 进行处理，<code>Downloader.processHeaders</code> 会等待这个 channel 的消息并进行处理；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- headers:</span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">				from += <span class="type">uint64</span>(<span class="built_in">len</span>(headers))</span><br><span class="line">  getHeaders(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 如果没有发送标头，或者所有标头等待 <code>fsHeaderContCheck</code> 秒，再次调用 <code>getHeaders</code> 请求区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.log.Trace(<span class="string">&quot;All headers delayed, waiting&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">					getHeaders(from)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码后来才加上的，其 commit 的记录在<a href="https://github.com/ethereum/go-ethereum/commit/6ee3b26f447459d3f3a316dbb572e461a273e193#diff-c2fa15e758e986688c646459d8970a50">这里</a>，而 「pull request」 在<a href="https://github.com/ethereum/go-ethereum/pull/17839">这里</a>。从 「pull request」 中作者的解释我们可以了解这段代码的逻辑和功能：这个修改主要是为了解决经常出现的 「invalid hash chain」 错误，出现这个错误的原因是因为在我们上一次从远程节点获取到一些区块并将它们加入到本地的主链的过程中，远程节点发生了 reorg 操作（参见<a href="https://yangzhe.me/2019/03/24/ethereum-blockchain/">这篇文章</a>里关于「主链与侧链」的介绍 ）；当我们再次根据高度请求新的区块时，对方返回给我们的是它的新的主链上的区块，而我们没有这个链上的历史区块，因此在本地写入区块时就会返回 「invalid hash chain」 错误。</p>
<p>要想发生 「reorg」 操作，就需要有新区块加入。在以太坊主网上，新产生一个区块的间隔是 10 秒到 20 秒左右。一般情况下，如果仅仅是区块数据，它的同步速度还是很快的，每次下载也有最大数量的限制。所以在新产生一个区块的这段时间里，足够同步完成一组区块数据而对方节点不会发生 「reorg」 操作。但是注意刚才说的「仅仅是区块数据」的同步较快，<strong>state 数据的同步就非常慢了</strong>。简单来说在完成同步之前可能会有多个 「pivot」 区块，这些区块的 state 数据会从网络上下载，这就大大拖慢了整个区块的同步速度，使得本地在同步一组区块的同时对方发生 「reorg」 操作的机率大大增加。</p>
<p>作者认为这种情况下发生的 「reorg」 操作是由新产生的区块的竞争引起的，所以最新的几个区块是「不稳定的」，如果本次同步的区块数量较多（也就是我们同步时消耗的时间比较长）（在这里「本次同步的区数数量较多」的表现是新收到的区块的最高高度与本地数据库中的最高高度的差距大于 <code>reorgProtThreshold</code>），那么在同步时可以先避免同步最新区块，这就是 <code>reorgProtThreshold</code> 和 <code>reorgProtHeaderDelay</code> 这个变量的由来。</p>
<p>至此，<code>Downloader.fetchHeaders</code> 方法就结束了，所有的区块头也就同步完成了。在上面我们提到填充<code>skeleton</code>的时候，是由<code>fillHeaderSkeleton</code>函数来完成，接下来就要细讲填充<code>skeleton</code>的细节。</p>
<hr>
<h3 id="fillHeaderSkeleton"><a href="#fillHeaderSkeleton" class="headerlink" title="fillHeaderSkeleton"></a>fillHeaderSkeleton</h3><p>首先我们知道以太坊在同步区块时，先确定要下载的区块的高度区间，然后将这个区间按 <code>MaxHeaderFetch</code> 切分成很多组，每一组的最后一个区块组成了 「skeleton」（最后一组不满 <code>MaxHeaderFetch</code> 个区块不算作一组）。不清楚的可以查看上面的图。</p>
<p>①：将一批<code>header</code>检索任务添加到队列中，以填充<code>skeleton</code>。</p>
<p>这个函数参照上面<strong>queue详解</strong>的分析</p>
<blockquote>
<p>func (q *queue) ScheduleSkeleton(from uint64, skeleton []*types.Header) {}</p>
</blockquote>
<p>②：调用<code>fetchParts</code> 获取<code>headers</code>数据</p>
<p><code>fetchParts</code>是很核心的函数，下面的<code>Fetchbodies</code>和<code>FetchReceipts</code>都会调用。先来大致看一下<code>fetchParts</code>的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> fetchParts(...) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">		<span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">		<span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">		<span class="keyword">case</span> &lt;-update:</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化下来就是这 5 个<code>channel</code>在处理，前面 4 个<code>channel</code>负责循环等待消息，<code>update</code>用来等待其他 4 个<code>channel</code>的通知来处理逻辑，先分开分析一个个的<code>channel</code>。</p>
<p>2.1 deliveryCh 传递下载的数据</p>
<p><code>deliveryCh</code> 作用就是传递下载的数据，当有数据被真正下载下来时，就会给这个 <code>channel</code> 发消息将数据传递过来。这个 channel 对应的分别是：<code>d.headerCh</code>、<code>d.bodyCh</code>、<code>d.receiptCh</code>，而这三个 <code>channel</code> 分别在以下三个方法中被写入数据：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。 看下<code>deliveryCh</code>如何处理数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">			<span class="keyword">if</span> peer := d.peers.Peer(packet.PeerId()); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">				accepted, err := deliver(packet)<span class="comment">//传递接收到的数据块并检查链有效性</span></span><br><span class="line">				<span class="keyword">if</span> err == errInvalidChain &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> err != errStaleDelivery &#123;</span><br><span class="line">					setIdle(peer, accepted)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span> &amp;&amp; packet.Items() == <span class="number">0</span>:</span><br><span class="line">					...</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>收到下载数据后判断节点是否有效，如果节点没有被移除，则会通过<code>deliver</code>传递接收到的下载数据。如果没有任何错误，则通知<code>update</code>处理。</p>
<p>要注意<code>deliver</code>是一个回调函数，它调用了 queue 对象的 Deliver 方法：<code>queue.DeliverHeaders</code>、<code>queue.DeliverBodies</code>、<code>queue.DeliverReceipts</code>，在收到下载数据就会调用此回调函数（<strong>queue相关函数分析参照queue详解部分</strong>）。</p>
<p>在上面处理错误部分，有一个<code>setIdle</code>函数，它也是回调函数，其实现都是调用了 <code>peerConnection</code> 对象的相关方法：<code>SetHeadersIdle</code>、<code>SetBodiesIdle</code>、<code>SetReceiptsIdle</code>。它这个函数是指某些节点针对某类数据是空闲的，比如<code>header</code>、<code>bodies</code>、<code>receipts</code>，如果需要下载这几类数据，就可以从空闲的节点下载这些数据。</p>
<p>2.2 <code>wakeCh</code> 唤醒<code>fetchParts</code> ，下载新数据或下载已完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">			<span class="keyword">if</span> !cont &#123;</span><br><span class="line">				finished = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们通过调用fetchParts传递的参数知道，<code>wakeCh</code> 的值其实是 <code>queue.headerContCh</code>。在 <code>queue.DeliverHeaders</code> 中发现所有需要下戴的 header 都下载完成了时，才会发送 false 给这个 channel。<code>fetchParts</code> 在收到这个消息时，就知道没有 header 需要下载了。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> DeliverHeaders(......) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">        q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样如此，<code>body</code>和<code>receipt</code>则是<code>bodyWakeCh</code>和<code>receiptWakeCh</code>，在 <code>processHeaders</code> 中，如果所有 <code>header</code> 已经下载完成了，那么发送 <code>false</code> 给这两个 <code>channel</code>，通知它们没有新的 <code>header</code> 了。 <code>body</code> 和 <code>receipt</code> 的下载依赖于 <code>header</code>,需要 <code>header</code> 先下载完成才能下载，所以对于下戴 <code>body</code> 或 <code>receipt</code> 的 <code>fetchParts</code> 来说，收到这个 <code>wakeCh</code> 就代表不会再有通知让自己下载数据了.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processHeaders(origin <span class="type">uint64</span>, pivot <span class="type">uint64</span>, td *big.Int) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> headers := &lt;-d.headerProcCh:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">                    <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">						...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 ticker 负责周期性的激活 <code>update</code>进行消息处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4 <code>update</code> （处理此前几个<code>channel</code>的数据）(<strong>重要</strong>)</p>
<p>2.4.1 判断是否有效节点，并获取超时数据的信息</p>
<p>获取超时数据的节点ID和数据数量，如果大于两个的话，就将这个节点设置为空闲状态(<code>setIdle</code>)，小于两个的话直接断开节点连接。</p>
<p><code>expire</code> 是一个回调函数，会返回当前所有的超时数据信息。这个函数的实际实现都是调用了 <code>queue</code> 对象的 <code>Expire</code> 方法：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>,此函数会统计当前正在下载的数据中，起始时间与当前时间的差距超过给定阈值（<code>downloader.requestTTL</code> 方法的返回值）的数据，并将其返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.peers.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errNoPeers</span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> pid, fails := <span class="keyword">range</span> expire() &#123;</span><br><span class="line">  <span class="keyword">if</span> peer := d.peers.Peer(pid); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fails &gt; <span class="number">2</span> &#123;</span><br><span class="line">						...</span><br><span class="line">						setIdle(peer, <span class="number">0</span>)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					...</span><br><span class="line">						<span class="keyword">if</span> d.dropPeer == <span class="literal">nil</span> &#123;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							d.dropPeer(pid)</span><br><span class="line">							....</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.4.2 处理完超时数据，判断是否还有下载的数据</p>
<p>如果没有其他可下载的内容，请等待或终止，这里<code>pending()</code>和<code>inFlight()</code>都是回调函数，<code>pending</code>分别对应了<code>queue.PendingHeaders</code>、<code>queue.PendingBlocks</code>、<code>queue.PendingReceipts</code>,用来返回各自要下载的任务数量。<code>inFlight()</code>分别对应了<code>queue.InFlightHeaders</code>、<code>queue.InFlightBlocks</code>、<code>queue.InFlightReceipts</code>,用来返回正在下载的数据数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !inFlight() &amp;&amp; finished &#123;</span><br><span class="line">				...</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4.3 使用空闲节点，调用<code>fetch</code>函数发送数据请求</p>
<p><code>Idle()</code>回调函数在上面已经提过了，<code>throttle()</code>回调函数则分别对<code>queue.ShouldThrottleBlocks</code>、<code>queue.ShouldThrottleReceipts</code>,用来表示是否应该下载<code>bodies</code>或者<code>receipts</code>。</p>
<p><code>reserve</code>函数分别对应<code>queue.ReserveHeaders</code>、<code>queue.ReserveBodies</code>、<code>queue.ReserveReceipts</code>,用来从从下载任务中选取一些可以下载的任务，并构造一个 <code>fetchRequest</code> 结构。它还返回一个 <code>process</code> 变量，标记着是否有空的数据正在被处理。比如有可能某区块中未包含任何一条交易，因此它的 <code>body</code> 和 <code>receipt</code> 都是空的，这种数据其实是不需要下载的。在 <code>queue</code> 对象的 <code>Reserve</code> 方法中，会对这种情况进行识别。如果遇到空的数据，这些数据会被直接标记为下载成功。在方法返回时，就将是否发生过「直接标记为下载成功」的情况返回。</p>
<p><code>capacity</code>回调函数分别对应<code>peerConnection.HeaderCapacity</code>、<code>peerConnection.BlockCapacity</code>、<code>peerConnection.ReceiptCapacity</code>,用来决定下载需要请求数据的个数。</p>
<p><code>fetch</code>回调函数分别对应<code>peer.FetchHeaders</code>、<code>peer.Fetchbodies</code>、<code>peer.FetchReceipts</code>,用来发送获取各类数据的请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">progressed, throttled, running := <span class="literal">false</span>, <span class="literal">false</span>, inFlight()</span><br><span class="line">			idles, total := idle()</span><br><span class="line">			<span class="keyword">for</span> _, peer := <span class="keyword">range</span> idles &#123;</span><br><span class="line">				<span class="keyword">if</span> throttle() &#123;</span><br><span class="line">					...</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				request, progress, err := reserve(peer, capacity(peer))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> progress &#123;</span><br><span class="line">					progressed = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">        <span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> request.From &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">if</span> err := fetch(peer, request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !progressed &amp;&amp; !throttled &amp;&amp; !running &amp;&amp; <span class="built_in">len</span>(idles) == total &amp;&amp; pending() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errPeersUnavailable</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>简单来概括这段代码就是：使用空闲节点下载数据，判断是否需要暂停，或者数据是否已经下载完成；之后选取数据进行下载；最后，如果没有遇到空块需要下载、且没有暂停下载和所有有效节点都空闲和确实有数据需要下载，但下载没有运行起来，就返回 <code>errPeersUnavailable</code> 错误。</p>
<p>到此为止<code>fetchParts</code>函数就分析的差不多了。里面涉及的跟<code>queue.go</code>相关的一些函数都在<strong>queue详解</strong>小节里介绍了。</p>
<hr>
<h3 id="processHeaders"><a href="#processHeaders" class="headerlink" title="processHeaders"></a>processHeaders</h3><p>通过<code>headerProcCh</code>接收<code>header</code>数据，并处理的过程是在<code>processHeaders</code>函数中完成的。整个处理过程集中在：<code>case headers := &lt;-d.headerProcCh中</code>:</p>
<p>①：如果<code>headers</code>的长度为0 ，则会有以下操作：</p>
<p>1.1 通知所有人<code>header</code>已经处理完毕</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 若没有检索到任何<code>header</code>，说明他们的<code>TD</code>小于我们的，或者已经通过我们的<code>fetcher</code>模块进行了同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode != LightSync &#123;</span><br><span class="line">					head := d.blockchain.CurrentBlock()</span><br><span class="line">					<span class="keyword">if</span> !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.3 如果是<code>fast</code>或者<code>light</code> 同步，确保传递了<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">					head := d.lightchain.CurrentHeader()</span><br><span class="line">					<span class="keyword">if</span> td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果<code>headers</code>的长度大于 0</p>
<p>2.1 如果是fast或者light 同步，调用**ightchain.InsertHeaderChain()**写入<code>header</code>到<code>leveldb</code>数据库；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line">  d.lightchain.InsertHeaderChain(chunk, frequency);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果是<code>fast</code>或者<code>full sync</code>模式，则调用 d.queue.Schedule进行内容(body和receipt)检索。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FullSync || d.mode == FastSync &#123;</span><br><span class="line">  ...</span><br><span class="line">  inserts := d.queue.Schedule(chunk, origin)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：如果找到更新的块号，则要发信号通知新任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.syncStatsChainHeight &lt; origin &#123;</span><br><span class="line">				d.syncStatsChainHeight = origin - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此处理<code>Headers</code>的分析就完成了。</p>
<hr>
<h2 id="同步bodies"><a href="#同步bodies" class="headerlink" title="同步bodies"></a>同步bodies</h2><p>同步<code>bodies</code> 则是由<code>fetchBodies</code>函数完成的。</p>
<h3 id="fetchBodies"><a href="#fetchBodies" class="headerlink" title="fetchBodies"></a>fetchBodies</h3><p>同步bodies的过程跟同步header类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code></li>
<li><code>ReserveBodies</code>()从<code>bodyTaskPool</code>中取出要同步的<code>body</code>；</li>
<li>调用<code>fetch</code>，也就是调用这里的<code>FetchBodies</code>从节点获取<code>body</code>，发送<code>GetBlockBodiesMsg</code>消息；</li>
<li>收到<code>bodyCh</code>的数据后，调用<code>deliver</code>函数，将Transactions和<code>Uncles</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步Receipts"><a href="#同步Receipts" class="headerlink" title="同步Receipts"></a>同步Receipts</h2><h3 id="fetchReceipts"><a href="#fetchReceipts" class="headerlink" title="fetchReceipts"></a>fetchReceipts</h3><p>同步<code>receipts</code>的过程跟同步<code>header</code>类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code>()</li>
<li><code>ReserveBodies</code>()从<code>ReceiptTaskPool</code>中取出要同步的<code>Receipt</code></li>
<li>调用这里的<code>FetchReceipts</code>从节点获取<code>receipts</code>，发送<code>GetReceiptsMsg</code>消息；</li>
<li>收到<code>receiptCh</code>的数据后，调用<code>deliver</code>函数，将<code>Receipts</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h2><p>这里我们讲两种模式下的状态同步：</p>
<ul>
<li><strong>fullSync</strong>: <code>processFullSyncContent</code>，<code>full</code>模式下<code>Receipts</code>没有缓存到<code>resultCache</code>中，直接先从缓存中取出<code>body</code>数据，然后执行交易生成状态，最后写入区块链。</li>
<li><strong>fastSync</strong>:<code>processFastSyncContent</code>：fast模式的Receipts、Transaction、Uncles都在resultCache中，所以还需要下载”state”，进行校验，再写入区块链。</li>
</ul>
<p>接下来大致的讨论下这两种方式。</p>
<h3 id="processFullSyncContent"><a href="#processFullSyncContent" class="headerlink" title="processFullSyncContent"></a>processFullSyncContent</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processFullSyncContent() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		results := d.queue.Results(<span class="literal">true</span>)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> err := d.importBlockResults(results); err != <span class="literal">nil</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">...</span><br><span class="line">	blocks := <span class="built_in">make</span>([]*types.Block, <span class="built_in">len</span>(results))</span><br><span class="line">	<span class="keyword">for</span> i, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		blocks[i] = types.NewBlockWithHeader(result.Header).WithBody(result.Transactions, result.Uncles)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接从<code>result</code>中获取数据并生成<code>block</code>，直接插入区块链中，就结束了。</p>
<hr>
<h3 id="processFastSyncContent"><a href="#processFastSyncContent" class="headerlink" title="processFastSyncContent"></a>processFastSyncContent</h3><p>fast模式同步状态内容比较多，大致也就如下几部分，我们开始简单分析以下。</p>
<p>①：下载最新的区块状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sync := d.syncState(latest.Root)</span><br></pre></td></tr></table></figure>

<p>我们直接用一张图来表示整个大致流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glxk6y6zhjj31180jstcl.jpg" alt="image-20201223100153241"></p>
<p>具体的代码读者自己翻阅，大致就是这么个简单过程。</p>
<p>②：计算出pivot块</p>
<p><code>pivot</code>为<code>latestHeight - 64</code>，调用<code>splitAroundPivot</code>()方法以pivot为中心，将<code>results</code>分为三个部分：<code>beforeP</code>，<code>P</code>，<code>afterP</code>；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pivot := <span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> height := latest.Number.Uint64(); height &gt; <span class="type">uint64</span>(fsMinFullBlocks) &#123;</span><br><span class="line">		pivot = height - <span class="type">uint64</span>(fsMinFullBlocks)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">P, beforeP, afterP := splitAroundPivot(pivot, results)</span><br></pre></td></tr></table></figure>

<p>③： 对<code>beforeP</code>的部分调用<code>commitFastSyncData</code>，将<code>body</code>和<code>receipt</code>都写入区块链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.commitFastSyncData(beforeP, sync); </span><br></pre></td></tr></table></figure>

<p>④：对<strong>P</strong>的部分更新状态信息为<code>P block</code>的状态，把<strong>P</strong>对应的<strong>result</strong>（包含<strong>body</strong>和<strong>receipt</strong>）调用<strong>commitPivotBlock</strong>插入本地区块链中，并调用<strong>FastSyncCommitHead</strong>记录这个<strong>pivot</strong>的<strong>hash</strong>值，存在<strong>downloader</strong>中，标记为快速同步的最后一个区块<strong>hash</strong>值；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.commitPivotBlock(P); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：对<code>afterP</code>调用<code>d.importBlockResults</code>，将<code>body</code>插入区块链，而不插入<code>receipt</code>。因为是最后 64 个区块，所以此时数据库中只有<code>header</code>和<code>body</code>，没有<code>receipt</code>和状态，要通过<code>fullSync</code>模式进行最后的同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.importBlockResults(afterP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个Downloader同步完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/ethereum/go-ethereum/pull/1889">https://github.com/ethereum/go-ethereum/pull/1889</a></p>
<p><a href="https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts">https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之blockChain分析</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之blockChain分析</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="blockchain关键元素"><a href="#blockchain关键元素" class="headerlink" title="blockchain关键元素"></a>blockchain关键元素</h2><ul>
<li><code>db</code>：持久化到底层数据储存，即<code>leveldb</code>；</li>
<li><code>genesisBlock</code>：创始区块</li>
<li><code>currentBlock</code>：当前区块，<code>blockchain</code>中并不是储存链所有的<code>block</code>，而是通过<code>currentBlock</code>向前回溯直到<code>genesisBlock</code>，这样就构成了区块链</li>
<li><code>bodyCache</code>、<code>bodyRLPCache</code>、<code>blockCache</code>、<code>futureBlocks</code>：区块链中的缓存结构，用于加快区块链的读取和构建；</li>
<li><code>hc</code>：<code>headerchain</code>区块头链，由<code>blockchain</code>额外维护的另一条链，由于<code>Header</code>和<code>Block</code>的储存空间是有很大差别的，但同时<code>Block</code>的<code>Hash</code>值就是<code>Header</code>（RLP）的<code>Hash</code>值，所以维护一个<code>headerchain</code>可以用于快速延长链，验证通过后再下载<code>blockchain</code>，或者可以与<code>blockchain</code>进行相互验证；</li>
<li><code>processor</code>：执行区块链交易的接口，收到一个新的区块时，要对区块中的所有交易执行一遍，一方面是验证，一方面是更新世界状态；</li>
<li><code>validator</code>：验证数据有效性的接口</li>
<li><code>futureBlocks</code>：收到的区块时间大于当前头区块时间15s而小于30s的区块，可作为当前节点待处理的区块。</li>
</ul>
<hr>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BadBlocks 处理客户端从网络上获取的最近的bad block列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> BadBlocks() []*types.Block &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addBadBlock 把bad block放入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> addBadBlock(block *types.Block) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CurrentBlock取回主链的当前头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentBlock() *types.Block &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentHeader检索规范链的当前头区块header。从HeaderChain的内部缓存中检索标头。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentHeader() *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentFastBlock取回主链的当前fast-sync头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentFastBlock() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将活动链或其子集写入给定的编写器.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Export(w io.Writer) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ExportN(w io.Writer, first <span class="type">uint64</span>, last <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FastSyncCommitHead快速同步，将当前头块设置为特定hash的区块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FastSyncCommitHead(hash common.Hash) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GasLimit返回当前头区块的gas limit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GasLimit() <span class="type">uint64</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Genesis 取回genesis区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Genesis() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过hash从数据库或缓存中取到一个区块体(transactions and uncles)或RLP数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBody(hash common.Hash) *types.Body &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBodyRLP(hash common.Hash) rlp.RawValue &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetBlock 通过hash和number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlock(hash common.Hash, number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByHash 通过hash取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByHash(hash common.Hash) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByNumber 通过number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByNumber(number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash和number区块的header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeader(hash common.Hash, number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定hash的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByHash(hash common.Hash) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定number的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByNumber(number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HasBlock检验hash对应的区块是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlock(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查给定hash和number的区块的区块头是否存在数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasHeader(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasState检验state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasState(hash common.Hash) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasBlockAndState检验hash对应的block和state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlockAndState(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash的区块的总难度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetTd(hash common.Hash, number <span class="type">uint64</span>) *big.Int&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取从给定hash的区块到genesis区块的所有hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockHashesFromHash(hash common.Hash, max <span class="type">uint64</span>) []common.Hash&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetReceiptsByHash 在特定的区块中取到所有交易的收据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetReceiptsByHash(hash common.Hash) types.Receipts &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetBlocksFromHash 取到特定hash的区块及其n-1个父区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlocksFromHash(hash common.Hash, n <span class="type">int</span>) (blocks []*types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetUnclesInChain 取回从给定区块到向前回溯特定距离到区块上的所有叔区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetUnclesInChain(block *types.Block, length <span class="type">int</span>) []*types.Header &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert 将新的头块注入当前块链。 该方法假设该块确实是真正的头。</span></span><br><span class="line"><span class="comment">// 如果它们较旧或者它们位于不同的侧链上，它还会将头部标题和头部快速同步块重置为同一个块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insert(block *types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertChain尝试将给定批量的block插入到规范链中，否则，创建一个分叉。 如果返回错误，它将返回失败块的索引号以及描述错误的错误。</span></span><br><span class="line"><span class="comment">//插入完成后，将触发所有累积的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertChain(chain types.Blocks) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// insertChain将执行实际的链插入和事件聚合。 </span></span><br><span class="line"><span class="comment">// 此方法作为单独方法存在的唯一原因是使用延迟语句使锁定更清晰。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks) (<span class="type">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertHeaderChain尝试将给定的headerchain插入到本地链中，可能会创建一个重组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertHeaderChain(chain []*types.Header, checkFreq <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertReceiptChain 使用交易和收据数据来完成已经存在的headerchain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//loadLastState从数据库加载最后一个已知的链状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> loadLastState() <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Processor 返回当前current processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Processor() Processor &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reset重置清除整个区块链，将其恢复到genesis state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Reset() <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ResetWithGenesisBlock 清除整个区块链, 用特定的genesis state重塑，被Reset所引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ResetWithGenesisBlock(genesis *types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// repair尝试通过回滚当前块来修复当前的区块链，直到找到具有关联状态的块。</span></span><br><span class="line"><span class="comment">// 用于修复由崩溃/断电或简单的非提交尝试导致的不完整的数据库写入。</span></span><br><span class="line"><span class="comment">//此方法仅回滚当前块。 当前标头和当前快速块保持不变。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> repair(head **types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reorgs需要两个块、一个旧链以及一个新链，并将重新构建块并将它们插入到新的规范链中，并累积潜在的缺失事务并发布有关它们的事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> reorg(oldBlock, newBlock *types.Block) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Rollback 旨在从数据库中删除不确定有效的链片段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Rollback(chain []common.Hash) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SetReceiptsData 计算收据的所有非共识字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetReceiptsData</span><span class="params">(config *params.ChainConfig, block *types.Block, receipts types.Receipts)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetHead将本地链回滚到指定的头部。</span></span><br><span class="line"><span class="comment">// 通常可用于处理分叉时重选主链。对于Header，新Header上方的所有内容都将被删除，新的头部将被设置。</span></span><br><span class="line"><span class="comment">// 但如果块体丢失，则会进一步回退（快速同步后的非归档节点）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetHead(head <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetProcessor设置状态修改所需要的processor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetProcessor(processor Processor) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetValidator 设置用于验证未来区块的validator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetValidator(validator Validator) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// State 根据当前头区块返回一个可修改的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> State() (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// StateAt 根据特定时间点返回新的可变状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> StateAt(root common.Hash) (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Stop 停止区块链服务，如果有正在import的进程，它会使用procInterrupt来取消。</span></span><br><span class="line"><span class="comment">// it will abort them using the procInterrupt.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Stop() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TrieNode从memory缓存或storage中检索与trie节点hash相关联的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> TrieNode(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Validator返回当前validator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Validator() Validator &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteBlockWithoutState仅将块及其元数据写入数据库，但不写入任何状态。 这用于构建竞争方叉，直到超过规范总难度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithoutState(block *types.Block, td *big.Int) (err <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// WriteBlockWithState将块和所有关联状态写入数据库。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// writeHeader将标头写入本地链，因为它的父节点已知。 如果新插入的报头的总难度变得大于当前已知的TD，则重新路由规范链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> writeHeader(header *types.Header) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理未来区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="blockchain初始化"><a href="#blockchain初始化" class="headerlink" title="blockchain初始化"></a>blockchain初始化</h2><p>主要步骤：</p>
<p>①：创建一个新的headerChain结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</span><br></pre></td></tr></table></figure>

<ol>
<li>根据number（0）获取genesisHeader</li>
<li>从rawdb中读取HeadBlock并存储在currentHeader中</li>
</ol>
<p>②：获取genesisBlock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>③：如果链不为空，则用老的链数据初始化链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> bc.empty() &#123;</span><br><span class="line">		rawdb.InitDatabaseFromFreezer(bc.db)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：加载最新的状态数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：检查区块哈希的当前状态，并确保链中没有任何坏块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</span><br><span class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Found bad hash, rewinding chain&quot;</span>, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.ParentHash)</span><br><span class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>)</span><br><span class="line">				log.Error(<span class="string">&quot;Chain rewind was successful, resuming normal operation&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：定时处理future block</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br><span class="line">	-&gt;procFutureBlocks</span><br><span class="line">		-&gt;InsertChain</span><br></pre></td></tr></table></figure>

<p>总的来说做了以下几件事：</p>
<ol>
<li>配置<code>cacheConfig</code>，创建各种lru缓存</li>
<li>初始化<code>triegc</code></li>
<li>初始化<code>stateDb</code>：<strong>state.NewDatabase(db)</strong></li>
<li>初始化区块和状态验证：<strong>NewBlockValidator()</strong></li>
<li>初始化状态处理器：<strong>NewStateProcessor()</strong></li>
<li>初始化区块头部链：<strong>NewHeaderChain()</strong></li>
<li>查找创世区块：<strong>bc.genesisBlock &#x3D; bc.GetBlockByNumber(0)</strong></li>
<li>加载最新的状态数据：<strong>bc.loadLastState()</strong></li>
<li>检查区块哈希的当前状态，并确保链中没有任何坏块</li>
<li><code>go bc.update()</code> 定时处理<code>future block</code></li>
</ol>
<h2 id="加载区块链状态"><a href="#加载区块链状态" class="headerlink" title="加载区块链状态"></a>加载区块链状态</h2><p>①：从数据库中恢复headblock，如果空的话，触发reset chain</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">head := rawdb.ReadHeadBlockHash(bc.db)</span><br><span class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Empty database, resetting chain&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：确保整个head block是可以获取的，若为空，则触发reset chain</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">currentBlock := bc.GetBlockByHash(head)</span><br><span class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Corrupt or empty database, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head block missing, resetting chain&quot;</span>, <span class="string">&quot;hash&quot;</span>, head)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：从stateDb中打开最新区块的状态trie，如果打开失败调用bc.repair(&amp;currentBlock)方法进行修复。修复方法就是从当前区块一个个的往前面找，直到找到好的区块，然后赋值给currentBlock。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Dangling block without a state associated, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head state missing, repairing chain&quot;</span>, <span class="string">&quot;number&quot;</span>, currentBlock.Number(), <span class="string">&quot;hash&quot;</span>, currentBlock.Hash())</span><br><span class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：存储当前的headblock和设置当前的headHeader以及头部快速块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.currentBlock.Store(currentBlock)</span><br><span class="line">....</span><br><span class="line">bc.hc.SetCurrentHeader(currentHeader)</span><br><span class="line">...</span><br><span class="line">bc.currentFastBlock.Store(currentBlock)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之rlpx协议</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之rlpx协议</p>
</blockquote>
<p>本文主要参考自eth官方文档：<a href="https://github.com/blockchainGuide">rlpx协议</a></p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><ul>
<li><code>X || Y</code>：表示X和Y的串联</li>
<li><code>X ^ Y</code>： X和Y按位异或</li>
<li><code>X[:N]</code>：X的前N个字节</li>
<li><code>[X, Y, Z, ...]</code>：[X, Y, Z, …]的RLP递归编码</li>
<li><code>keccak256(MESSAGE)</code>：以太坊使用的keccak256哈希算法</li>
<li><code>ecies.encrypt(PUBKEY, MESSAGE, AUTHDATA)</code>：RLPx使用的非对称身份验证加密函数     AUTHDATA是身份认证的数据，并非密文的一部分     但是AUTHDATA会在生成消息tag前，写入HMAC-256哈希函数</li>
<li><code>ecdh.agree(PRIVKEY, PUBKEY)</code>：是PRIVKEY和PUBKEY之间的椭圆曲线Diffie-Hellman协商函数</li>
</ul>
<hr>
<h2 id="ECIES加密"><a href="#ECIES加密" class="headerlink" title="ECIES加密"></a>ECIES加密</h2><p>ECIES (Elliptic Curve Integrated Encryption Scheme) 非对称加密用于RLPx握手。RLPx使用的加密系统：</p>
<ul>
<li>椭圆曲线secp256k1基点<code>G</code></li>
<li><code>KDF(k, len)</code>：密钥推导函数 NIST SP 800-56 Concatenation</li>
<li><code>MAC(k, m)</code>：HMAC函数，使用了SHA-256哈希</li>
<li><code>AES(k, iv, m)</code>：AES-128对称加密函数，CTR模式</li>
</ul>
<p>假设Alice想发送加密消息给Bob，并且希望Bob可以用他的静态私钥<code>kB</code>解密。Alice知道Bob的静态公钥<code>KB</code>。</p>
<p>Alice为了对消息<code>m</code>进行加密：</p>
<ol>
<li>生成一个随机数<code>r</code>并生成对应的椭圆曲线公钥<code>R = r * G</code></li>
<li>计算共享密码<code>S = Px</code>，其中 <code>(Px, Py) = r * KB</code></li>
<li>推导加密及认证所需的密钥<code>kE || kM = KDF(S, 32)</code>以及随机向量<code>iv</code></li>
<li>使用AES加密 <code>c = AES(kE, iv, m)</code></li>
<li>计算MAC校验 <code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>发送完整密文<code>R || iv || c || d</code>给Bob</li>
</ol>
<p>Bob对密文<code>R || iv || c || d</code>进行解密：</p>
<ol>
<li>推导共享密码<code>S = Px</code>, 其中<code>(Px, Py) = r * KB = kB * R</code></li>
<li>推导加密认证用的密钥<code>kE || kM = KDF(S, 32)</code></li>
<li>验证MAC<code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>获得明文<code>m = AES(kE, iv || c)</code></li>
</ol>
<hr>
<h2 id="节点身份"><a href="#节点身份" class="headerlink" title="节点身份"></a>节点身份</h2><p>所有的加密操作都基于<strong>secp256k1</strong>椭圆曲线。每个节点维护一个静态的<strong>secp256k1</strong>私钥。建议该私钥只能进行手动重置（例如删除文件或数据库条目）。</p>
<hr>
<h2 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h2><p>RLPx连接基于TCP通信，并且每次通信都会生成随机的临时密钥用于加密和验证。生成临时密钥的过程被称作“握手” (handshake)，握手在发起端（initiator, 发起TCP连接请求的节点）和接收端（recipient, 接受连接的节点）之间进行。</p>
<ol>
<li>发起端向接收端发起TCP连接，发送<code>auth</code>消息</li>
<li>接收端接受连接，解密、验证<code>auth</code>消息（检查recovery of signature &#x3D;&#x3D; <code>keccak256(ephemeral-pubk)</code>）</li>
<li>接收端通过<code>remote-ephemeral-pubk</code> 和 <code>nonce</code>生成<code>auth-ack</code>消息</li>
<li>接收端推导密钥，发送首个包含<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息的数据帧 (frame)</li>
<li>发起端接收到<code>auth-ack</code>消息，导出密钥</li>
<li>发起端发送首个加密后的数据帧，包含发起端<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息</li>
<li>接收端接收并验证首个加密后的数据帧</li>
<li>发起端接收并验证首个加密后的数据帧</li>
<li>如果两边的首个加密数据帧的MAC都验证通过，则加密握手完成</li>
</ol>
<p>如果首个数据帧的验证失败，则任意一方都可以断开连接。</p>
<h3 id="握手消息"><a href="#握手消息" class="headerlink" title="握手消息"></a>握手消息</h3><p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">auth = auth-size || enc-auth-body</span><br><span class="line">auth-size = size of enc-auth-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">auth-vsn = <span class="number">4</span></span><br><span class="line">auth-body = [sig, initiator-pubk, initiator-nonce, auth-vsn, ...]</span><br><span class="line">enc-auth-body = ecies.encrypt(recipient-pubk, auth-body || auth-padding, auth-size)</span><br><span class="line">auth-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ack = ack-size || enc-ack-body</span><br><span class="line">ack-size = size of enc-ack-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">ack-vsn = <span class="number">4</span></span><br><span class="line">ack-body = [recipient-ephemeral-pubk, recipient-nonce, ack-vsn, ...]</span><br><span class="line">enc-ack-body = ecies.encrypt(initiator-pubk, ack-body || ack-padding, ack-size)</span><br><span class="line">ack-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p>实现必须忽略<code>auth-vsn</code> 和 <code>ack-vsn</code>中的所有不匹配。</p>
<p>实现必须忽略<code>auth-body</code> 和 <code>ack-body</code>中的所有额外列表元素。</p>
<p>握手消息互换后，密钥生成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">static-shared-secret = ecdh.agree(privkey, remote-pubk)</span><br><span class="line">ephemeral-key = ecdh.agree(ephemeral-privkey, remote-ephemeral-pubk)</span><br><span class="line">shared-secret = keccak256(ephemeral-key || keccak256(nonce || initiator-nonce))</span><br><span class="line">aes-secret = keccak256(ephemeral-key || shared-secret)</span><br><span class="line">mac-secret = keccak256(ephemeral-key || aes-secret)</span><br></pre></td></tr></table></figure>

<h2 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h2><p>握手后所有的消息都按帧 (frame) 传输。一帧数据携带属于某一功能的一条加密消息。</p>
<p>分帧传输的主要目的是在单一连接上实现可靠的支持多路复用协议。其次，因数据包分帧，为消息认证码产生了适当的分界点，使得加密流变得简单了。通过握手生成的密钥对数据帧进行加密和验证。</p>
<p>帧头提供关于消息大小和消息源功能的信息。填充字节用于防止缓存区不足，使得帧组件按指定区块字节大小对齐。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">frame = header-ciphertext || header-mac || frame-ciphertext || frame-mac</span><br><span class="line">header-ciphertext = aes(aes-secret, header)</span><br><span class="line">header = frame-size || header-data || header-padding</span><br><span class="line">header-data = [capability-id, context-id]</span><br><span class="line">capability-id = integer, always zero</span><br><span class="line">context-id = integer, always zero</span><br><span class="line">header-padding = zero-fill header to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br><span class="line">frame-ciphertext = aes(aes-secret, frame-data || frame-padding)</span><br><span class="line">frame-padding = zero-fill frame-data to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>RLPx中的消息认证 (Message authentication) 使用了两个keccak256状态，分别用于两个传输方向。<code>egress-mac</code>和<code>ingress-mac</code>分别代表发送和接收状态，每次发送或者接收密文，其状态都会更新。初始握手后，MAC状态初始化如下:</p>
<p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br></pre></td></tr></table></figure>

<p>当发送一帧数据时，通过即将发送的数据更新<code>egress-mac</code>状态，然后计算相应的MAC值。通过将帧头与其对应MAC值的加密输出异或来进行更新。这样做是为了确保对明文MAC和密文执行统一操作。所有的MAC值都以明文发送。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ header-ciphertext</span><br><span class="line">egress-mac = keccak256.update(egress-mac, header-mac-seed)</span><br><span class="line">header-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p><strong>计算 <code>frame-mac</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.update(egress-mac, frame-ciphertext)</span><br><span class="line">frame-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ keccak256.digest(egress-mac)[:16]</span><br><span class="line">egress-mac = keccak256.update(egress-mac, frame-mac-seed)</span><br><span class="line">frame-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p>只要发送者和接受者按相同方式更新<code>egress-mac</code>和<code>ingress-mac</code>，并且在ingress帧中比对<code>header-mac</code> 和 <code>frame-mac</code>的值，就能对ingress帧中的MAC值进行校验。这一步应当在解密<code>header-ciphertext</code> 和 <code>frame-ciphertext</code>之前完成。</p>
<hr>
<h2 id="功能消息"><a href="#功能消息" class="headerlink" title="功能消息"></a>功能消息</h2><p>初始握手后的所有消息均与“功能”相关。单个RLPx连接上就可以同时使用任何数量的功能。</p>
<p>功能由简短的ASCII名称和版本号标识。连接两端都支持的功能在隶属于“ p2p”功能的<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息中进行交换，p2p功能需要在所有连接中都可用。</p>
<h3 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h3><p>初始Hello消息编码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame-data = msg-id || msg-data</span><br><span class="line">frame-size = length of frame-data, encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<p>其中，<code>msg-id</code>是标识消息的由RLP编码的整数，<code>msg-data</code>是包含消息数据的RLP列表。</p>
<p>Hello之后的所有消息均使用Snappy算法压缩。请注意，压缩消息的<code>frame-size</code>指<code>msg-data</code>压缩前的大小。消息的压缩编码为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame-data = msg-id || snappyCompress(msg-data)</span><br><span class="line">frame-size = length of (msg-id || msg-data) encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<h2 id="基于msg-id的复用"><a href="#基于msg-id的复用" class="headerlink" title="基于msg-id的复用"></a>基于<code>msg-id</code>的复用</h2><p>frame中虽然支持<code>capability-id</code>，但是在本RLPx版本中并没有将该字段用于不同功能之间的复用（当前版本仅使用msg-id来实现复用）。</p>
<p>每种功能都会根据需要分配尽可能多的msg-id空间。所有这些功能所需的msg-id空间都必须通过静态指定。在连接和接收<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息时，两端都具有共享功能（包括版本）的对等信息，并且能够就msg-id空间达成共识。</p>
<p>msg-id应当大于0x11(0x00-0x10保留用于“ p2p”功能）。</p>
<hr>
<h2 id="p2p功能"><a href="#p2p功能" class="headerlink" title="p2p功能"></a>p2p功能</h2><p>所有连接都具有“p2p”功能。初始握手后，连接的两端都必须发送<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>或<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。在接收到Hello消息后，会话就进入激活状态，并且可以开始发送其他消息。由于前向兼容性，实现必须忽略协议版本中的所有差异。与处于较低版本的节点通信时，实现应尝试靠近该版本。</p>
<p>任何时候都可能会收到<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。</p>
<h3 id="Hello-0x00"><a href="#Hello-0x00" class="headerlink" title="Hello (0x00)"></a>Hello (0x00)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[protocolVersion: P, clientId: B, capabilities, listenPort: P, nodeKey: B_64, ...]</span><br></pre></td></tr></table></figure>

<p>握手完成后，双方发送的第一包数据。在收到Hello消息前，不能发送任何其他消息。实现必须忽略Hello消息中所有其他列表元素，因为可能会在未来版本中用到。</p>
<ul>
<li><code>protocolVersion</code>当前p2p功能版本为第5版</li>
<li><code>clientId</code>表示客户端软件身份，人类可读字符串, 比如”Ethereum(++)&#x2F;1.0.0“</li>
<li><code>capabilities</code>支持的子协议列表，名称及其版本：<code>[[cap1, capVersion1], [cap2, capVersion2], ...]</code></li>
<li><code>listenPort</code>节点的收听端口 (位于当前连接路径的接口)，0表示没有收听</li>
<li><code>nodeId</code>secp256k1的公钥，对应节点私钥</li>
</ul>
<h3 id="Disconnect-0x01"><a href="#Disconnect-0x01" class="headerlink" title="Disconnect (0x01)"></a>Disconnect (0x01)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[reason: P]</span><br></pre></td></tr></table></figure>

<p>通知节点断开连接。收到该消息后，节点应当立即断开连接。如果是发送，正常的主机会给节点2秒钟读取时间，使其主动断开连接。</p>
<p><code>reason</code> 一个可选整数，表示断开连接的原因：</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x00</code></td>
<td>Disconnect requested</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>TCP sub-system error</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>Breach of protocol, e.g. a malformed message, bad RLP, …</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td>Useless peer</td>
</tr>
<tr>
<td><code>0x04</code></td>
<td>Too many peers</td>
</tr>
<tr>
<td><code>0x05</code></td>
<td>Already connected</td>
</tr>
<tr>
<td><code>0x06</code></td>
<td>Incompatible P2P protocol version</td>
</tr>
<tr>
<td><code>0x07</code></td>
<td>Null node identity received - this is automatically invalid</td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>Client quitting</td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>Unexpected identity in handshake</td>
</tr>
<tr>
<td><code>0x0a</code></td>
<td>Identity is the same as this node (i.e. connected to itself)</td>
</tr>
<tr>
<td><code>0x0b</code></td>
<td>Ping timeout</td>
</tr>
<tr>
<td><code>0x10</code></td>
<td>Some other reason specific to a subprotocol</td>
</tr>
</tbody></table>
<h3 id="Ping-0x02"><a href="#Ping-0x02" class="headerlink" title="Ping (0x02)"></a>Ping (0x02)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>要求节点立即进行<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#pong-0x03">Pong</a>回复。</p>
<h3 id="Pong-0x03"><a href="#Pong-0x03" class="headerlink" title="Pong (0x03)"></a>Pong (0x03)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>回复节点的<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#ping-0x02">Ping</a>包。</p>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="返回传输对象"><a href="#返回传输对象" class="headerlink" title="返回传输对象"></a>返回传输对象</h4><blockquote>
<p>返回一个transport对象,连接持续5秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handshakeTimeout 5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRLPX</span><span class="params">(fd net.Conn)</span></span> transport &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><blockquote>
<p>返回Msg对象,调用读写器的ReadMsg,连接持续30秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> ReadMsg() (Msg, <span class="type">error</span>) &#123;</span><br><span class="line">  ..</span><br><span class="line">	t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入消息"><a href="#写入消息" class="headerlink" title="写入消息"></a>写入消息</h4><blockquote>
<p>调用读写器的WriteMsg写信息,连接持续20秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> WriteMsg(msg Msg) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议版本握手"><a href="#协议版本握手" class="headerlink" title="协议版本握手"></a>协议版本握手</h4><blockquote>
<p>协议握手,输入输出均是protoHandshake对象,包含了版本号、名称、容量、端口号、ID和一个扩展属性,握手时会对这些信息进行验证</p>
</blockquote>
<h4 id="加密握手"><a href="#加密握手" class="headerlink" title="加密握手"></a>加密握手</h4><blockquote>
<p>握手时主动发起者叫<strong>initiator</strong></p>
<p>接收方叫<strong>receiver</strong></p>
<p>分别对应两种处理方式<strong>initiatorEncHandshake</strong>和receiverEncHandshake</p>
<p>两种处理方式成功以后都会得到一个<strong>secrets</strong>对象,保存了共享密钥信息,它会跟原有的<strong>net.Conn</strong>对象一起生成一个帧处理器:<strong>rlpxFrameRW</strong></p>
<p>握手双方使用到的信息有:各自的公私钥地址对**(iPrv,iPub,rPrv,rPub)<strong>、各自生成的随机公私钥对</strong>(iRandPrv,iRandPub,rRandPrv,rRandPub)<strong>、各自生成的临时随机数</strong>(initNonce,respNonce).**<br> 其中i开头的表示发起方**(initiator)<strong>信息,r开头的表示接收方</strong>(receiver)**信息.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> doEncHandshake(prv *ecdsa.PrivateKey, dial *ecdsa.PublicKey) (*ecdsa.PublicKey, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sec secrets</span><br><span class="line">		err <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> dial == <span class="literal">nil</span> &#123;</span><br><span class="line">		sec, err = receiverEncHandshake(t.fd, prv) <span class="comment">// 接收者</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sec, err = initiatorEncHandshake(t.fd, prv, dial) <span class="comment">//主动发起者</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	t.rw = newRLPXFrameRW(t.fd, sec)</span><br><span class="line">	t.wmu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> sec.Remote.ExportECDSA(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就讲解一下主动握手部分源码<code>initiatorEncHandshake</code>：</p>
<p>①：初始化握手对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h := &amp;encHandshake&#123;initiator: <span class="literal">true</span>, remote: ecies.ImportECDSAPublic(remote)&#125;</span><br></pre></td></tr></table></figure>

<p>②：生成验证信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authMsg, err := h.makeAuthMsg(prv) </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *encHandshake)</span></span> makeAuthMsg(prv *ecdsa.PrivateKey) (*authMsgV4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 生成己方随机数initNonce</span></span><br><span class="line">	h.initNonce = <span class="built_in">make</span>([]<span class="type">byte</span>, shaLen)</span><br><span class="line">	_, err := rand.Read(h.initNonce)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 生成随机的一组公私钥对</span></span><br><span class="line">	h.randomPrivKey, err = ecies.GenerateKey(rand.Reader, crypto.S256(), <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成静态共享秘密token(用己方私钥和对方公钥进行有限域乘法)</span></span><br><span class="line">	token, err := h.staticSharedSecret(prv)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//  和己方随机数异或后用随机生成的私钥签名</span></span><br><span class="line">	signed := xor(token, h.initNonce)</span><br><span class="line">	signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：封包,将验证信息和握手进行rlp编码并拼接前缀信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authPacket, err := sealEIP8(authMsg, h)</span><br></pre></td></tr></table></figure>

<p>④：通过conn发送消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.Write(authPacket)</span><br></pre></td></tr></table></figure>

<p>⑤：处理接收的信息,得到响应包</p>
<blockquote>
<p><code>readHandshakeMsg</code>比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 </p>
<p>结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authRespMsg := <span class="built_in">new</span>(authRespV4)</span><br><span class="line">authRespPacket, err := readHandshakeMsg(authRespMsg, encAuthRespLen, prv, conn)</span><br></pre></td></tr></table></figure>

<p>⑥：填充响应的respNonce(对方随机数,生成共享私钥用)和remoteRandomPub(对方的随机公钥)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.handleAuthResp(authRespMsg)</span><br></pre></td></tr></table></figure>

<p>⑦：将请求包和响应包封装成共享秘密(secrets)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.secrets(authPacket, authRespPacket)</span><br></pre></td></tr></table></figure>

<p>到此RLPX 相关的比较重要的内容就解读差不多了。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md">https://github.com/ethereum/devp2p/blob/master/rlpx.md</a> </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之p2p网络启动</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之p2p网络启动</p>
<p>资料代码及文章:<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>持续输出区块链相关技术文章，喜欢作者可以持续关注，文章有问题，可以随时指出。</p>
</blockquote>
<h2 id="p2p源码目录"><a href="#p2p源码目录" class="headerlink" title="p2p源码目录"></a>p2p源码目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discover/          基于UDP的节点发现V4协议</span><br><span class="line">  discv5/            节点发现V5协议</span><br><span class="line">  enode/             节点信息</span><br><span class="line">  enr/               以太坊节点记录（ethereum node records)</span><br><span class="line">  nat/               网络地址转换，用于内网穿透</span><br><span class="line">  netutil/</span><br><span class="line">  protocol/</span><br><span class="line">  simulations/       本地p2p网络的模拟器</span><br><span class="line">  dial.go            建立连接请求，以任务的形式 </span><br><span class="line">  message.go         定义了读写的接口</span><br><span class="line">  metrics.go         计时器和计量器工具</span><br><span class="line">  peer.go            节点</span><br><span class="line">  protocol.go        子协议</span><br><span class="line">  rlpx.go            加密传输协议 </span><br><span class="line">  server.go          底层p2p网络的函数入口 </span><br></pre></td></tr></table></figure>



<h2 id="启动p2p网络"><a href="#启动p2p网络" class="headerlink" title="启动p2p网络"></a>启动p2p网络</h2><p>启动p2p网络主要会做以下几件事：</p>
<ol>
<li>发现远程节点，建立相邻节点列表</li>
<li>监听远程节点发过来的建立TCP请求</li>
<li>向远程节点发送建立TCP连接请求</li>
</ol>
<p>首先找到p2p网络启动的入口：</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p><code>start</code>函数主要做了以下6件事：</p>
<ol>
<li>初始化server的字段</li>
<li>设置本地节点setupLocalNode</li>
<li>设置监听TCP连接请求setupListening</li>
<li>设置节点发现（setupDiscovery）V4版本</li>
<li>设置最大可以主动发起的连接为50&#x2F;3</li>
<li>srv.run(dialer) 发起建立TCP连接请求</li>
</ol>
<p>其中setupLocalNode、setupListening、setupDiscovery、newDialState、srv.run(dialer)是我们要重点分析的函数。</p>
<h4 id="设置本地节点"><a href="#设置本地节点" class="headerlink" title="设置本地节点"></a>设置本地节点</h4><p>进入到setupLocalNode中：</p>
<p>①：创建devp2p握手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pubkey := crypto.FromECDSAPub(&amp;srv.PrivateKey.PublicKey)</span><br><span class="line">	srv.ourHandshake = &amp;protoHandshake&#123;Version: baseProtocolVersion, Name: srv.Name, ID: pubkey[<span class="number">1</span>:]&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		srv.ourHandshake.Caps = <span class="built_in">append</span>(srv.ourHandshake.Caps, p.<span class="built_in">cap</span>())</span><br><span class="line">	&#125;</span><br><span class="line">sort.Sort(capsByNameAndVersion(srv.ourHandshake.Caps))</span><br></pre></td></tr></table></figure>

<p>握手协议包括协议版本号，节点名称和节点的公钥，存入到Caps中要根据名称和协议排序。</p>
<p>②：创建本地节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, err := enode.OpenDB(srv.Config.NodeDatabase)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	srv.nodedb = db</span><br><span class="line">	srv.localnode = enode.NewLocalNode(db, srv.PrivateKey)</span><br><span class="line">	srv.localnode.SetFallbackIP(net.IP&#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> check conflicts</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">			srv.localnode.Set(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先从节点数据库中去获取节点信息，如果不存在则新建本地节点并设置默认IP，同时将节点记录的协议特定信息存入到本地节点中。</p>
<hr>
<h4 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h4><p>进入到<code>setupListening</code>:</p>
<p>①：启动监听器</p>
<p>②：如果配置了NAT，则更新本地节点记录并映射TCP监听端口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> tcp, ok := listener.Addr().(*net.TCPAddr); ok &#123;</span><br><span class="line">		srv.localnode.Set(enr.TCP(tcp.Port))</span><br><span class="line">		<span class="keyword">if</span> !tcp.IP.IsLoopback() &amp;&amp; srv.NAT != <span class="literal">nil</span> &#123;</span><br><span class="line">			srv.loopWG.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				nat.Map(srv.NAT, srv.quit, <span class="string">&quot;tcp&quot;</span>, tcp.Port, tcp.Port, <span class="string">&quot;ethereum p2p&quot;</span>)</span><br><span class="line">				srv.loopWG.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：开启P2P监听，接收<code>inbound</code>连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv.listenLoop()</span><br></pre></td></tr></table></figure>

<p>这个函数需要进一步分析：</p>
<p>主要有以下逻辑：</p>
<ul>
<li><p>首先<code>defaultMaxPendingPeers</code>这个字段指的是<code>inbound</code> 和<code>outbound</code>连接，默认最大值为50</p>
</li>
<li><p>将监听的连接返回给<code>listener</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fd, err = srv.listener.Accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取监听的连接的地址并检查这个连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remoteIP := netutil.AddrIP(fd.RemoteAddr())</span><br><span class="line"><span class="keyword">if</span> err := srv.checkInboundConn(fd, remoteIP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkInboundConn</code>主要是做了以下的判断：</p>
<ul>
<li>拒绝不符合NetRestrict的连接（NetRestrict是指已经限定了某些连接，除此之外会拒绝）</li>
<li>拒绝尝试过多的节点</li>
</ul>
</li>
<li><p>最后真正建立连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			srv.SetupConn(fd, inboundConn, <span class="literal">nil</span>)<span class="comment">// 连接建立过程（将连接添加为peer）</span></span><br><span class="line">			slots &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;()</span><br></pre></td></tr></table></figure>

<p>要注意setupConn的第三个字段传入的是nil，表示还没有拨号，如果正在拨号的话需要节点公钥。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dialPubkey *ecdsa.PublicKey</span><br><span class="line">	<span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		dialPubkey = <span class="built_in">new</span>(ecdsa.PublicKey)</span><br><span class="line">		<span class="keyword">if</span> err := dialDest.Load((*enode.Secp256k1)(dialPubkey)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;dial destination doesn&#x27;t have a secp256k1 public key&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是进行RLPX（RLPX会单独讲）握手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remotePubkey, err := c.doEncHandshake(srv.PrivateKey, dialPubkey)</span><br></pre></td></tr></table></figure>

<p>如果dialDest 不为nil，检查公钥是否匹配，如果为nil,就从连接中返回一个node出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// For dialed connections, check that the remote public key matches.</span></span><br><span class="line">		<span class="comment">//对于拨号连接，请检查远程公钥是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> dialPubkey.X.Cmp(remotePubkey.X) != <span class="number">0</span> || dialPubkey.Y.Cmp(remotePubkey.Y) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> DiscUnexpectedIdentity</span><br><span class="line">		&#125;</span><br><span class="line">		c.node = dialDest</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.node = nodeFromConn(remotePubkey, c.fd)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正执行握手了 ,这部分也属于RLPX，跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">phs, err := c.doProtoHandshake(srv.ourHandshake)</span><br></pre></td></tr></table></figure>

<p>之后要进行检查，如果成功了的话，连接就会作为节点被添加，并且启动了runPeer.</p>
<p>到此为止，整个listenLoop 就完成了。</p>
<hr>
</li>
</ul>
<h4 id="设置节点发现"><a href="#设置节点发现" class="headerlink" title="设置节点发现"></a>设置节点发现</h4><p>进入到<code>srv.setupDiscovery()</code></p>
<p>①：添加特定于协议的发现源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">added := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">if</span> proto.DialCandidates != <span class="literal">nil</span> &amp;&amp; !added[proto.Name] &#123;</span><br><span class="line">			srv.discmix.AddSource(proto.DialCandidates)</span><br><span class="line">			added[proto.Name] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果DHT禁用的话，就不要在UDP上监听</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> srv.NoDiscovery &amp;&amp; !srv.DiscoveryV5 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：监听给定的socket 上的发现的包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<h4 id="创建DialState"><a href="#创建DialState" class="headerlink" title="创建DialState"></a>创建DialState</h4><p>dialstate负责拨号和查找发现。</p>
<p>①：初始化dialstate</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &amp;dialstate&#123;</span><br><span class="line">   maxDynDials: maxdyn,</span><br><span class="line">   self:        self,</span><br><span class="line">   netrestrict: cfg.NetRestrict,</span><br><span class="line">   log:         cfg.Logger,</span><br><span class="line">   static:      <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]*dialTask),</span><br><span class="line">   dialing:     <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]connFlag),</span><br><span class="line">   bootnodes:   <span class="built_in">make</span>([]*enode.Node, <span class="built_in">len</span>(cfg.BootstrapNodes)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：加入初始引导节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s.bootnodes, cfg.BootstrapNodes)</span><br><span class="line"><span class="keyword">if</span> s.log == <span class="literal">nil</span> &#123;</span><br><span class="line">	s.log = log.Root()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③： 加入静态节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> cfg.StaticNodes &#123;</span><br><span class="line">		s.addStatic(n)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>bootnodes</code>是初始引导节点，在节点没有接收到任何节点的连接请求，也没有节点可以给我们邻居节点的时候，就去连接<code>bootnodes</code>，它硬编码在了以太坊的源码中。</p>
<p><code>static</code>是静态节点，如果我们想和某些节点保持长期的连接，就把它们加入到静态节点的列表中</p>
<p>接下来就是到了运行p2p网络的时候了，主要的函数是：<code>go srv.run(dialer)</code></p>
<hr>
<h2 id="运行p2p网络"><a href="#运行p2p网络" class="headerlink" title="运行p2p网络"></a>运行p2p网络</h2><h3 id="srv-run-dialer"><a href="#srv-run-dialer" class="headerlink" title="srv.run(dialer)"></a>srv.run(dialer)</h3><p>在p2p网络启动时候，我们会监听远程节点发送过来的TCP请求，到了运行p2p网络的时候，我们则会向远程节点发起TCP的连接请求。首先我们要知道我们所说的发起TCP连接请求可以形容成拨号，每个拨号都是以任务的形式存在，进入到<code>srv.run(dialer)</code>分析</p>
<p>整个函数就是一个循环，介绍下它的主要功能：</p>
<h4 id="发起TCP连接任务"><a href="#发起TCP连接任务" class="headerlink" title="发起TCP连接任务"></a>发起TCP连接任务</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scheduleTasks()</span><br></pre></td></tr></table></figure>

<p><code>scheduleTasks</code>主要是从queued task 中去获取任务，通过查询dialer以查找新任务并立即启动尽可能多的任务，我们这里要注意个变量<code>maxActiveDialTasks</code>,它的默认值为16 ，而安排任务的核心方法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nt := dialstate.newTasks(<span class="built_in">len</span>(runningTasks)+<span class="built_in">len</span>(queuedTasks), peers, time.Now())</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<p>①：为没有连接的静态节点创建拨号任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> id, t := <span class="keyword">range</span> s.static &#123;</span><br><span class="line">		err := s.checkDial(t.dest, peers)</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> errNotWhitelisted, errSelf:</span><br><span class="line">			s.log.Warn(<span class="string">&quot;Removing static dial candidate&quot;</span>, <span class="string">&quot;id&quot;</span>, t.dest.ID, <span class="string">&quot;addr&quot;</span>, &amp;net.TCPAddr&#123;IP: t.dest.IP(), Port: t.dest.TCP()&#125;, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="built_in">delete</span>(s.static, t.dest.ID())</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			s.dialing[id] = t.flags</span><br><span class="line">			newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先对拨号节点进行校验：正在连接，已经连接，是本身，不在白名单中，最近连接过的都会报错，并且不是在白名单中的和自身的节点会直接从静态节点列表中删除，校验通过的创建任务。</p>
<p>②：计算所需的动态拨号数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">needDynDials := s.maxDynDials</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		<span class="keyword">if</span> p.rw.is(dynDialedConn) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, flag := <span class="keyword">range</span> s.dialing &#123;</span><br><span class="line">		<span class="keyword">if</span> flag&amp;dynDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们主动发起的TCP连接请求是由节点最大连接数除以拨号比率得出的，即<code>maxPeers/radio</code>，同时我们会判断节点中是否已经有建立了连接的节点和正在拨号的节点，有的话会needDynDials会减去。</p>
<p>③：如果找不到任何的peers,就去随机找bootnode，发起连接</p>
<p>不过这个一般适用在<strong>测试网或者私链</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(peers) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(s.bootnodes) &gt; <span class="number">0</span> &amp;&amp; needDynDials &gt; <span class="number">0</span> &amp;&amp; now.Sub(s.start) &gt; fallbackInterval &#123;</span><br><span class="line">		bootnode := s.bootnodes[<span class="number">0</span>]</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes[:<span class="number">0</span>], s.bootnodes[<span class="number">1</span>:]...)</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes, bootnode)</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, bootnode) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：从节点发现结果中创建动态拨号任务</p>
<p>如果不满足最大任务数量的话，就去<code>s.lookupBuf</code>中寻找，<code>lookupBuf</code>通过KAD算法获取的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(s.lookupBuf) &amp;&amp; needDynDials &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, s.lookupBuf[i]) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.lookupBuf = s.lookupBuf[:<span class="built_in">copy</span>(s.lookupBuf, s.lookupBuf[i:])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.lookupBuf) &lt; needDynDials &amp;&amp; !s.lookupRunning &#123;</span><br><span class="line">		s.lookupRunning = <span class="literal">true</span></span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, &amp;discoverTask&#123;want: needDynDials - <span class="built_in">len</span>(s.lookupBuf)&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：没有需要执行的任务，保持拨号逻辑继续运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nRunning == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(newtasks) == <span class="number">0</span> &amp;&amp; s.hist.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t := &amp;waitExpireTask&#123;s.hist.nextExpiry().Sub(now)&#125;</span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此创建新任务结束，返回<code>newTasks</code></p>
<hr>
<h4 id="执行TCP连接任务"><a href="#执行TCP连接任务" class="headerlink" title="执行TCP连接任务"></a>执行TCP连接任务</h4><p>直到满足最大活动任务数才开始任务执行，具体的执行过程在以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">startTasks := <span class="function"><span class="keyword">func</span><span class="params">(ts []task)</span></span> (rest []task) &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> ; <span class="built_in">len</span>(runningTasks) &lt; maxActiveDialTasks &amp;&amp; i &lt; <span class="built_in">len</span>(ts); i++ &#123;</span><br><span class="line">			t := ts[i]</span><br><span class="line">			srv.log.Trace(<span class="string">&quot;New dial task&quot;</span>, <span class="string">&quot;task&quot;</span>, t)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.Do(srv); taskdone &lt;- t &#125;()</span><br><span class="line">			runningTasks = <span class="built_in">append</span>(runningTasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ts[i:]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Do(srv);</span><br></pre></td></tr></table></figure>

<p>执行的主要任务包括下面几种：</p>
<ol>
<li>dialTask</li>
<li>discoverTask</li>
<li>waitExpireTask</li>
</ol>
<p>最关键的就是<code>dialTask</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> Do(srv *Server) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.dest.Incomplete() &#123;</span><br><span class="line">		<span class="keyword">if</span> !t.resolve(srv) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err := t.dial(srv, t.dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		srv.log.Trace(<span class="string">&quot;Dial error&quot;</span>, <span class="string">&quot;task&quot;</span>, t, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="comment">// Try resolving the ID of static nodes if dialing failed.</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(*dialError); ok &amp;&amp; t.flags&amp;staticDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> t.resolve(srv) &#123;</span><br><span class="line">				t.dial(srv, t.dest)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的连接是在<code>t.dail</code>中做的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际的网络连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> dial(srv *Server, dest *enode.Node) <span class="type">error</span> &#123;</span><br><span class="line">	fd, err := srv.Dialer.Dial(dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;dialError&#123;err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mfd := newMeteredConn(fd, <span class="literal">false</span>, &amp;net.TCPAddr&#123;IP: dest.IP(), Port: dest.TCP()&#125;)</span><br><span class="line">	<span class="keyword">return</span> srv.SetupConn(mfd, t.flags, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下面就没必要深究了，实际的网络连接操作到此为止了。</p>
<hr>
<h4 id="管理TCP连接任务"><a href="#管理TCP连接任务" class="headerlink" title="管理TCP连接任务"></a>管理TCP连接任务</h4><p>在TCP连接任务完成后，会对连接有各种处理，如下：</p>
<p>①：停止p2p服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-srv.quit:</span><br><span class="line"><span class="keyword">break</span> running</span><br></pre></td></tr></table></figure>

<p>②：添加静态节点到peer列表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addstatic:</span><br><span class="line">srv.log.Trace(<span class="string">&quot;Adding static node&quot;</span>, <span class="string">&quot;node&quot;</span>, n)</span><br><span class="line">dialstate.addStatic(n)</span><br></pre></td></tr></table></figure>

<p>③：发送断开连接请求，并断开连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removestatic:</span><br><span class="line">dialstate.removeStatic(n)</span><br><span class="line">			<span class="keyword">if</span> p, ok := peers[n.ID()]; ok &#123;</span><br><span class="line">				p.Disconnect(DiscRequested)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>断开连接会立即返回，并且不会等连接关闭。</p>
<p>④：标记可信节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addtrusted:</span><br><span class="line">trusted[n.ID()] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>⑤：从信任节点中删除一个节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removetrusted:</span><br><span class="line"><span class="built_in">delete</span>(trusted, n.ID())</span><br></pre></td></tr></table></figure>

<p>⑥：拨号任务完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-taskdone:newTasks</span><br><span class="line">dialstate.taskDone(t, time.Now())</span><br><span class="line">delTask(t)</span><br></pre></td></tr></table></figure>

<p>⑦：连接已通过加密握手,远程身份是已知的（但尚未经过验证）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> c := &lt;-srv.checkpointPostHandshake:</span><br><span class="line">c.cont &lt;- srv.postHandshakeChecks(peers, inboundCount, c)</span><br></pre></td></tr></table></figure>

<p>⑧：连接已通过协议握手，已知其功能并验证了远程身份</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := srv.addPeerChecks(peers, inboundCount, c)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 握手完成，所有检查完毕</span></span><br><span class="line">				p := newPeer(srv.log, c, srv.Protocols)</span><br><span class="line">			<span class="comment">//启用了消息事件就把peerfeed传给peer</span></span><br><span class="line">				<span class="keyword">if</span> srv.EnableMsgEvents &#123;</span><br><span class="line">					p.events = &amp;srv.peerFeed</span><br><span class="line">				&#125;</span><br><span class="line">				name := truncateName(c.name)</span><br><span class="line">	p.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)+<span class="number">1</span>, <span class="string">&quot;name&quot;</span>, name)</span><br><span class="line">				<span class="keyword">go</span> srv.runPeer(p) <span class="comment">// 重点</span></span><br><span class="line">				peers[c.node.ID()] = p</span><br><span class="line">				<span class="keyword">if</span> p.Inbound() &#123;</span><br><span class="line">					inboundCount++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> conn, ok := c.fd.(*meteredConn); ok &#123;</span><br><span class="line">					conn.handshakeDone(p)<span class="comment">// </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p><code>addPeerChecks</code>会删除没有匹配协议的连接，并且会重复握手后检查，因为自执行这些检查后可能已更改。连接通过握手后，将调用<code>handshakeDone</code></p>
<p>⑨：Peer断开连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> pd := &lt;-srv.delpeer:</span><br><span class="line">d := common.PrettyDuration(mclock.Now() - pd.created)</span><br><span class="line">			pd.log.Debug(<span class="string">&quot;Removing p2p peer&quot;</span>, <span class="string">&quot;addr&quot;</span>, pd.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)<span class="number">-1</span>, <span class="string">&quot;duration&quot;</span>, d, <span class="string">&quot;req&quot;</span>, pd.requested, <span class="string">&quot;err&quot;</span>, pd.err)</span><br><span class="line">			<span class="built_in">delete</span>(peers, pd.ID())</span><br><span class="line">			<span class="keyword">if</span> pd.Inbound() &#123;</span><br><span class="line">				inboundCount--</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个主要的处理TCP连接的循环讲解结束。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><ol>
<li>开启p2p网络主要包括：设置本地节点，监听TCP连接以及设置节点发现</li>
<li>运行P2P网络之后主要包括：发起TCP连接并执行连接，以及相关的连接处理。</li>
</ol>
<blockquote>
<p>公众号：区块链技术栈     </p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之p2p节点发现</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之p2p节点发现</p>
</blockquote>
<p>在阅读节点发现源码之前必须要理解kadmilia算法，<a href="https://github.com/blockchainGuide/">可以参考：KAD算法详解</a>。</p>
<h2 id="节点发现概述"><a href="#节点发现概述" class="headerlink" title="节点发现概述"></a>节点发现概述</h2><p>节点发现，使本地节点得知其他节点的信息，进而加入到p2p网络中。</p>
<p>以太坊的节点发现基于类似的kademlia算法，源码中有两个版本，v4和v5。v4适用于全节点，通过<code>discover.ListenUDP</code>使用，v5适用于轻节点通过<code>discv5.ListenUDP</code>使用，本文介绍的是v4版本。</p>
<p>节点发现功能主要涉及 <strong>Server</strong> <strong>Table</strong> <strong>udp</strong> 这几个数据结构，它们有独自的事件响应循环，节点发现功能便是它们互相协作完成的。其中，每个以太坊客户端启动后都会在本地运行一个<strong>Server</strong>，并将网络拓扑中相邻的节点视为<strong>Node</strong>，而<strong>Table</strong>是<strong>Node</strong>的容器，<strong>udp</strong>则是负责维持底层的连接。这些结构的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzetbpzowj30z00egtbh.jpg" alt="image-20201123210628944"></p>
<h2 id="p2p服务开启节点发现"><a href="#p2p服务开启节点发现" class="headerlink" title="p2p服务开启节点发现"></a>p2p服务开启节点发现</h2><p>在P2p的server.go 的start方法中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := srv.setupDiscovery(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>setupDiscovery</code>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovery V4</span></span><br><span class="line">	<span class="keyword">var</span> unhandled <span class="keyword">chan</span> discover.ReadPacket</span><br><span class="line">	<span class="keyword">var</span> sconn *sharedUDPConn</span><br><span class="line">	<span class="keyword">if</span> !srv.NoDiscovery &#123;</span><br><span class="line">		...</span><br><span class="line">		ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover.ListenUDP</code>方法即开启了节点发现的功能.</p>
<p>首先解析出监听地址的UDP端口，根据端口返回与之相连的UDP连接，之后返回连接的本地网络地址，接着设置最后一个UDP-on-IPv4端口。到此为止节点发现的一些准备工作做好，接下下来开始UDP的监听：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<p>然后进行UDP 的监听，下面是监听的过程：</p>
<h3 id="监听UDP"><a href="#监听UDP" class="headerlink" title="监听UDP"></a>监听UDP</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听给定的socket 上的发现的包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenUDP</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> ListenV4(c, ln, cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenV4</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	closeCtx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	t := &amp;UDPv4&#123;</span><br><span class="line">		conn:            c,</span><br><span class="line">		priv:            cfg.PrivateKey,</span><br><span class="line">		netrestrict:     cfg.NetRestrict,</span><br><span class="line">		localNode:       ln,</span><br><span class="line">		db:              ln.Database(),</span><br><span class="line">		gotreply:        <span class="built_in">make</span>(<span class="keyword">chan</span> reply),</span><br><span class="line">		addReplyMatcher: <span class="built_in">make</span>(<span class="keyword">chan</span> *replyMatcher),</span><br><span class="line">		closeCtx:        closeCtx,</span><br><span class="line">		cancelCloseCtx:  cancel,</span><br><span class="line">		log:             cfg.Log,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.log == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.log = log.Root()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.tab = tab</span><br><span class="line">	<span class="keyword">go</span> tab.loop() <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	t.wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> t.loop() <span class="comment">//</span></span><br><span class="line">	<span class="keyword">go</span> t.readLoop(cfg.Unhandled) <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<h4 id="1-新建路由表"><a href="#1-新建路由表" class="headerlink" title="1.新建路由表"></a>1.新建路由表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) </span><br></pre></td></tr></table></figure>

<p>新建路由表做了以下几件事：</p>
<ul>
<li>初始化table对象</li>
<li>设置bootnode（setFallbackNodes）<ul>
<li>节点第一次启动的时候，节点会与硬编码在以太坊源码中的<code>bootnode</code>进行连接，所有的节点加入几乎都先连接了它。连接上<code>bootnode</code>后，获取<code>bootnode</code>部分的邻居节点，然后进行节点发现，获取更多的活跃的邻居节点</li>
<li>nursery 是在 Table 为空并且数据库中没有存储节点时的初始连接节点（上文中的 6 个节点），通过 bootnode 可以发现新的邻居</li>
</ul>
</li>
<li>tab.seedRand：使用提供的种子值将生成器初始化为确定性状态</li>
<li>loadSeedNodes：加载种子节点；从保留已知节点的数据库中随机的抽取30个节点，再加上引导节点列表中的节点，放置入k桶中，如果K桶没有空间，则假如到替换列表中。</li>
</ul>
<h4 id="2-测试邻居节点连通性"><a href="#2-测试邻居节点连通性" class="headerlink" title="2.测试邻居节点连通性"></a>2.测试邻居节点连通性</h4><p>首先知道UDP协议是没有连接的概念的，所以需要不断的ping 来测试对端节点是否正常，在新建路由表之后，就来到下面的循环，不断的去做上面的事。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tab.loop()</span><br></pre></td></tr></table></figure>

<p>定时运行<code>doRefresh</code>、<code>doRevalidate</code>、<code>copyLiveNodes</code>进行刷新K桶。</p>
<p>以太坊的k桶设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	alpha           = <span class="number">3</span>  <span class="comment">// Kademlia并发参数, 是系统内一个优化参数,控制每次从K桶最多取出节点个数,ethereum取值3</span></span><br><span class="line">  </span><br><span class="line">	bucketSize      = <span class="number">16</span> <span class="comment">// K桶大小(可容纳节点数)</span></span><br><span class="line">  </span><br><span class="line">	maxReplacements = <span class="number">10</span> <span class="comment">// 每桶更换列表的大小</span></span><br><span class="line">	hashBits          = <span class="built_in">len</span>(common.Hash&#123;&#125;) * <span class="number">8</span> <span class="comment">//每个节点ID长度,32*8=256, 32位16进制</span></span><br><span class="line">	nBuckets          = hashBits / <span class="number">15</span>       <span class="comment">//  K桶个数</span></span><br><span class="line">  ）</span><br></pre></td></tr></table></figure>

<p>首先搞清楚这三个定时器运行的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">refreshInterval    = <span class="number">30</span> * time.Minute</span><br><span class="line">revalidateInterval = <span class="number">10</span> * time.Second</span><br><span class="line">copyNodesInterval  = <span class="number">30</span> * time.Second</span><br></pre></td></tr></table></figure>

<h5 id="doRefresh"><a href="#doRefresh" class="headerlink" title="doRefresh"></a><code>doRefresh</code></h5><p>doRefresh对随机目标执行查找以保持K桶已满。如果表为空（初始引导程序或丢弃的有故障），则插入种子节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>从数据库加载随机节点和引导节点。这应该会产生一些以前见过的节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.loadSeedNodes()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地节点ID作为目标节点进行查找最近的邻居节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.net.lookupSelf()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> lookupSelf() []*enode.Node &#123;</span><br><span class="line">	<span class="keyword">return</span> t.newLookup(t.closeCtx, encodePubkey(&amp;t.priv.PublicKey)).run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> newLookup(ctx context.Context, targetKey encPubkey) *lookup &#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">return</span> t.findnode(n.ID(), n.addr(), targetKey)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向这些节点发起<code>findnode</code>操作查询离target节点最近的节点列表,将查询得到的节点进行<code>ping-pong</code>测试,将测试通过的节点落库保存</p>
<p>经过这个流程后,节点的K桶就能够比较均匀地将不同网络节点更新到本地K桶中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc (t *UDPv4) findnode(toid enode.ID, toaddr *net.UDPAddr, target encPubkey) ([]*node, <span class="type">error</span>) &#123;</span><br><span class="line">	t.ensureBond(toid, toaddr)</span><br><span class="line">	nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>, bucketSize)</span><br><span class="line">	nreceived := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 设置回应回调函数，等待类型为neighborsPacket的邻近节点包，如果类型对，就执行回调请求</span></span><br><span class="line">	rm := t.pending(toid, toaddr.IP, p_neighborsV4, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> (matched <span class="type">bool</span>, requestDone <span class="type">bool</span>) &#123;</span><br><span class="line">		reply := r.(*neighborsV4)</span><br><span class="line">		<span class="keyword">for</span> _, rn := <span class="keyword">range</span> reply.Nodes &#123;</span><br><span class="line">			nreceived++</span><br><span class="line">      <span class="comment">// 得到一个简单的node结构</span></span><br><span class="line">			n, err := t.nodeFromRPC(toaddr, rn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				t.log.Trace(<span class="string">&quot;Invalid neighbor node received&quot;</span>, <span class="string">&quot;ip&quot;</span>, rn.IP, <span class="string">&quot;addr&quot;</span>, toaddr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nreceived &gt;= bucketSize</span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="comment">//上面了一个管道事件，下面开始发送真正的findnode报文，然后进行等待了</span></span><br><span class="line">	t.send(toaddr, toid, &amp;findnodeV4&#123;</span><br><span class="line">		Target:     target,</span><br><span class="line">		Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix()),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> nodes, &lt;-rm.errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>查找3个随机的目标节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		tab.net.lookupRandom()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="doRevalidate"><a href="#doRevalidate" class="headerlink" title="doRevalidate"></a><code>doRevalidate</code></h5><p>doRevalidate检查随机存储桶中的最后一个节点是否仍然存在，如果不是，则替换或删除该节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>返回随机的非空K桶中的最后一个节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">last, bi := tab.nodeToRevalidate()</span><br></pre></td></tr></table></figure>
</li>
<li><p>对最后的节点执行Ping操作，然后等待Pong</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remoteSeq, err := tab.net.ping(unwrapNode(last))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果节点ping通了的话，将节点移动到最前面</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.bumpInBucket(b, last)</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有收到回复，选择一个替换节点，或者如果没有任何替换节点，则删除该节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.replace(b, last)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="copyLiveNodes"><a href="#copyLiveNodes" class="headerlink" title="copyLiveNodes"></a><code>copyLiveNodes</code></h5><p>copyLiveNodes将表中的节点添加到数据库,如果节点在表中的时间超过了5分钟。</p>
<p>这部分代码比较简单，就伸展阐述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n.livenessChecks &gt; <span class="number">0</span> &amp;&amp; now.Sub(n.addedAt) &gt;= seedMinTableTime &#123;</span><br><span class="line">				tab.db.UpdateNode(unwrapNode(n))</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-检测各类信息"><a href="#3-检测各类信息" class="headerlink" title="3.检测各类信息"></a>3.检测各类信息</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> t.loop()</span><br></pre></td></tr></table></figure>

<p>loop循环主要监听以下几类消息：</p>
<ul>
<li>case &lt;-t.closeCtx.Done()：检测是否停止</li>
<li>p :&#x3D; &lt;-t.addReplyMatcher：检测是否有添加新的待处理消息</li>
<li>r :&#x3D; &lt;-t.gotreply：检测是否接收到其他节点的回复消息</li>
</ul>
<h4 id="4-处理UDP数据包"><a href="#4-处理UDP数据包" class="headerlink" title="4. 处理UDP数据包"></a>4. 处理UDP数据包</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> t.readLoop(cfg.Unhandled)</span><br></pre></td></tr></table></figure>

<p>主要有以下两件事：</p>
<ol>
<li><p>循环接收其他节点发来的udp消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nbytes, from, err := t.conn.ReadFromUDP(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理接收到的UDP消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.handlePacket(from, buf[:nbytes])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来对这两个函数进行进一步的解析。</p>
<h5 id="接收UDP消息"><a href="#接收UDP消息" class="headerlink" title="接收UDP消息"></a>接收UDP消息</h5><p>接收UDP消息比较的简单，就是不断的从连接中读取Packet数据，它有以下几种消息：</p>
<ul>
<li><p><code>ping</code>：用于判断远程节点是否在线。</p>
</li>
<li><p><code>pong</code>：用于回复<code>ping</code>消息的响应。</p>
</li>
<li><p><code>findnode</code>：查找与给定的目标节点相近的节点。</p>
</li>
<li><p><code>neighbors</code>：用于回复<code>findnode</code>的响应，与给定的目标节点相近的节点列表</p>
</li>
</ul>
<hr>
<h5 id="处理UDP消息"><a href="#处理UDP消息" class="headerlink" title="处理UDP消息"></a>处理UDP消息</h5><p>主要做了以下几件事：</p>
<ol>
<li><p>数据包解码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet, fromKey, hash, err := decodeV4(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查数据包是否有效，是否可以处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet.preverify(t, from, fromID, fromKey)</span><br></pre></td></tr></table></figure>

<p>在校验这一块，涉及不同的消息类型不同的校验，我们来分别对各种消息进行分析。</p>
<p>①：<code>ping</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验公钥是否有效</li>
</ul>
<p>②：<code>pong</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验回复是否正确</li>
</ul>
<p>③：<code>findNodes</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验节点是否是最近的节点</li>
</ul>
<p>④：<code>neighbors</code></p>
<ul>
<li>校验消息是否过期</li>
<li>用于回复<code>findnode</code>的响应，校验回复是否正确</li>
</ul>
</li>
<li><p>处理packet数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet.handle(t, from, fromID, hash)</span><br></pre></td></tr></table></figure>

<p>相同的，也会有4种消息，但是我们这边重点讲处理findNodes的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里就稍微介绍下如何处理<code>findnode</code>的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// 确定最近的节点</span></span><br><span class="line">	target := enode.ID(crypto.Keccak256Hash(req.Target[:]))</span><br><span class="line">	t.tab.mutex.Lock()</span><br><span class="line">	<span class="comment">//最接近的返回表中最接近给定id的n个节点</span></span><br><span class="line">	closest := t.tab.closest(target, bucketSize, <span class="literal">true</span>).entries</span><br><span class="line">	t.tab.mutex.Unlock()</span><br><span class="line">	<span class="comment">// 以每个数据包最多maxNeighbors的块的形式发送邻居，以保持在数据包大小限制以下。</span></span><br><span class="line">	p := neighborsV4&#123;Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix())&#125;</span><br><span class="line">	<span class="keyword">var</span> sent <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> closest &#123; <span class="comment">//扫描这些最近的节点列表，然后一个包一个包的发送给对方</span></span><br><span class="line">		<span class="keyword">if</span> netutil.CheckRelayIP(from.IP, n.IP()) == <span class="literal">nil</span> &#123;</span><br><span class="line">			p.Nodes = <span class="built_in">append</span>(p.Nodes, nodeToRPC(n))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) == maxNeighbors &#123;</span><br><span class="line">			t.send(from, fromID, &amp;p)<span class="comment">//给对方发送 neighborsPacket 包，里面包含节点列表</span></span><br><span class="line">			p.Nodes = p.Nodes[:<span class="number">0</span>]</span><br><span class="line">			sent = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) &gt; <span class="number">0</span> || !sent &#123;</span><br><span class="line">		t.send(from, fromID, &amp;p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先先确定最近的节点，再一个包一个包的发给对方，并校验节点的IP，最后把有效的节点发送给请求方。</p>
</li>
</ol>
<hr>
<h2 id="涉及的结构体："><a href="#涉及的结构体：" class="headerlink" title="涉及的结构体："></a>涉及的结构体：</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>conn ：接口，包括了从UDP中读取和写入，关闭UDP连接以及获取本地地址。</li>
<li>netrestrict：IP网络列表</li>
<li>localNode：本地节点</li>
<li>tab：路由表</li>
</ul>
<hr>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul>
<li><p>buckets：所有节点都加到这个里面，按照距离</p>
</li>
<li><p>nursery：启动节点</p>
</li>
<li><p>rand：随机来源</p>
</li>
<li><p>ips：跟踪IP，确保IP中最多N个属于同一网络范围</p>
</li>
<li><p>net: UDP 传输的接口</p>
<ul>
<li>返回本地节点</li>
<li>将enrRequest发送到给定的节点并等待响应</li>
<li>findnode向给定节点发送一个findnode请求，并等待该节点最多发送了k个邻居</li>
<li>返回查找最近的节点</li>
<li>将ping消息发送到给定的节点，然后等待答复</li>
</ul>
</li>
</ul>
<p>以下是table的结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkm6yzncc3j30t00ggdim.jpg" alt="image-20201112104254003"></p>
<hr>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/blockchainguide/tree/main/%E4%B8%BB%E6%B5%81%E5%8C%BA%E5%9D%97%E9%93%BE/ethereum/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/p2p">思维导图获取地址</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzexhy1kqj31d80mqafh.jpg" alt="image-20201123211034861"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="http://mindcarver.cn/">http://mindcarver.cn/</a>     ⭐️⭐️⭐️⭐️</p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> ⭐️⭐️⭐️⭐️</p>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">https://www.cnblogs.com/xiaolincoding/p/12571184.html</a> </p>
<p><a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/</a></p>
<p><a href="https://www.jianshu.com/p/b232c870dcd2">https://www.jianshu.com/p/b232c870dcd2</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/113684">https://bbs.huaweicloud.com/blogs/113684</a></p>
<p><a href="https://www.jianshu.com/p/94d02a41a146">https://www.jianshu.com/p/94d02a41a146</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之state</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之state</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">｜-database.go 底层的存储设计</span><br><span class="line">｜-dump.go  用来dumpstateDB数据</span><br><span class="line">｜-iterator.go，用来遍历Trie</span><br><span class="line">｜-journal.go，用来记录状态的改变</span><br><span class="line">｜-state_object.go 通过state object操作账户值，并将修改后的storage trie写入数据库</span><br><span class="line">｜-statedb.go，以太坊整个的状态</span><br><span class="line">｜-sync.go，用来和downloader结合起来同步state</span><br></pre></td></tr></table></figure>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>以太坊的本质就是一个**基于交易的状态机(transaction-based state machine)**。在计算机科学中，一个 <em>状态机</em> 是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。</p>
<p>我们从**创世纪状态(genesis state)**开始，在网络中还没有任何交易的时候产生状态。当第一个区块执行第一个交易时候开始产生状态，直到执行完N个交易，第一个区块的最终状态产生，第二个区块的第一笔交易执行后将会改变第一个区块链的最终状态，以此类推，从而产生最终的区块状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkmt3uuo1j31g20hatb4.jpg" alt="image-20210112090020770"></p>
<h3 id="以太坊状态数据库"><a href="#以太坊状态数据库" class="headerlink" title="以太坊状态数据库"></a>以太坊状态数据库</h3><p>区块的状态数据并非保存在链上，而是将这些状态维护在默克尔压缩前缀树中，在区块链上仅记录对应的<code>Trie Root</code> 值。使用<code>LevelDB</code>维护树的持久化内容，而这个用来维护映射的数据库叫做 <code>StateDB</code>。</p>
<p>首先我们用一张图来大致了解一下<code>StateDB</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml0k9uv54j31c60g840z.jpg" alt="image-20210112165612767"></p>
<p>可以看到图中一共有两种状态，一个是世界状态<code>Trie</code>,一个是<code>storage Trie</code>,两者都是MPT树，世界状态包含了一个个的账户状态，账户状态通过以账户地址为键，维护在表示世界状态的树中，而每个账户状态中存储这账户存储树的<code>Root</code>。账户状态存储一下信息：</p>
<ol>
<li><strong>nonce</strong>: 表示此账户发出的交易数量</li>
<li><strong>balance</strong>: 账户余额 </li>
<li><strong>storageRoot</strong>:  账户存储树的Root根，用来存储合约信息</li>
<li><strong>codeHash</strong>: 账户的 EVM 代码哈希值，当这个地址接收到一个消息调用时，这些代码会被执行; 它和其它字段不同，创建后不可更改。如果 codeHash 为空，则说明该账户是一个简单的外部账户，只存在 <code>nonce</code> 和 <code>balance</code>。</li>
</ol>
<p>接下来将会分析State相关的一些类，着重关注<code>statedb.go、state_object.go、database.go</code>,其中涉及的Trie相关的代码可以参照：<a href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a></p>
<h3 id="关键的数据结构"><a href="#关键的数据结构" class="headerlink" title="关键的数据结构"></a>关键的数据结构</h3><p><strong>Account</strong></p>
<p>Account存储的是账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span>      <span class="comment">//账户发出的交易数量</span></span><br><span class="line">	Balance  *big.Int    <span class="comment">// 账户的余额</span></span><br><span class="line">	Root     common.Hash <span class="comment">//账户存储树的Root根，用来存储合约信息</span></span><br><span class="line">	CodeHash []<span class="type">byte</span>      <span class="comment">// 账户的 EVM 代码哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StateObject</strong></p>
<p>表示一个状态对象，可以从中获取到账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	address  common.Address</span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">	dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存的第一个错误</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Write caches.</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	originStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	pendingStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">	dirtyStorage Storage </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StateDB</strong></p>
<p>用来存储状态对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">  db   Database</span><br><span class="line">	trie Trie <span class="comment">// 当前所有账户组成的MPT树</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这几个相关账户状态修改</span></span><br><span class="line">	stateObjects        <span class="keyword">map</span>[common.Address]*stateObject <span class="comment">// 存储缓存的账户状态信息</span></span><br><span class="line">	stateObjectsPending <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 状态对象已经完成但是还没有写入到Trie中</span></span><br><span class="line">	stateObjectsDirty   <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 在当前执行中修改的状态对象 ，用于后续commit </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三者之间的关系：</p>
<p>StateDB-&gt;Trie-&gt;Account-&gt;stateObject</p>
<p><strong>从StateDB中取出Trie根，根据地址从Trie树中获取账户的rlp编码数据，再进行解码成Account，然后根据Account生成stateObject</strong></p>
</blockquote>
<h2 id="StateDB存储状态"><a href="#StateDB存储状态" class="headerlink" title="StateDB存储状态"></a>StateDB存储状态</h2><p>StateDB读写状态主要关心以下几个文件：</p>
<ul>
<li>database.go</li>
<li>state_object.go</li>
<li>statedb.go</li>
</ul>
<p>接下来分别介绍这么几个文件，相当关键。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><h4 id="根据世界状态root打开世界状态树"><a href="#根据世界状态root打开世界状态树" class="headerlink" title="根据世界状态root打开世界状态树"></a>根据世界状态root打开世界状态树</h4><p>从<code>StateDB</code>中打开一个<code>Trie</code>大致经历以下过程：</p>
<blockquote>
<p>OpenTrie(root common.Hash)-&gt;NewSecure-&gt;New</p>
</blockquote>
<h4 id="根据账户地址和-stoage-root打开状态存储树"><a href="#根据账户地址和-stoage-root打开状态存储树" class="headerlink" title="根据账户地址和 stoage root打开状态存储树"></a>根据账户地址和 stoage root打开状态存储树</h4><p>创建一个账户的存储Trie过程如下：</p>
<blockquote>
<p>OpenStorageTrie(addrHash, root common.Hash)-&gt;NewSecure-New</p>
</blockquote>
<h4 id="Account和StateObject"><a href="#Account和StateObject" class="headerlink" title="Account和StateObject"></a>Account和StateObject</h4><p>以太坊的账户分为普通账户和合约账户,以<code>Account</code>表示，<code>Account</code>是账户的数据，不包含账户地址，账户需要使用地址来表示，地址在<code>stateObject</code>中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span></span><br><span class="line">	Balance  *big.Int</span><br><span class="line">	Root     common.Hash <span class="comment">// 存储树的merkle树根 账户状态</span></span><br><span class="line">	CodeHash []<span class="type">byte</span> <span class="comment">//合约账户专属，合约代码编译后的Hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">  address  common.Address <span class="comment">// 账户地址</span></span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">  dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存存的第一个错误</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line">	originStorage Storage <span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	pendingStorage Storage <span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	dirtyStorage Storage <span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建StateObject"><a href="#创建StateObject" class="headerlink" title="创建StateObject"></a>创建StateObject</h4><p>创建状态对象会在两个地方进行调用：</p>
<ol>
<li>检索或者创建状态对象</li>
<li>创建账户</li>
</ol>
<p>最终都会去调用<code>createObject</code>创建一个新的状态对象。如果有一个现有的帐户给定的地址，老的将被覆盖并作为第二个返回值返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr)<span class="comment">// 如果存在老的，获取用来以后删除掉</span></span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="state-object-go"><a href="#state-object-go" class="headerlink" title="state_object.go"></a>state_object.go</h3><p><code>state_object.go</code>是很重要的文件，我们直接通过比较重要的函数来了解它。</p>
<h4 id="增加账户余额"><a href="#增加账户余额" class="headerlink" title="增加账户余额"></a>增加账户余额</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AddBalance-&gt;SetBalance</span><br></pre></td></tr></table></figure>

<h4 id="将对象的存储树保存到db"><a href="#将对象的存储树保存到db" class="headerlink" title="将对象的存储树保存到db"></a>将对象的存储树保存到db</h4><p>主要就做了两件事：</p>
<ol>
<li><em>updateTrie将缓存的存储修改写入对象的存储Trie。</em> </li>
<li><em>将所有节点写入到trie的内存数据库中</em></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> CommitTrie(db Database) <span class="type">error</span> &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	...</span><br><span class="line">	root, err := s.trie.Commit(<span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一件事会在下面继续讲，第二件事可以参照我之前关于 <a href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a>的讲解。</p>
<p>①：<strong>将缓存的存储修改写入对象的存储Trie</strong></p>
<blockquote>
<p>主要流程： 最终还是调用了trie.go的insert方法</p>
<p>updateTrie-&gt;TryUpdate-&gt;insert</p>
</blockquote>
<ol>
<li><code>s.finalise()</code> 将<code>dirtyStorage</code>中的所有数据移动到<code>pendingStorage</code>中</li>
<li>根据账户哈希和账户<code>root</code>打开账户存储树</li>
<li>将<code>key</code>与<code>trie</code>中的<code>value</code>关联，更新数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateTrie(db Database) Trie &#123;</span><br><span class="line">	s.finalise() ①</span><br><span class="line">...</span><br><span class="line">	</span><br><span class="line">	tr := s.getTrie(db) ②</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> s.pendingStorage &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (value == common.Hash&#123;&#125;) &#123;</span><br><span class="line">			s.setError(tr.TryDelete(key[:]))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		s.setError(tr.TryUpdate(key[:], v)) ③</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个核心也就是<code>updateTrie</code>，调用了<code>trie</code>的<code>insert</code>方法进行处理。</p>
<p>②：<strong>将所有节点写入到trie的内存数据库，其key以sha3哈希形式存储</strong></p>
<blockquote>
<p>流程：</p>
<p>trie.Commit-&gt;t.trie.Commit-&gt;t.hashRoot</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SecureTrie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.getSecKeyCache()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t.trie.db.lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> hk, key := <span class="keyword">range</span> t.secKeyCache &#123;</span><br><span class="line">			t.trie.db.insertPreimage(common.BytesToHash([]<span class="type">byte</span>(hk)), key)</span><br><span class="line">		&#125;</span><br><span class="line">		t.trie.db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		t.secKeyCache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.trie.Commit(onleaf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>KeyCache</code>中已经有了，直接插入到磁盘数据库，否则的话插入到<code>Trie</code>的内存数据库。</p>
<h4 id="将trie根设置为的当前根哈希"><a href="#将trie根设置为的当前根哈希" class="headerlink" title="将trie根设置为的当前根哈希"></a>将trie根设置为的当前根哈希</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateRoot(db Database) &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.db.StorageHashes += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	s.data.Root = s.trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法也比较简单，底层调用<code>UpdateTrie</code>然后再更新<code>root</code>.</p>
<p><code>State_object.go</code>的核心方法也就这么些内容。</p>
<h3 id="statedb-go"><a href="#statedb-go" class="headerlink" title="statedb.go"></a>statedb.go</h3><h4 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h4><p>创建账户的核心就是创建状态对象，然后再初始化值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> CreateAccount(addr common.Address) &#123;</span><br><span class="line">	newObj, prev := s.createObject(addr)</span><br><span class="line">	<span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		newObj.setBalance(prev.data.Balance)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr) </span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除、更新、获取状态对象"><a href="#删除、更新、获取状态对象" class="headerlink" title="删除、更新、获取状态对象"></a>删除、更新、获取状态对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> deleteStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> updateStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getStateObject(obj *stateObject) &#123;</span><br></pre></td></tr></table></figure>

<p>这三个方法底层分别都是调用<code>Trie.TryDelete、Trie.TryUpdate、Trie.TryGet</code>方法来分别获取。</p>
<p>这里大致的讲一下<code>getStateObject</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getDeletedStateObject(addr common.Address) *stateObject &#123;</span><br><span class="line">	<span class="comment">// Prefer live objects if any is available</span></span><br><span class="line">	<span class="keyword">if</span> obj := s.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> obj</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on loading the object from the database</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.AccountReads += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Load the object from the database</span></span><br><span class="line">	enc, err := s.trie.TryGet(addr[:])</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">		s.setError(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> data Account</span><br><span class="line">	<span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Insert into the live set</span></span><br><span class="line">	obj := newObject(s, addr, data)</span><br><span class="line">	s.setStateObject(obj)</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致就做了以下几件事：</p>
<ol>
<li>先从<code>StateDB</code>中获取<code>stateObjects</code>,有的话就返回。</li>
<li>如果没有的话就从<code>stateDB</code>的<code>trie</code>中获取账户状态数据，获取到<code>rlp</code>编码的数据之后，将其解码。</li>
<li>根据状态数据<code>Account</code> 构造<code>stateObject</code></li>
</ol>
<h4 id="余额操作"><a href="#余额操作" class="headerlink" title="余额操作"></a>余额操作</h4><p>余额的操作大致有添加、减少、和设定。我们就拿添加来分析：</p>
<p>根据地址获取<code>stateObject</code>，然后<code>addBalance</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> AddBalance(addr common.Address, amount *big.Int) &#123;</span><br><span class="line">	stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.AddBalance(amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="储存快照和回退快照"><a href="#储存快照和回退快照" class="headerlink" title="储存快照和回退快照"></a>储存快照和回退快照</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Snapshot() <span class="type">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> RevertToSnapshot(revid <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>储存快照和回退快照，我们可以在提交交易的流程中找到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">	snap := w.current.state.Snapshot()</span><br><span class="line"></span><br><span class="line">	receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	w.current.txs = <span class="built_in">append</span>(w.current.txs, tx)</span><br><span class="line">	w.current.receipts = <span class="built_in">append</span>(w.current.receipts, receipt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> receipt.Logs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们会对当前状态进行快照，然后执行<code>ApplyTransaction</code>，如果在预执行交易的阶段出错了，那么会回退到备份的快照位置。之前的修改全部会回退。</p>
<h4 id="计算状态Trie的当前根哈希"><a href="#计算状态Trie的当前根哈希" class="headerlink" title="计算状态Trie的当前根哈希"></a>计算状态Trie的当前根哈希</h4><p>计算状态Trie的当前根哈希是由<code>IntermediateRoot</code>来完成的。</p>
<p>①：<strong>确定所有的脏存储状态（简单理解就是当前执行修改的所有对象）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Finalise(deleteEmptyObjects <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;</span><br><span class="line">		obj, exist := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> !exist &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> obj.suicided || (deleteEmptyObjects &amp;&amp; obj.empty()) &#123;</span><br><span class="line">			obj.deleted = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.finalise()</span><br><span class="line">		&#125;</span><br><span class="line">		s.stateObjectsPending[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.clearJournalAndRefund()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个跟<code>state_object</code>的<code>finalise</code>方法是一个方式，底层就是调用了<code>obj.finalise</code>将<code>dirty</code>状态的所有数据全部推入到<code>pending</code>中去，等待处理。</p>
<p>②：<strong>处理stateObjectsPending中的数据</strong></p>
<p>先更新账户的<code>Root</code>根，然后再将将给定的对象写入<code>trie</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsPending &#123;</span><br><span class="line">		obj := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line">			s.deleteStateObject(obj)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.updateRoot(s.db)</span><br><span class="line">			s.updateStateObject(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将状态写入底层内存Trie数据库"><a href="#将状态写入底层内存Trie数据库" class="headerlink" title="将状态写入底层内存Trie数据库"></a>将状态写入底层内存Trie数据库</h4><p>这部分功能由commit方法完成。</p>
<ol>
<li>计算状态Trie的当前根哈希</li>
<li>将状态对象中的所有更改写入到存储树</li>
</ol>
<p>第一步在上面已经讲过了，第二步的内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsDirty &#123;</span><br><span class="line">		<span class="keyword">if</span> obj := s.stateObjects[addr]; !obj.deleted &#123;</span><br><span class="line">			....</span><br><span class="line">			<span class="keyword">if</span> err := obj.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是<code>objectCommitTrie</code>,这也是上面<code>state_object</code>的内容。</p>
<p>总结流程如下：</p>
<blockquote>
<p>1.IntermediateRoot</p>
<p>2.CommitTrie-&gt;updateTrie-&gt;trie.Commit-&gt;trie.db.insertPreimage(已经有了直接持久化到硬盘数据库)</p>
<p>​														  -&gt;t.trie.Commit（没有就提交到存储树中）</p>
</blockquote>
<p>最后看一下以太坊数据库的读写过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmlw6izetsj31ha0oogom.jpg" alt="image-20210113111013494"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://www.jianshu.com/p/20d7f7c37b03">https://www.jianshu.com/p/20d7f7c37b03</a></p>
<p><a href="https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033">https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033</a></p>
<p><a href="https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf">https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf</a></p>
<p><a href="http://www.ltk100.com/article-112-1.html">http://www.ltk100.com/article-112-1.html</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Trie树</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Trie树</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之txpool</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之txpool</p>
<p>请结合以下代码阅读:<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文章不易，也希望大家多多指出问题</p>
</blockquote>
<h2 id="交易池概念原理"><a href="#交易池概念原理" class="headerlink" title="交易池概念原理"></a>交易池概念原理</h2><p>交易池工作概况：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzwre4v4ej31120tcgpa.jpg" alt="image-20201225104748102"></p>
<ol>
<li>交易池的数据来源主要来自：<ul>
<li>本地提交，也就是第三方应用通过调用本地以太坊节点的<code>RPC</code>服务所提交的交易；</li>
<li>远程同步，是指通过广播同步的形式，将其他以太坊节点的交易数据同步至本地节点;</li>
</ul>
</li>
<li>交易池中交易去向：被Miner模块获取并验证，用于挖矿；挖矿成功后写进区块并被广播</li>
<li><code>Miner</code>取走交易是复制，交易池中的交易并不减少。直到交易被写进规范链后才从交易池删除；</li>
<li>交易如果被写进分叉，交易池中的交易也不减少，等待重新打包。</li>
</ol>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><h3 id="TxPoolConfig"><a href="#TxPoolConfig" class="headerlink" title="TxPoolConfig"></a>TxPoolConfig</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Locals    []common.Address <span class="comment">// 本地账户地址存放</span></span><br><span class="line">	NoLocals  <span class="type">bool</span>             <span class="comment">// 是否开启本地交易机制</span></span><br><span class="line">	Journal   <span class="type">string</span>           <span class="comment">// 本地交易存放路径</span></span><br><span class="line">	Rejournal time.Duration    <span class="comment">// 持久化本地交易的间隔</span></span><br><span class="line">	PriceLimit <span class="type">uint64</span>         <span class="comment">// 价格超出比例，若想覆盖一笔交易的时候，若价格上涨比例达不到要求，那么不能覆盖</span></span><br><span class="line">	PriceBump  <span class="type">uint64</span> <span class="comment">// 替换现有交易的最低价格涨幅百分比（一次）</span></span><br><span class="line">	AccountSlots <span class="type">uint64</span> <span class="comment">// 每个账户的可执行交易限制</span></span><br><span class="line">	GlobalSlots  <span class="type">uint64</span> <span class="comment">// 全部账户最大可执行交易</span></span><br><span class="line">	AccountQueue <span class="type">uint64</span> <span class="comment">// 单个账户不可执行的交易限制</span></span><br><span class="line">	GlobalQueue  <span class="type">uint64</span> <span class="comment">// 全部账户最大非执行交易限制</span></span><br><span class="line">	Lifetime time.Duration <span class="comment">// 一个账户在queue中的交易可以存活的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认配置：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="TxPool"><a href="#TxPool" class="headerlink" title="TxPool"></a>TxPool</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      TxPoolConfig <span class="comment">// 交易池配置</span></span><br><span class="line">	chainconfig *params.ChainConfig <span class="comment">// 区块链配置</span></span><br><span class="line">	chain       blockChain <span class="comment">// 定义blockchain接口</span></span><br><span class="line">	gasPrice    *big.Int</span><br><span class="line">	txFeed      event.Feed <span class="comment">//时间流</span></span><br><span class="line">	scope       event.SubscriptionScope <span class="comment">// 订阅范围</span></span><br><span class="line">	signer      types.Signer <span class="comment">//签名</span></span><br><span class="line">	mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">	istanbul <span class="type">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">	currentState  *state.StateDB <span class="comment">// 当前头区块对应的状态</span></span><br><span class="line">	pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">	currentMaxGas <span class="type">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">	locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">	journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">	pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">	queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">	beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">	all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">	priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">	chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">	chainHeadSub    event.Subscription</span><br><span class="line">	reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">	reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">	queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">	reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">	wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="txpool初始化"><a href="#txpool初始化" class="headerlink" title="txpool初始化"></a>txpool初始化</h2><p><code>Txpool</code>初始化主要做了以下几件事：</p>
<p>①：检查配置  配置有问题则用默认值填充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config = (&amp;config).sanitize()</span><br></pre></td></tr></table></figure>

<p>   对于这部分的检查查看<code>TxPoolConfig</code>的字段。</p>
<p>②：初始化本地账户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.locals = newAccountSet(pool.signer)</span><br></pre></td></tr></table></figure>

<p>③：将配置的本地账户地址加到交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.locals.add(addr)</span><br></pre></td></tr></table></figure>

<p>   我们在安装以太坊客户端可以指定一个数据存储目录，此目录便会存储着所有我们导入的或者通过本地客户端创建的帐户<code>keystore</code>文件。而这个加载过程便是从该目录加载帐户数据</p>
<p>④：更新交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.reset(<span class="literal">nil</span>, chain.CurrentBlock().Header())</span><br></pre></td></tr></table></figure>

<p>⑤：创建所有交易存储的列表，所有交易的价格用最小堆存放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.priced = newTxPricedList(pool.all)</span><br></pre></td></tr></table></figure>

<p>   通过排序，优先处理<code>gasprice</code>越高的交易。</p>
<p>⑥：如果本地交易开启 那么从本地磁盘加载本地交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑦：订阅链上事件消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>

<p>⑧：开启主循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> pool.loop()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：local交易比remote交易具有更高的权限，一是不轻易被替换；二是持久化，即通过一个本地的journal文件保存尚未打包的local交易。所以在节点启动的时候，优先从本地加载local交易。</p>
<p>本地地址会被加入白名单，凡由此地址发送的交易均被认为是local交易，不论是从本地递交还是从远端发送来的。</p>
</blockquote>
<p>到此为止交易池加载过程结束。</p>
<h2 id="添加交易到txpool"><a href="#添加交易到txpool" class="headerlink" title="添加交易到txpool"></a>添加交易到txpool</h2><p>之前我们说过交易池中交易的来源一方面是其他节点广播过来的，一方面是本地提交的，追根到源代码一个是<code>AddLocal</code>，一个是<code>AddRemote</code>,不管哪个都会调用<code>addTxs</code>。我们对添加交易的讨论就会从这个函数开始，它主要做了以下几件事,先用一张简图说明一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxhi23euj31ak0u0h34.jpg" alt="image-20201225104721173"></p>
<ol>
<li><p>过滤池中已经存在的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(tx.Hash()) != <span class="literal">nil</span> &#123;</span><br><span class="line">  errs[i] = fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, tx.Hash())</span><br><span class="line">			knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将交易添加到队列中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newErrs, dirtyAddrs := pool.addTxsLocked(news, local)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">进入到addTxsLocked函数中：</span><br><span class="line">replaced, err := pool.add(tx, local)</span><br></pre></td></tr></table></figure>

<p>进入到 <code>pool.add</code>函数中，这个<code>add</code>函数相当重要，它是将交易添加到<code>queue</code>中，等待后面的promote，到<code>pending</code>中去。如果在<code>queue</code>或者<code>pending</code>中已经存在，并且它的gas price更高时，将覆盖之前的交易。下面来拆开的分析一下add 这个函数。</p>
<p>①：看交易是否收到过，如果已经收到过就丢弃</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding already known transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, hash)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果交易没通过验证也要丢弃，这里的重点是验证函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">validateTx: 主要做了以下几件事</span><br><span class="line">- 交易大小不能超过<span class="number">32</span>kb</span><br><span class="line">- 交易金额不能为负</span><br><span class="line">- 交易gas值不能超出当前交易池设定的gaslimit</span><br><span class="line">- 交易签名必须正确</span><br><span class="line">- 如果交易为远程交易，则需验证其gasprice是否小于交易池gasprice最小值，如果是本地，优先打包，不管gasprice</span><br><span class="line">- 判断当前交易nonce值是否过低</span><br><span class="line">- 交易所需花费的转帐手续费是否大于帐户余额  cost == V + GP * GL</span><br><span class="line">- 判断交易花费gas是否小于其预估花费gas</span><br></pre></td></tr></table></figure>

<p>③：如果交易池已满，丢弃价格过低的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</span><br><span class="line">		<span class="keyword">if</span> !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		drop := pool.priced.Discard(pool.all.Count()-<span class="type">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue<span class="number">-1</span>), pool.locals)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</span><br><span class="line">			...</span><br><span class="line">			pool.removeTx(tx.Hash(), <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>注意这边的<code>GlobalSlots</code>和<code>GlobalQueue</code> ，就是我们说的<code>pending</code>和<code>queue</code>的最大容量，如果交易池的交易数超过两者之和，就要丢弃价格过低的交易。</p>
</li>
</ol>
<p>④：判断当前交易在pending队列中是否存在<code>nonce</code>值相同的交易。存在则判断当前交易所设置的<code>gasprice</code>是否超过设置的<code>PriceBump</code>百分比，超过则替换覆盖已存在的交易，否则报错返回<code>替换交易gasprice过低</code>，并且把它扔到<code>queue</code>队列中<code>(enqueueTx)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</span><br><span class="line"><span class="comment">// Nonce already pending, check if required price bump is met</span></span><br><span class="line"> 		inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line"><span class="keyword">if</span> !inserted &#123;</span><br><span class="line"> 			pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">// New transaction is better, replace old one</span></span><br><span class="line"> 		<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line"> 			pool.all.Remove(old.Hash())</span><br><span class="line"> 			pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"> 			pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		pool.all.Add(tx)</span><br><span class="line"> 		pool.priced.Put(tx)</span><br><span class="line"> 		pool.journalTx(from, tx)</span><br><span class="line"> 		pool.queueTxEvent(tx)</span><br><span class="line"> 		log.Trace(<span class="string">&quot;Pooled new executable transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;from&quot;</span>, from, <span class="string">&quot;to&quot;</span>, tx.To())</span><br><span class="line"> 		<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// New transaction isn&#x27;t replacing a pending one, push into queue</span></span><br><span class="line"> 	replaced, err = pool.enqueueTx(hash, tx)</span><br></pre></td></tr></table></figure>

<p>   添加交易的流程就到此为止了。接下来就是如何把<code>queue</code>（暂时不可执行）中添加的交易扔到<code>pending</code>（可执行交易）中，速成<code>promote</code>。</p>
<ol start="3">
<li><p>提升交易</p>
<p>提升交易主要把交易从<code>queue</code>扔到<code>pending</code>中，我们在接下来的里面重点讲</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := pool.requestPromoteExecutables(dirtyAddrs)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="交易升级"><a href="#交易升级" class="headerlink" title="交易升级"></a>交易升级</h2><p><code>promoteExecutables</code>将<code>future queue</code>中的交易移动到<code>pending</code>中，同时也会删除很多无效交易比如<code>nonce</code>低或者余额低等等，主要分以下步骤：先看张图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxix54vaj313m0si4d2.jpg" alt="image-20201225104612253"></p>
<p>①：将所有<code>queue</code>中<code>nonce</code>低于账户当前<code>nonce</code>的交易从<code>all</code>里面删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">forwards := list.Forward(pool.currentState.GetNonce(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> forwards &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>②：将所有<code>queue</code>中花费大于账户余额 或者<code>gas</code>大于限制的交易从all里面删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：将所有可执行的交易从<code>queue</code>里面移到<code>pending</code>里面（<code>proteTx</code>）</p>
<p>注：可执行交易：将<code>pending</code>里面<code>nonce</code>值大于等于账户当前状态<code>nonce</code>的，且<code>nonce</code>连续的几笔交易作为准备好的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">readies := list.Ready(pool.pendingNonces.get(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> readies &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			<span class="keyword">if</span> pool.promoteTx(addr, hash, tx) &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Promoting queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				promoted = <span class="built_in">append</span>(promoted, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是 <strong>promoteTx</strong>的处理，这个方法与add的不同之处在于，<code>addTx</code>是获得到的<strong>新交易插入pending</strong>，而<code>promoteTx</code>是将<strong>queue列表中的Txs放入pending</strong>接下来我们先看看里面是如何来处理的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">	<span class="keyword">if</span> !inserted &#123;</span><br><span class="line">		<span class="comment">// An older transaction was better, discard this</span></span><br><span class="line">		<span class="comment">// 老的交易更好，删除这个交易</span></span><br><span class="line">		pool.all.Remove(hash)</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Otherwise discard any previous transaction and mark this</span></span><br><span class="line">	<span class="comment">// 现在这个交易更好，删除旧的交易</span></span><br><span class="line">	<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要就做了这几件事：</p>
<ol>
<li>将交易插入<code>pending</code>中，如果待插入的交易<code>nonce</code>在<code>pending</code>列表中存在，那么待插入的交易<code>gas price</code>大于或等于原交易价值的<code>110%（</code>跟<code>pricebump</code>设定有关）时，替换原交易</li>
<li>如果新交易替换了某个交易，从<code>all</code>列表中删除老交易</li>
<li>最后更新一下<code>all</code>列表</li>
</ol>
<p>经过<code>proteTx</code>之后，要扔到<code>pending</code>的交易都放在了<code>promoted []*types.Transaction</code>中，再回到<code>promoteExecutables</code>中，继续下面步骤：</p>
<p>④：如果非本地账户<code>queue</code>大于限制（<code>AccountQueue</code>），从最后取出<code>nonce</code>较大的交易进行<code>remove</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !pool.locals.contains(addr) &#123;</span><br><span class="line">			caps = list.Cap(<span class="type">int</span>(pool.config.AccountQueue))</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> caps &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				pool.all.Remove(hash)</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：最后如果队列中此账户的交易为空则删除此账户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.queue, addr)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此我们的升级交易要做的事情就完毕了。</p>
<hr>
<h2 id="交易降级"><a href="#交易降级" class="headerlink" title="交易降级"></a>交易降级</h2><p>交易降级的几个场景：</p>
<ol>
<li>出现了新的区块，将会从<code>pending</code>中移除出现在区块中的交易到<code>queue</code>中</li>
<li>或者是另外一笔交易（<code>gas price</code> 更高）,则会从<code>pending</code>中移除到<code>queue</code>中</li>
</ol>
<p>关键函数：demoteUnexecutables，主要做的事情如下：</p>
<p>①：遍历<code>pending</code>中所有地址对应的交易列表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure>

<p>②：删除所有认为过旧的交易（<code>low nonce</code>）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">olds := list.Forward(nonce)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：删除所有费用过高的交易（余额低或用尽），并将所有无效者送到<code>queue</code>中以备后用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops))</span><br><span class="line">		pendingNofundsMeter.Mark(<span class="type">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Demoting pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.enqueueTx(hash, tx)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果交易前面有间隙，将后面的交易移到<code>queue</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Len() &gt; <span class="number">0</span> &amp;&amp; list.txs.Get(nonce) == <span class="literal">nil</span> &#123;</span><br><span class="line">			gapped := list.Cap(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(<span class="string">&quot;Demoting invalidated transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				pool.enqueueTx(hash, tx)</span><br><span class="line">			&#125;</span><br><span class="line">			pendingGauge.Dec(<span class="type">int64</span>(<span class="built_in">len</span>(gapped)))</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>注：间隙的出现通常是因为交易余额问题导致的。假如原规范链 A 上交易m花费10，分叉后该账户又在分叉链B发出一个交易m花费20，这就导致该账户余额本来可以支付A链上的某笔交易，但在B链上可能就不够了。这个余额不足的交易在B如果是n+3，那么在A链上n+2，n+4号交易之间就出现了空隙，这就导致从n+3开始往后所有的交易都要降级；</p>
<p>到此为止交易降级结束。</p>
<hr>
<h2 id="重置交易池"><a href="#重置交易池" class="headerlink" title="重置交易池"></a>重置交易池</h2><hr>
<p><strong>重置交易池</strong>将检索区块链的当前状态（主要由于更新导致链状态变化），并确保交易池的内容对于链状态而言是有效的。</p>
<p><code>reset</code>的调用时机如下：</p>
<ol>
<li><code>TxPool</code>初始化的过程：<code>NewTxPool</code>；</li>
<li><code>TxPool</code>事件监听<code>go</code>程收到规范链更新事件</li>
</ol>
<p>流程图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjq7vc6bz8j31260sodlq.jpg" alt="image-20201015185551752"></p>
<p>根据上面流程图，主要功能是由于规范链的更新，重新整理交易池：</p>
<p>①：<em>如果老区块头不为空 且老区块头不是新区块的父区块，说明新老区块不在一条链上</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> oldHead != <span class="literal">nil</span> &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>如果新头区块和旧头区块相差大于64，则所有交易不必回退到交易池</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> depth := <span class="type">uint64</span>(math.Abs(<span class="type">float64</span>(oldNum) - <span class="type">float64</span>(newNum))); depth &gt; <span class="number">64</span> &#123;</span><br><span class="line">  log.Debug(<span class="string">&quot;Skipping deep transaction reorg&quot;</span>, <span class="string">&quot;depth&quot;</span>, depth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：<em>如果旧链的头区块大于新链的头区块高度，旧链向后退并回收所有回退的交易</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>④：<em>如果新链的头区块大于旧链的头区块，新链后退并回收交易</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：<em>当新旧链到达同一高度的时候同时回退，知道找到共同的父节点</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.Hash() != add.Hash() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br></pre></td></tr></table></figure>

<p>⑥：<em>给交易池设置最新的世界状态</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to reset txpool state&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pool.currentState = statedb</span><br><span class="line">	pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">	pool.currentMaxGas = newHead.GasLimit</span><br></pre></td></tr></table></figure>

<p>⑦：<em>把旧链回退的交易放入交易池</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">senderCacher.<span class="built_in">recover</span>(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>到此整个<code>reset</code>的流程就结束了。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a href="https://github.com/mindcarver/blockchain_guide">https://github.com/mindcarver/blockchain_guide</a> </p>
<p><a href="https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0">https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0</a></p>
<p><a href="https://blog.csdn.net/lj900911/article/details/84825739">https://blog.csdn.net/lj900911/article/details/84825739</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之区块上链入库</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之区块上链入库</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>不管是矿工挖矿还是<code>Fetcher</code>同步，<code>Downloader</code>同步，或者是导入本地文件等等，最中都是将区块上链入库。接下来我们就详细分析这部分的动作。</p>
<h2 id="几处可能调用的地方"><a href="#几处可能调用的地方" class="headerlink" title="几处可能调用的地方"></a>几处可能调用的地方</h2><p>①：在Downloader同步最后会将区块插入到区块链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：创建一个新的以太坊协议管理器，也会将区块插入到链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProtocolManager</span><span class="params">(...)</span></span> (*ProtocolManager, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  n, err := manager.blockchain.InsertChain(blocks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：插入侧链数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertSideChain(block *types.Block, it *insertIterator) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> _, err := bc.insertChain(blocks, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④：从本地文件导入链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateAdminAPI)</span></span> ImportChain(file <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> _, err := api.eth.BlockChain().InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：fetcher同步导入块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span></span> insert(peer <span class="type">string</span>, block *types.Block) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是比较常见的需要将区块上链的动作。调用的核心方法就是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks, verifySeals <span class="type">bool</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>获取区块链所有相关文章以及资料，请参阅：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<h2 id="插入数据到blockchain中"><a href="#插入数据到blockchain中" class="headerlink" title="插入数据到blockchain中"></a>插入数据到blockchain中</h2><p>①：如果链正在中断，直接返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;bc.procInterrupt) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启并行的签名恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[<span class="number">0</span>].Number()), chain)</span><br></pre></td></tr></table></figure>

<p>③：开启并行校验header</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br></pre></td></tr></table></figure>

<p>校验<code>header</code>是共识引擎所要做的事情，我们这里只分析<code>ethash</code>它的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyHeaders(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">  errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeaderWorker(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>, index <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> parent *types.Header</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">		parent = chain.GetHeader(headers[<span class="number">0</span>].ParentHash, headers[<span class="number">0</span>].Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[index<span class="number">-1</span>].Hash() == headers[index].ParentHash &#123;</span><br><span class="line">		parent = headers[index<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chain.GetHeader(headers[index].Hash(), headers[index].Number.Uint64()) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// known block</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ethash.verifyHeader(chain, headers[index], parent, <span class="literal">false</span>, seals[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用<code>verifyHeaderWorker</code>进行校验，主要检验块的祖先是否已知以及块是否已知，接着会调用<code>verifyHeader</code>进行更深的校验，也是最核心的校验，大概做了以下几件事：</p>
<ol>
<li>header.Extra<em>不可超过32字节</em></li>
<li>header.Time<em>不能超过15秒，15秒以后的就被认定为未来的块</em></li>
<li><em>当前header的时间戳不可以等于父块的时间戳</em></li>
<li><em>根据难度计算算法得出的expected必须和header.Difficulty 一致。</em></li>
<li><em>Gas limit 要 &lt;&#x3D; 2 ^ 63-1</em></li>
<li><em>gasUsed&lt;&#x3D; gasLimit</em></li>
<li><em>Gas limit 要在允许范围内</em></li>
<li><em>块号必须是父块加1</em></li>
<li><em>根据 ethash.VerifySeal去验证块是否满足POW难度要求</em></li>
</ol>
<p>到此验证header的事情就做完了。</p>
<p>④：循环校验body</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block, err := it.next()</span><br><span class="line">	-&gt; ValidateBody</span><br><span class="line">		-&gt; VerifyUncles</span><br></pre></td></tr></table></figure>

<p>包括以下错误：</p>
<ul>
<li><strong>block</strong>已知</li>
<li><strong>uncle</strong>太多</li>
<li>重复的<strong>uncle</strong></li>
<li><strong>uncle</strong>是祖先块</li>
<li><strong>uncle</strong>哈希不匹配</li>
<li>交易哈希不匹配</li>
<li>未知祖先</li>
<li>祖先块的状态无法获取</li>
</ul>
<p>4.1 如果<code>block</code>存在，且是已知块，则写入已知块。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.writeKnownBlock(block)</span><br></pre></td></tr></table></figure>

<p>4.2 如果是祖先块的状态无法获取的错误，则作为侧链插入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.insertSideChain(block, it)</span><br></pre></td></tr></table></figure>

<p>4.3 如果是未来块或者未知祖先，则添加未来块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.addFutureBlock(block);</span><br></pre></td></tr></table></figure>

<p>注意这里的添加 futureBlock，会被扔进futureBlocks里面去，在NewBlockChain的时候会开启新的goroutine:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;</span><br><span class="line">  futureTimer := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-futureTimer.C:</span><br><span class="line">			bc.procFutureBlocks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> procFutureBlocks() &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">for</span> _, hash := <span class="keyword">range</span> bc.futureBlocks.Keys() &#123;</span><br><span class="line">		<span class="keyword">if</span> block, exist := bc.futureBlocks.Peek(hash); exist &#123;</span><br><span class="line">			blocks = <span class="built_in">append</span>(blocks, block.(*types.Block))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">			bc.InsertChain(blocks[i : i+<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会开启一个计时器，每5秒就会去执行插入这些未来的块。</p>
<p>4.4 如果是其他错误，直接中断，并且报告坏块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.futureBlocks.Remove(block.Hash())</span><br><span class="line">...</span><br><span class="line">bc.reportBlock(block, <span class="literal">nil</span>, err)</span><br></pre></td></tr></table></figure>

<p>⑤：没有校验错误</p>
<p>5.1 如果是坏块，则报告；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> BadHashes[block.Hash()] &#123;</span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, ErrBlacklistedHash)</span><br><span class="line">			<span class="keyword">return</span> it.index, ErrBlacklistedHash</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.2 如果是未知块，则写入未知块；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrKnownBlock &#123;</span><br><span class="line">			logger := log.Debug</span><br><span class="line">			<span class="keyword">if</span> bc.chainConfig.Clique == <span class="literal">nil</span> &#123;</span><br><span class="line">				logger = log.Warn</span><br><span class="line">			&#125;</span><br><span class="line">		...</span><br><span class="line">			<span class="keyword">if</span> err := bc.writeKnownBlock(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> it.index, err</span><br><span class="line">			&#125;</span><br><span class="line">			stats.processed++</span><br><span class="line">			lastCanon = block</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.3 根据给定trie，创建状态；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := it.previous()</span><br><span class="line">		<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">			parent = bc.GetHeader(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		statedb, err := state.New(parent.Root, bc.stateCache)</span><br></pre></td></tr></table></figure>

<p>5.4执行块中的交易： (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>5.5 使用默认的validator校验状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.validator.ValidateState(block, statedb, receipts, usedGas);</span><br></pre></td></tr></table></figure>

<p>5.6 将块写入到区块链中并获取状态：  (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">status, err := bc.writeBlockWithState(block, receipts, logs, statedb, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：校验写入区块的状态</p>
<ul>
<li><code>CanonStatTy</code> ： 插入成功新的block</li>
<li><code>SideStatTy</code>：插入成功新的分叉区块</li>
<li><code>Default</code>：插入未知状态的block</li>
</ul>
<p>⑦：如果还有块，并且是未来块的话，那么将块添加到未来块的缓存中去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.addFutureBlock(block)</span><br></pre></td></tr></table></figure>

<p>至此<code>insertChain</code> 大概介绍清楚。</p>
<hr>
<h3 id="执行块中交易"><a href="#执行块中交易" class="headerlink" title="执行块中交易"></a>执行块中交易</h3><p>在我们将区块上链，有一个关键步骤就是执行区块交易：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>进入函数，具体分析：</p>
<p>①：准备要用的字段，循环执行交易</p>
<p>关键函数：<code>ApplyTransaction</code>,根据此函数返回收据。</p>
<p>1.1 将交易结构转成<code>Message</code>结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))</span><br></pre></td></tr></table></figure>

<p>1.2 创建要在EVM环境中使用的新上下文</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">context := NewEVMContext(msg, header, bc, author)</span><br></pre></td></tr></table></figure>

<p>1.3 创建一个新环境，其中包含有关事务和调用机制的所有相关信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">vmenv := vm.NewEVM(context, statedb, config, cfg)</span><br></pre></td></tr></table></figure>

<p>1.4 将交易应用到当前状态(包含在env中)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</span><br></pre></td></tr></table></figure>

<p>这部分代码继续跟进：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyMessage</span><span class="params">(evm *vm.EVM, msg Message, gp *GasPool)</span></span> ([]<span class="type">byte</span>, <span class="type">uint64</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewStateTransition</code> 是一个状态转换对象，<code>TransitionDb()</code> 负责转换交易状态，继续跟进：<br>先进行<code>preCheck</code>，用来校验<code>nonce</code>是否正确</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.preCheck()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> st.msg.CheckNonce() &#123;</span><br><span class="line">		nonce := st.state.GetNonce(st.msg.From())</span><br><span class="line">		<span class="keyword">if</span> nonce &lt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooHigh</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nonce &gt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooLow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>计算所需<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gas, err := IntrinsicGas(st.data, contractCreation, homestead, istanbul)</span><br></pre></td></tr></table></figure>

<p>扣除<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err = st.useGas(gas); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span></span> useGas(amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> st.gas &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> vm.ErrOutOfGas</span><br><span class="line">	&#125;</span><br><span class="line">	st.gas -= amount</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是合约交易,则新建一个合约</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>如果不是合约交易，则增加<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>重点关注<code>evm.call</code>方法：</p>
<p><em>检查账户是否有足够的气体进行转账</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果stateDb不存在此账户，则新建账户</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">  evm.StateDB.CreateAccount(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>执行转账操作</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br></pre></td></tr></table></figure>

<p><em>创建合约</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contract := NewContract(caller, to, value, gas)</span><br></pre></td></tr></table></figure>

<p><em>执行合约</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ret, err = run(evm, contract, input, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>添加余额</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.state.AddBalance(st.evm.Coinbase, <span class="built_in">new</span>(big.Int).Mul(<span class="built_in">new</span>(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</span><br></pre></td></tr></table></figure>

<p>回到<code>ApplyTransaction</code></p>
<p>1.5 调用<code>IntermediateRoot</code>计算状态<code>trie</code>的当前根哈希值。</p>
<p>最终确定所有肮脏的存储状态，并把它们写进<code>trie</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.Finalise(deleteEmptyObjects)</span><br></pre></td></tr></table></figure>

<p>将trie根设置为当前的根哈希并将给定的<code>object</code>写入到<code>trie</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj.updateRoot(s.db)</span><br><span class="line">s.updateStateObject(obj)</span><br></pre></td></tr></table></figure>

<p>1.6 创建收据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipt := types.NewReceipt(root, failed, *usedGas)</span><br><span class="line">	receipt.TxHash = tx.Hash()</span><br><span class="line">	receipt.GasUsed = gas</span><br><span class="line">	<span class="keyword">if</span> msg.To() == <span class="literal">nil</span> &#123;</span><br><span class="line">		receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the receipt logs and create a bloom for filtering</span></span><br><span class="line">	receipt.Logs = statedb.GetLogs(tx.Hash())</span><br><span class="line">	receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</span><br><span class="line">	receipt.BlockHash = statedb.BlockHash()</span><br><span class="line">	receipt.BlockNumber = header.Number</span><br><span class="line">	receipt.TransactionIndex = <span class="type">uint</span>(statedb.TxIndex())</span><br></pre></td></tr></table></figure>

<p>②：最后完成区块，应用任何共识引擎特定的额外功能(例如区块奖励)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Finalize(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header) &#123;</span><br><span class="line">	<span class="comment">// Accumulate any block and uncle rewards and commit the final state root</span></span><br><span class="line">	<span class="comment">//累积任何块和叔叔的奖励并提交最终状态树根</span></span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止<code>bc.processor.Process</code>执行完毕，返回<code>receipts</code>.</p>
<hr>
<h3 id="校验状态"><a href="#校验状态" class="headerlink" title="校验状态"></a>校验状态</h3><p>大致包括4部分的校验：</p>
<p>①：校验使用的<code>gas</code>是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> block.GasUsed() != usedGas &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gas used (remote: %d local: %d)&quot;</span>, block.GasUsed(), usedGas)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：校验bloom是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rbloom := types.CreateBloom(receipts)</span><br><span class="line">	<span class="keyword">if</span> rbloom != header.Bloom &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid bloom (remote: %x  local: %x)&quot;</span>, header.Bloom, rbloom)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：校验收据哈希是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line">	<span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>, header.ReceiptHash, receiptSha)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：校验merkleroot 是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root := statedb.IntermediateRoot(v.config.IsEIP158(header.Number)); header.Root != root &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid merkle root (remote: %x local: %x)&quot;</span>, header.Root, root)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将块和关联状态写入到数据库"><a href="#将块和关联状态写入到数据库" class="headerlink" title="将块和关联状态写入到数据库"></a>将块和关联状态写入到数据库</h3><p>函数：<strong>WriteBlockWithState</strong></p>
<p>①：计算块的<code>total td</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptd := bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>②：添加待插入块本身的<code>td</code> ,并将此时最新的<code>total td</code> 存储到数据库中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd)</span><br></pre></td></tr></table></figure>

<p>③：将块的<code>header</code>和<code>body</code>分别序列化到数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rawdb.WriteBlock(bc.db, block)</span><br><span class="line">	-&gt;WriteBody(db, block.Hash(), block.NumberU64(), block.Body())</span><br><span class="line">	-&gt;WriteHeader(db, block.Header())</span><br></pre></td></tr></table></figure>

<p>④：将状态写入底层内存<code>Trie</code>数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">state.Commit(bc.chainConfig.IsEIP158(block.Number()))</span><br></pre></td></tr></table></figure>

<p>⑤：遍历节点数据写入到磁盘</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">triedb.Commit(header.Root, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：存储一个块的所有交易数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts)</span><br></pre></td></tr></table></figure>

<p>⑦：将新的<code>head</code>块注入到当前链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.insert(block)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储分配给规范块的哈希</li>
<li>存储头块的哈希</li>
<li>存储最新的快</li>
<li>更新<code>currentFastBlock</code></li>
</ul>
<p>⑧：发送<code>chainEvent</code>事件或者<code>ChainSideEvent</code>事件或者<code>ChainHeadEvent</code>事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.chainFeed.Send(ChainEvent&#123;Block: block, Hash: block.Hash(), Logs: logs&#125;)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			bc.logsFeed.Send(logs)</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span> emitHeadEvent &#123;</span><br><span class="line">			bc.chainHeadFeed.Send(ChainHeadEvent&#123;Block: block&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bc.chainSideFeed.Send(ChainSideEvent&#123;Block: block&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此writeBlockWithState 结束，从上面可以知道，insertChain的最终还是调用了<code>writeBlockWithState</code>的insert方法完成了最终的上链入库动作。</p>
<p>最后整个<code>insertChain</code> <em>函数，如果已经完成了插入，就发送<code>chain head</code>事件</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</span><br><span class="line">		bc.chainHeadFeed.Send(ChainHeadEvent&#123;lastCanon&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>比较常见的有这么几处会进行订阅<code>chain head</code> 事件：</p>
<ol>
<li><p>在tx_pool.go中，收到此事件会进行换head的操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在worker.go中,其他节点的矿工收到此事件就会停止当前的挖矿，继续下一个挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">worker.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>到此整个区块上链入库就完成了，最后再送上一张总结的图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glyqxrr9p0j31530u0jz0.jpg" alt="image-20201224104046731"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之挖矿流程</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之挖矿流程</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> (文章资料在此，给个Star哦)</p>
</blockquote>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以太坊挖矿的主要流程是由<code>miner</code>包负责的，下面是基本的一个架构：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glkzcyd6xhj31am0u0qe0.jpg" alt="image-20201212125409326"></p>
<p>首先外部是通过<code>miner</code>对象进行了操作，<code>miner</code>里面则是实用<code>worker</code>对象来实现挖矿的整体功能。miner决定着是否停止挖矿或者是否可以开始挖矿，同时还可以设置矿工的地址来获取奖励。</p>
<p>真正调度处理挖矿相关细节的则是在worker.go里面，我们先来看一张总体的图。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllc2fgu1gj31cw0rwdlc.jpg" alt="image-20201212201358073"></p>
<p>上图我们看到有四个循环，分别通过几个<code>channel</code>负责不同的事：</p>
<h3 id="newWorkLoop"><a href="#newWorkLoop" class="headerlink" title="newWorkLoop"></a>newWorkLoop</h3><ol>
<li><code>startCh</code>：接收<code>startCh</code>信号，开始挖矿</li>
<li><code>chainHeadCh</code>：表示接收到新区块，需要终止当前的挖矿工作，开始新的挖矿。</li>
<li><code>timer.C</code>：默认每三秒检查一次是否有新交易需要处理。如果有则需要重新开始挖矿。以便将加高的交易优先打包到区块中。</li>
</ol>
<p>在 <code>newWorkLoop</code> 中还有一个辅助信号，<code>resubmitAdjustCh</code> 和 <code>resubmitIntervalCh</code>。运行外部修改timer计时器的时钟。<code>resubmitAdjustCh</code>是根据历史情况重新计算一个合理的间隔时间。而<code>resubmitIntervalCh</code>则允许外部，实时通过 <code>Miner</code> 实例方法 <code>SetRecommitInterval</code> 修改间隔时间。</p>
<h3 id="mainLoop"><a href="#mainLoop" class="headerlink" title="mainLoop"></a>mainLoop</h3><ol>
<li><code>newWorkCh</code>:接收生成新的挖矿任务信号</li>
<li><code>chainSideCh</code>:接收区块链中加入了一个新区块作为当前链头的旁支的信号</li>
<li><code>txsCh</code>:接收交易池的Pending中新加入了交易事件的信号</li>
</ol>
<p><code>TaskLoop</code>则是提交新的挖矿任务，而<code>resultLoop</code>则是成功出块之后做的一些处理。</p>
<hr>
<h2 id="启动挖矿"><a href="#启动挖矿" class="headerlink" title="启动挖矿"></a>启动挖矿</h2><h3 id="挖矿的参数设置"><a href="#挖矿的参数设置" class="headerlink" title="挖矿的参数设置"></a>挖矿的参数设置</h3><p><code>geth</code>挖矿的参数设置定义在 <code>cmd/utils/flags.go</code> 文件中</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–mine</td>
<td align="left">false</td>
<td align="center">是否开启自动挖矿</td>
</tr>
<tr>
<td align="left">–miner.threads</td>
<td align="left">0</td>
<td align="center">挖矿时可用并行PoW计算的协程（轻量级线程）数。 兼容过时参数 —minerthreads。</td>
</tr>
<tr>
<td align="left">–miner.notify</td>
<td align="left">空</td>
<td align="center">挖出新块时用于通知远程服务的任意数量的远程服务地址。 是用 <code>,</code>分割的多个远程服务器地址。 如：”<a href="http://api.miner.com,http//api2.miner.com%E2%80%9C">http://api.miner.com,http://api2.miner.com“</a></td>
</tr>
<tr>
<td align="left">–miner.noverify</td>
<td align="left">false</td>
<td align="center">是否禁用区块的PoW工作量校验。</td>
</tr>
<tr>
<td align="left">–miner.gasprice</td>
<td align="left">1000000000 wei</td>
<td align="center">矿工可接受的交易Gas价格， 低于此GasPrice的交易将被拒绝写入交易池和不会被矿工打包到区块。</td>
</tr>
<tr>
<td align="left">–miner.gastarget</td>
<td align="left">8000000 gas</td>
<td align="center">动态计算新区块燃料上限（gaslimit）的下限值。 兼容过时参数 —targetgaslimit。</td>
</tr>
<tr>
<td align="left">–miner.gaslimit</td>
<td align="left">8000000 gas</td>
<td align="center">动态技术新区块燃料上限的上限值。</td>
</tr>
<tr>
<td align="left">–miner.etherbase</td>
<td align="left">第一个账户</td>
<td align="center">用于接收挖矿奖励的账户地址， 默认是本地钱包中的第一个账户地址。</td>
</tr>
<tr>
<td align="left">–miner.extradata</td>
<td align="left">geth版本号</td>
<td align="center">允许矿工自定义写入区块头的额外数据。</td>
</tr>
<tr>
<td align="left">–miner.recommit</td>
<td align="left">3s</td>
<td align="center">重新开始挖掘新区块的时间间隔。 将自动放弃进行中的挖矿后，重新开始一次新区块挖矿。</td>
</tr>
</tbody></table>
<h3 id="常见的启动挖矿的方式"><a href="#常见的启动挖矿的方式" class="headerlink" title="常见的启动挖矿的方式"></a>常见的启动挖矿的方式</h3><h4 id="参数设置挖矿"><a href="#参数设置挖矿" class="headerlink" title="参数设置挖矿"></a>参数设置挖矿</h4><blockquote>
<p>dgeth –dev –mine</p>
</blockquote>
<h4 id="控制台启动挖矿"><a href="#控制台启动挖矿" class="headerlink" title="控制台启动挖矿"></a>控制台启动挖矿</h4><blockquote>
<p>miner.start(1)</p>
</blockquote>
<h4 id="rpc-启动挖矿"><a href="#rpc-启动挖矿" class="headerlink" title="rpc 启动挖矿"></a>rpc 启动挖矿</h4><p>这是部署节点使用的方式，一般设置如下：</p>
<blockquote>
<p>&#x2F;geth –datadir “&#x2F;data0” –nodekeyhex “27aa615f5fa5430845e4e99229def5f23e9525a20640cc49304f40f3b43824dc” –bootnodes $enodeid –mine –debug –metrics –syncmode&#x3D;”full” –gcmode&#x3D;archive –istanbul.blockperiod 5 –gasprice 0 –port 30303 –rpc –rpcaddr “0.0.0.0” –rpcport 8545 –rpcapi “db,eth,net,web3,personal” –nat any –allow-insecure-unlock </p>
</blockquote>
<hr>
<p>开始源码分析，进入到<code>miner.go</code>的<code>New</code>函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(eth Backend, config *Config, chainConfig *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine, isLocalBlock <span class="keyword">func</span>(block *types.Block)</span></span> <span class="type">bool</span>) *Miner &#123;</span><br><span class="line">	miner := &amp;Miner&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> miner.update()</span><br><span class="line">	<span class="keyword">return</span> miner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> update() &#123;</span><br><span class="line">  <span class="keyword">switch</span> ev.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> downloader.StartEvent:</span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> miner.Mining() &#123;</span><br><span class="line">					miner.Stop()</span><br><span class="line">					atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">1</span>)</span><br><span class="line">					log.Info(<span class="string">&quot;Mining aborted due to sync&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> downloader.DoneEvent, downloader.FailedEvent:</span><br><span class="line">				shouldStart := atomic.LoadInt32(&amp;miner.shouldStart) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">1</span>)</span><br><span class="line">				atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> shouldStart &#123;</span><br><span class="line">					miner.Start(miner.coinbase)</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们初始化的<code>canStart=1</code> ， 如果<code>Downloader</code>模块正在同步，则<code>canStart=0</code>,并且停止挖矿，如果<code>Downloader</code>模块<code>Done</code>或者<code>Failed</code>，则<code>canStart=1</code>,且同时<code>shouldStart=0</code>,miner将启动。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">miner.Start(miner.coinbase)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> Start(coinbase common.Address) &#123;</span><br><span class="line">...</span><br><span class="line">	miner.worker.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> start() &#123;</span><br><span class="line">...</span><br><span class="line">	w.startCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将会进入到<code>mainLoop</code>中去处理<code>startCh</code>：</p>
<p>①：清除过旧的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">clearPending(w.chain.CurrentBlock().NumberU64())</span><br></pre></td></tr></table></figure>

<p>②：提交新的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commit := <span class="function"><span class="keyword">func</span><span class="params">(noempty <span class="type">bool</span>, s <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">		w.newWorkCh &lt;- &amp;newWorkReq&#123;interrupt: interrupt, noempty: noempty, timestamp: timestamp&#125;</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成新的挖矿任务"><a href="#生成新的挖矿任务" class="headerlink" title="生成新的挖矿任务"></a>生成新的挖矿任务</h2><p>根据<code>newWorkCh</code>生成新的挖矿任务，进入到<code>CommitNewWork</code>中：</p>
<p>①：组装<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">header := &amp;types.Header&#123; <span class="comment">//组装header</span></span><br><span class="line">		ParentHash: parent.Hash(),</span><br><span class="line">		Number:     num.Add(num, common.Big1), <span class="comment">//num+1</span></span><br><span class="line">		GasLimit:   core.CalcGasLimit(parent, w.config.GasFloor, w.config.GasCeil),</span><br><span class="line">		Extra:      w.extra,</span><br><span class="line">		Time:       <span class="type">uint64</span>(timestamp),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：根据共识引擎吃初始化header的共识字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.engine.Prepare(w.chain, header); </span><br></pre></td></tr></table></figure>

<p>③：为当前挖矿新任务创建环境</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.makeCurrent(parent, header)</span><br></pre></td></tr></table></figure>

<p>④：添加叔块</p>
<p>叔块集分本地矿工打包区块和其他挖矿打包的区块。优先选择自己挖出的区块。选择时，将先删除太旧的区块，只从最近的7(staleThreshold)个高度中选择，最多<strong>选择两个叔块</strong>放入新区块中.在真正添加叔块的同时会进行校验，包括如下：</p>
<ul>
<li>叔块存在报错</li>
<li>添加的uncle是父块的兄弟报错</li>
<li>叔块的父块未知报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commitUncles(w.localUncles)</span><br><span class="line">commitUncles(w.remoteUncles)</span><br></pre></td></tr></table></figure>

<p>⑤：如果noempty为false，则提交空块，不填充交易进入到区块中,表示提前挖矿</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !noempty &#123;</span><br><span class="line">  w.commit(uncles, <span class="literal">nil</span>, <span class="literal">false</span>, tstart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：填充交易到新区块中</p>
<p>6.1 从交易池中获取交易，并把交易分为本地交易和远程交易，本地交易优先，先将本地交易提交，再将外部交易提交。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">localTxs, remoteTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions), pending</span><br><span class="line">	<span class="keyword">for</span> _, account := <span class="keyword">range</span> w.eth.TxPool().Locals() &#123;</span><br><span class="line">		<span class="keyword">if</span> txs := remoteTxs[account]; <span class="built_in">len</span>(txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(remoteTxs, account)</span><br><span class="line">			localTxs[account] = txs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(localTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   txs := types.NewTransactionsByPriceAndNonce(w.current.signer, localTxs)</span><br><span class="line">   <span class="keyword">if</span> w.commitTransactions(txs, w.coinbase, interrupt) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remoteTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.2提交交易 </p>
<ul>
<li>首先校验有没有可用的<code>Gas</code></li>
<li>如果碰到以下情况要进行交易执行的中断<ul>
<li>新的头块事件到达，中断信号为 1     (整个任务会被丢弃)</li>
<li><code>worker</code> 开启或者重启，中断信号为 1     （整个任务会被丢弃）</li>
<li><code>worker</code>重新创建挖矿任务根据新的交易，中断信号为 2 （任务还是会被送入到共识引擎）</li>
</ul>
</li>
</ul>
<p>6.3开始执行交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logs, err := w.commitTransaction(tx, coinbase)</span><br></pre></td></tr></table></figure>

<p>6.4执行交易获取收据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br></pre></td></tr></table></figure>

<p>如果执行出错，直接回退上一个快照</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>出错的原因大概有以下几个：</p>
<ul>
<li>超出当前块的<code>gas limit</code></li>
<li><code>Nonce</code> 太低</li>
<li><code>Nonce</code> 太高</li>
</ul>
<p>执行成功的话讲交易和收据存入到<code>w.current</code>中。</p>
<p>⑦：执行交易的状态更改，并组装成最终块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.commit(uncles, w.fullTaskHook, <span class="literal">true</span>, tstart)</span><br></pre></td></tr></table></figure>

<p>执行交易的状态更改，并组装成最终块是由下面的共识引擎所完成的事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block, err := w.engine.FinalizeAndAssemble(w.chain, w.current.header, s, w.current.txs, uncles, w.current.receipts)</span><br></pre></td></tr></table></figure>

<p>底层会调用 <code>state.IntermediateRoot</code>执行状态更改。组装成最终块意味着到这打包任务完成。接着就是要提交新的挖矿任务。</p>
<hr>
<h2 id="提交新的挖矿任务"><a href="#提交新的挖矿任务" class="headerlink" title="提交新的挖矿任务"></a>提交新的挖矿任务</h2><p>①：获取<code>sealHash</code>（挖矿前的区块哈希），重复提交则跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sealHash := w.engine.SealHash(task.block.Header()) <span class="comment">// 返回挖矿前的块的哈希</span></span><br><span class="line">			<span class="keyword">if</span> sealHash == prev &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②:生成新的挖矿请求，结果返回到<code>reultCh</code>或者<code>StopCh</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.engine.Seal(w.chain, task.block, w.resultCh, stopCh);</span><br></pre></td></tr></table></figure>

<p>挖矿的结果会返回到<code>resultCh</code>中或者<code>stopCh</code>中，<code>resultCh</code>有数据成功出块，<code>stopCh</code>不为空，则中断挖矿线程。</p>
<hr>
<h2 id="成功出块"><a href="#成功出块" class="headerlink" title="成功出块"></a>成功出块</h2><p><code>resultCh</code>有区块数据，则成功挖出了块，到最后的成功出块我们还需要进行相应的验证判断。</p>
<p>①：块为空或者链上已经有块或者<code>pendingTasks</code>不存在相关的<code>sealhash</code>,跳过处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> block == <span class="literal">nil</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> w.chain.HasBlock(block.Hash(), block.NumberU64()) &#123;&#125;</span><br><span class="line">task, exist := w.pendingTasks[sealhash] <span class="keyword">if</span> !exist &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：更新<code>receipts</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> task.receipts &#123;</span><br><span class="line">  receipt.BlockHash = hash</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：提交块和状态到数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := w.chain.WriteBlockWithState(block, receipts, logs, task.state, <span class="literal">true</span>) <span class="comment">// 互斥</span></span><br></pre></td></tr></table></figure>

<p>④：广播区块并宣布链插入事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.mux.Post(core.NewMinedBlockEvent&#123;Block: block&#125;)</span><br></pre></td></tr></table></figure>

<p>⑤：等待规范确认本地挖出的块</p>
<p>新区块并非立即稳定，暂时存入到未确认区块集中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.unconfirmed.Insert(block.NumberU64(), block.Hash())</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><p>整个挖矿流程还是比较的简单，通过 4 个<code>Loop</code>互相工作，从开启挖矿到生成新的挖矿任务到提交新的挖矿任务到最后的成功出块，这里面的共识处理细节不会提到，接下来的文章会说到。</p>
<blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part2/mine/design.html">https://learnblockchain.cn/books/geth/part2/mine/design.html</a></p>
<p><a href="https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8">https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之区块和交易广播</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%A4%E6%98%93%E5%B9%BF%E6%92%AD-5/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之区块和交易广播</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a>  (文章及学习资料，给个star哦)</p>
</blockquote>
<h2 id="ProtocolManager详解"><a href="#ProtocolManager详解" class="headerlink" title="ProtocolManager详解"></a>ProtocolManager详解</h2><p><code>ProtocolManager</code>，从字面上看是协议管理器，负责着<code>p2p</code>通信协议的管理。它连接了<code>p2p</code>的逻辑层<code>peer</code>与顶层<code>peer</code>之间的调用，从顶层将协议传递至逻辑层，再从逻辑层得到<code>message</code>传递到顶层。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9hs30wqfj30zw0rodox.jpg" alt="image-20201202142450663"></p>
<ol>
<li><code>fastSync</code>规定了同步的模式 ；</li>
<li><code>acceptTxs</code>是节点是否接受交易的阀门，只有当<code>pm.acceptTxs == 1</code>时，节点才会接受交易。这个操作只会在同步结束后再开始，即同步的时候节点是不会接受交易的；</li>
<li><code>SubProtocols</code>中是以太坊的通讯协议，通常只有一个值，即<code>eth63</code>。</li>
<li><code>downloader</code>是一个下载器，用于主动从远程节点中获取<code>hashes</code>和<code>blocks</code>。</li>
<li><code>fetcher</code>则被动的收集网络其他以太坊节点发过来的同步通知，进行验证，并做出相应的处理。</li>
</ol>
<hr>
<p><code>ProtocolManager.Start()</code>启动了四条<code>go</code>程，分别是交易订阅广播协程（<code>txBroadcastLoop</code>）、挖矿订阅协程（<code>minedBroadcastLoop</code>）、节点定期同步协程（<code>syncer</code>）和交易同步协程（txsyncLoop）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9hyirjjaj31io0rck40.jpg" alt="image-20201202143101376"></p>
<ol>
<li>&#x3D;&#x3D;txBroadcastLoop&#x3D;&#x3D;:广播新出现的交易对象。<code>txBroadcastLoop()</code>会在<code>txCh</code>通道的收端持续等待，一旦接收到有关新交易的事件，会立即调用<code>BroadcastTx()</code>函数广播给那些尚无该交易对象的相邻个体。</li>
<li>&#x3D;&#x3D;minedBroadcastLoop&#x3D;&#x3D;:广播新挖掘出的区块。<code>minedBroadcastLoop()</code>持续等待本节点的新挖掘出区块事件，然后立即广播给需要的相邻个体。当不再订阅新挖掘区块事件时，这个函数才会结束等待并返回。</li>
<li>&#x3D;&#x3D;syncer&#x3D;&#x3D;:<strong>定时的和网络其他节点同步，并处理网络节点的相关通知</strong>。定时与相邻个体进行区块全链的强制同步。syncer()首先启动fetcher成员，然后进入一个无限循环，每次循环中都会向相邻peer列表中“最优”的那个peer作一次区块全链同步。发起上述同步的理由分两种：如果有新登记(加入)的相邻个体，则在整个peer列表数目大于5时，发起之；如果没有新peer到达，则以10s为间隔定时的发起之。这里所谓”最优”指的是peer中所维护区块链的TotalDifficulty(td)最高，由于Td是全链中从创世块到最新头块的Difficulty值总和，所以Td值最高就意味着它的区块链是最新的，跟这样的peer作区块全链同步，显然改动量是最小的，此即”最优”。</li>
<li>&#x3D;&#x3D;txsyncLoop&#x3D;&#x3D;：<strong>把新的交易均匀的同步给网路节点</strong>。</li>
</ol>
<hr>
<h2 id="广播的情形"><a href="#广播的情形" class="headerlink" title="广播的情形"></a>广播的情形</h2><ol>
<li><code>minedBroadcastLoop()</code>监听到新区块事件后，把新区块和区块<code>hash</code>分别广播出去；</li>
<li>从远程节点同步完成后，将<code>CurrentBlock</code>广播出去，此时广播的是区块<code>hash</code>；</li>
<li><code>txBlockcastLoop()</code>监听到区块池的新增交易事件时会广播交易；</li>
</ol>
<hr>
<h2 id="广播区块及区块哈希"><a href="#广播区块及区块哈希" class="headerlink" title="广播区块及区块哈希"></a>广播区块及区块哈希</h2><p>广播区块的入口在<code>pm.minedBroadcastLoop()</code>,进入到<code>BroadcastBlock</code>,这里的参数为<code>bool</code>值，如果传入的为true，则将区块block和总难度td发送给一部分节点，节点数为根号n；如果传入的为false，则将区块的hash发送给所有的节点。<strong>需要注意的是两个广播函数都执行</strong>。</p>
<p>进入到<code>true</code>分支：<strong>代表只传播区块给一部分节点</strong></p>
<p>①：首先计算一个临时的TD</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">			td = <span class="built_in">new</span>(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>))</span><br><span class="line">		&#125; </span><br></pre></td></tr></table></figure>

<p>②：发送块到peers的子集</p>
<p>对节点数进行开方，16开方得4，然后取前4个节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transferLen := <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(<span class="built_in">len</span>(peers))))</span><br><span class="line">		<span class="keyword">if</span> transferLen &lt; minBroadcastPeers &#123;</span><br><span class="line">			transferLen = minBroadcastPeers</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> transferLen &gt; <span class="built_in">len</span>(peers) &#123;</span><br><span class="line">			transferLen = <span class="built_in">len</span>(peers)</span><br><span class="line">		&#125;</span><br><span class="line">		transfer := peers[:transferLen]</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">			peer.AsyncSendNewBlock(block, td) <span class="comment">// 块传播</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>执行完之后直接return出去，再次执行此函数，此时不会走ture分支，直接判断判断本地是否有区块，如果有则发送区区块哈希给剩下的节点，如果没有，则不做发送哈希的操作。</p>
<blockquote>
<p>如果本地存在这个要广播的区块(很可能就是出块节点，或者接受块的节点已经插入到区块链中),那就还要像其他没有被广播到区块的节点发送区块哈希。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fp0u7e3j31bw0hkthh.jpg" alt="image-20201125150810051"></p>
<blockquote>
<p>如果本地不存在这个要广播的区块哈希(应该是还没接收到区块或者区块哈希的节点)，那它只要向它的节点列表里发送区块即可。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fwwxfh2j31bi0e4tfv.jpg" alt="image-20201125151546035"></p>
<hr>
<p>接下来就是重点分析<code>AsyncSendNewBlock</code>和<code>AsyncSendNewBlockHash</code>两个函数了。</p>
<h3 id="AsyncSendNewBlock"><a href="#AsyncSendNewBlock" class="headerlink" title="AsyncSendNewBlock"></a>AsyncSendNewBlock</h3><blockquote>
<p>发送块到需要广播的节点的广播队列中</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.queuedProps &lt;- &amp;propEvent&#123;block: block, td: td&#125;:</span><br><span class="line">		p.knownBlocks.Add(block.Hash())</span><br><span class="line">		<span class="keyword">for</span> p.knownBlocks.Cardinality() &gt;= maxKnownBlocks &#123;</span><br><span class="line">			p.knownBlocks.Pop()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>queuedProps</code>是用来存放要广播的块的队列，同时，要把广播的块标记为已知，还不能超过1024（<strong>maxKnownBlocks</strong>）个。超过就会弹出队列第一个<code>propEvent()</code> 。接下来就是处理队列中的块了。</p>
<p>在<code>eth/peer.go</code>中，有个专门处理广播的循环<code>brodcast</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span></span> broadcast() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Broadcast transactions&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="built_in">len</span>(txs))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> prop := &lt;-p.queuedProps:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlock(prop.block, prop.td); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Propagated block&quot;</span>, <span class="string">&quot;number&quot;</span>, prop.block.Number(), <span class="string">&quot;hash&quot;</span>, prop.block.Hash(), <span class="string">&quot;td&quot;</span>, prop.td)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> block := &lt;-p.queuedAnns:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlockHashes([]common.Hash&#123;block.Hash()&#125;, []<span class="type">uint64</span>&#123;block.NumberU64()&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Announced block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-p.term:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>广播新块到远程节点</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.SendNewBlock(prop.block, prop.td);</span><br></pre></td></tr></table></figure>

<p>远程节点收到块后同样也会标记哈希存入队列，并且不会超过最大，同时发送一个<code>NewBlockMsg</code>，<code>msgcode</code>为<code>0x07</code>,同时数据会被RLP编码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.knownBlocks.Add(block.Hash())</span><br><span class="line">	<span class="keyword">for</span> p.knownBlocks.Cardinality() &gt;= maxKnownBlocks &#123;</span><br><span class="line">		p.knownBlocks.Pop()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p2p.Send(p.rw, NewBlockMsg, []<span class="keyword">interface</span>&#123;&#125;&#123;block, td&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(w MsgWriter, msgcode <span class="type">uint64</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	size, r, err := rlp.EncodeToReader(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w.WriteMsg(Msg&#123;Code: msgcode, Size: <span class="type">uint32</span>(size), Payload: r&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此广播区块的过程结束，交由远程节点去处理<code>NewBlockMsg</code>消息。</p>
<hr>
<h3 id="AsyncSendNewBlockHash"><a href="#AsyncSendNewBlockHash" class="headerlink" title="AsyncSendNewBlockHash"></a>AsyncSendNewBlockHash</h3><p>广播哈希的过程跟广播区块的过程非常的类似，最终是由远程节点去处理<code>NewBlockHashesMsg</code>消息。</p>
<p>广播区块的过程完毕之后，会直接进入下一个阶段，调用<code>fetcher</code>模块去同步这些广播的区块，接下的文章会讲到。</p>
<hr>
<h2 id="广播交易"><a href="#广播交易" class="headerlink" title="广播交易"></a>广播交易</h2><p>广播交易的入口在<code>pm.txBroadcastLoop()</code>，直接进入到<code>pm.BroadcastTxs(event.Txs)</code>，大概做了以下几件事：</p>
<p>①：将交易广播给一批没有这个交易的节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">		peers := pm.peers.PeersWithoutTx(tx.Hash())</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">			txset[peer] = <span class="built_in">append</span>(txset[peer], tx)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">&quot;Broadcast transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.Hash(), <span class="string">&quot;recipients&quot;</span>, <span class="built_in">len</span>(peers))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：异步发送交易给这些节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> peer, txs := <span class="keyword">range</span> txset &#123;</span><br><span class="line">		peer.AsyncSendTransactions(txs)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入到<code>AsyncSendTransactions</code>:</p>
<p>将所有交易标记为已知交易，同时还要保证没有超过最大的已知交易（32768笔）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> p.queuedTxs &lt;- txs:</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">			p.knownTxs.Add(tx.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> p.knownTxs.Cardinality() &gt;= maxKnownTxs &#123;</span><br><span class="line">			p.knownTxs.Pop()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">		<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span></span> SendTransactions(txs types.Transactions) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> p2p.Send(p.rw, TxMsg, txs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送交易最终会发送一个<code>TxMsg</code>消息，接收到这个消息的节点会通过<code>pm.txpool.AddRemotes(txs)</code>处理交易。</p>
<hr>
<h2 id="消息处理（handleMsg）"><a href="#消息处理（handleMsg）" class="headerlink" title="消息处理（handleMsg）"></a>消息处理（handleMsg）</h2><p><code>handleMsg</code>从对方连接中读取消息，根据消息码的不同进行处理,从而将广播和同步之间来回的消息进行处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> handleMsg(p *peer) <span class="type">error</span> &#123;</span><br><span class="line">    msg, err := p.rw.ReadMsg()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> msg.Size &gt; ProtocolMaxMsgSize &#123;</span><br><span class="line">        <span class="keyword">return</span> errResp(ErrMsgTooLarge, <span class="string">&quot;%v &gt; %v&quot;</span>, msg.Size, ProtocolMaxMsgSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> msg.Discard()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg.Code == StatusMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == GetBlockHeadersMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == BlockHeadersMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == GetBlockBodiesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == BlockBodiesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == GetNodeDataMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == NodeDataMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == GetReceiptsMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == ReceiptsMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == NewBlockHashesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == NewBlockMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == TxMsg: ......</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> errResp(ErrInvalidMsgCode, <span class="string">&quot;%v&quot;</span>, msg.Code)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a> 最新发布</p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a>  资料更新</p>
</blockquote>
]]></content>
  </entry>
</search>
