<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="mindcarver&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="mindcarver&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="mindcarver">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>mindcarver's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">mindcarver's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">死磕以太坊源码|以太坊启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:14:12" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码|以太坊启动流程</p>
<p>文章以及资料（开源）：<a target="_blank" rel="noopener" href="https://github.com/mindcarver/blockchain_guide">github地址</a>  </p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6tgnjvkhj20jg0c6mxi.jpg" alt="9ff239564d5d1129fa544f25d95c7468"></p>
<h1 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h1><p>以太坊是如何启动一个网络节点的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./geth --datadir &quot;../data0&quot; --nodekeyhex &quot;27aa615f5fa5430845e4e97229def5f23e9525a20640cc49304f40f3b43824dc&quot; --bootnodes $enodeid --mine --debug --metrics --syncmode=&quot;full&quot; --gcmode=archive  --gasprice 0 --port 30303 --rpc --rpcaddr &quot;0.0.0.0&quot; --rpcport 8545 --rpcapi &quot;db,eth,net,web3,personal&quot; --nat any --allow-insecure-unlock  2&gt;&gt;log 1&gt;&gt;log 0&gt;&gt;log &gt;&gt;log &amp;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>geth : 编译好的geth程序，可以起别名</li>
<li>datadir：数据库和keystore密钥的数据目录</li>
<li>nodekeyhex: 十六进制的P2P节点密钥</li>
<li>bootnodes:用于P2P发现引导的enode urls</li>
<li>mine：打开挖矿</li>
<li>debug:突出显示调用位置日志(文件名及行号)</li>
<li>metrics: 启用metrics收集和报告</li>
<li>syncmode:同步模式 (“fast”, “full”, or “light”)</li>
<li>gcmode:表示即时将内存中的数据写入到文件中，否则重启节点可能会导致区块高度归零而丢失数据</li>
<li>gasprice:挖矿接受交易的最低gas价格</li>
<li>port:网卡监听端口(默认值:30303)</li>
<li>rpc:启用HTTP-RPC服务器</li>
<li>rpcaddr:HTTP-RPC服务器接口地址(默认值:“localhost”)</li>
<li>rpcport:HTTP-RPC服务器监听端口(默认值:8545)</li>
<li>rpcapi:基于HTTP-RPC接口提供的API</li>
<li>nat: NAT端口映射机制 (any|none|upnp|pmp|extip:<IP>) (默认: “any”)</li>
<li>allow-insecure-unlock:用于解锁账户</li>
</ul>
<p>详细的以太坊启动参数可以参考我的以太坊理论系列，里面有对参数的详细解释。</p>
<hr>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>geth</code>位于<code>cmd/geth/main.go</code>文件中，入口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmkul302pj31gu0mcnd2.jpg" alt="image-20201012152238541"></p>
<p>我们通过这张图可以看出来：main()并不是真正意义上的入口，在初始化完常量和变量以后，会先调用模块的init()函数，然后才是main()函数。所以初始化的工作是在init()函数里完成的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize the CLI app and start Geth</span></span><br><span class="line">	app.Action = geth</span><br><span class="line">	app.HideVersion = <span class="literal">true</span> <span class="comment">// we have a command to print the version</span></span><br><span class="line">	app.Copyright = <span class="string">&quot;Copyright 2013-2019 The go-ethereum Authors&quot;</span></span><br><span class="line">	app.Commands = []cli.Command&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从这我们找到了入口函数geth:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<ol>
<li>准备操作内存缓存配额并设置度量系统</li>
<li>加载配置和注册服务</li>
<li>启动节点</li>
<li>守护当前线程</li>
</ol>
<h2 id="加载配置和注册服务"><a href="#加载配置和注册服务" class="headerlink" title="加载配置和注册服务"></a>加载配置和注册服务</h2><p>makeFullNode</p>
<h3 id="1-加载配置"><a href="#1-加载配置" class="headerlink" title="1.加载配置"></a>1.加载配置</h3><p>makeConfigNode</p>
<p>首先加载默认配置(作为主网节点启动)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cfg := gethConfig&#123;</span><br><span class="line">		Eth:  eth.DefaultConfig,</span><br><span class="line">		Shh:  whisper.DefaultConfig,</span><br><span class="line">		Node: defaultNodeConfig(),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>eth.DefaultConfig</strong> : 以太坊节点的主要参数配置。主要包括: 同步模式(fast)、chainid、交易池配置、gasprice、挖矿配置等；</li>
<li><strong>whisper.DefaultConfig</strong> : 主要用于配置网络间通讯；</li>
<li><strong>defaultNodeConfig()</strong> : 主要用于配置对外提供的RPC节点服务；</li>
<li><strong>dashboard.DefaultConfig</strong> : 主要用于对外提供看板数据访问服务。</li>
</ul>
<p>接着加载自定义配置（适用私有链）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> file := ctx.GlobalString(configFileFlag.Name); file != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := loadConfig(file, &amp;cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后加载命令窗口参数（开发阶段）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">utils.SetNodeConfig(ctx, &amp;cfg.Node) <span class="comment">// 本地节点配置</span></span><br><span class="line">utils.SetEthConfig(ctx, stack, &amp;cfg.Eth)<span class="comment">// 以太坊配置</span></span><br><span class="line">utils.SetShhConfig(ctx, stack, &amp;cfg.Shh)<span class="comment">// whisper配置</span></span><br></pre></td></tr></table></figure>

<h3 id="2-RegisterEthService"><a href="#2-RegisterEthService" class="headerlink" title="2.RegisterEthService"></a>2.RegisterEthService</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterEthService</span><span class="params">(stack *node.Node, cfg *eth.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> cfg.SyncMode == downloader.LightSync &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			fullNode, err := eth.New(ctx, cfg)</span><br><span class="line">			<span class="keyword">if</span> fullNode != <span class="literal">nil</span> &amp;&amp; cfg.LightServ &gt; <span class="number">0</span> &#123;</span><br><span class="line">				ls, _ := les.NewLesServer(fullNode, cfg)</span><br><span class="line">				fullNode.AddLesServer(ls)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fullNode, err</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">&quot;Failed to register the Ethereum service: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了两个新类型：ServiceContext和Service。</p>
<p>先看一下ServiceContext的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         *Config</span><br><span class="line">	services       <span class="keyword">map</span>[reflect.Type]Service <span class="comment">// Index of the already constructed services</span></span><br><span class="line">	EventMux       *event.TypeMux           <span class="comment">// Event multiplexer used for decoupled notifications</span></span><br><span class="line">	AccountManager *accounts.Manager        <span class="comment">// Account manager created by the node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceContext主要是存储了一些从结点（或者叫协议栈）那里继承过来的、和具体Service无关的一些信息，比如结点config、account manager等。其中有一个services字段保存了当前正在运行的所有Service.</p>
<p>接下来看一下Service的定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Protocols retrieves the P2P protocols the service wishes to start.</span></span><br><span class="line">	<span class="comment">// 协议检索服务希望启动的P2P协议</span></span><br><span class="line">	Protocols() []p2p.Protocol</span><br><span class="line"></span><br><span class="line">	<span class="comment">// APIs retrieves the list of RPC descriptors the service provides</span></span><br><span class="line">	<span class="comment">// API检索服务提供的RPC描述符列表</span></span><br><span class="line">	APIs() []rpc.API</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start is called after all services have been constructed and the networking</span></span><br><span class="line">	<span class="comment">// layer was also initialized to spawn any goroutines required by the service.</span></span><br><span class="line">	<span class="comment">//在所有服务都已构建完毕并且网络层也已初始化以生成服务所需的所有goroutine之后，将调用start。</span></span><br><span class="line">	Start(server *p2p.Server) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop terminates all goroutines belonging to the service, blocking until they</span></span><br><span class="line">	<span class="comment">// are all terminated.</span></span><br><span class="line">	<span class="comment">//Stop终止属于该服务的所有goroutine，直到它们全部终止为止一直阻塞。</span></span><br><span class="line">	Stop() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务注册过程中，主要注册四个服务：EthService、DashboardService、ShhService、EthStatsService，这四种服务类均扩展自Service接口。其中，EthService根据同步模式的不同，分为两种实现：</p>
<ul>
<li>LightEthereum，支持LightSync模式</li>
<li>Ethereum，支持FullSync、FastSync模式</li>
</ul>
<p>LightEthereum作为轻客户端，与Ethereum区别在于，它只需要更新区块头。当需要查询区块体数据时，需要通过调用其他全节点的les服务进行查询；另外，轻客户端本身是不能进行挖矿的。</p>
<p>回到RegisterEthService代码，分两个来讲：</p>
<p>LightSync同步：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx *node.ServiceContext, config *eth.Config)</span></span> (*LightEthereum, <span class="type">error</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="number">1.</span>ctx.OpenDatabase <span class="comment">// 创建leveldb数据库</span></span><br><span class="line">  <span class="number">2.</span>core.SetupGenesisBlockWithOverride<span class="comment">// 根据创世配置初始化链数据目录</span></span><br><span class="line">  <span class="number">3.</span>实例化本地链id、共识引擎、注册peer节点、帐户管理器以及布隆过滤器的初始化</span><br><span class="line">  <span class="number">4.</span>light.NewLightChain<span class="comment">// 使用数据库中可用的信息返回完全初始化的轻链。它初始化默认的以太坊头</span></span><br><span class="line">  <span class="number">5.</span>light.NewTxPool <span class="comment">// 实例化交易池NewTxPool</span></span><br><span class="line">  <span class="number">6.</span>leth.ApiBackend = &amp;LesApiBackend&#123;ctx.ExtRPCEnabled(), leth, <span class="literal">nil</span>&#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FullSync&#x2F;Fast同步：</p>
<ol>
<li><p>参数校验</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> config.SyncMode == downloader.LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> !config.SyncMode.IsValid() &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.Miner.GasPrice == <span class="literal">nil</span> || config.Miner.GasPrice.Cmp(common.Big0) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.NoPruning &amp;&amp; config.TrieDirtyCache &gt; <span class="number">0</span> &#123;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>打开数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.OpenDatabaseWithFreezer</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据创世配置初始化链数据目录</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core.SetupGenesisBlockWithOverride</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化Ethereum对象</p>
</li>
<li><p>创建BlockChain实例对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core.NewBlockChain</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化交易池</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core.NewTxPool</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化协议管理器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewProtocolManager(...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化对外API服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;EthAPIBackend&#123;ctx.ExtRPCEnabled(), eth, <span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-RegisterShhService"><a href="#3-RegisterShhService" class="headerlink" title="3.RegisterShhService"></a>3.RegisterShhService</h3><p>注册Whisper服务，用于p2p网络间加密通信。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whisper.New(cfg), <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RegisterEthStatsService"><a href="#4-RegisterEthStatsService" class="headerlink" title="4.RegisterEthStatsService"></a>4.RegisterEthStatsService</h3><p>注册状态推送服务,将当前以太坊网络状态推送至指定URL地址.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethstats.New(url, ethServ, lesServ)</span><br></pre></td></tr></table></figure>

<h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><p>启动本地节点以及启动所有注册的服务。</p>
<h3 id="1-启动节点"><a href="#1-启动节点" class="headerlink" title="1.启动节点"></a>1.启动节点</h3><p>startNode</p>
<h4 id="1-1-stack-Start"><a href="#1-1-stack-Start" class="headerlink" title="1.1 stack.Start()"></a>1.1 stack.Start()</h4><ol>
<li><p>实例化p2p.Server对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为注册的服务创建上下文</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">  ctx := &amp;ServiceContext&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收集协议并启动新组装的p2p server</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">  <span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后启动配置的RPC接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n.startRPC(services)</span><br></pre></td></tr></table></figure>

<ul>
<li>startInProc (启动进程内通讯服务)</li>
<li>startIPC （启动IPC RPC端点）</li>
<li>startHTTP（启动HTTP RPC端点）</li>
<li>startWS （启动websocket RPC端点）</li>
</ul>
</li>
</ol>
<h3 id="2-解锁账户"><a href="#2-解锁账户" class="headerlink" title="2.解锁账户"></a>2.解锁账户</h3><p>unlockAccounts</p>
<p>在datadir&#x2F;keystore目录主要用于记录在当前节点创建的帐户keystore文件。如果你的keystore文件不在本地是无法进行解锁的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解锁datadir/keystore目录中帐户</span></span><br><span class="line">ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</span><br><span class="line">	passwords := utils.MakePasswordList(ctx)</span><br><span class="line">	<span class="keyword">for</span> i, account := <span class="keyword">range</span> unlocks &#123;</span><br><span class="line">		unlockAccount(ks, account, i, passwords)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注册钱包事件"><a href="#3-注册钱包事件" class="headerlink" title="3.注册钱包事件"></a>3.注册钱包事件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> accounts.WalletEvent, <span class="number">16</span>)</span><br><span class="line">stack.AccountManager().Subscribe(events)</span><br></pre></td></tr></table></figure>

<h3 id="4-监听钱包事件"><a href="#4-监听钱包事件" class="headerlink" title="4.监听钱包事件"></a>4.监听钱包事件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		<span class="keyword">switch</span> event.Kind &#123;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletArrived:</span><br><span class="line">			<span class="keyword">if</span> err := event.Wallet.Open(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Warn(<span class="string">&quot;New wallet appeared, failed to open&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletOpened:</span><br><span class="line">			status, _ := event.Wallet.Status()</span><br><span class="line">			log.Info(<span class="string">&quot;New wallet appeared&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;status&quot;</span>, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> derivationPaths []accounts.DerivationPath</span><br><span class="line">			<span class="keyword">if</span> event.Wallet.URL().Scheme == <span class="string">&quot;ledger&quot;</span> &#123;</span><br><span class="line">				derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.LegacyLedgerBaseDerivationPath)</span><br><span class="line">			&#125;</span><br><span class="line">			derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.DefaultBaseDerivationPath)</span><br><span class="line"></span><br><span class="line">			event.Wallet.SelfDerive(derivationPaths, ethClient)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> accounts.WalletDropped:</span><br><span class="line">			log.Info(<span class="string">&quot;Old wallet dropped&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL())</span><br><span class="line">			event.Wallet.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="5-启动挖矿"><a href="#5-启动挖矿" class="headerlink" title="5.启动挖矿"></a>5.启动挖矿</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethereum.StartMining(threads)</span><br></pre></td></tr></table></figure>

<h2 id="启动守护线程"><a href="#启动守护线程" class="headerlink" title="启动守护线程"></a>启动守护线程</h2><p>stop通道阻塞当前线程，直到节点被停止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.Wait()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以太坊启动主要就做了3件事，包括加载配置注册服务、启动节点相关服务以及启动守护线程。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/" class="post-title-link" itemprop="url">死磕以太坊源码分析之txpool</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:14:01" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之txpool</p>
<p>请结合以下代码阅读:<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文章不易，也希望大家多多指出问题</p>
</blockquote>
<h2 id="交易池概念原理"><a href="#交易池概念原理" class="headerlink" title="交易池概念原理"></a>交易池概念原理</h2><p>交易池工作概况：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzwre4v4ej31120tcgpa.jpg" alt="image-20201225104748102"></p>
<ol>
<li>交易池的数据来源主要来自：<ul>
<li>本地提交，也就是第三方应用通过调用本地以太坊节点的<code>RPC</code>服务所提交的交易；</li>
<li>远程同步，是指通过广播同步的形式，将其他以太坊节点的交易数据同步至本地节点;</li>
</ul>
</li>
<li>交易池中交易去向：被Miner模块获取并验证，用于挖矿；挖矿成功后写进区块并被广播</li>
<li><code>Miner</code>取走交易是复制，交易池中的交易并不减少。直到交易被写进规范链后才从交易池删除；</li>
<li>交易如果被写进分叉，交易池中的交易也不减少，等待重新打包。</li>
</ol>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><h3 id="TxPoolConfig"><a href="#TxPoolConfig" class="headerlink" title="TxPoolConfig"></a>TxPoolConfig</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Locals    []common.Address <span class="comment">// 本地账户地址存放</span></span><br><span class="line">	NoLocals  <span class="type">bool</span>             <span class="comment">// 是否开启本地交易机制</span></span><br><span class="line">	Journal   <span class="type">string</span>           <span class="comment">// 本地交易存放路径</span></span><br><span class="line">	Rejournal time.Duration    <span class="comment">// 持久化本地交易的间隔</span></span><br><span class="line">	PriceLimit <span class="type">uint64</span>         <span class="comment">// 价格超出比例，若想覆盖一笔交易的时候，若价格上涨比例达不到要求，那么不能覆盖</span></span><br><span class="line">	PriceBump  <span class="type">uint64</span> <span class="comment">// 替换现有交易的最低价格涨幅百分比（一次）</span></span><br><span class="line">	AccountSlots <span class="type">uint64</span> <span class="comment">// 每个账户的可执行交易限制</span></span><br><span class="line">	GlobalSlots  <span class="type">uint64</span> <span class="comment">// 全部账户最大可执行交易</span></span><br><span class="line">	AccountQueue <span class="type">uint64</span> <span class="comment">// 单个账户不可执行的交易限制</span></span><br><span class="line">	GlobalQueue  <span class="type">uint64</span> <span class="comment">// 全部账户最大非执行交易限制</span></span><br><span class="line">	Lifetime time.Duration <span class="comment">// 一个账户在queue中的交易可以存活的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认配置：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="TxPool"><a href="#TxPool" class="headerlink" title="TxPool"></a>TxPool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      TxPoolConfig <span class="comment">// 交易池配置</span></span><br><span class="line">	chainconfig *params.ChainConfig <span class="comment">// 区块链配置</span></span><br><span class="line">	chain       blockChain <span class="comment">// 定义blockchain接口</span></span><br><span class="line">	gasPrice    *big.Int</span><br><span class="line">	txFeed      event.Feed <span class="comment">//时间流</span></span><br><span class="line">	scope       event.SubscriptionScope <span class="comment">// 订阅范围</span></span><br><span class="line">	signer      types.Signer <span class="comment">//签名</span></span><br><span class="line">	mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">	istanbul <span class="type">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">	currentState  *state.StateDB <span class="comment">// 当前头区块对应的状态</span></span><br><span class="line">	pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">	currentMaxGas <span class="type">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">	locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">	journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">	pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">	queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">	beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">	all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">	priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">	chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">	chainHeadSub    event.Subscription</span><br><span class="line">	reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">	reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">	queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">	reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">	wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="txpool初始化"><a href="#txpool初始化" class="headerlink" title="txpool初始化"></a>txpool初始化</h2><p><code>Txpool</code>初始化主要做了以下几件事：</p>
<p>①：检查配置  配置有问题则用默认值填充</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config = (&amp;config).sanitize()</span><br></pre></td></tr></table></figure>

<p>   对于这部分的检查查看<code>TxPoolConfig</code>的字段。</p>
<p>②：初始化本地账户</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.locals = newAccountSet(pool.signer)</span><br></pre></td></tr></table></figure>

<p>③：将配置的本地账户地址加到交易池</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.locals.add(addr)</span><br></pre></td></tr></table></figure>

<p>   我们在安装以太坊客户端可以指定一个数据存储目录，此目录便会存储着所有我们导入的或者通过本地客户端创建的帐户<code>keystore</code>文件。而这个加载过程便是从该目录加载帐户数据</p>
<p>④：更新交易池</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.reset(<span class="literal">nil</span>, chain.CurrentBlock().Header())</span><br></pre></td></tr></table></figure>

<p>⑤：创建所有交易存储的列表，所有交易的价格用最小堆存放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.priced = newTxPricedList(pool.all)</span><br></pre></td></tr></table></figure>

<p>   通过排序，优先处理<code>gasprice</code>越高的交易。</p>
<p>⑥：如果本地交易开启 那么从本地磁盘加载本地交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑦：订阅链上事件消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>

<p>⑧：开启主循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> pool.loop()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：local交易比remote交易具有更高的权限，一是不轻易被替换；二是持久化，即通过一个本地的journal文件保存尚未打包的local交易。所以在节点启动的时候，优先从本地加载local交易。</p>
<p>本地地址会被加入白名单，凡由此地址发送的交易均被认为是local交易，不论是从本地递交还是从远端发送来的。</p>
</blockquote>
<p>到此为止交易池加载过程结束。</p>
<h2 id="添加交易到txpool"><a href="#添加交易到txpool" class="headerlink" title="添加交易到txpool"></a>添加交易到txpool</h2><p>之前我们说过交易池中交易的来源一方面是其他节点广播过来的，一方面是本地提交的，追根到源代码一个是<code>AddLocal</code>，一个是<code>AddRemote</code>,不管哪个都会调用<code>addTxs</code>。我们对添加交易的讨论就会从这个函数开始，它主要做了以下几件事,先用一张简图说明一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxhi23euj31ak0u0h34.jpg" alt="image-20201225104721173"></p>
<ol>
<li><p>过滤池中已经存在的交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(tx.Hash()) != <span class="literal">nil</span> &#123;</span><br><span class="line">  errs[i] = fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, tx.Hash())</span><br><span class="line">			knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将交易添加到队列中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newErrs, dirtyAddrs := pool.addTxsLocked(news, local)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入到addTxsLocked函数中：</span><br><span class="line">replaced, err := pool.add(tx, local)</span><br></pre></td></tr></table></figure>

<p>进入到 <code>pool.add</code>函数中，这个<code>add</code>函数相当重要，它是将交易添加到<code>queue</code>中，等待后面的promote，到<code>pending</code>中去。如果在<code>queue</code>或者<code>pending</code>中已经存在，并且它的gas price更高时，将覆盖之前的交易。下面来拆开的分析一下add 这个函数。</p>
<p>①：看交易是否收到过，如果已经收到过就丢弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding already known transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, hash)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果交易没通过验证也要丢弃，这里的重点是验证函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">validateTx: 主要做了以下几件事</span><br><span class="line">- 交易大小不能超过<span class="number">32</span>kb</span><br><span class="line">- 交易金额不能为负</span><br><span class="line">- 交易gas值不能超出当前交易池设定的gaslimit</span><br><span class="line">- 交易签名必须正确</span><br><span class="line">- 如果交易为远程交易，则需验证其gasprice是否小于交易池gasprice最小值，如果是本地，优先打包，不管gasprice</span><br><span class="line">- 判断当前交易nonce值是否过低</span><br><span class="line">- 交易所需花费的转帐手续费是否大于帐户余额  cost == V + GP * GL</span><br><span class="line">- 判断交易花费gas是否小于其预估花费gas</span><br></pre></td></tr></table></figure>

<p>③：如果交易池已满，丢弃价格过低的交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</span><br><span class="line">		<span class="keyword">if</span> !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		drop := pool.priced.Discard(pool.all.Count()-<span class="type">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue<span class="number">-1</span>), pool.locals)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</span><br><span class="line">			...</span><br><span class="line">			pool.removeTx(tx.Hash(), <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>注意这边的<code>GlobalSlots</code>和<code>GlobalQueue</code> ，就是我们说的<code>pending</code>和<code>queue</code>的最大容量，如果交易池的交易数超过两者之和，就要丢弃价格过低的交易。</p>
</li>
</ol>
<p>④：判断当前交易在pending队列中是否存在<code>nonce</code>值相同的交易。存在则判断当前交易所设置的<code>gasprice</code>是否超过设置的<code>PriceBump</code>百分比，超过则替换覆盖已存在的交易，否则报错返回<code>替换交易gasprice过低</code>，并且把它扔到<code>queue</code>队列中<code>(enqueueTx)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</span><br><span class="line"><span class="comment">// Nonce already pending, check if required price bump is met</span></span><br><span class="line"> 		inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line"><span class="keyword">if</span> !inserted &#123;</span><br><span class="line"> 			pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">// New transaction is better, replace old one</span></span><br><span class="line"> 		<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line"> 			pool.all.Remove(old.Hash())</span><br><span class="line"> 			pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"> 			pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		pool.all.Add(tx)</span><br><span class="line"> 		pool.priced.Put(tx)</span><br><span class="line"> 		pool.journalTx(from, tx)</span><br><span class="line"> 		pool.queueTxEvent(tx)</span><br><span class="line"> 		log.Trace(<span class="string">&quot;Pooled new executable transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;from&quot;</span>, from, <span class="string">&quot;to&quot;</span>, tx.To())</span><br><span class="line"> 		<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// New transaction isn&#x27;t replacing a pending one, push into queue</span></span><br><span class="line"> 	replaced, err = pool.enqueueTx(hash, tx)</span><br></pre></td></tr></table></figure>

<p>   添加交易的流程就到此为止了。接下来就是如何把<code>queue</code>（暂时不可执行）中添加的交易扔到<code>pending</code>（可执行交易）中，速成<code>promote</code>。</p>
<ol start="3">
<li><p>提升交易</p>
<p>提升交易主要把交易从<code>queue</code>扔到<code>pending</code>中，我们在接下来的里面重点讲</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done := pool.requestPromoteExecutables(dirtyAddrs)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="交易升级"><a href="#交易升级" class="headerlink" title="交易升级"></a>交易升级</h2><p><code>promoteExecutables</code>将<code>future queue</code>中的交易移动到<code>pending</code>中，同时也会删除很多无效交易比如<code>nonce</code>低或者余额低等等，主要分以下步骤：先看张图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxix54vaj313m0si4d2.jpg" alt="image-20201225104612253"></p>
<p>①：将所有<code>queue</code>中<code>nonce</code>低于账户当前<code>nonce</code>的交易从<code>all</code>里面删除</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">forwards := list.Forward(pool.currentState.GetNonce(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> forwards &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>②：将所有<code>queue</code>中花费大于账户余额 或者<code>gas</code>大于限制的交易从all里面删除</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：将所有可执行的交易从<code>queue</code>里面移到<code>pending</code>里面（<code>proteTx</code>）</p>
<p>注：可执行交易：将<code>pending</code>里面<code>nonce</code>值大于等于账户当前状态<code>nonce</code>的，且<code>nonce</code>连续的几笔交易作为准备好的交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readies := list.Ready(pool.pendingNonces.get(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> readies &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			<span class="keyword">if</span> pool.promoteTx(addr, hash, tx) &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Promoting queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				promoted = <span class="built_in">append</span>(promoted, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是 <strong>promoteTx</strong>的处理，这个方法与add的不同之处在于，<code>addTx</code>是获得到的<strong>新交易插入pending</strong>，而<code>promoteTx</code>是将<strong>queue列表中的Txs放入pending</strong>接下来我们先看看里面是如何来处理的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">	<span class="keyword">if</span> !inserted &#123;</span><br><span class="line">		<span class="comment">// An older transaction was better, discard this</span></span><br><span class="line">		<span class="comment">// 老的交易更好，删除这个交易</span></span><br><span class="line">		pool.all.Remove(hash)</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Otherwise discard any previous transaction and mark this</span></span><br><span class="line">	<span class="comment">// 现在这个交易更好，删除旧的交易</span></span><br><span class="line">	<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要就做了这几件事：</p>
<ol>
<li>将交易插入<code>pending</code>中，如果待插入的交易<code>nonce</code>在<code>pending</code>列表中存在，那么待插入的交易<code>gas price</code>大于或等于原交易价值的<code>110%（</code>跟<code>pricebump</code>设定有关）时，替换原交易</li>
<li>如果新交易替换了某个交易，从<code>all</code>列表中删除老交易</li>
<li>最后更新一下<code>all</code>列表</li>
</ol>
<p>经过<code>proteTx</code>之后，要扔到<code>pending</code>的交易都放在了<code>promoted []*types.Transaction</code>中，再回到<code>promoteExecutables</code>中，继续下面步骤：</p>
<p>④：如果非本地账户<code>queue</code>大于限制（<code>AccountQueue</code>），从最后取出<code>nonce</code>较大的交易进行<code>remove</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !pool.locals.contains(addr) &#123;</span><br><span class="line">			caps = list.Cap(<span class="type">int</span>(pool.config.AccountQueue))</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> caps &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				pool.all.Remove(hash)</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：最后如果队列中此账户的交易为空则删除此账户</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.queue, addr)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此我们的升级交易要做的事情就完毕了。</p>
<hr>
<h2 id="交易降级"><a href="#交易降级" class="headerlink" title="交易降级"></a>交易降级</h2><p>交易降级的几个场景：</p>
<ol>
<li>出现了新的区块，将会从<code>pending</code>中移除出现在区块中的交易到<code>queue</code>中</li>
<li>或者是另外一笔交易（<code>gas price</code> 更高）,则会从<code>pending</code>中移除到<code>queue</code>中</li>
</ol>
<p>关键函数：demoteUnexecutables，主要做的事情如下：</p>
<p>①：遍历<code>pending</code>中所有地址对应的交易列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure>

<p>②：删除所有认为过旧的交易（<code>low nonce</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">olds := list.Forward(nonce)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：删除所有费用过高的交易（余额低或用尽），并将所有无效者送到<code>queue</code>中以备后用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops))</span><br><span class="line">		pendingNofundsMeter.Mark(<span class="type">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Demoting pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.enqueueTx(hash, tx)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果交易前面有间隙，将后面的交易移到<code>queue</code>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Len() &gt; <span class="number">0</span> &amp;&amp; list.txs.Get(nonce) == <span class="literal">nil</span> &#123;</span><br><span class="line">			gapped := list.Cap(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(<span class="string">&quot;Demoting invalidated transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				pool.enqueueTx(hash, tx)</span><br><span class="line">			&#125;</span><br><span class="line">			pendingGauge.Dec(<span class="type">int64</span>(<span class="built_in">len</span>(gapped)))</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>注：间隙的出现通常是因为交易余额问题导致的。假如原规范链 A 上交易m花费10，分叉后该账户又在分叉链B发出一个交易m花费20，这就导致该账户余额本来可以支付A链上的某笔交易，但在B链上可能就不够了。这个余额不足的交易在B如果是n+3，那么在A链上n+2，n+4号交易之间就出现了空隙，这就导致从n+3开始往后所有的交易都要降级；</p>
<p>到此为止交易降级结束。</p>
<hr>
<h2 id="重置交易池"><a href="#重置交易池" class="headerlink" title="重置交易池"></a>重置交易池</h2><hr>
<p><strong>重置交易池</strong>将检索区块链的当前状态（主要由于更新导致链状态变化），并确保交易池的内容对于链状态而言是有效的。</p>
<p><code>reset</code>的调用时机如下：</p>
<ol>
<li><code>TxPool</code>初始化的过程：<code>NewTxPool</code>；</li>
<li><code>TxPool</code>事件监听<code>go</code>程收到规范链更新事件</li>
</ol>
<p>流程图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjq7vc6bz8j31260sodlq.jpg" alt="image-20201015185551752"></p>
<p>根据上面流程图，主要功能是由于规范链的更新，重新整理交易池：</p>
<p>①：<em>如果老区块头不为空 且老区块头不是新区块的父区块，说明新老区块不在一条链上</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> oldHead != <span class="literal">nil</span> &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>如果新头区块和旧头区块相差大于64，则所有交易不必回退到交易池</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> depth := <span class="type">uint64</span>(math.Abs(<span class="type">float64</span>(oldNum) - <span class="type">float64</span>(newNum))); depth &gt; <span class="number">64</span> &#123;</span><br><span class="line">  log.Debug(<span class="string">&quot;Skipping deep transaction reorg&quot;</span>, <span class="string">&quot;depth&quot;</span>, depth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：<em>如果旧链的头区块大于新链的头区块高度，旧链向后退并回收所有回退的交易</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>④：<em>如果新链的头区块大于旧链的头区块，新链后退并回收交易</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：<em>当新旧链到达同一高度的时候同时回退，知道找到共同的父节点</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.Hash() != add.Hash() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br></pre></td></tr></table></figure>

<p>⑥：<em>给交易池设置最新的世界状态</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to reset txpool state&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pool.currentState = statedb</span><br><span class="line">	pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">	pool.currentMaxGas = newHead.GasLimit</span><br></pre></td></tr></table></figure>

<p>⑦：<em>把旧链回退的交易放入交易池</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">senderCacher.<span class="built_in">recover</span>(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>到此整个<code>reset</code>的流程就结束了。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mindcarver/blockchain_guide">https://github.com/mindcarver/blockchain_guide</a> </p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0">https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lj900911/article/details/84825739">https://blog.csdn.net/lj900911/article/details/84825739</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/" class="post-title-link" itemprop="url">死磕以太坊源码分析之Trie树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:13:49" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>147</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之Trie树</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/" class="post-title-link" itemprop="url">死磕以太坊源码分析之state</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:13:35" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之state</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">｜-database.go 底层的存储设计</span><br><span class="line">｜-dump.go  用来dumpstateDB数据</span><br><span class="line">｜-iterator.go，用来遍历Trie</span><br><span class="line">｜-journal.go，用来记录状态的改变</span><br><span class="line">｜-state_object.go 通过state object操作账户值，并将修改后的storage trie写入数据库</span><br><span class="line">｜-statedb.go，以太坊整个的状态</span><br><span class="line">｜-sync.go，用来和downloader结合起来同步state</span><br></pre></td></tr></table></figure>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>以太坊的本质就是一个**基于交易的状态机(transaction-based state machine)**。在计算机科学中，一个 <em>状态机</em> 是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。</p>
<p>我们从**创世纪状态(genesis state)**开始，在网络中还没有任何交易的时候产生状态。当第一个区块执行第一个交易时候开始产生状态，直到执行完N个交易，第一个区块的最终状态产生，第二个区块的第一笔交易执行后将会改变第一个区块链的最终状态，以此类推，从而产生最终的区块状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkmt3uuo1j31g20hatb4.jpg" alt="image-20210112090020770"></p>
<h3 id="以太坊状态数据库"><a href="#以太坊状态数据库" class="headerlink" title="以太坊状态数据库"></a>以太坊状态数据库</h3><p>区块的状态数据并非保存在链上，而是将这些状态维护在默克尔压缩前缀树中，在区块链上仅记录对应的<code>Trie Root</code> 值。使用<code>LevelDB</code>维护树的持久化内容，而这个用来维护映射的数据库叫做 <code>StateDB</code>。</p>
<p>首先我们用一张图来大致了解一下<code>StateDB</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml0k9uv54j31c60g840z.jpg" alt="image-20210112165612767"></p>
<p>可以看到图中一共有两种状态，一个是世界状态<code>Trie</code>,一个是<code>storage Trie</code>,两者都是MPT树，世界状态包含了一个个的账户状态，账户状态通过以账户地址为键，维护在表示世界状态的树中，而每个账户状态中存储这账户存储树的<code>Root</code>。账户状态存储一下信息：</p>
<ol>
<li><strong>nonce</strong>: 表示此账户发出的交易数量</li>
<li><strong>balance</strong>: 账户余额 </li>
<li><strong>storageRoot</strong>:  账户存储树的Root根，用来存储合约信息</li>
<li><strong>codeHash</strong>: 账户的 EVM 代码哈希值，当这个地址接收到一个消息调用时，这些代码会被执行; 它和其它字段不同，创建后不可更改。如果 codeHash 为空，则说明该账户是一个简单的外部账户，只存在 <code>nonce</code> 和 <code>balance</code>。</li>
</ol>
<p>接下来将会分析State相关的一些类，着重关注<code>statedb.go、state_object.go、database.go</code>,其中涉及的Trie相关的代码可以参照：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a></p>
<h3 id="关键的数据结构"><a href="#关键的数据结构" class="headerlink" title="关键的数据结构"></a>关键的数据结构</h3><p><strong>Account</strong></p>
<p>Account存储的是账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span>      <span class="comment">//账户发出的交易数量</span></span><br><span class="line">	Balance  *big.Int    <span class="comment">// 账户的余额</span></span><br><span class="line">	Root     common.Hash <span class="comment">//账户存储树的Root根，用来存储合约信息</span></span><br><span class="line">	CodeHash []<span class="type">byte</span>      <span class="comment">// 账户的 EVM 代码哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StateObject</strong></p>
<p>表示一个状态对象，可以从中获取到账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	address  common.Address</span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">	dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存的第一个错误</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Write caches.</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	originStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	pendingStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">	dirtyStorage Storage </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StateDB</strong></p>
<p>用来存储状态对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">  db   Database</span><br><span class="line">	trie Trie <span class="comment">// 当前所有账户组成的MPT树</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这几个相关账户状态修改</span></span><br><span class="line">	stateObjects        <span class="keyword">map</span>[common.Address]*stateObject <span class="comment">// 存储缓存的账户状态信息</span></span><br><span class="line">	stateObjectsPending <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 状态对象已经完成但是还没有写入到Trie中</span></span><br><span class="line">	stateObjectsDirty   <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 在当前执行中修改的状态对象 ，用于后续commit </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三者之间的关系：</p>
<p>StateDB-&gt;Trie-&gt;Account-&gt;stateObject</p>
<p><strong>从StateDB中取出Trie根，根据地址从Trie树中获取账户的rlp编码数据，再进行解码成Account，然后根据Account生成stateObject</strong></p>
</blockquote>
<h2 id="StateDB存储状态"><a href="#StateDB存储状态" class="headerlink" title="StateDB存储状态"></a>StateDB存储状态</h2><p>StateDB读写状态主要关心以下几个文件：</p>
<ul>
<li>database.go</li>
<li>state_object.go</li>
<li>statedb.go</li>
</ul>
<p>接下来分别介绍这么几个文件，相当关键。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><h4 id="根据世界状态root打开世界状态树"><a href="#根据世界状态root打开世界状态树" class="headerlink" title="根据世界状态root打开世界状态树"></a>根据世界状态root打开世界状态树</h4><p>从<code>StateDB</code>中打开一个<code>Trie</code>大致经历以下过程：</p>
<blockquote>
<p>OpenTrie(root common.Hash)-&gt;NewSecure-&gt;New</p>
</blockquote>
<h4 id="根据账户地址和-stoage-root打开状态存储树"><a href="#根据账户地址和-stoage-root打开状态存储树" class="headerlink" title="根据账户地址和 stoage root打开状态存储树"></a>根据账户地址和 stoage root打开状态存储树</h4><p>创建一个账户的存储Trie过程如下：</p>
<blockquote>
<p>OpenStorageTrie(addrHash, root common.Hash)-&gt;NewSecure-New</p>
</blockquote>
<h4 id="Account和StateObject"><a href="#Account和StateObject" class="headerlink" title="Account和StateObject"></a>Account和StateObject</h4><p>以太坊的账户分为普通账户和合约账户,以<code>Account</code>表示，<code>Account</code>是账户的数据，不包含账户地址，账户需要使用地址来表示，地址在<code>stateObject</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span></span><br><span class="line">	Balance  *big.Int</span><br><span class="line">	Root     common.Hash <span class="comment">// 存储树的merkle树根 账户状态</span></span><br><span class="line">	CodeHash []<span class="type">byte</span> <span class="comment">//合约账户专属，合约代码编译后的Hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">  address  common.Address <span class="comment">// 账户地址</span></span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">  dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存存的第一个错误</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line">	originStorage Storage <span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	pendingStorage Storage <span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	dirtyStorage Storage <span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建StateObject"><a href="#创建StateObject" class="headerlink" title="创建StateObject"></a>创建StateObject</h4><p>创建状态对象会在两个地方进行调用：</p>
<ol>
<li>检索或者创建状态对象</li>
<li>创建账户</li>
</ol>
<p>最终都会去调用<code>createObject</code>创建一个新的状态对象。如果有一个现有的帐户给定的地址，老的将被覆盖并作为第二个返回值返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr)<span class="comment">// 如果存在老的，获取用来以后删除掉</span></span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="state-object-go"><a href="#state-object-go" class="headerlink" title="state_object.go"></a>state_object.go</h3><p><code>state_object.go</code>是很重要的文件，我们直接通过比较重要的函数来了解它。</p>
<h4 id="增加账户余额"><a href="#增加账户余额" class="headerlink" title="增加账户余额"></a>增加账户余额</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddBalance-&gt;SetBalance</span><br></pre></td></tr></table></figure>

<h4 id="将对象的存储树保存到db"><a href="#将对象的存储树保存到db" class="headerlink" title="将对象的存储树保存到db"></a>将对象的存储树保存到db</h4><p>主要就做了两件事：</p>
<ol>
<li><em>updateTrie将缓存的存储修改写入对象的存储Trie。</em> </li>
<li><em>将所有节点写入到trie的内存数据库中</em></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> CommitTrie(db Database) <span class="type">error</span> &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	...</span><br><span class="line">	root, err := s.trie.Commit(<span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一件事会在下面继续讲，第二件事可以参照我之前关于 <a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a>的讲解。</p>
<p>①：<strong>将缓存的存储修改写入对象的存储Trie</strong></p>
<blockquote>
<p>主要流程： 最终还是调用了trie.go的insert方法</p>
<p>updateTrie-&gt;TryUpdate-&gt;insert</p>
</blockquote>
<ol>
<li><code>s.finalise()</code> 将<code>dirtyStorage</code>中的所有数据移动到<code>pendingStorage</code>中</li>
<li>根据账户哈希和账户<code>root</code>打开账户存储树</li>
<li>将<code>key</code>与<code>trie</code>中的<code>value</code>关联，更新数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateTrie(db Database) Trie &#123;</span><br><span class="line">	s.finalise() ①</span><br><span class="line">...</span><br><span class="line">	</span><br><span class="line">	tr := s.getTrie(db) ②</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> s.pendingStorage &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (value == common.Hash&#123;&#125;) &#123;</span><br><span class="line">			s.setError(tr.TryDelete(key[:]))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		s.setError(tr.TryUpdate(key[:], v)) ③</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个核心也就是<code>updateTrie</code>，调用了<code>trie</code>的<code>insert</code>方法进行处理。</p>
<p>②：<strong>将所有节点写入到trie的内存数据库，其key以sha3哈希形式存储</strong></p>
<blockquote>
<p>流程：</p>
<p>trie.Commit-&gt;t.trie.Commit-&gt;t.hashRoot</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SecureTrie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.getSecKeyCache()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t.trie.db.lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> hk, key := <span class="keyword">range</span> t.secKeyCache &#123;</span><br><span class="line">			t.trie.db.insertPreimage(common.BytesToHash([]<span class="type">byte</span>(hk)), key)</span><br><span class="line">		&#125;</span><br><span class="line">		t.trie.db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		t.secKeyCache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.trie.Commit(onleaf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>KeyCache</code>中已经有了，直接插入到磁盘数据库，否则的话插入到<code>Trie</code>的内存数据库。</p>
<h4 id="将trie根设置为的当前根哈希"><a href="#将trie根设置为的当前根哈希" class="headerlink" title="将trie根设置为的当前根哈希"></a>将trie根设置为的当前根哈希</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateRoot(db Database) &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.db.StorageHashes += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	s.data.Root = s.trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法也比较简单，底层调用<code>UpdateTrie</code>然后再更新<code>root</code>.</p>
<p><code>State_object.go</code>的核心方法也就这么些内容。</p>
<h3 id="statedb-go"><a href="#statedb-go" class="headerlink" title="statedb.go"></a>statedb.go</h3><h4 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h4><p>创建账户的核心就是创建状态对象，然后再初始化值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> CreateAccount(addr common.Address) &#123;</span><br><span class="line">	newObj, prev := s.createObject(addr)</span><br><span class="line">	<span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		newObj.setBalance(prev.data.Balance)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr) </span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除、更新、获取状态对象"><a href="#删除、更新、获取状态对象" class="headerlink" title="删除、更新、获取状态对象"></a>删除、更新、获取状态对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> deleteStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> updateStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getStateObject(obj *stateObject) &#123;</span><br></pre></td></tr></table></figure>

<p>这三个方法底层分别都是调用<code>Trie.TryDelete、Trie.TryUpdate、Trie.TryGet</code>方法来分别获取。</p>
<p>这里大致的讲一下<code>getStateObject</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getDeletedStateObject(addr common.Address) *stateObject &#123;</span><br><span class="line">	<span class="comment">// Prefer live objects if any is available</span></span><br><span class="line">	<span class="keyword">if</span> obj := s.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> obj</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on loading the object from the database</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.AccountReads += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Load the object from the database</span></span><br><span class="line">	enc, err := s.trie.TryGet(addr[:])</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">		s.setError(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> data Account</span><br><span class="line">	<span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Insert into the live set</span></span><br><span class="line">	obj := newObject(s, addr, data)</span><br><span class="line">	s.setStateObject(obj)</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致就做了以下几件事：</p>
<ol>
<li>先从<code>StateDB</code>中获取<code>stateObjects</code>,有的话就返回。</li>
<li>如果没有的话就从<code>stateDB</code>的<code>trie</code>中获取账户状态数据，获取到<code>rlp</code>编码的数据之后，将其解码。</li>
<li>根据状态数据<code>Account</code> 构造<code>stateObject</code></li>
</ol>
<h4 id="余额操作"><a href="#余额操作" class="headerlink" title="余额操作"></a>余额操作</h4><p>余额的操作大致有添加、减少、和设定。我们就拿添加来分析：</p>
<p>根据地址获取<code>stateObject</code>，然后<code>addBalance</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> AddBalance(addr common.Address, amount *big.Int) &#123;</span><br><span class="line">	stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.AddBalance(amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="储存快照和回退快照"><a href="#储存快照和回退快照" class="headerlink" title="储存快照和回退快照"></a>储存快照和回退快照</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Snapshot() <span class="type">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> RevertToSnapshot(revid <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>储存快照和回退快照，我们可以在提交交易的流程中找到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">	snap := w.current.state.Snapshot()</span><br><span class="line"></span><br><span class="line">	receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	w.current.txs = <span class="built_in">append</span>(w.current.txs, tx)</span><br><span class="line">	w.current.receipts = <span class="built_in">append</span>(w.current.receipts, receipt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> receipt.Logs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们会对当前状态进行快照，然后执行<code>ApplyTransaction</code>，如果在预执行交易的阶段出错了，那么会回退到备份的快照位置。之前的修改全部会回退。</p>
<h4 id="计算状态Trie的当前根哈希"><a href="#计算状态Trie的当前根哈希" class="headerlink" title="计算状态Trie的当前根哈希"></a>计算状态Trie的当前根哈希</h4><p>计算状态Trie的当前根哈希是由<code>IntermediateRoot</code>来完成的。</p>
<p>①：<strong>确定所有的脏存储状态（简单理解就是当前执行修改的所有对象）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Finalise(deleteEmptyObjects <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;</span><br><span class="line">		obj, exist := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> !exist &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> obj.suicided || (deleteEmptyObjects &amp;&amp; obj.empty()) &#123;</span><br><span class="line">			obj.deleted = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.finalise()</span><br><span class="line">		&#125;</span><br><span class="line">		s.stateObjectsPending[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.clearJournalAndRefund()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个跟<code>state_object</code>的<code>finalise</code>方法是一个方式，底层就是调用了<code>obj.finalise</code>将<code>dirty</code>状态的所有数据全部推入到<code>pending</code>中去，等待处理。</p>
<p>②：<strong>处理stateObjectsPending中的数据</strong></p>
<p>先更新账户的<code>Root</code>根，然后再将将给定的对象写入<code>trie</code>。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsPending &#123;</span><br><span class="line">		obj := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line">			s.deleteStateObject(obj)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.updateRoot(s.db)</span><br><span class="line">			s.updateStateObject(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将状态写入底层内存Trie数据库"><a href="#将状态写入底层内存Trie数据库" class="headerlink" title="将状态写入底层内存Trie数据库"></a>将状态写入底层内存Trie数据库</h4><p>这部分功能由commit方法完成。</p>
<ol>
<li>计算状态Trie的当前根哈希</li>
<li>将状态对象中的所有更改写入到存储树</li>
</ol>
<p>第一步在上面已经讲过了，第二步的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsDirty &#123;</span><br><span class="line">		<span class="keyword">if</span> obj := s.stateObjects[addr]; !obj.deleted &#123;</span><br><span class="line">			....</span><br><span class="line">			<span class="keyword">if</span> err := obj.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是<code>objectCommitTrie</code>,这也是上面<code>state_object</code>的内容。</p>
<p>总结流程如下：</p>
<blockquote>
<p>1.IntermediateRoot</p>
<p>2.CommitTrie-&gt;updateTrie-&gt;trie.Commit-&gt;trie.db.insertPreimage(已经有了直接持久化到硬盘数据库)</p>
<p>​														  -&gt;t.trie.Commit（没有就提交到存储树中）</p>
</blockquote>
<p>最后看一下以太坊数据库的读写过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmlw6izetsj31ha0oogom.jpg" alt="image-20210113111013494"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/20d7f7c37b03">https://www.jianshu.com/p/20d7f7c37b03</a></p>
<p><a target="_blank" rel="noopener" href="https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033">https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033</a></p>
<p><a target="_blank" rel="noopener" href="https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf">https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ltk100.com/article-112-1.html">http://www.ltk100.com/article-112-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/" class="post-title-link" itemprop="url">死磕以太坊源码分析之MPT树-下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:13:23" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之MPT树-下</p>
<p>文章以及资料请查看：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">上篇</a>主要介绍了以太坊中的MPT树的原理，这篇主要会对MPT树涉及的源码进行拆解分析。<code>trie</code>模块主要有以下几个文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-encoding.<span class="keyword">go</span> 主要讲编码之间的转换</span><br><span class="line">|-hasher.<span class="keyword">go</span> 实现了从某个结点开始计算子树的哈希的功能</span><br><span class="line">|-node.<span class="keyword">go</span> 定义了一个Trie树中所有结点的类型和解析的代码</span><br><span class="line">|-sync.<span class="keyword">go</span> 实现了SyncTrie对象的定义和所有方法</span><br><span class="line">|-iterator.<span class="keyword">go</span> 定义了所有枚举相关接口和实现</span><br><span class="line">|-secure_trie.<span class="keyword">go</span> 实现了SecureTrie对象</span><br><span class="line">|-proof.<span class="keyword">go</span> 为key构造一个merkle证明</span><br><span class="line">|-trie.<span class="keyword">go</span> Trie树的增删改查</span><br><span class="line">|-database.<span class="keyword">go</span> 对内存中的trie树节点进行引用计数</span><br></pre></td></tr></table></figure>



<h2 id="实现概览"><a href="#实现概览" class="headerlink" title="实现概览"></a>实现概览</h2><h3 id="encoding-go"><a href="#encoding-go" class="headerlink" title="encoding.go"></a>encoding.go</h3><p>这个主要是讲三种编码（<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>）的实现与转换，<code>trie</code>中全程都需要用到这些，该文件中主要实现了如下功能：</p>
<ol>
<li>hex编码转换为Compact编码：<code>hexToCompact()</code></li>
<li>Compact编码转换为hex编码：<code>compactToHex()</code></li>
<li>keybytes编码转换为Hex编码：<code>keybytesToHex()</code></li>
<li>hex编码转换为keybytes编码：<code>hexToKeybytes()</code></li>
<li>获取两个字节数组的公共前缀的长度：<code>prefixLen()</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    terminator := <span class="type">byte</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123; <span class="comment">//检查是否有结尾为0x10 =&gt; 16</span></span><br><span class="line">        terminator = <span class="number">1</span> <span class="comment">//有结束标记16说明是叶子节点</span></span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//去除尾部标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>) <span class="comment">// 字节数组</span></span><br><span class="line">    </span><br><span class="line">    buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// 标志byte为00000000或者00100000</span></span><br><span class="line">    <span class="comment">//如果长度为奇数，添加奇数位标志1，并把第一个nibble字节放入buf[0]的低四位</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">// 奇数标志 00110000</span></span><br><span class="line">        buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// 第一个nibble包含在第一个字节中 0011xxxx</span></span><br><span class="line">        hex = hex[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将两个nibble字节合并成一个字节</span></span><br><span class="line">    decodeNibbles(hex, buf[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将十六进制的bibbles转成key bytes，这只能用于偶数长度的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToKeybytes</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123;</span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can&#x27;t convert hex key of odd length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    key := <span class="built_in">make</span>([]<span class="type">byte</span>, (<span class="built_in">len</span>(hex)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    decodeNibbles(hex, key)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回a和b的公共前缀的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixLen</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, length = <span class="number">0</span>, <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; length &#123;</span><br><span class="line">        length = <span class="built_in">len</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i] != b[i] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="node-go"><a href="#node-go" class="headerlink" title="node.go"></a>node.go</h3><h4 id="四种节点"><a href="#四种节点" class="headerlink" title="四种节点"></a>四种节点</h4><p>node 接口分四种实现: fullNode，shortNode，valueNode，hashNode，其中只有 fullNode 和 shortNode 可以带有子节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123;</span><br><span class="line">		Children [<span class="number">17</span>]node <span class="comment">// 分支节点</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123; <span class="comment">//扩展节点</span></span><br><span class="line">		Key   []<span class="type">byte</span></span><br><span class="line">		Val   node <span class="comment">//可能指向叶子节点，也可能指向分支节点。</span></span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="type">byte</span></span><br><span class="line">	valueNode []<span class="type">byte</span> <span class="comment">// 叶子节点值，但是该叶子节点最终还是会包装在shortNode中</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="trie-go"><a href="#trie-go" class="headerlink" title="trie.go"></a>trie.go</h3><p>Trie对象实现了MPT树的所有功能，包括(key, value)对的增删改查、计算默克尔哈希，以及将整个树写入数据库中。</p>
<h3 id="iterator-go"><a href="#iterator-go" class="headerlink" title="iterator.go"></a>iterator.go</h3><p><code>nodeIterator</code>提供了遍历树内部所有结点的功能。其结构如下：此结构体是在<code>trie.go</code>定义的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	trie.NodeIterator</span><br><span class="line">	t   *odrTrie</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面包含了一个接口<code>NodeIterator</code>，它的实现则是由<code>iterator.go</code>来提供的，其方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Next(descend <span class="type">bool</span>) <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Hash() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Parent() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Leaf() <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafKey() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafBlob() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafProof() [][]<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Path() []<span class="type">byte</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> seek(prefix []<span class="type">byte</span>) <span class="type">error</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> peek(descend <span class="type">bool</span>) (*nodeIteratorState, *<span class="type">int</span>, []<span class="type">byte</span>, <span class="type">error</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> nextChild(parent *nodeIteratorState, ancestor common.Hash) (*nodeIteratorState, []<span class="type">byte</span>, <span class="type">bool</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> push(state *nodeIteratorState, parentIndex *<span class="type">int</span>, path []<span class="type">byte</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> pop() </span><br></pre></td></tr></table></figure>

<p><code>NodeIterator</code>的核心是<code>Next</code>方法，每调用一次这个方法，NodeIterator对象代表的当前节点就会更新至下一个节点，当所有结点遍历结束，<code>Next</code>方法返回<code>false</code>。</p>
<p>生成NodeIterator结口的方法有以下3种：</p>
<p><strong>①：Trie.NodeIterator(start []byte)</strong></p>
<p>通过<code>start</code>参数指定从哪个路径开始遍历，如果为<code>nil</code>则从头到尾按顺序遍历。</p>
<p><strong>②：NewDifferenceIterator(a, b NodeIterator)</strong></p>
<p>当调用<code>NewDifferenceIterator(a, b NodeIterator)</code>后，生成的<code>NodeIterator</code>只遍历存在于 b 但不存在于 a 中的结点。</p>
<p><strong>③：NewUnionIterator(iters []NodeIterator)</strong></p>
<p>当调用<code>NewUnionIterator(its []NodeIterator)</code>后，生成的<code>NodeIterator</code>遍历的结点是所有传入的结点的合集。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><p><code>Database</code>是<code>trie</code>模块对真正数据库的缓存层，其目的是对缓存的节点进行引用计数，从而实现区块的修剪功能。主要方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(diskdb ethdb.KeyValueStore)</span></span> *Database</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabaseWithCache</span><span class="params">(diskdb ethdb.KeyValueStore, cache <span class="type">int</span>)</span></span> *Database </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> DiskDB() ethdb.KeyValueReader</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> InsertBlob(hash common.Hash, blob []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insert(hash common.Hash, blob []<span class="type">byte</span>, node node)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insertPreimage(hash common.Hash, preimage []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> node(hash common.Hash) node</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Node(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> preimage(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> secureKey(key []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Nodes() []common.Hash</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Reference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Dereference(root common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> dereference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Cap(limit common.StorageSize) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Commit(node common.Hash, report <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h3 id="security-trie-go"><a href="#security-trie-go" class="headerlink" title="security_trie.go"></a>security_trie.go</h3><p>可以理解为加密了的<code>trie</code>的实现，<code>ecurity_trie</code>包装了一下<code>trie</code>树， 所有的<code>key</code>都转换成<code>keccak256</code>算法计算的<code>hash</code>值。同时在数据库里面存储<code>hash</code>值对应的原始的<code>key</code>。<br>但是官方在代码里也注释了，这个代码不稳定，除了测试用例，别的地方并没有使用该代码。</p>
<h3 id="proof-go"><a href="#proof-go" class="headerlink" title="proof.go"></a>proof.go</h3><ul>
<li>Prove()：根据给定的<code>key</code>，在<code>trie</code>中，将满足<code>key</code>中最大长度前缀的路径上的节点都加入到<code>proofDb</code>（队列中每个元素满足：未编码的hash以及对应<code>rlp</code>编码后的节点）</li>
<li>VerifyProof()：验证<code>proffDb</code>中是否存在满足输入的<code>hash</code>，和对应key的节点，如果满足，则返回<code>rlp</code>解码后的该节点。</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Trie对象的增删改查"><a href="#Trie对象的增删改查" class="headerlink" title="Trie对象的增删改查"></a>Trie对象的增删改查</h3><p>①：<strong>Trie树的初始化</strong></p>
<p>如果<code>root</code>不为空，就通过<code>resolveHash</code>来加载整个<code>Trie</code>树，如果为空，就新建一个<code>Trie</code>树。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span></span> (*Trie, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db: db,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root != (common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<strong>Trie树的插入</strong></p>
<p>首先Trie树的插入是个递归调用的过程，它会从根开始找，一直找到合适的位置插入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>n: 当前要插入的节点</li>
<li>prefix: 当前已经处理完的<strong>key</strong>(节点共有的前缀)</li>
<li>key: 未处理完的部分<strong>key</strong>，完整的<code>key = prefix + key</code></li>
<li>value：需要插入的值</li>
</ul>
<p>返回值说明：</p>
<ul>
<li>bool : 操作是否改变了<strong>Trie</strong>树(<strong>dirty</strong>)</li>
<li>Node :插入完成后的子树的根节点</li>
</ul>
<p>接下来就是分别对<code>shortNode</code>、<code>fullNode</code>、<code>hashNode</code>、<code>nil</code> 几种情况进行说明。</p>
<p><strong>2.1：节点为nil</strong></p>
<p>空树直接返回<code>shortNode</code>， 此时整颗树的根就含有了一个<code>shortNode</code>节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2 ：节点为shortNode</strong></p>
<ul>
<li><p>首先计算公共前缀，如果公共前缀就等于<code>key</code>，那么说明这两个<code>key</code>是一样的，如果<code>value</code>也一样的(<code>dirty == false</code>)，那么返回错误。</p>
</li>
<li><p>如果没有错误就更新<code>shortNode</code>的值然后返回</p>
</li>
<li><p>如果公共前缀不完全匹配，那么就需要把公共前缀提取出来形成一个独立的节点(扩展节点),扩展节点后面连接一个<code>branch</code>节点，<code>branch</code>节点后面看情况连接两个<code>short</code>节点。</p>
</li>
<li><p>首先构建一个branch节点(branch :&#x3D; &amp;fullNode{flags: t.newFlag()}),然后再branch节点的Children位置调用t.insert插入剩下的两个short节点</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">matchlen := prefixLen(key, n.Key)</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</span><br><span class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.3: 节点为fullNode</strong></p>
<p>节点是<code>fullNode</code>(也就是分支节点)，那么直接往对应的孩子节点调用<code>insert</code>方法,然后把对应的孩子节点指向新生成的节点。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">		&#125;</span><br><span class="line">		n = n.<span class="built_in">copy</span>()</span><br><span class="line">		n.flags = t.newFlag()</span><br><span class="line">		n.Children[key[<span class="number">0</span>]] = nn</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.4: 节点为hashnode</strong></p>
<p>暂时还在数据库中的节点，先调用 <code>t.resolveHash(n, prefix)</code>来加载到内存，然后调用<code>insert</code>方法来插入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rn, err := t.resolveHash(n, prefix)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<strong>Trie树查询值</strong></p>
<p>其实就是根据输入的<code>hash</code>，找到对应的叶子节点的数据。主要看<code>TryGet</code>方法。</p>
<p>参数：</p>
<ul>
<li><code>origNode</code>：当前查找的起始<strong>node</strong>位置</li>
<li><code>key</code>：输入要查找的数据的<strong>hash</strong></li>
<li><code>pos</code>：当前<strong>hash</strong>匹配到第几位</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> tryGet(origNode node, key []<span class="type">byte</span>, pos <span class="type">int</span>) (value []<span class="type">byte</span>, newnode node, didResolve <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//表示当前trie是空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> valueNode: <span class="comment">////这就是我们要查找的叶子节点对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> *shortNode: <span class="comment">////在叶子节点或者扩展节点匹配</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Val = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> *fullNode:<span class="comment">//在分支节点匹配</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Children[key[pos]] = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//说明当前节点是轻节点，需要从db中获取</span></span><br><span class="line">		child, err := t.resolveHash(n, key[:pos])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</span><br><span class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>didResolve</code>用于判断<code>trie</code>树是否会发生变化，<code>tryGet()</code>只是用来获取数据的，当<code>hashNode</code>去<code>db</code>中获取该<code>node</code>值后需要更新现有的trie，<code>didResolve</code>就会发生变化。其他就是基本的递归查找树操作。</p>
<p>④：<strong>Trie树更新值</strong></p>
<p>更新值，其实就是调用insert方法进行操作。</p>
<p>到此Trie树的增删改查就讲解的差不多了。</p>
<h3 id="将节点写入到Trie的内存数据库"><a href="#将节点写入到Trie的内存数据库" class="headerlink" title="将节点写入到Trie的内存数据库"></a>将节点写入到Trie的内存数据库</h3><p>如果要把节点写入到内存数据库，需要序列化，可以先去了解下以太坊的Rlp编码。这部分工作由<code>trie.Commit()</code>完成，当<code>trie.Commit(nil)</code>，会执行序列化和缓存等操作，序列化之后是使用的<code>Compact Encoding</code>进行编码，从而达到节省空间的目的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;commit called on trie with nil database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.root = cached</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大概讲了这些：</p>
<ul>
<li>每次执行<code>Commit()</code>，该trie的<code>cachegen</code>就会加 1</li>
<li><code>Commit()</code>方法返回的是<code>trie.root</code>所指向的<code>node</code>的<code>hash</code>（未编码）</li>
<li>其中的<code>hashRoot()</code>方法目的是<code>返回trie.root所指向的node的hash</code>以及<code>每个节点都带有各自hash的trie树的root</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为每个node生成一个hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> hashRoot(db *Database, onleaf LeafCallback) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	h := newHasher(onleaf)</span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</span><br><span class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>) <span class="comment">//为每个节点生成一个未编码的hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>hashRoot</code>的核心方法就是 <code>h.hash</code>，它返回了头节点的<code>hash</code>以及每个子节点都带有<code>hash</code>的头节点（Trie.root指向它），大致做了以下几件事：</p>
<p>①：<em>如果我们不存储节点，而只是哈希，则从缓存中获取数据</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dirty &#123;</span><br><span class="line">			<span class="keyword">switch</span> n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *fullNode, *shortNode:</span><br><span class="line">				<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>递归调用<code>h.hashChildren</code>，求出所有的子节点的<code>hash</code>值，再把原有的子节点替换成现在子节点的<code>hash</code>值</em></p>
<p><strong>2.1:如果节点是<code>shortNode</code></strong></p>
<p>首先把<code>collapsed.Key从Hex Encoding</code> 替换成 <code>Compact Encoding</code>, 然后递归调用<code>hash</code>方法计算子节点的<code>hash</code>和<code>cache</code>，从而把子节点替换成了子节点的<code>hash</code>值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line">		collapsed.Key = hexToCompact(n.Key)</span><br><span class="line">		cached.Key = common.CopyBytes(n.Key)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</span><br><span class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> original, original, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2:节点是fullNode</strong></p>
<p> 遍历每个子节点，把子节点替换成子节点的<code>Hash</code>值，否则的化这个节点没有<code>children</code>。直接返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">		collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> original, original, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</span><br><span class="line"><span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<em>存储节点n的哈希值，如果我们指定了存储层，它会写对应的键&#x2F;值对</em></p>
<p>store()方法主要就做了两件事：</p>
<ul>
<li><code>rlp</code>序列化<code>collapsed</code>节点并将其插入db磁盘中</li>
<li>生成当前节点的<code>hash</code></li>
<li>将节点哈希插入<code>db</code></li>
</ul>
<p><strong>3.1：空数据或者hashNode，则不处理</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2:生成节点的RLP编码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">h.tmp.Reset()                                 <span class="comment">// 缓存初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := rlp.Encode(&amp;h.tmp, n); err != <span class="literal">nil</span> &#123; <span class="comment">//将当前node序列化</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;encode error: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.tmp) &lt; <span class="number">32</span> &amp;&amp; !force &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">// Nodes smaller than 32 bytes are stored inside their parent 编码后的node长度小于32，若force为true，则可确保所有节点都被编码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//长度过大的，则都将被新计算出来的hash取代</span></span><br><span class="line">	hash, _ := n.cache() <span class="comment">//取出当前节点的hash</span></span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		hash = h.makeHashNode(h.tmp) <span class="comment">//生成哈希node</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3:将Trie节点合并到中间内存缓存中</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hash := common.BytesToHash(hash)</span><br><span class="line">		db.lock.Lock()</span><br><span class="line">		db.insert(hash, h.tmp, n)</span><br><span class="line">		db.lock.Unlock()</span><br><span class="line">		<span class="comment">// Track external references from account-&gt;storage trie</span></span><br><span class="line">		<span class="comment">//跟踪帐户-&gt;存储Trie中的外部引用</span></span><br><span class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *shortNode:</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok &#123;  <span class="comment">//指向的是分支节点</span></span><br><span class="line">					h.onleaf(child, hash) <span class="comment">//用于统计当前节点的信息，比如当前节点有几个子节点，当前有效的节点数</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> *fullNode:</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</span><br><span class="line">						h.onleaf(child, hash)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止将节点写入到<code>Trie</code>的内存数据库就已经完成了。</p>
<p><em>如果觉得文章不错可以关注公众号：<strong>区块链技术栈</strong>，详细的所有以太坊源码分析文章内容以及代码资料都在其中。</em></p>
<h3 id="Trie树缓存机制"><a href="#Trie树缓存机制" class="headerlink" title="Trie树缓存机制"></a>Trie树缓存机制</h3><p><code>Trie</code>树的结构里面有两个参数， 一个是<code>cachegen</code>,一个是<code>cachelimit</code>。这两个参数就是<code>cache</code>控制的参数。 <code>Trie</code>树每一次调用<code>Commit</code>方法，会导致当前的<code>cachegen</code>增加1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">    t.cachegen++</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>Trie</code>树插入的时候，会把当前的<code>cachegen</code>存放到节点中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> newFlag() nodeFlag &#123;</span><br><span class="line">    <span class="keyword">return</span> nodeFlag&#123;dirty: <span class="literal">true</span>, gen: t.cachegen&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>trie.cachegen - node.cachegen &gt; cachelimit</code>，就可以把节点从内存里面拿掉。 也就是说节点经过几次<code>Commit</code>，都没有修改，那么就把节点从内存里面干掉。 只要<code>trie</code>路径上新增或者删除一个节点，整个路径的节点都需要重新实例化，也就是节点中的<code>nodeFlag</code>被初始化了。都需要重新更新到<code>db</code>磁盘。</p>
<p>拿掉节点过程在 <code>hasher.hash</code>方法中， 这个方法是在<code>commit</code>的时候调用。如果方法的<code>canUnload</code>方法调用返回真，那么就拿掉节点，如果只返回了<code>hash</code>节点，而没有返回<code>node</code>节点，这样节点就没有引用，不久就会被gc清除掉。 节点被拿掉之后，会用一个<code>hashNode</code>节点来表示这个节点以及其子节点。 如果后续需要使用，可以通过方法把这个节点加载到内存里面来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> hash(n node, db *Database, force <span class="type">bool</span>) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">   	....</span><br><span class="line">       <span class="comment">// 从缓存中卸载节点。它的所有子节点将具有较低或相等的缓存世代号码。</span></span><br><span class="line">       cacheUnloadCounter.Inc(<span class="number">1</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考-总结"><a href="#参考-总结" class="headerlink" title="参考&amp;总结"></a>参考&amp;总结</h2><p>这部分重要的内容也就上面讲述的，主要集中在<code>Trie</code>上面，如果有不对的地方，可以及时指正哦。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/about/">https://mindcarver.cn/about/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/" class="post-title-link" itemprop="url">死磕以太坊源码分析之MPT树-上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:13:10" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之MPT树-上</p>
</blockquote>
<h2 id="前缀树Trie"><a href="#前缀树Trie" class="headerlink" title="前缀树Trie"></a>前缀树Trie</h2><p>前缀树（又称字典树），通常来说，一个前缀树是用来<code>存储字符串</code>的。前缀树的每一个节点代表一个<code>字符串</code>（<code>前缀</code>）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>组成的。如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm73i6xursj31820qq789.jpg" alt="image-20201231160000592"></p>
<p>Trie的结点看上去是这样子的：</p>
<blockquote>
<p>[ [Ia, Ib, … I*], value]</p>
</blockquote>
<p>其中 <code>[Ia, Ib, ... I*]</code> 在本文中我们将其称为结点的 <em>索引数组</em> ，它以 key 中的下一个字符为索引，每个元素<code>I*</code>指向对应的子结点。 <code>value</code> 则代表从根节点到当前结点的路径组成的key所对应的值。如果不存在这样一个 key，则 value 的值为空。</p>
<p>前缀树的性质：</p>
<ol>
<li><p>每一层节点上面的值都不相同；</p>
</li>
<li><p>根节点不存储值；除根节点外每一个节点都<strong>只包含一个字符</strong>，代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>。</p>
</li>
<li><p>前缀树的查找效率是$O(m)$，$m$为所查找节点的长度，而哈希表的查找效率为$O(1)$。且一次查找会有 m 次 <code>IO</code>开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
</li>
<li><p>当存在一个节点，其内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
</li>
</ol>
<h2 id="压缩前缀树Patricia-Tree"><a href="#压缩前缀树Patricia-Tree" class="headerlink" title="压缩前缀树Patricia Tree"></a>压缩前缀树Patricia Tree</h2><p><strong>基数树</strong>（也叫<strong>基数特里树</strong>或<strong>压缩前缀树</strong>）是一种数据结构，是一种更节省空间的<strong>前缀树</strong>，其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数 <em>r</em> ，其中 <em>r</em> 为正整数， <em>x</em> 为 2 的幂， <em>x</em>≥1 ，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70dwcmgdj31780kkqae.jpg" alt="image-20201231133805927"></p>
<p>图中可以很容易看出数中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<h2 id="默克尔树Merkle-Tree"><a href="#默克尔树Merkle-Tree" class="headerlink" title="默克尔树Merkle Tree"></a>默克尔树Merkle Tree</h2><p>Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm69qu5vh8j31ba0ragpn.jpg" alt="image-20201230225028932"></p>
<p>在构造<code>Merkle</code>树时，首先要计算数据块的哈希值，通常，选用<code>SHA-256</code>等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如<code>CRC</code>。然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希，再重复这个步骤，一直到计算出根哈希值。</p>
<p>所以我们可以简单总结出<strong>merkle Tree</strong> 有以下几个性质：</p>
<ul>
<li>校验整体数据的正确性</li>
<li>快速定位错误</li>
<li>快速校验部分数据是否在原始的数据中</li>
<li>存储空间开销大（<strong>大量中间哈希</strong>）</li>
</ul>
<h2 id="以太坊的改进方案"><a href="#以太坊的改进方案" class="headerlink" title="以太坊的改进方案"></a>以太坊的改进方案</h2><h3 id="使用-byte作为key类型"><a href="#使用-byte作为key类型" class="headerlink" title="使用[]byte作为key类型"></a>使用[]byte作为key类型</h3><p>在以太坊的Trie模块中，key和value都是[]byte类型。如果要使用其它类型，需要将其转换成[]byte类型（比如使用<strong>rlp</strong>进行转换）。</p>
<p><strong>Nibble</strong> ：是 key 的基本单元，是一个四元组（四个 bit 位的组合例如二进制表达的 0010 就是一个四元组）</p>
<p>在Trie模块对外提供的接口中，key类型是[]byte。但在内部实现里，将key中的每个字节按高4位和低4位拆分成了两个字节。比如你传入的key是：</p>
<blockquote>
<p>[0x1a, 0x2b, 0x3c, 0x4d]</p>
</blockquote>
<p>Trie内部将这个key拆分成：</p>
<blockquote>
<p>[0x1, 0xa, 0x2, 0xb, 0x3, 0xc, 0x4, 0xd]</p>
</blockquote>
<p>Trie内部的编码中将拆分后的<strong>每一个字节</strong>称为 <strong>nibble</strong></p>
<p>如果使用一个完整的 byte 作为 key 的最小单位，那么前文提到的索引数组的大小应该是 256（byte作为数组的索引，最大值为255，最小值为0）。而索引数组的每个元素都是一个 32 字节的哈希,这样每个结点要占用大量的空间。并且索引数组中的元素多数情况下是空的，不指向任何结点。因此这种实现方法占用大量空间而不使用。以太坊的改进方法，可以将索引数组的大小降为 16（4个bit的最大值为0xF，最小值为 0），因此大大减少空间的浪费。</p>
<h3 id="新增类型节点"><a href="#新增类型节点" class="headerlink" title="新增类型节点"></a>新增类型节点</h3><p>前缀树和<code>merkle</code>树存在明显的局限性，所以以太坊为<code>MPT</code>树新增了几种不同类型的树节点，通过针对不同节点不同操作来解决效率以及存储上的问题。</p>
<ol>
<li><strong>shortNode</strong>: 叶子节点或者扩展节点，当 <code>shortNode.Key</code>的末尾字节是终止符 <code>16</code> 时表示为叶子节点。当 <code>shortNode</code> 是叶子节点是，<code>Val</code> 是 valueNode。</li>
<li><strong>fullNode</strong>:  分支节点，<code>fullNode[16]</code>的类型是 <code>valueNode</code>。前 16 个元素对应键中可能存在的一个十六进制字符。如果键<code>[key,value]</code>在对应的分支处结束，则在列表末尾存储 <code>value</code> 。</li>
<li><strong>hashNode</strong>: 应该取名为 <code>collapsedNode</code> 折叠节点更合适些，但因为其值是一个哈希值当做指针使用，所以取名 <code>hashNode</code>。使用这个哈希值可以从数据库读取节点数据展开节点。</li>
<li><strong>valueNode</strong>: 数据节点，实际的业务数据值，严格来说他不属于树中的节点，它只存在于 <code>fullNode.Children</code> 或者 shortNode.Val 中。</li>
</ol>
<p>简单先看个例子，假设有3个键值对，看一下在以太坊中是怎么以MPT的形式存储的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg6d40u15j31hu0o0jzy.jpg" alt="image-20210108122909361"></p>
<h3 id="以太坊中使用到的MPT树结构"><a href="#以太坊中使用到的MPT树结构" class="headerlink" title="以太坊中使用到的MPT树结构"></a>以太坊中使用到的MPT树结构</h3><ul>
<li><code>State Trie</code> 区块头中的状态树<ul>
<li>key &#x3D;&gt; sha3(以太坊账户地址 address)</li>
<li>value &#x3D;&gt; rlp(账号内容信息 account)</li>
</ul>
</li>
<li>Transactions Trie 区块头中的交易树<ul>
<li>key &#x3D;&gt; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Receipts Trie</code> 区块头中的收据树<ul>
<li>key &#x3D; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Storage Trie</code> 存储树<ul>
<li>存储只能合约状态</li>
<li>每个账号有自己的 Storage Trie</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70f77s2dj319g0lymyz.jpg" alt="image-20201231141329137"></p>
<p>这两个区块头中，<code>state root</code>、<code>tx root</code>、 <code>receipt root</code>分别存储了这三棵树的树根，第二个区块显示了当账号 17 5的数据变更(<strong>27 -&gt; 45</strong>)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。</p>
<h3 id="key编码规则"><a href="#key编码规则" class="headerlink" title="key编码规则"></a>key编码规则</h3><p>三种编码方式分别为：</p>
<ol>
<li><strong>Raw</strong>编码（原生的字符）；</li>
<li><strong>Hex</strong>编码（扩展的16进制编码）；</li>
<li><strong>Hex-Prefix</strong>编码（16进制前缀编码）；</li>
</ol>
<p><strong>Raw编码</strong></p>
<p><strong>Raw</strong>编码就是原生的<strong>key</strong>值，不做任何改变。这种编码方式的<strong>key</strong>，<em>是<strong>MPT</strong>对外提供接口的默认编码方式</em>。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<p><strong>Hex编码</strong></p>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em>.</p>
<p>为了减少分支节点孩子的个数，将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p>
<blockquote>
<p>半字节，在计算机中，通常将8位二进制数称为字节，而把4位二进制数称为半字节。 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。</p>
</blockquote>
<p>从<strong>Raw</strong>编码向<strong>Hex</strong>编码的转换规则是：</p>
<ul>
<li><strong>Raw</strong>编码输入的每个字符分解为高 4 位和低 4 位</li>
<li>如果是叶子节点，则在最后加上<strong>Hex</strong>值<code>0x10</code>表示结束</li>
<li>如果是分支节点不附加任何<strong>Hex</strong>值</li>
</ul>
<p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p>
<table>
<thead>
<tr>
<th align="left">i</th>
<th align="left">key[i]</th>
<th align="left">key[i]二进制</th>
<th align="left">nibbles[i*2]&#x3D;高四位</th>
<th align="left">nibbles[i*2+1]&#x3D;低四位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">114</td>
<td align="left">01110010</td>
<td align="left">0111&#x3D; 7</td>
<td align="left">0010&#x3D; 2</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">111</td>
<td align="left">01101111</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1111&#x3D;15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">109</td>
<td align="left">01101101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1101&#x3D;13</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">97</td>
<td align="left">01100001</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0001&#x3D;1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">110</td>
<td align="left">01101110</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1110&#x3D;14</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">01100101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0101&#x3D;5</td>
</tr>
</tbody></table>
<p>最终得到 Hex(“romane”) &#x3D; <code>[7 2 6 15 6 13 6 1 6 14 6 5 16]</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="type">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span>   <span class="comment">// 高四位</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span> <span class="comment">// 低四位</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span> <span class="comment">// 最后一位存入标示符 代表是hex编码</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Hex-Prefix</strong>编码</p>
<p><strong>数学公式定义：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm75cvok4yj318s07iwfg.jpg" alt="image-20201231170415071"></p>
<p>Hex-Prefix 编码是一种任意量的半字节转换为数组的有效方式，还可以在存入一个标识符来区分不同节点类型。 因此 HP 编码是在由一个标识符前缀和半字节转换为数组的两部分组成。存入到数据库中存在节点 Key 的只有扩展节点和叶子节点，因此 HP 只用于区分扩展节点和叶子节点，不涉及无节点 key 的分支节点。其编码规则如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm74pxxc7yj31ju0cm41o.jpg" alt="image-20201231164209626"></p>
<p>前缀标识符由两部分组成：节点类型和奇偶标识，并存储在编码后字节的第一个半字节中。 0 表示扩展节点类型，1 表示叶子节点，偶为 0，奇为 1。最终可以得到唯一标识的前缀标识：</p>
<ul>
<li>0：偶长度的扩展节点</li>
<li>1：奇长度的扩展节点</li>
<li>2：偶长度的叶子节点</li>
<li>3：奇长度的叶子节点</li>
</ul>
<p>当偶长度时，第一个字节的低四位用<code>0</code>填充，当是奇长度时，则将 key[0] 存放在第一个字节的低四位中，这样 HP 编码结果始终是偶长度。 这里为什么要区分节点 key 长度的奇偶呢？这是因为，半字节 <code>1</code> 和 <code>01</code> 在转换为 bytes 格式时都成为<code>&lt;01&gt;</code>，无法区分两者。</p>
<p>例如，上图 “以太坊 MPT 树的哈希计算”中的控制节点1的key 为 <code>[ 7 2 6 f 6 d]</code>，因为是偶长度，则 HP[0]&#x3D; (00000000) &#x3D;0，H[1:]&#x3D; 解码半字节(key)。 而节点 3 的 key 为 <code>[1 6 e 6 5]</code>，为奇长度，则 HP[0]&#x3D; (0001 0001)&#x3D;17。</p>
<p><strong>HP</strong>编码的规则如下：</p>
<ul>
<li>key结尾为<strong>0x10</strong>，则去掉这个终止符</li>
<li>key之前补一个四元组这个Byte第0位区分奇偶信息，第 1 位区分节点类型</li>
<li>如果输入<strong>key</strong>的长度是偶数，则再添加一个四元组0x0在flag四元组后</li>
<li>将原来的key内容压缩，将分离的两个byte以高四位低四位进行合并</li>
</ul>
<blockquote>
<p>十六进制前缀编码相当于一个逆向的过程，比如输入的是[6 2 6 15 6 2 16]，</p>
<p>根据第一个规则去掉终止符16。根据第二个规则key前补一个四元组，从右往左第一位为1表示叶子节点，</p>
<p>从右往左第0位如果后面key的长度为偶数设置为0，奇数长度设置为1，那么四元组0010就是2。</p>
<p>根据第三个规则，添加一个全0的补在后面，那么就是20.根据第三个规则内容压缩合并，那么结果就是[0x20 0x62 0x6f 0x62]</p>
</blockquote>
<p> <strong>HP 编码源码实现:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	terminator := <span class="type">byte</span>(<span class="number">0</span>) <span class="comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span></span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123;     <span class="comment">//验证hex有后缀编码，</span></span><br><span class="line">		terminator = <span class="number">1</span>         <span class="comment">//hex编码有后缀，则t=1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//此处只是去掉后缀部分的hex编码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">////这一阶段的buf[0]可以理解为公式中的16*f(t)</span></span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// the flag byte</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;     <span class="comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span></span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">////这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// first nibble is contained in the first byte</span></span><br><span class="line">		hex = hex[<span class="number">1</span>:]    <span class="comment">//此时获取的hex编码无前缀无后缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:]) <span class="comment">//将hex编码映射到compact编码中</span></span><br><span class="line">	<span class="keyword">return</span> buf                  <span class="comment">//返回compact编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71rsyyekj319w05ygml.jpg" alt="image-20201231150011417"></p>
<p>以上介绍的MPT树，可以用来存储内容为任何长度的<code>key-value</code>数据项。倘若数据项的<code>key</code>长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：</p>
<ul>
<li>查询一个节点可能会需要许多次 IO 读取，效率低下；</li>
<li>系统易遭受 Dos 攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用<code>SLOAD</code>指令读取该树节点的内容，造成系统执行效率极度下降；</li>
<li>所有的 key 其实是一种明文的形式进行存储；</li>
</ul>
<p>为了解决以上问题，以太坊对<strong>MPT</strong>再进行了一次封装，对数据项的<strong>key</strong>进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是<code>(sha3(key), value)</code></p>
<p><strong>优势</strong>：</p>
<ul>
<li>传入MPT接口的 key 是固定长度的（32字节），可以避免出现树中出现长度很长的路径；</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>每次树操作需要增加一次哈希计算；</li>
<li>需要在数据库中存储额外的<code>sha3(key)</code>与<code>key</code>之间的对应关系；</li>
</ul>
<p>完整的编码流程如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71x5i5djj31by07275g.jpg" alt="image-20201231150520220"></p>
<h2 id="MPT轻节点"><a href="#MPT轻节点" class="headerlink" title="MPT轻节点"></a>MPT轻节点</h2><p>上面的MPT树，有两个问题：</p>
<ul>
<li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li>
<li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制，大体如下：</p>
<ul>
<li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li>
<li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li>
</ul>
<h4 id="轻节点中添加数据"><a href="#轻节点中添加数据" class="headerlink" title="轻节点中添加数据"></a>轻节点中添加数据</h4><p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm8hgf9f3ij319a0pcgqh.jpg" alt="image-20210101204824090"></p>
<p>到此以太坊的MPT树的基础讲解结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> 文章及视频学习资料</p>
<p><a target="_blank" rel="noopener" href="https://eth.wiki/en/fundamentals/patricia-tree">https://eth.wiki/en/fundamentals/patricia-tree</a></p>
<p><a target="_blank" rel="noopener" href="https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D">https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D</a></p>
<p><a target="_blank" rel="noopener" href="https://ethfans.org/toya/articles/588">https://ethfans.org/toya/articles/588</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/">https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/</a></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1909.11590.pdf">https://arxiv.org/pdf/1909.11590.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EVM指令集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:12:59" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EVM指令集</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>以下指令集持续更新，最新文章请参考上面</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn1z0rqeqaj31c00u0k20.jpg" alt="f4a720afd869d70c3d1d2149980ba0e9"></p>
<h2 id="EVM-指令集概念"><a href="#EVM-指令集概念" class="headerlink" title="EVM 指令集概念"></a>EVM 指令集概念</h2><p><strong>EVM执行的是字节码</strong>。由于操作码被限制在一个字节以内，所以EVM指令集最多只能容纳<strong>256</strong>条指令。目前EVM已经定义了<code>100</code>多条指令，还有<strong>100</strong>多条指令可供以后扩展。<strong>这100多条指令包括算术运算指令，比较操作指令，按位运算指令，密码学计算指令，栈、memory、storage操作指令，跳转指令，区块、智能合约相关指令等</strong>。</p>
<h2 id="EVM指令集"><a href="#EVM指令集" class="headerlink" title="EVM指令集"></a>EVM指令集</h2><h3 id="算数运算指令集"><a href="#算数运算指令集" class="headerlink" title="算数运算指令集"></a>算数运算指令集</h3><blockquote>
<p><em>0x0</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">STOP:       &quot;STOP&quot;,</span><br><span class="line">ADD:        &quot;ADD&quot;, //加法运算</span><br><span class="line">MUL:        &quot;MUL&quot;, //乘法运算</span><br><span class="line">SUB:        &quot;SUB&quot;, //减法运算</span><br><span class="line">DIV:        &quot;DIV&quot;, //无符号整除运算</span><br><span class="line">SDIV:       &quot;SDIV&quot;, //有符号整除运算</span><br><span class="line">MOD:        &quot;MOD&quot;, //无符号取模运算</span><br><span class="line">SMOD:       &quot;SMOD&quot;, //有符号取模运算</span><br><span class="line">EXP:        &quot;EXP&quot;,  //指数运算</span><br><span class="line">NOT:        &quot;NOT&quot;,</span><br><span class="line"></span><br><span class="line">//从栈顶弹出两个元素，进行比较，</span><br><span class="line">//然后把结果（1表示true，0表示false）推入栈顶。</span><br><span class="line">//其中LT和GT把弹出的元素解释为无符号整数进行比较，</span><br><span class="line">//SLT和SGT把弹出的元素解释为有符号数进行比较，EQ不关心符号</span><br><span class="line">LT:         &quot;LT&quot;,  //无符号小于比较</span><br><span class="line">GT:         &quot;GT&quot;, //无符号大于比较</span><br><span class="line">SLT:        &quot;SLT&quot;, //有符号小于比较</span><br><span class="line">SGT:        &quot;SGT&quot;, //有符号大于比较</span><br><span class="line">EQ:         &quot;EQ&quot;,  // 等于比较</span><br><span class="line"></span><br><span class="line">//SZERO指令从栈顶弹出一个元素，判断它是否为0，如果是，则把1推入栈顶，否则把0推入栈顶</span><br><span class="line">ISZERO:     &quot;ISZERO&quot;, //布尔取反</span><br><span class="line"></span><br><span class="line">//SIGNEXTEND指令从栈顶依次弹出k和x，并</span><br><span class="line">//把x解释为k+1（0 &lt;= k &lt;= 31）字节有符号整数，然</span><br><span class="line">//后把x符号扩展至32字节。比如x是二进制10000000，k是0，</span><br><span class="line">//则符号扩展之后，结果为二进制1111…10000000（共249个1）</span><br><span class="line">SIGNEXTEND: &quot;SIGNEXTEND&quot; //符号位扩展</span><br></pre></td></tr></table></figure>



<h3 id="位运算指令集"><a href="#位运算指令集" class="headerlink" title="位运算指令集"></a>位运算指令集</h3><blockquote>
<p><em>0x10</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//AND、OR、XOR指令从栈顶弹出两个元素，进行按位运算，然后把结果推入栈顶</span><br><span class="line">AND:    &quot;AND&quot;,</span><br><span class="line">OR:     &quot;OR&quot;,</span><br><span class="line">XOR:    &quot;XOR&quot;,</span><br><span class="line"></span><br><span class="line">//BYTE指令先后从栈顶弹出n和x，取x的第n个字节并推入栈顶。</span><br><span class="line">//由于EVM的字长是32个字节，所以n在[0, 31]区间内才有意义，</span><br><span class="line">//否则BYTE的运算结果就是0。另外，字节是从左到右数的，因此第0个字节占据字的最高位8个比特</span><br><span class="line">BYTE:   &quot;BYTE&quot;, </span><br><span class="line"></span><br><span class="line">//这三条指令都是先后从栈顶弹出两个数n和x，</span><br><span class="line">//其中x是要进行位移操作顶数，n是位移比特数，然后把结果推入栈顶</span><br><span class="line">SHL:    &quot;SHL&quot;,</span><br><span class="line">//SHR和SAR的区别在于，前者执行逻辑右移（空缺补0），后者执行算术右移（空缺补符号位）</span><br><span class="line">SHR:    &quot;SHR&quot;,</span><br><span class="line">SAR:    &quot;SAR&quot;,</span><br><span class="line"></span><br><span class="line">ADDMOD: &quot;ADDMOD&quot;,</span><br><span class="line"></span><br><span class="line">//MULMOD指令依次从栈顶弹出x、y、z三个数，</span><br><span class="line">//先计算x和y的乘积（不受溢出限制），再计算乘积和z的模，最后把结果推入栈顶</span><br><span class="line">//假定乘积不会溢出，那么MULMOD(x, y, z)等价于x * y % z</span><br><span class="line">MULMOD: &quot;MULMOD&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="加密指令集"><a href="#加密指令集" class="headerlink" title="加密指令集"></a>加密指令集</h3><blockquote>
<p><em>0x20</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA3: &quot;SHA3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="关闭状态指令集"><a href="#关闭状态指令集" class="headerlink" title="关闭状态指令集"></a>关闭状态指令集</h3><blockquote>
<p><em>0x30</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ADDRESS:        &quot;ADDRESS&quot;,</span><br><span class="line">BALANCE:        &quot;BALANCE&quot;,</span><br><span class="line">ORIGIN:         &quot;ORIGIN&quot;,</span><br><span class="line">CALLER:         &quot;CALLER&quot;,</span><br><span class="line">CALLVALUE:      &quot;CALLVALUE&quot;,</span><br><span class="line">CALLDATALOAD:   &quot;CALLDATALOAD&quot;,</span><br><span class="line">CALLDATASIZE:   &quot;CALLDATASIZE&quot;,</span><br><span class="line">CALLDATACOPY:   &quot;CALLDATACOPY&quot;,</span><br><span class="line">CODESIZE:       &quot;CODESIZE&quot;,</span><br><span class="line">CODECOPY:       &quot;CODECOPY&quot;,</span><br><span class="line">GASPRICE:       &quot;GASPRICE&quot;,</span><br><span class="line">EXTCODESIZE:    &quot;EXTCODESIZE&quot;,</span><br><span class="line">EXTCODECOPY:    &quot;EXTCODECOPY&quot;,</span><br><span class="line">RETURNDATASIZE: &quot;RETURNDATASIZE&quot;,</span><br><span class="line">RETURNDATACOPY: &quot;RETURNDATACOPY&quot;,</span><br><span class="line">EXTCODEHASH:    &quot;EXTCODEHASH&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="块操作指令集"><a href="#块操作指令集" class="headerlink" title="块操作指令集"></a>块操作指令集</h3><blockquote>
<p><em>0x40</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BLOCKHASH:   &quot;BLOCKHASH&quot;,</span><br><span class="line">COINBASE:    &quot;COINBASE&quot;,</span><br><span class="line">TIMESTAMP:   &quot;TIMESTAMP&quot;,</span><br><span class="line">NUMBER:      &quot;NUMBER&quot;,</span><br><span class="line">DIFFICULTY:  &quot;DIFFICULTY&quot;,</span><br><span class="line">GASLIMIT:    &quot;GASLIMIT&quot;,</span><br><span class="line">CHAINID:     &quot;CHAINID&quot;,</span><br><span class="line">SELFBALANCE: &quot;SELFBALANCE&quot;</span><br></pre></td></tr></table></figure>



<h3 id="存储和执行指令集"><a href="#存储和执行指令集" class="headerlink" title="存储和执行指令集"></a>存储和执行指令集</h3><blockquote>
<p><em>0x50</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POP: &quot;POP&quot;,  // 栈顶弹出元素</span><br><span class="line">MLOAD:    &quot;MLOAD&quot;,</span><br><span class="line">MSTORE:   &quot;MSTORE&quot;,</span><br><span class="line">MSTORE8:  &quot;MSTORE8&quot;,</span><br><span class="line">SLOAD:    &quot;SLOAD&quot;, //先取出栈顶元素x，然后在storage中取以x为键的值（storage[x]）存入栈顶</span><br><span class="line">SSTORE:   &quot;SSTORE&quot;, //存储storage是一个键值存储，可将256位字映射到256位字</span><br><span class="line">JUMP:     &quot;JUMP&quot;,</span><br><span class="line">JUMPI:    &quot;JUMPI&quot;,</span><br><span class="line">PC:       &quot;PC&quot;,</span><br><span class="line">MSIZE:    &quot;MSIZE&quot;,</span><br><span class="line">GAS:      &quot;GAS&quot;,</span><br><span class="line">JUMPDEST: &quot;JUMPDEST&quot;</span><br></pre></td></tr></table></figure>



<h3 id="Push指令集"><a href="#Push指令集" class="headerlink" title="Push指令集"></a>Push指令集</h3><blockquote>
<p><em>0x60</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// PUSH系列指令把紧跟在指令后面的N（1 ～ 32）字节元素推入栈顶</span><br><span class="line">PUSH1:  &quot;PUSH1&quot;,</span><br><span class="line">...</span><br><span class="line">PUSH32: &quot;PUSH32&quot;,</span><br><span class="line"></span><br><span class="line">   //DUP系列指令复制从栈顶开始数的第N（1 ～ 16）个元素，并把复制后的元素推入栈顶</span><br><span class="line">DUP1:  &quot;DUP1&quot;,</span><br><span class="line">DUP2:  &quot;DUP2&quot;,</span><br><span class="line">...</span><br><span class="line">DUP16: &quot;DUP16&quot;,</span><br><span class="line"></span><br><span class="line">//SWAP系列指令把栈顶元素和从栈顶开始数的第N（1 ～ 16）+ 1 个元素进行交换。</span><br><span class="line">SWAP1:  &quot;SWAP1&quot;,</span><br><span class="line">...</span><br><span class="line">SWAP16: &quot;SWAP16&quot;,</span><br><span class="line"></span><br><span class="line">LOG0:   &quot;LOG0&quot;,</span><br><span class="line">...</span><br><span class="line">LOG4:   &quot;LOG4&quot;,</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:12:28" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmma6b1e5zj312g0pmnpe.jpg" alt="image-20210113191423657"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>abi是什么？<br>前面我们认识到的是智能合约直接在EVM上的表示方式，但是，比如我想用java端程序去访问智能合约的某个方法，难道让java开发人员琢磨透汇编和二进制的表示，再去对接？<br>这明显是不可能的，为此abi产生了。这是一个通用可读的json格式的数据，任何别的客户端开发人员或者别的以太坊节点只要指定要调用的方法，通过abi将其解析为字节码并传递给evm，evm来计算处理该字节码并返回结果给前端。abi就起到这么一个作用，类似于传统的客户端和服务器端地址好交互规则，比如json格式的数据，然后进行交互。</p>
<p>在本系列的上一篇文章中我们看到了<code>Solidity</code>是如何在EVM存储器中表示复杂数据结构的。但是如果无法交互，数据就是没有意义的。智能合约就是数据和外界的中间体。</p>
<p>在这篇文章中我们将会看到<code>Solidity</code>和<code>EVM</code>可以让外部程序来调用合约的方法并改变它的状态。</p>
<p>“外部程序”不限于<code>DApp/JavaScript</code>。任何可以使用<code>HTTP RPC</code>与以太坊节点通信的程序，都可以通过创建一个交易与部署在区块链上的任何合约进行交互。</p>
<p>创建一个交易就像发送一个<code>HTTP</code>请求。<code>Web</code>的服务器会接收你的<code>HTTP</code>请求，然后改变数据库。交易会被网络接收，底层的区块链会扩展到包含改变的状态。</p>
<p>交易对于智能合约就像<code>HTTP</code>请求对于<code>Web</code>服务器。</p>
<h2 id="合约交易"><a href="#合约交易" class="headerlink" title="合约交易"></a>合约交易</h2><p>让我们来看一下将状态变量设置在<code>0x1</code>位置上的交易。我们想要交互的合约有一个对变量<code>a</code>的设置者和获取者：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  function setA(uint256 _a) &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  function getA() returns(uint256) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约部署在Rinkeby测试网上。可以随意使用Etherscan，并搜索地址 <a target="_blank" rel="noopener" href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2#code">0x62650ae5…</a>进行查看。</p>
<p>我创建了一个可以调用<code>setA(1)</code>的交易，可以在地址<a target="_blank" rel="noopener" href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5">0x7db471e5…</a>上查看该交易。</p>
<p>交易的input data是：</p>
<blockquote>
<p>0xee919d500000000000000000000000000000000000000000000000000000000000000001</p>
</blockquote>
<p>对于EVM而言，这只是36字节的元数据。它对元数据不会进行处理，会直接将元数据作为<code>calldata</code>传递给智能合约。如果智能合约是个Solidity程序，那么它会将这些输入字节解释为方法调用，并为<code>setA(1)</code>执行适当的汇编代码。</p>
<p>输入数据可以分成两个子部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方法选择器(<span class="number">4</span>字节)</span><br><span class="line"><span class="number">0xee919d5</span></span><br><span class="line">#第一个参数(<span class="number">32</span>字节)</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000001</span></span><br></pre></td></tr></table></figure>

<p>前面的4个字节是方法选择器，剩下的输入数据是方法的参数，32个字节的块。在这个例子中，只有一个参数，值是<code>0x1</code>。</p>
<p>方法选择器是方法签名的 kecccak256 哈希值。在这个例子中方法的签名是<code>setA(uint256)</code>，也就是方法名称和参数的类型。</p>
<p>让我们用Python来计算方法选择器。首先，哈希方法签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 安装pyethereum [https:<span class="comment">//github.com/ethereum/pyethereum/#installation](https://github.com/ethereum/pyethereum/#installation)&gt; from ethereum.utils import sha3&gt; sha3(&quot;setA(uint256)&quot;).hex()&#x27;ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后获取哈希值的前4字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sha3(<span class="string">&quot;setA(uint256)&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;ee919d50&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="应用二进制接口（ABI）"><a href="#应用二进制接口（ABI）" class="headerlink" title="应用二进制接口（ABI）"></a>应用二进制接口（ABI）</h2><p>对于EVM而言，交易的输入数据(<code>calldata</code>)只是一个字节序列。EVM内部不支持调用方法。</p>
<p>智能合约可以选择通过以结构化的方式处理输入数据来模拟方法调用，就像前面所说的那样。</p>
<p>如果EVM上的所有语言都同意相同的方式解释输入数据，那么它们就可以很容易进行交互。 <a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding">合约应用二进制接口</a>（ABI）指定了一个通用的编码模式。</p>
<p>我们已经看到了ABI是如何编码一个简单的方法调用，例如<code>SetA(1)</code>。在后面章节中我们将会看到方法调用和更复杂的参数是如何编码的。</p>
<h2 id="调用一个获取者"><a href="#调用一个获取者" class="headerlink" title="调用一个获取者"></a>调用一个获取者</h2><p>如果你调用的方法改变了状态，那么整个网络必须要同意。这就需要有交易，并消耗gas。</p>
<p>一个获取者如<code>getA()</code>不会改变任何东西。我们可以将方法调用发送到本地的以太坊节点，而不用请求整个网络来执行计算。一个<code>eth_call</code>RPC请求可以允许你在本地模拟交易。这对于只读方法或gas使用评估比较有帮助。</p>
<p>一个<code>eth_call</code>就像一个缓存的HTTP GET请求。</p>
<ul>
<li>它不改变全球的共识状态</li>
<li>本地区块链(“缓存”)可能会有点稍微过时</li>
</ul>
<p>制作一个<code>eth_call</code>来调用 <code>getA</code>方法，通过返回值来获取状态<code>a</code>。首先，计算方法选择器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sha3(<span class="string">&quot;getA()&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;d46300fd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于没有参数，输入数据就只有方法选择器了。我们可以发送一个<code>eth_call</code>请求给任意的以太坊节点。对于这个例子，我们依然将请求发送给 infura.io的公共以太坊节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST \-H <span class="string">&quot;Content-Type: application/json&quot;</span> \<span class="string">&quot;[https://rinkeby.infura.io/YOUR_INFURA_TOKEN](https://rinkeby.infura.io/YOUR_INFURA_TOKEN)&quot;</span> \--data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;id&quot;: 1,&quot;method&quot;: &quot;eth_call&quot;,&quot;params&quot;: [&#123;&quot;to&quot;: &quot;0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2&quot;,&quot;data&quot;: &quot;0xd46300fd&quot;&#125;,&quot;latest&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据ABI，该字节应该会解释为<code>0x1</code>数值。</p>
<h2 id="外部方法调用的汇编"><a href="#外部方法调用的汇编" class="headerlink" title="外部方法调用的汇编"></a>外部方法调用的汇编</h2><p>现在来看看编译的合约是如何处理源输入数据的，并以此来制作一个方法调用。思考一个定义了<code>setA(uint256)</code>的合约：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="comment">// 注意: `payable` 让汇编简单一点点</span></span><br><span class="line">  function setA(uint256 _a) payable &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --bin --asm --optimize call.sol</span><br></pre></td></tr></table></figure>

<p>调用方法的汇编代码在合约内部，在<code>sub_0</code>标签下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sub_0: assembly &#123;</span><br><span class="line">    mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="number">0xee919d50</span></span><br><span class="line">    dup2</span><br><span class="line">    eq</span><br><span class="line">    tag_2</span><br><span class="line">    jumpi</span><br><span class="line">  tag_1:</span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">    dup1</span><br><span class="line">    revert</span><br><span class="line">  tag_2:</span><br><span class="line">    tag_3</span><br><span class="line">    calldataload(<span class="number">0x4</span>)</span><br><span class="line">    jump(tag_4)</span><br><span class="line">  tag_3:</span><br><span class="line">    stop</span><br><span class="line">  tag_4:</span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:96  a */</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:101  a = _a */</span></span><br><span class="line">    dup2</span><br><span class="line">    swap1</span><br><span class="line">    sstore</span><br><span class="line">  tag_5:</span><br><span class="line">    pop</span><br><span class="line">    jump <span class="comment">// 跳出</span></span><br><span class="line">auxdata: <span class="number">0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个样板代码与此讨论是无关的，但是仅供参考：</p>
<ul>
<li>最上面的<code>mstore(0x40, 0x60)</code>为sha3哈希保留了内存中的前64个字节。不管合约是否需要，这个都会存在的。</li>
<li>最下面的<code>auxdata</code>用来验证发布的源码与部署的字节码是否相同的。这个是可选择的，但是嵌入到了编译器中</li>
</ul>
<p>将剩下的汇编代码分成两个部分，这样容易分析一点：</p>
<ul>
<li>匹配选择器并跳掉方法处</li>
<li>加载参数、执行方法，并从方法返回</li>
</ul>
<p>首先，匹配选择器的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载前4个字节作为方法选择器</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">//  如果选择器匹配`0xee919d50`, 跳转到 setA</span></span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2</span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line"><span class="comment">// setA函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>除了开始从调用数据里面加载4字节时的位转移，其他的都是非常清晰明朗的。为了清晰可见，给出了汇编逻辑的低级伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// 跳转到setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<p>实际方法调用的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setA</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 方法调用之后跳转的地方</span></span><br><span class="line">  tag_3</span><br><span class="line">  <span class="comment">// 加载第一个参数(数值0x1).</span></span><br><span class="line">  calldataload(<span class="number">0x4</span>)</span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  jump(tag_4)</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// sstore(0x0, 0x1)</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  <span class="comment">//程序的结尾，将会跳转到 tag_3并停止</span></span><br><span class="line">  jump</span><br><span class="line">tag_3:</span><br><span class="line">  <span class="comment">// 程序结尾</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>在进入方法体之前，汇编代码做了两件事情：</p>
<ol>
<li>保存了一个位置，方法调用之后返回此位置</li>
<li>从调用数据里面加载参数到栈中</li>
</ol>
<p>低级的伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存位置，方法调用结束后返回此位置</span></span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA</span></span><br><span class="line">  <span class="comment">// 从调用数据里面加载参数到栈中</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">4</span>+<span class="number">32</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>将这两部分组合起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// goto setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 无匹配方法。失败</span></span><br><span class="line">  revert</span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA(uint256 _a)</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">36</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有趣的小细节：<code>revert</code>的操作码是<code>fd</code>。但是在黄皮书中你不会找到它的详细说明，或者在代码中找到它的实现。实际上，<code>fd</code>不是确实存在的！这是个无效的操作。当EVM遇到了一个无效的操作，它会放弃并且会有还原状态的副作用。</p>
</blockquote>
<h2 id="处理多个方法"><a href="#处理多个方法" class="headerlink" title="处理多个方法"></a>处理多个方法</h2><p>Solidity编译器是如何为有多个方法的合约产生汇编代码的？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    function setA(uint256 _a) &#123;</span><br><span class="line">      a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    function setB(uint256 _b) &#123;</span><br><span class="line">      b = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单，只要一些<code>if-else</code>分支就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methodSelector = calldata[0:4]</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// if methodSelector == 0x9cdcf9b</span></span><br><span class="line"><span class="number">0x9cdcf9b</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2 <span class="comment">// SetB</span></span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// elsif methodSelector == 0xee919d50</span></span><br><span class="line">dup1</span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">eq</span><br><span class="line">tag_3 <span class="comment">// SetA</span></span><br><span class="line">jumpi</span><br></pre></td></tr></table></figure>

<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0x9cdcf9b&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2</span><br><span class="line">elsif methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// Cannot find a matching method. Fail.</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<h2 id="ABI为复杂方法调用进行编码"><a href="#ABI为复杂方法调用进行编码" class="headerlink" title="ABI为复杂方法调用进行编码"></a>ABI为复杂方法调用进行编码</h2><p>对于一个方法调用，交易输入数据的前4个字节总是方法选择器。跟在后面的32字节块就是方法参数。 <a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI编码规范</a>显示了更加复杂的参数类型是如何被编码的，但是阅读起来非常的痛苦。</p>
<p>另一个学习ABI编码的方式是使用 <a target="_blank" rel="noopener" href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py">pyethereum的ABI编码函数</a> 来研究不同数据类型是如何编码的。我们会从简单的例子开始，然后建立更复杂的类型。</p>
<p>首先，导出<code>encode_abi</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from ethereum.abi <span class="keyword">import</span> encode_abi</span><br></pre></td></tr></table></figure>

<p>对于一个有3个<code>uint256</code>类型参数的方法（例如<code>foo(uint256 a, uint256 b, uint256 c)</code>），编码参数只是简单的依次对<code>uint256</code>数值进行编码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 第一个数组列出了参数的类型</span><br><span class="line"># 第二个数组列出了参数的值</span><br><span class="line">&gt; encode_abi([<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小于32字节的类型会被填充到32字节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi([<span class="string">&quot;int8&quot;</span>, <span class="string">&quot;uint32&quot;</span>, <span class="string">&quot;uint64&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure>

<p>对于定长数组，元素还是32字节的块（如果必要的话会填充0），依次排列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">   [<span class="string">&quot;int8[3]&quot;</span>, <span class="string">&quot;int256[3]&quot;</span>],</span><br><span class="line">   [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// int8[3]. Zero-padded to 32 bytes.</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="comment">// int256[3].</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000005</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<h2 id="ABI为动态数组编码"><a href="#ABI为动态数组编码" class="headerlink" title="ABI为动态数组编码"></a>ABI为动态数组编码</h2><p>ABI介绍了一种间接的编码动态数组的方法，遵循一个叫做<a target="_blank" rel="noopener" href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741">头尾编码</a>的模式。</p>
<p>该模式其实就是动态数组的元素被打包到交易的调用数据尾部，参数(“头”)会被引用到调用数据里，这里就是数组元素。</p>
<p>如果我们调用的方法有3个动态数组，参数的编码就会像这样（添加注释和换行为了更加的清晰）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>],</span><br><span class="line">  [[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1: 数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：数组数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 参数3： 数组数据在0x160位置 </span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">/************* TAIL (128**3 bytes) *************/</span></span><br><span class="line"><span class="comment">//  0x60位置。参数1的数据</span></span><br><span class="line"><span class="comment">// 长度后跟这元素</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// 0xe0位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">//0x160位置。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<p><code>HEAD</code>部分有32字节参数，指出<code>TAIL</code>部分的位置，<code>TAIL</code>部分包含了3个动态数组的实际数据。</p>
<p>举个例子，第一个参数是<code>0x60</code>，指出调用数据的第96个(<code>0x60</code>)字节。如果你看一下第96个字节，它是数组的开始地方。前32字节是长度，后面跟着的是3个元素。</p>
<p>混合动态和静态参数是可能的。这里有个(<code>static</code>，<code>dynamic</code>，<code>static</code>)参数。静态参数按原样编码，而第二个动态数组的数据放到了尾部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256&quot;</span>],</span><br><span class="line">  [<span class="number">0xaaaa</span>, [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], <span class="number">0xbbbb</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1： 0xaaaa</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>aaaa</span><br><span class="line"><span class="comment">// 参数2：数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数3： 0xbbbb</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>bbbb</span><br><span class="line"><span class="comment">/************* TAIL (128 bytes) *************/</span></span><br><span class="line"><span class="comment">// 0x60位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br></pre></td></tr></table></figure>

<h2 id="编码字节数组"><a href="#编码字节数组" class="headerlink" title="编码字节数组"></a>编码字节数组</h2><p>字符串和字节数组同样是头尾编码。唯一的区别是字节数组会被紧密的打包成一个32字节的块，就像：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// 参数1： 字符串数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：字符串数据在0xa0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a0</span><br><span class="line"><span class="comment">// 参数3：字符串数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 0x60 (96)。 参数1的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6161616100000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xa0 (160)。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6262626200000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xe0 (224)。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6363636300000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>对于每个字符串&#x2F;字节数组，前面的32字节是编码长度，后面跟着才是字符串&#x2F;字节数组的内容。</p>
<p>如果字符串大于32字节，那么多个32字节块就会被使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码字符串的48字节</span></span><br><span class="line">ethereum.abi.encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;a&quot;</span> * (<span class="number">32</span>+<span class="number">16</span>)]</span><br><span class="line">).hex()</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">//字符串的长度为0x30 (48)</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000030</span></span><br><span class="line"><span class="number">6161616161616161616161616161616161616161616161616161616161616161</span></span><br><span class="line"><span class="number">6161616161616161616161616161616100000000000000000000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>嵌套数组中每个嵌套有一个间接寻址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[][]&quot;</span>],</span><br><span class="line">  [[[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">//参数1：外层数组在0x20位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">// 0x20。每个元素都是里层数组的位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">// array[0]在0x60位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// array[1] 在0xe0位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">// array[2]在0x160位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<h2 id="Gas成本和ABI编码设计"><a href="#Gas成本和ABI编码设计" class="headerlink" title="Gas成本和ABI编码设计"></a>Gas成本和ABI编码设计</h2><p>为什么ABI将方法选择器截断到4个字节？如果我们不使用sha256的整个32字节，会不会不幸的碰到不同方法发生冲突的情况？ 如果这个截断是为了节省成本，那么为什么在用更多的0来进行填充时，而仅仅只为了节省方法选择器中的28字节而截断呢？</p>
<p>这种设计看起来互相矛盾……直到我们考虑到一个交易的gas成本。</p>
<ul>
<li>每笔交易需要支付 21000 gas</li>
<li>每笔交易的0字节或代码需要支付 4 gas</li>
<li>每笔交易的非0字节或代码需要支付 68 gas</li>
</ul>
<p>啊哈！0要便宜17倍，0填充现在看起来没有那么不合理了。</p>
<p>方法选择器是一个加密哈希值，是个伪随机。一个随机的字符串倾向于拥有很多的非0字节，因为每个字节只有0.3%（1&#x2F;255）的概率是0。</p>
<ul>
<li><code>0x1</code>填充到32字节成本是192 gas<br>4*31 (0字节) + 68 (1个非0字节)</li>
<li>sha256可能有32个非0字节，成本大概2176 gas<br>32 * 68</li>
<li>sha256截断到4字节，成本大概272 gas<br>32*4</li>
</ul>
<p>ABI展示了另外一个底层设计的奇特例子，通过gas成本结构进行激励。</p>
<blockquote>
<h3 id="负整数…"><a href="#负整数…" class="headerlink" title="负整数…."></a>负整数….</h3></blockquote>
<p>一般使用叫做 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Two's_complement">补码</a>的方式来表达负整数。<code>int8</code>类型<code>-1</code>的数值编码会都是1。<code>1111 1111</code>。</p>
<p>ABI用1来填充负整数，所以<code>-1</code>会被填充为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure>

<p>越大的负整数（<code>-1</code>大于<code>-2</code>）1越多，会花费相当多的gas。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与智能合约交互，你需要发送原始字节。它会进行一些计算，可能会改变自己的状态，然后会返回给你原始字节。方法调用实际上不存在，这是ABI创造的集体假象。</p>
<p>ABI被指定为一个低级格式，但是在功能上更像一个跨语言RPC框架的序列化格式。</p>
<p>我们可以在DApp和Web App的架构层面之间进行类比：</p>
<ul>
<li>区块链就是一个备份数据库</li>
<li>合约就像web服务器</li>
<li>交易就像请求</li>
<li>ABI是数据交换格式，就像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protocol Buffer</a>。</li>
</ul>
<blockquote>
<p>翻译自 <a target="_blank" rel="noopener" href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EVM介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:12:41" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>172</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EVM介绍</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote>
<p>|-opcodes.go 具体指令集的含义</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EVM固定长度数据类型表示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:12:12" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EVM固定长度数据类型表示</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>翻译自 <a target="_blank" rel="noopener" href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
<p>我们先看一个简单的<code>Solidity</code>合约的汇编代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该合约归结于<code>sstore</code>指令的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0x0</span>, <span class="number">0x1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>EVM将<code>0x1</code>数值存储在<code>0x0</code>的位置上</li>
<li>每个存储槽可以存储正好<strong>32</strong>字节(或<strong>256</strong>位)</li>
</ul>
<p>在本文中我们将会开始研究<code>Solidity</code>如何使用<code>32</code>字节的块来表示更加复杂的数据类型如结构体和数组。我们也将会看到存储是如何被优化的，以及优化是如何失败的。</p>
<p>在典型编程语言中理解数据类型在底层是如何表示的没有太大的作用。但是在<code>Solidity</code>(或其他的EVM语言)中，这个知识点是非常重要的，因为存储的访问是非常昂贵的：</p>
<ul>
<li><code>sstore</code>指令成本是20000 gas，或比基本的算术指令要贵~5000x</li>
<li><code>sload</code>指令成本是 200 gas，或比基本的算术指令要贵~100x</li>
</ul>
<p>这里说的成本，就是真正的金钱，而不仅仅是毫秒级别的性能。运行和使用合约的成本基本上是由<code>sstore</code>指令和<code>sload</code>指令来主导的！</p>
<h2 id="Parsecs磁带上的Parsecs"><a href="#Parsecs磁带上的Parsecs" class="headerlink" title="Parsecs磁带上的Parsecs"></a>Parsecs磁带上的Parsecs</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm7k9gjm5j31e80mqh7z.jpg" alt="image-20210113174357355"></p>
<p>构建一个通用计算机器需要两个基本要素：</p>
<ul>
<li>一种循环的方式，无论是跳转还是递归</li>
<li>无限量的内存</li>
</ul>
<p><code>EVM</code>的汇编代码有跳转，<code>EVM</code>的存储器提供无限的内存。这对于一切就已经足够了，包括模拟一个运行以太坊的世界，这个世界本身就是一个模拟运行以太坊的世界………</p>
<p>EVM的存储器对于合约来说就像一个无限的自动收报机磁带，磁带上的每个槽都能存储32个字节，就像这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span>...</span><br></pre></td></tr></table></figure>

<p>我们将会看到数据是如何在无限的磁带中生存的。</p>
<blockquote>
<p>磁带的长度是2²⁵⁶，或者每个合约~10⁷⁷存储槽。可观测的宇宙粒子数是10⁸⁰。大概1000个合约就可以容纳所有的质子、中子和电子。不要相信营销炒作，因为它比无穷大要短的多。</p>
</blockquote>
<h2 id="空磁带"><a href="#空磁带" class="headerlink" title="空磁带"></a>空磁带</h2><p>存储器初始的时候是空白的，默认是0。拥有无限的磁带不需要任何的成本。</p>
<p>以一个简单的合约来演示一下0值的行为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    uint256 c;</span><br><span class="line">    uint256 d;</span><br><span class="line">    uint256 e;</span><br><span class="line">    uint256 f;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      f = <span class="number">0xc0fefe</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局很简单。</p>
<ul>
<li>变量<code>a</code>在<code>0x0</code>的位置上</li>
<li>变量<code>b</code>在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>关键问题是：如果我们只使用<code>f</code>，我们需要为<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>支付多少成本？</p>
<p>编译一下再看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sstore(0x5, 0xc0fefe)</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>所以一个存储变量的声明不需要任何成本，因为没有初始化的必要。Solidity为存储变量保留了位置，但是只有当你存储数据进去的时候才需要进行付费。</p>
<p>这样的话，我们只需要为存储<code>0x5</code>进行付费。</p>
<p>如果我们手动编写汇编代码的话，我们可以选择任意的存储位置，而用不着”扩展”存储器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个任意的存储位置</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0xc0fefe</span>, <span class="number">0x42</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取零"><a href="#读取零" class="headerlink" title="读取零"></a>读取零</h2><p>你不仅可以写在存储器的任意位置，你还可以立刻读取任意的位置。从一个未初始化的位置读取只会返回<code>0x0</code>。</p>
<p>让我们看看一个合约从一个未初始化的位置<code>a</code>读取数据：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-zero-value.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// sload(0x0) returning 0x0</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">  <span class="comment">// a + 1; where a == 0</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// sstore(0x0, a + 1)</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意生成从一个未初始化的位置<code>sload</code>的代码是无效的。</p>
<p>然而，我们可以比Solidity编译器聪明。既然我们知道<code>tag_2</code>是构造器，而且<code>a</code>从未被写入过数据，那么我们可以用<code>0x0</code>替换掉<code>sload</code>，以此节省5000 gas。</p>
<h2 id="结构体的表示"><a href="#结构体的表示" class="headerlink" title="结构体的表示"></a>结构体的表示</h2><p>来看一下我们的第一个复杂数据类型，一个拥有 6 个域的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t;</span><br><span class="line">    <span class="function">function <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局和状态变量是一样的：</p>
<ul>
<li><code>t.a</code>域在<code>0x0</code>的位置上</li>
<li><code>t.b</code>域在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>就像之前一样，我们可以直接写入<code>t.f</code>而不用为初始化付费。</p>
<p>编译一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">struct</span>-fields.sol</span><br></pre></td></tr></table></figure>

<p>然后我们看见一模一样的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h3 id="固定长度数组"><a href="#固定长度数组" class="headerlink" title="固定长度数组"></a>固定长度数组</h3><p>让我们来声明一个定长数组：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器知道这里到底有几个<code>uint256</code>(32字节)类型的数值，所以它可以很容易让数组里面的元素依次存储起来，就像它存储变量和结构体一样。</p>
<p>在这个合约中，我们再次存储到<code>0x5</code>的位置上。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">tag_4:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>这个稍微长一点，但是如果你仔细一点，你会看见它们其实是一样的。我们手动的来优化一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="comment">// 0+5. 替换为0x5</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// 压入栈中然后立刻出栈。没有作用，只是移除</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>移除掉标记和伪指令之后，我们再次得到相同的字节码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h2 id="数组边界检查"><a href="#数组边界检查" class="headerlink" title="数组边界检查"></a>数组边界检查</h2><p>我们看到了定长数组、结构体和状态变量在存储器中的布局是一样的，但是产生的汇编代码是不同的。这是因为<code>Solidity</code>为数组的访问产生了边界检查代码。</p>
<p>让我们再次编译数组合约，这次去掉优化的选项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码在下面已经注释了，并且打印出每条指令的机器状态：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">    [<span class="meta">0xc0fefe</span>]</span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  dup1</span><br><span class="line">  <span class="comment">/* 数组边界检查代码 */</span></span><br><span class="line">  <span class="comment">// 5 &lt; 6</span></span><br><span class="line">  <span class="number">0x6</span></span><br><span class="line">    [<span class="meta">0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x5 0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  lt</span><br><span class="line">    [<span class="meta">0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  <span class="comment">// bound_check_ok = 1 (TRUE)</span></span><br><span class="line">  <span class="comment">// if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125;</span></span><br><span class="line">  tag_5</span><br><span class="line">    [<span class="meta">tag_5 0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  jumpi</span><br><span class="line">    <span class="comment">// 测试条件为真，跳转到 tag_5.</span></span><br><span class="line">    <span class="comment">//  `jumpi` 从栈中消耗两项数据</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  invalid</span><br><span class="line"><span class="comment">// 数据访问有效，继续执行</span></span><br><span class="line"><span class="comment">// stack: [0x5 0xc0fefe]</span></span><br><span class="line">tag_5:</span><br><span class="line">  sstore</span><br><span class="line">    []</span><br><span class="line">    storage: &#123; <span class="number">0x5</span> =&gt; <span class="number">0xc0fefe</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在已经看见了边界检查代码。我们也看见了编译器可以对这类东西进行一些优化，但是不是非常完美。</p>
<p>在本文的后面我们将会看到数组的边界检查是如何干扰编译器优化的，比起存储变量和结构体，定长数组的效率更低。</p>
<h2 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h2><p>存储是非常昂贵的。一个关键的优化就是尽可能的将数据打包成一个32字节数值。</p>
<p>考虑一个有 4 个存储变量的合约，每个变量都是 64 位，全部加起来就是 256 位（32字节）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="type">uint64</span> a;</span><br><span class="line">    <span class="type">uint64</span> b;</span><br><span class="line">    <span class="type">uint64</span> c;</span><br><span class="line">    <span class="type">uint64</span> d;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望（希望）编译器使用一个<code>sstore</code>指令将这些数据存放到同一个存储槽中。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:122  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:125:131  0xaaaa */</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="built_in">not</span>(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  <span class="function">swap1</span></span><br><span class="line"><span class="function">  swap2</span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0x80</span>), exp(<span class="number">0x2</span>, <span class="number">0x40</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:139:149  b = 0xbbbb */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xbbbb0000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), exp(<span class="number">0x2</span>, <span class="number">0x80</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:157:167  c = 0xcccc */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xcccc00000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">sub</span><span class="params">(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), <span class="number">0x1</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:175:185  d = 0xdddd */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xdddd000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  swap1</span></span><br><span class="line"><span class="function">  sstore</span></span><br></pre></td></tr></table></figure>

<p>这里还是有很多的位转移我没能弄明白，但是无所谓。最关键事情是这里只有一个<code>sstore</code>指令。</p>
<p>这样优化就成功！</p>
<h2 id="干扰优化器"><a href="#干扰优化器" class="headerlink" title="干扰优化器"></a>干扰优化器</h2><p>优化器并不能一直工作的这么好。让我们来干扰一下优化器。唯一的改变就是使用协助函数来设置存储变量：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    uint64 b;</span><br><span class="line">    uint64 c;</span><br><span class="line">    uint64 d;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setAB</span>();</span><br><span class="line">      <span class="title function_">setCD</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setAB</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setCD</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing-helpers.sol</span><br></pre></td></tr></table></figure>

<p>输出的汇编代码太多了，我们忽略了大多数的细节，只关注结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 通过跳到tag_5来调用setAB()</span></span><br><span class="line">  jump</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//通过跳到tag_7来调用setCD() </span></span><br><span class="line">  jump</span><br><span class="line"><span class="comment">// setAB()函数</span></span><br><span class="line">tag_5:</span><br><span class="line">  <span class="comment">// 进行位转移和设置a，b</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_9:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setAB()的地方</span></span><br><span class="line"><span class="comment">//setCD()函数</span></span><br><span class="line">tag_7:</span><br><span class="line">  <span class="comment">// 进行位转移和设置c，d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_10:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setCD()的地方</span></span><br></pre></td></tr></table></figure>

<p>现在这里有两个<code>sstore</code>指令而不是一个。Solidity编译器可以优化一个标签内的东西，但是无法优化跨标签的。</p>
<p>调用函数会让你消耗更多的成本，不是因为函数调用昂贵（他们只是一个跳转指令），而是因为<code>sstore</code>指令的优化可能会失败。</p>
<p>为了解决这个问题，Solidity编译器应该学会如何內联函数，本质上就是不用调用函数也能得到相同的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">0xaaaa</span>;</span><br><span class="line">b <span class="operator">=</span> <span class="number">0xbbbb</span>;</span><br><span class="line">c <span class="operator">=</span> <span class="number">0xcccc</span>;</span><br><span class="line">d <span class="operator">=</span> <span class="number">0xdddd</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们仔细阅读输出的完整汇编代码，我们会看见<code>setAB()</code>和<code>setCD()</code>函数的汇编代码被包含了两次，不仅使代码变得臃肿了，并且还需要花费额外的gas来部署合约。在学习合约的生命周期时我们再来谈谈这个问题。</p>
</blockquote>
<h2 id="为什么优化器会被干扰？"><a href="#为什么优化器会被干扰？" class="headerlink" title="为什么优化器会被干扰？"></a>为什么优化器会被干扰？</h2><p>因为优化器不会跨标签进行优化。思考一下”1+1”，在同一个标签下，它会被优化成<code>0x2</code>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化成功！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>但是如果指令被标签分开的话就不会被优化了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化失败！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>在0.4.13版本中上面的行为都是真实的。也许未来会改变。</p>
<h2 id="再次干扰优化器"><a href="#再次干扰优化器" class="headerlink" title="再次干扰优化器"></a>再次干扰优化器</h2><p>让我们看看优化器失败的另一种方式，打包适用于定长数组吗？思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再一次，这里有4个64位的数值我们希望能打包成一个32位的数值，只使用一个<code>sstore</code>指令。</p>
<p>编译的汇编代码太长了，我们就数数<code>sstore</code>和<code>sload</code>指令的条数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ solc --bin --asm --optimize c-<span class="built_in">static</span>-<span class="keyword">array</span>--packing.sol | grep -E <span class="string">&#x27;(sstore|sload)&#x27;</span></span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>哦，不！即使定长数组与等效的结构体和存储变量的存储布局是一样的，优化也失败了。现在需要4对<code>sload</code>和<code>sstore</code>指令。</p>
<p>快速的看一下汇编代码，可以发现每个数组的访问都有一个边界检查代码，它们在不同的标签下被组织起来。优化无法跨标签，所以优化失败。</p>
<p>不过有个小安慰。其他额外的3个<code>sstore</code>指令比第一个要便宜：</p>
<ul>
<li><code>sstore</code>指令第一次写入一个新位置需要花费 20000 gas</li>
<li><code>sstore</code>指令后续写入一个已存在的位置需要花费 5000 gas</li>
</ul>
<p>所以这个特殊的优化失败会花费我们35000 gas而不是20000 gas，多了额外的75%。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果Solidity编译器能弄清楚存储变量的大小，它就会将这些变量依次的放入存储器中。如果可能的话，编译器会将数据紧密的打包成32字节的块。</p>
<p>总结一下目前我们见到的打包行为：</p>
<ul>
<li>存储变量：打包</li>
<li>结构体：打包</li>
<li>定长数组：不打包。在理论上应该是打包的</li>
</ul>
<p>因为存储器访问的成本较高，所以你应该将存储变量作为自己的数据库模式。当写一个合约时，做一个小实验是比较有用的，检测汇编代码看看编译器是否进行了正确的优化。</p>
<p>我们可以肯定Solidity编译器在未来肯定会改良。对于现在而言，很不幸，我们不能盲目的相信它的优化器。</p>
<p>它需要你真正的理解存储变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mindcarver"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">mindcarver</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mindcarver" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mindcarver" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/626984947@qq.com" title="E-Mail → 626984947@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/mindcarver001" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;mindcarver001" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mindcarver</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">199k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:01</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'mvGWtuPpkVTSqWCt8xxQ8x8p-gzGzoHsz',
      appKey     : 'IYnOZJ2Y6xvBXl8J1LtKZ59G',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
