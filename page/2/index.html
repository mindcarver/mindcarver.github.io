<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="mindcarver&#39;s blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="mindcarver&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="mindcarver">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>mindcarver's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">mindcarver's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EVM动态数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:11:32" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EVM动态数据类型</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm9mzi9m8j314y0u07wl.jpg" alt="image-20210113185500297"></p>
<p>Solidity提供了在其他编程语言常见的数据类型。除了简单的值类型比如数字和结构体，还有一些其他数据类型，随着数据的增加可以进行动态扩展的动态类型。动态类型的3大类：</p>
<ul>
<li>映射(Mappings)：<code>mapping(bytes32 =&gt; uint256)</code>， <code>mapping(address =&gt; string)</code>等等</li>
<li>数组(Arrays)：<code>[]uint256</code>，<code>[]byte</code>等等</li>
<li>字节数组(Byte arrays)：只有两种类型：<code>string</code>，<code>bytes</code></li>
</ul>
<p>在本系列的第二篇文章中我们看见了固定大小的简单类型在内存中的表示方式。</p>
<ul>
<li>基本数值：<code>uint256</code>，<code>byte</code>等等</li>
<li>定长数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code></li>
<li>组合了上面类型的结构体</li>
</ul>
<p>固定大小的存储变量都是尽可能的打包成32字节的块然后依次存放在存储器中的。（如果这看起来很陌生，请阅读本系列的第二篇文章： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9df8d15418ed">固定长度数据类型的表示方法</a></p>
<p>在本文中我们将会研究Solidity是如何支持更加复杂的数据结构的。在表面上看可能Solidity中的数组和映射比较熟悉，但是从它们的实现方式来看在本质上却有着不同的性能特征。</p>
<p>我们会从映射开始，这是三者当中最简单的。数组和字节数组其实就是拥有更加高级特征的映射。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>让我们存储一个数值在<code>uint256 =&gt; uint256</code>映射中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xC0FEFE</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize c-mapping.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 不做任何事情，应该会被优化掉</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  swap1</span><br><span class="line">  dup2</span><br><span class="line">  mstore</span><br><span class="line">  <span class="number">0x20</span></span><br><span class="line">  mstore</span><br><span class="line">  <span class="comment">// 将0x42 存储在地址0x798...187c上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line"> <span class="number">0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>我们可以将EVM想成一个键-值( key-value)数据库，不过每个key都限制为32字节。与其直接使用key<code>0xC0FEFE</code>，不如使用key的哈希值<code>0x798...187c</code>，并且<code>0x42</code>存储在这里。哈希函数使用的是<code>keccak256</code>(SHA256)函数。</p>
<p>在这个例子中我们没有看见<code>keccak256</code>指令本身，因为优化器已经提前计算了结果并內联到了字节码中。在没什么作用的<code>mstore</code>指令中，我们依然可以看到计算的痕迹。</p>
<h2 id="计算地址"><a href="#计算地址" class="headerlink" title="计算地址"></a>计算地址</h2><p>使用一些Python代码来把<code>0xC0FEFE</code>哈希成<code>0x798...187c</code>。如果你想要跟着做下去，你需要安装Python 3.6，或者安装<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://pypi.python.org/pypi/pysha3">pysha3</a> 来获得<code>keccak_256</code>哈希函数。</p>
<p>定义两个协助函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="comment">#将数值转换成32字节数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytes32</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(<span class="string">&#x27;%064x&#x27;</span> % i)</span><br><span class="line"><span class="comment"># 计算32字节数组的 keccak256 哈希值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keccak256</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sha3.keccak_256(x).hexdigest()</span><br></pre></td></tr></table></figure>

<p>将数值转换成32个字节：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&#x27;</span></span><br><span class="line">&gt;&gt;&gt; bytes32(<span class="number">0xC0FEFE</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>+</code>操作符，将两个字节数组连接起来：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>) + bytes32(<span class="number">2</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02&#x27;</span></span><br></pre></td></tr></table></figure>

<p>计算一些字节的 keccak256 哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; keccak256(bytes(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以计算<code>0x798...187c</code>了。</p>
<p>存储变量<code>items</code>的位置是<code>0x0</code>（因为它是第一个存储变量）。连接key<code>0xc0fefe</code>和<code>items</code>的位置来获取地址：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key = 0xC0FEFE, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xC0FEFE</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为key计算存储地址的公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(bytes32(key) + bytes32(position))</span><br></pre></td></tr></table></figure>

<h2 id="两个映射"><a href="#两个映射" class="headerlink" title="两个映射"></a>两个映射</h2><p>我们先把公式放在这里，后面数值存储时需要计算会用到该公式。</p>
<p>假设我们的合约有两个映射：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsA;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsB;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      itemsA[<span class="number">0xAAAA</span>] = <span class="number">0xAAAA</span>;</span><br><span class="line">      itemsB[<span class="number">0xBBBB</span>] = <span class="number">0xBBBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsA</code>的位置是<code>0</code>，key为<code>0xAAAA</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key = 0xAAAA, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xAAAA</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsB</code>的位置为<code>1</code>，key为<code>0xBBBB</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key = 0xBBBB, position = 1</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xBBBB</span>) + bytes32(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用编译器来验证一下这些计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping<span class="number">-2.</span>sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ... 忽略可能会被优化掉的内存操作</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="number">0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0xbbbb</span></span><br><span class="line">  <span class="number">0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>跟期望的结果一样。</p>
<h2 id="汇编代码中的KECCAK256"><a href="#汇编代码中的KECCAK256" class="headerlink" title="汇编代码中的KECCAK256"></a>汇编代码中的KECCAK256</h2><p>编译器可以提前计算key的地址是因为相关的值是常量。如果key使用的是变量，那么哈希就必须要在汇编代码中完成。现在我们无效化优化器，来看看在汇编代码中哈希是如何完成的。</p>
<p>事实证明很容易就能让优化器无效，只要引入一个间接的虚变量<code>i</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="comment">//这个变量会造成常量的优化失败</span></span><br><span class="line">    uint256 i = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[i] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<code>items</code>的位置依然是<code>0x0</code>，所以我们应该期待地址与之前是一样的。</p>
<p>加上优化选项进行编译，但是这次不会提前计算哈希值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping--no-constant-folding.sol</span><br></pre></td></tr></table></figure>

<p>注释的汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 加载`i` 到栈中</span></span><br><span class="line">  sload(<span class="number">0x1</span>)</span><br><span class="line">    [<span class="meta">0xC0FEFE</span>]</span><br><span class="line">  <span class="comment">// 将key`0xC0FEFE`存放在内存中的0x0位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0xC0FEFE 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将位置 `0x0` 存储在内存中的 0x20 (32)位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x20</span> <span class="comment">// 32</span></span><br><span class="line">    [<span class="meta">0x20 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0x20 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x20 0x0 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">      <span class="number">0x20</span> =&gt; <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从第0个字节开始，哈希在内存中接下来的0x40(64)个字节</span></span><br><span class="line">  <span class="number">0x40</span> <span class="comment">// 64</span></span><br><span class="line">    [<span class="meta">0x40 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x0 0x40</span>]</span><br><span class="line">  keccak256</span><br><span class="line">    [<span class="meta">0x798...187c</span>]</span><br><span class="line">  <span class="comment">// 将0x42 存储在计算的地址上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">    [<span class="meta">0x42 0x798...187c</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x798...187c 0x42</span>]</span><br><span class="line">  sstore</span><br><span class="line">    store: &#123;</span><br><span class="line">      <span class="number">0x798</span>..<span class="number">.187</span>c =&gt; <span class="number">0x42</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>mstore</code>指令写入32个字节到内存中。内存操作便宜很多，只需要3 gas就可以读取和写入。前半部分的汇编代码就是通过将key和位置加载到相邻的内存块中来进行“连接”的：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">31</span>  <span class="number">32</span>                 <span class="number">63</span></span><br><span class="line"><span class="punctuation">[</span>    key (<span class="number">32</span> bytes)    <span class="punctuation">]</span><span class="punctuation">[</span> position (<span class="number">32</span> bytes) <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>然后<code>keccak256</code>指令哈希内存中的数据。成本取决于被哈希的数据有多少：</p>
<ul>
<li>每个SHA3操作需要支付 30 gas</li>
<li>每个32字节的字需要支付 6 gas</li>
</ul>
<p>对于一个<code>uint256</code>类型key，gas的成本是42：<code>30 + 6 * 2</code>。</p>
<h2 id="映射大数值"><a href="#映射大数值" class="headerlink" title="映射大数值"></a>映射大数值</h2><p>每个存储槽只能存储32字节。如果我们尝试存储一个更大一点的结构体会怎么样？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> <span class="title class_">Tuple</span>) tuples;</span><br><span class="line">    struct <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">a</span> = <span class="number">0x1A</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">b</span> = <span class="number">0x1B</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">c</span> = <span class="number">0x1C</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，你会看见3个<code>sstore</code>指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">//忽略未优化的代码</span></span><br><span class="line">  <span class="number">0x1a</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1b</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1c</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意计算的地址除了最后一个数字其他都是一样的。<code>Tulp</code>结构体成员是依次排列的(..7d, ..7e, ..7f)。</p>
<h2 id="映射不会打包"><a href="#映射不会打包" class="headerlink" title="映射不会打包"></a>映射不会打包</h2><p>考虑到映射的设计方式，每项需要的最小存储空间是32字节，即使你实际只需要存储1个字节：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint8) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xA</span>] = <span class="number">0xAA</span>;</span><br><span class="line">      items[<span class="number">0xB</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个数值大于32字节，那么你需要的存储空间会以32字节依次增加。</p>
<h2 id="动态数组是映射的升级"><a href="#动态数组是映射的升级" class="headerlink" title="动态数组是映射的升级"></a>动态数组是映射的升级</h2><p>在典型语言中，数组只是连续存储在内存中一系列相同类型的元素。假设你有一个包含100个<code>uint8</code>类型的元素数组，那么这就会占用100个字节的内存。这种模式的话，将整个数组加载到CPU的缓存中然后循环遍历每个元素会便宜一点。</p>
<p>对于大多数语言而言，数组比映射都会便宜一些。不过在Solidity中，数组是更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br></pre></td></tr></table></figure>

<p>但是请记住，对于这些存储槽的每次访问实际上就像数据库中的key-value的查找一样。访问一个数组的元素跟访问一个映射的元素是没什么区别的。</p>
<p>思考一下<code>[]uint256</code>类型，它本质上与<code>mapping(uint256 =&gt; uint256)</code>是一样的，只不过后者多了一点特征，让它看起去就像数组一样。</p>
<ul>
<li><code>length</code>表示一共有多少个元素</li>
<li>边界检查。当读取或写入时索引值大于<code>length</code>就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小时，自动清除未使用的存储槽</li>
<li><code>bytes</code>和<code>string</code>的特殊优化让短数组(小于32字节)存储更加高效</li>
</ul>
<h2 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h2><p>看一下保存3个元素的数组：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-darray.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组访问的汇编代码难以追踪，使用<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://remix.ethereum.org/">Remix</a>调试器来运行合约：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8388873-3f80ed93b21b374a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>模拟的最后，我们可以看到有4个存储槽被使用了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000bb</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p><code>chunks</code>变量的位置是<code>0x0</code>，用来存储数组的长度（<code>0x3</code>），哈希变量的位置来找到存储数组数据的地址：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个地址上数组的每个元素依次排列（<code>0x29..63</code>，<code>0x29..64</code>，<code>0x29..65</code>）。</p>
<h2 id="动态数据打包"><a href="#动态数据打包" class="headerlink" title="动态数据打包"></a>动态数据打包</h2><p>所有重要的打包行为是什么样的？数组与映射比较，数组的一个优势就是打包。拥有4个元素的<code>uint128[]</code>数组元素刚刚好需要2个存储槽（再加1个存储槽用来存储长度）。</p>
<p>思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行这个代码，存储器的最后看起来像这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000bb000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000dd000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p>只有三个存储槽被使用了，跟预料的一样。长度再次存储在存储变量的<code>0x0</code>位置上。4个元素被打包放入两个独立的存储槽中。该数组的开始地址是变量位置的哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在的地址是每两个数组元素增加一次，看起来很好！</p>
<p>但是汇编代码本身优化的并不好。因为使用了两个存储槽，所以我们会希望优化器使用两个<code>sstore</code>指令来完成任务。不幸的是，由于边界检查(和一些其他因素)，所以没有办法将<code>sstore</code>指令优化掉。</p>
<p>使用4个<code>sstore</code>指令才能完成任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:105:116  s[0] = 0xAA */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:126:137  s[1] = 0xBB */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:147:158  s[2] = 0xCC */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:168:179  s[3] = 0xDD */</span><br><span class="line">sstore</span><br></pre></td></tr></table></figure>

<h3 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h3><p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度小于31字节，只需要1个存储槽来存储整个数组。长一点的字节数组跟正常数组的表示方式差不多。</p>
<p>看看短一点的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组只有3个字节（小于31字节），所以它只占用1个存储槽。在Remix中运行，存储看起来如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0xaabbcc0000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<p>数据<code>0xaabbcc...</code>从左到右的进行存储。后面的0是空数据。最后的<code>0x06</code>字节是数组的编码长度。公式是<code>长度=编码长度/2</code>，在这个例子中实际长度是<code>6/2=3</code>。</p>
<p><code>string</code>与<code>bytes</code>的原理一模一样。</p>
<h2 id="长字节数组"><a href="#长字节数组" class="headerlink" title="长字节数组"></a>长字节数组</h2><p>如果数据的长度大于31字节，字节数组就跟<code>[]byte</code>一样。来看一下长度为128字节的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行，可以看见使用了4个存储槽：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x0000...<span class="number">0000</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0101</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0001</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0002</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0003</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0004</span></span><br></pre></td></tr></table></figure>

<p><code>0x0</code>的存储槽不再用来存储数据，整个存储槽现在存储编码的数组长度。要获得实际长度，使用<code>长度=（编码长度-1）/2</code>公式。在这个例子中长度是<code>（0x101 - 1）/2=128</code>。实际的字节被保存在<code>0x290d...e563</code>，并且存储槽是连续的。</p>
<p>字节数组的汇编代码相当多。除了正常的边界检查和数组恢复大小等，它还需要对长度进行编码&#x2F;解码，以及注意长字节数组和短字节数组之间的转换。</p>
<blockquote>
<p>为什么要编码长度？因为编码之后，可以很容易的测试出来字节数组是长还是短。注意对于长数组而言编码长度总是奇数，而短数组的编码长度总是偶数。汇编代码只需要查看一下最后一位是否为0，为0就是偶数（短数组），非0就是奇数（长数组）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查看Solidity编译器的内部工作，可以看见熟悉的数据结构例如映射和数组与传统编程语言完全不同。</p>
<p>概括：</p>
<ul>
<li>数组跟映射一样，非高效</li>
<li>比映射的汇编代码更加复杂</li>
<li>小类型(<code>byte</code>，<code>uint8</code>，<code>string</code>)时存储比映射高效</li>
<li>汇编代码优化的不是很好。即使是打包，每个任务都会有一个<code>sstore</code>指令</li>
</ul>
<p>EVM的存储器就是一个键值数据库，跟git很像。如果你改变了任一东西，根节点的校验和也会改变。如果两个根节点拥有相同的校验和，存储的数据就能保证是一样的。</p>
<p>为了体会Solidity和EVM的奇特，可以想象一下在git仓库里数组里面的每个元素都是它自己的文件。当你改变数组里一个元素的值，实际上就相当于创建了一个提交。当你迭代一个数组时，你不能一次性的加载整个数组，你必须要到仓库中进行查找并分别找到每个文件。</p>
<p>不仅仅这样，每个文件都限制到32字节！因为我们需要将数据结构都分割成32字节的块，Solidity编译器的所有逻辑和优化都是很负责的，全部在汇编的时候完成。</p>
<p>不过32字节的限制是完全任意的。支持键值存储的可以使用key来存储任意类型的数值。也许未来我们添加新的EVM指令使用key来存储任意的字节数组。</p>
<p>不过现在，EVM存储器就是一个伪装成32字节数组的键值数据库。</p>
<blockquote>
<p>可以看看<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624">ArrayUtils::resizeDynamicArray</a> 来了解一下当恢复数组大小时编译器的动作。正常情况下数据结构都会作为语言的标准库来完成的，但是在Solidity中嵌入到了编译器里面。</p>
</blockquote>
<blockquote>
<p>翻译自 <a target="_blank" rel="noopener" href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/" class="post-title-link" itemprop="url">死磕以太坊源码分析之EthDB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:11:56" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>249</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之EthDB</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|-leveldb.go</span><br><span class="line">|-memorydb.go</span><br><span class="line">|-batch.go</span><br><span class="line">|-database.go</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/nb/9496943">https://www.jianshu.com/nb/9496943</a> （levelDB源码）</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/" class="post-title-link" itemprop="url">死磕以太坊源码分析之Ethash共识算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:11:15" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之Ethash共识算法</p>
<p>代码分支：<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/tree/v1.9.9">https://github.com/ethereum/go-ethereum/tree/v1.9.9</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>目前以太坊中有两个共识算法的实现：<code>clique</code>和<code>ethash</code>。而<code>ethash</code>是目前以太坊主网（<code>Homestead</code>版本）的<code>POW</code>共识算法。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><code>ethash</code>模块位于以太坊项目目录下的<code>consensus/ethash</code>目录下。</p>
<ul>
<li><strong>algorithm.go</strong><br>实现了<code>Dagger-Hashimoto</code>算法的所有功能，比如生成<code>cache</code>和<code>dataset</code>、根据<code>Header</code>和<code>Nonce</code>计算挖矿哈希等。</li>
<li><strong>api.go</strong><br>实现了供<code>RPC</code>使用的<code>api</code>方法。</li>
<li><strong>consensus.go</strong><br>实现了以太坊共识接口的部分方法，包括<code>Verify</code>系列方法（<code>VerifyHeader</code>、<code>VerifySeal</code>等）、<code>Prepare</code>和<code>Finalize</code>、<code>CalcDifficulty</code>、<code>Author</code>、<code>SealHash</code>。</li>
<li><strong>ethash.go</strong><br>实现了<code>cache</code>结构体和<code>dataset</code>结构体及它们各自的方法、<code>MakeCache</code>&#x2F;<code>MakeDataset</code>函数、<code>Ethash</code>对象的<code>New</code>函数，和<code>Ethash</code>的内部方法。</li>
<li><strong>sealer.go</strong><br>实现了共识接口的<code>Seal</code>方法，和<code>Ethash</code>的内部方法<code>mine</code>。这些方法实现了<code>ethash</code>的挖矿功能。</li>
</ul>
<h2 id="Ethash-设计原理"><a href="#Ethash-设计原理" class="headerlink" title="Ethash 设计原理"></a>Ethash 设计原理</h2><h3 id="Ethash设计目标"><a href="#Ethash设计目标" class="headerlink" title="Ethash设计目标"></a>Ethash设计目标</h3><p>以太坊设计共识算法时，期望达到三个目的：</p>
<ol>
<li>抗<code>ASIC</code>性：为算法创建专用硬件的优势应尽可能小，让普通计算机用户也能使用CPU进行开采。<ul>
<li>通过内存限制来抵制（<code>ASIC</code>使用矿机内存昂贵）</li>
<li>大量随机读取内存数据时计算速度就不仅仅受限于计算单元，更受限于内存的读出速度。</li>
</ul>
</li>
<li>轻客户端可验证性: 一个区块应能被轻客户端快速有效校验。</li>
<li>矿工应该要求存储完整的区块链状态。</li>
</ol>
<h3 id="哈希数据集"><a href="#哈希数据集" class="headerlink" title="哈希数据集"></a>哈希数据集</h3><p><code>ethash</code>要计算哈希，需要先有一块数据集。这块数据集较大，初始大小大约有<code>1G</code>，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。计算哈希的数据源就是从这块数据集中来的；而决定使用数据集中的哪些数据进行哈希计算的，才是<code>header</code>的数据和<code>Nonce</code>字段。这部分是由<code>Dagger</code>算法实现的。</p>
<h4 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h4><p><code>Dagger</code>算法是用来生成数据集<code>Dataset</code>的，核心的部分就是<code>Dataset</code>的生成方式和组织结构。</p>
<p>可以把<code>Dataset</code>想成多个<code>item</code>（<strong>dataItem</strong>）组成的数组，每个<code>item</code>是<code>64</code>字节的byte数组（一条哈希）。<code>dataset</code>的初始大小约为<code>1G</code>，每隔3万个区块（一个<code>epoch</code>区间）就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。</p>
<p><code>Dataset</code>的每个<code>item</code>是由一个缓存块（<code>cache</code>）生成的，缓存块也可以看做多个<code>item</code>（<strong>cacheItem</strong>）组成，缓存块占用的内存要比<code>dataset</code>小得多，它的初始大小约为<code>16M</code>。同<code>dataset</code>类似，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>128K</code>左右。</p>
<p>生成一条<code>dataItem</code>的程是：从缓存块中“随机”（这里的“随机”不是真的随机数，而是指事前不能确定，但每次计算得到的都是一样的值）选择一个<code>cacheItem</code>进行计算，得的结果参与下次计算，这个过程会循环 256 次。</p>
<p>缓存块是由<code>seed</code>生成的，而<code>seed</code>的值与块的高度有关。所以生成<code>dataset</code>的过程如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm8arq9t7j30x80eytji.jpg" alt="image-20201213144908721"></p>
<p><code>Dagger</code>还有一个关键的地方，就是确定性。即同一个<code>epoch</code>内，每次计算出来的<code>seed</code>、缓存、<code>dataset</code>都是相同的。否则对于同一个区块，挖矿的人和验证的人使用不同的<code>dataset</code>，就没法进行验证了。</p>
<hr>
<h3 id="Hashimoto算法"><a href="#Hashimoto算法" class="headerlink" title="Hashimoto算法"></a>Hashimoto算法</h3><p>是<code>Thaddeus Dryja</code>创造的。旨在通过<code>IO</code>限制来抵制矿机。在挖矿过程中，使内存读取限制条件，由于内存设备本身会比计算设备更加便宜以及普遍，在内存升级优化方面，全世界的大公司也都投入巨大，以使内存能够适应各种用户场景，所以有了随机访问内存的概念<code>RAM</code>，因此,现有的内存可能会比较接近最优的评估算法。<code>Hashimoto</code>算法使用区块链作为源数据，满足了上面的 1 和 3 的要求。</p>
<p>它的作用就是使用区块Header的哈希和Nonce字段、利用dataset数据，生成一个最终的哈希值。</p>
<hr>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="生成哈希数据集"><a href="#生成哈希数据集" class="headerlink" title="生成哈希数据集"></a>生成哈希数据集</h3><p><code>generate</code>函数位于<code>ethash.go</code>文件中，主要是为了生成<code>dataset</code>,其中包扩以下内容。</p>
<h4 id="生成cache-size"><a href="#生成cache-size" class="headerlink" title="生成cache size"></a>生成cache size</h4><p><code>cache size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> *，   <code>epochLength</code> 为 30000，如果<code>epoch</code> 小于 2048，则从已知的<code>epoch</code>返回相应的<code>cache size</code>，否则重新计算<code>epoch</code> </p>
<p><code>cache</code>的大小是线性增长的，<code>size</code>的值等于(2^24^ + 2^17^ * epoch - 64)，用这个值除以 64 看结果是否是一个质数，如果不是，减去128 再重新计算，直到找到最大的质数为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csize := cacheSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> cacheSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcCacheSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCacheSize</span><span class="params">(epoch <span class="type">int</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	size := cacheInitBytes + cacheGrowthBytes*<span class="type">uint64</span>(epoch) - hashBytes</span><br><span class="line">	<span class="keyword">for</span> !<span class="built_in">new</span>(big.Int).SetUint64(size / hashBytes).ProbablyPrime(<span class="number">1</span>) &#123; <span class="comment">// Always accurate for n &lt; 2^64</span></span><br><span class="line">		size -= <span class="number">2</span> * hashBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成dataset-size"><a href="#生成dataset-size" class="headerlink" title="生成dataset size"></a>生成dataset size</h4><p><code>dataset Size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> , 类似上面生成<code>cache size</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsize := datasetSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">datasetSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> datasetSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcDatasetSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-seed-种子"><a href="#生成-seed-种子" class="headerlink" title="生成 seed 种子"></a>生成 seed 种子</h4><p><em>seedHash是用于生成验证缓存和挖掘数据集的种子。</em>长度为 32。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seed := seedHash(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">seedHash</span><span class="params">(block <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> block &lt; epochLength &#123;</span><br><span class="line">		<span class="keyword">return</span> seed</span><br><span class="line">	&#125;</span><br><span class="line">	keccak256 := makeHasher(sha3.NewLegacyKeccak256())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(block/epochLength); i++ &#123;</span><br><span class="line">		keccak256(seed, seed)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成cache"><a href="#生成cache" class="headerlink" title="生成cache"></a>生成cache</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generateCache(cache, d.epoch, seed)</span><br></pre></td></tr></table></figure>

<p>接下来分析<code>generateCache</code>的关键代码：</p>
<p>先了解一下<strong>hashBytes</strong>，在下面的计算中都是以此为单位，它的值为 64 ，相当于一个<code>keccak512</code>哈希的长度,下文以<strong>item</strong>称呼<code>[hashBytes]byte</code>。</p>
<p>①：初始化<code>cache</code></p>
<p>此循环用来初始化<code>cache</code>：先将<code>seed</code>的哈希填入<code>cache</code>的第一个<code>item</code>,随后使用前一个<code>item</code>的哈希，填充后一个<code>item</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> offset := <span class="type">uint64</span>(hashBytes); offset &lt; size; offset += hashBytes &#123;</span><br><span class="line">		keccak512(cache[offset:], cache[offset-hashBytes:offset])</span><br><span class="line">		atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：对cache中数据按规则做异或</p>
<p>为对于每一个<code>item</code>（<code>srcOff</code>），“随机”选一个<code>item</code>（<code>xorOff</code>）与其进行异或运算；将运算结果的哈希写入<code>dstOff</code>中。这个运算逻辑将进行<code>cacheRounds</code>次。</p>
<p>两个需要注意的地方：</p>
<ul>
<li>一是<code>srcOff</code>是从尾部向头部变化的，而<code>dstOff</code>是从头部向尾部变化的。并且它俩是对应的，即当<code>srcOff</code>代表倒数第x个item时，<code>dstOff</code>则代表正数第x个item。</li>
<li>二是<code>xorOff</code>的选取。注意我们刚才的“随机”是打了引号的。<code>xorOff</code>的值看似随机，因为在给出<code>seed</code>之前，你无法知道xorOff的值是多少；但一旦<code>seed</code>的值确定了，那么每一次<code>xorOff</code>的值都是确定的。而seed的值是由区块的高度决定的。这也是同一个<code>epoch</code>内总是能得到相同<code>cache</code>数据的原因。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cacheRounds; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; rows; j++ &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				srcOff = ((j - <span class="number">1</span> + rows) % rows) * hashBytes</span><br><span class="line">				dstOff = j * hashBytes</span><br><span class="line">				xorOff = (binary.LittleEndian.Uint32(cache[dstOff:]) % <span class="type">uint32</span>(rows)) * hashBytes</span><br><span class="line">			)</span><br><span class="line">			bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBytes], cache[xorOff:xorOff+hashBytes])</span><br><span class="line">			keccak512(cache[dstOff:], temp)</span><br><span class="line"></span><br><span class="line">			atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="生成dataset"><a href="#生成dataset" class="headerlink" title="生成dataset"></a>生成dataset</h4><p><code>dataset</code>大小的计算和<code>cache</code>类似，量级不同：2^30^ + 2^23^ * epoch - 128，然后每次减256寻找最大质数。</p>
<p>生成数据是一个循环，每次生成64个字节，主要的函数是<code>generateDatasetItem</code>：</p>
<p><code>generateDatasetItem</code>的数据来源就是<code>cache</code>数据，而最终的dataset值会存储在mix变量中。整个过程也是由多个循环构成。 </p>
<p>①：初始化<code>mix</code>变量</p>
<p>根据cache值对<code>mix</code>变量进行初始化。其中<code>hashWords</code>代表的是一个<code>hash</code>里有多少个<code>word</code>值：一个<code>hash</code>的长度为<code>hashBytes</code>即64字节，一个<code>word</code>（uint32类型）的长度为 4 字节，因此<code>hashWords</code>值为 16。选取<code>cache</code>中的哪一项数据是由参数<code>index</code>和<code>i</code>变量决定的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">byte</span>, hashBytes)</span><br><span class="line">binary.LittleEndian.PutUint32(mix, cache[(index%rows)*hashWords]^index)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; hashWords; i++ &#123;</span><br><span class="line">	binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], cache[(index%rows)*hashWords+<span class="type">uint32</span>(i)])</span><br><span class="line">&#125;</span><br><span class="line">keccak512(mix, mix)</span><br></pre></td></tr></table></figure>

<p>②：将<code>mix</code>转换成<code>[]uint32</code>类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intMix := <span class="built_in">make</span>([]<span class="type">uint32</span>, hashWords)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intMix); i++ &#123;</span><br><span class="line">		intMix[i] = binary.LittleEndian.Uint32(mix[i*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：将<code>cache</code>数据聚合进<code>intmix</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; datasetParents; i++ &#123;</span><br><span class="line">		parent := fnv(index^i, intMix[i%<span class="number">16</span>]) % rows</span><br><span class="line">		fnvHash(intMix, cache[parent*hashWords:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>FNV</code>哈希算法，是一种不需要使用密钥的哈希算法。</p>
<p>这个算法很简单：a乘以FNV质数0x01000193，然后再和b异或。</p>
<p>首先用这个算法算出一个索引值，利用这个索引从<code>cache</code>中选出一个值（<code>data</code>），然后对<code>mix</code>中的每个字节都计算一次<code>FNV</code>，得到最终的哈希值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnv</span><span class="params">(a, b <span class="type">uint32</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">0x01000193</span> ^ b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnvHash</span><span class="params">(mix []<span class="type">uint32</span>, data []<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">        mix[i] = mix[i]*<span class="number">0x01000193</span> ^ data[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>④：将<code>intMix</code>又恢复成<code>mix</code>并计算<code>mix</code>的哈希返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> intMix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	keccak512(mix, mix)</span><br><span class="line">	<span class="keyword">return</span> mix</span><br></pre></td></tr></table></figure>

<p><code>generateCache</code>和<code>generateDataset</code>是实现<code>Dagger</code>算法的核心函数，到此整个生成哈希数据集的的过程结束。</p>
<hr>
<h3 id="共识引擎核心函数"><a href="#共识引擎核心函数" class="headerlink" title="共识引擎核心函数"></a>共识引擎核心函数</h3><p>代码位于<code>consensus.go</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glnee6vhalj31py0lkgq4.jpg" alt="image-20201214150532321"></p>
<p>①：<code>Author</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回coinbase, coinbase是打包第一笔交易的矿工的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Author(header *types.Header) (common.Address, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> header.Coinbase, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<code>VerifyHeader</code></p>
<p>主要有两步检查，第一步检查<strong>header是否已知</strong>或者<strong>是未知的祖先</strong>，第二步是<code>ethash</code>的检查：</p>
<p>2.1 header.Extra 不能超过32字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(<span class="built_in">len</span>(header.Extra)) &gt; params.MaximumExtraDataSize &#123;  <span class="comment">// 不超过32字节</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;extra-data too long: %d &gt; %d&quot;</span>, <span class="built_in">len</span>(header.Extra), params.MaximumExtraDataSize)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 时间戳不能超过15秒，15秒以后的就被认定为未来的块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !uncle &#123;</span><br><span class="line">		<span class="keyword">if</span> header.Time &gt; <span class="type">uint64</span>(time.Now().Add(allowedFutureBlockTime).Unix()) &#123;</span><br><span class="line">			<span class="keyword">return</span> consensus.ErrFutureBlock</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 当前header的时间戳小于父块的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> header.Time &lt;= parent.Time &#123; <span class="comment">// 当前header的时间小于等于父块的</span></span><br><span class="line">		<span class="keyword">return</span> errZeroBlockTime</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 根据时间戳和父块的难度来验证块的难度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expected := ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.5验证<code>gas limit</code>小于2^63^ -1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cap</span> := <span class="type">uint64</span>(<span class="number">0x7fffffffffffffff</span>)</span><br><span class="line">	<span class="keyword">if</span> header.GasLimit &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasLimit: have %v, max %v&quot;</span>, header.GasLimit, <span class="built_in">cap</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 确认<code>gasUsed</code>为&lt;&#x3D; <code>gasLimit</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> header.GasUsed &gt; header.GasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasUsed: have %d, gasLimit %d&quot;</span>, header.GasUsed, header.GasLimit)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 验证块号是父块加1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> diff := <span class="built_in">new</span>(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(<span class="number">1</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrInvalidNumber</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.8检查给定的块是否满足pow难度要求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> seal &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.VerifySeal(chain, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：<code>VerifyUncles</code></p>
<p>3.1叔叔块最多两个 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(block.Uncles()) &gt; maxUncles &#123;</span><br><span class="line">		<span class="keyword">return</span> errTooManyUncles</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.2收集叔叔块和祖先块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">number, parent := block.NumberU64()<span class="number">-1</span>, block.ParentHash()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">		ancestor := chain.GetBlock(parent, number)</span><br><span class="line">		<span class="keyword">if</span> ancestor == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ancestors[ancestor.Hash()] = ancestor.Header()</span><br><span class="line">		<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> ancestor.Uncles() &#123;</span><br><span class="line">			uncles.Add(uncle.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		parent, number = ancestor.ParentHash(), number<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ancestors[block.Hash()] = block.Header()</span><br><span class="line">	uncles.Add(block.Hash())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.3 确保叔块只被奖励一次且叔块有个有效的祖先</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, uncle := <span class="keyword">range</span> block.Uncles() &#123;</span><br><span class="line">		<span class="comment">// Make sure every uncle is rewarded only once</span></span><br><span class="line">		hash := uncle.Hash()</span><br><span class="line">		<span class="keyword">if</span> uncles.Contains(hash) &#123;</span><br><span class="line">			<span class="keyword">return</span> errDuplicateUncle</span><br><span class="line">		&#125;</span><br><span class="line">		uncles.Add(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure the uncle has a valid ancestry</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[hash] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errUncleIsAncestor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ancestors[uncle.ParentHash] == <span class="literal">nil</span> || uncle.ParentHash == block.ParentHash() &#123;</span><br><span class="line">			<span class="keyword">return</span> errDanglingUncle</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], <span class="literal">true</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：<code>Prepare</code></p>
<blockquote>
<p>初始化<code>header</code>的<code>Difficulty</code>字段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	header.Difficulty = ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>⑤：<code>Finalize</code>会执行交易后的所有状态修改（例如，区块奖励），但<strong>不会组装</strong>该区块。</p>
<p>5.1累积任何块和叔块的奖励</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accumulateRewards(chain.Config(), state, header, uncles)</span><br></pre></td></tr></table></figure>

<p>5.2计算状态树的根哈希并提交到<code>header</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br></pre></td></tr></table></figure>

<p>⑥：<code>FinalizeAndAssemble</code> 运行任何交易后状态修改（例如，块奖励），并组装最终块。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> FinalizeAndAssemble(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, <span class="type">error</span>) &#123;</span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, uncles, receipts), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显就是比<code>Finalize</code>多了 <code>types.NewBlock</code></p>
<p>⑦：<code>SealHash</code>返回在<code>seal</code>之前块的哈希（会跟<code>seal</code>之后的块哈希不同）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> SealHash(header *types.Header) (hash common.Hash) &#123;</span><br><span class="line">	hasher := sha3.NewLegacyKeccak256()</span><br><span class="line"></span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra,</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑧：<code>Seal</code>给定的输入块生成一个新的密封请求（<strong>挖矿</strong>），并将结果推送到给定的通道中。</p>
<p>注意，该方法将立即返回并将异步发送结果。 根据共识算法，可能还会返回多个结果。这部分会在下面的挖矿中具体分析，这里跳过。</p>
<hr>
<h3 id="挖矿细节"><a href="#挖矿细节" class="headerlink" title="挖矿细节"></a>挖矿细节</h3><blockquote>
<p>大家在阅读本文时有任何疑问均可留言给我，我一定会及时回复。如果觉得写得不错可以关注最下方<strong>参考</strong>的 <code>github项目</code>，可以第一时间关注作者文章动态。</p>
</blockquote>
<p>挖矿的核心接口定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seal(chain ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>进入到<code>seal</code>函数：</p>
<p>①：如果运行错误的<code>POW</code>，直接返回空的<code>nonce</code>和<code>MixDigest</code>，同时块也是空块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		header := block.Header()</span><br><span class="line">		header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> results &lt;- block.WithSeal(header):</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;fake&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：共享<code>pow</code>的话，则转到它的共享对象执行<code>Seal</code>操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.shared.Seal(chain, block, results, stop)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：获取种子源，并根据其生成<code>ethash</code>需要的种子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f ethash.rand == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 获得种子</span></span><br><span class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ethash.lock.Unlock()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">// 给rand赋值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：挖矿的核心工作交给<code>mine</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line">		pend.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>, nonce <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()</span><br><span class="line">			ethash.mine(block, id, nonce, abort, locals) <span class="comment">// 真正执行挖矿的动作</span></span><br><span class="line">		&#125;(i, <span class="type">uint64</span>(ethash.rand.Int63()))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：处理挖矿的结果</p>
<ul>
<li>外部意外中止，停止所有挖矿线程</li>
<li>其中一个线程挖到正确块，中止其他所有线程</li>
<li>ethash对象发生改变，停止当前所有操作，重启当前方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> result *types.Block</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> result = &lt;-locals:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> results &lt;- result: <span class="comment">//其中一个线程挖到正确块，中止其他所有线程</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ethash.update:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">			<span class="keyword">if</span> err := ethash.Seal(chain, block, results, stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				ethash.config.Log.Error(<span class="string">&quot;Failed to restart sealing after update&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以知道<code>seal</code>的核心工作是由<code>mine</code>函数完成的，重点介绍一下。</p>
<p><code>mine</code>函数其实也比较简单，它是<em>真正的<code>pow</code>矿工，用来搜索一个<code>nonce</code>值，<code>nonce</code>值开始于<code>seed</code>值，<code>seed</code>值是能最终产生正确的可匹配可验证的区块难度</em></p>
<p>①：从区块头中提取相关数据，放在全局变量域中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		header  = block.Header()</span><br><span class="line">		hash    = ethash.SealHash(header).Bytes()</span><br><span class="line">		target  = <span class="built_in">new</span>(big.Int).Div(two256, header.Difficulty) <span class="comment">// 这是用来验证的target</span></span><br><span class="line">		number  = header.Number.Uint64()</span><br><span class="line">		dataset = ethash.dataset(number, <span class="literal">false</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>②：开始产生随机<code>nonce</code>，直到我们中止或找到一个好的<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		attempts = <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">		nonce    = seed</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>③： 聚集完整的<code>dataset</code>数据，为特定的header和nonce产生最终哈希值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoFull</span><span class="params">(dataset []<span class="type">uint32</span>, hash []<span class="type">byte</span>, nonce <span class="type">uint64</span>)</span></span> ([]<span class="type">byte</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line">  <span class="comment">//定义一个lookup函数，用于在数据集中查找数据</span></span><br><span class="line">	lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">uint32</span>)</span></span> []<span class="type">uint32</span> &#123;</span><br><span class="line">		offset := index * hashWords <span class="comment">//hashWords是上面定义的常量值= 16</span></span><br><span class="line">		<span class="keyword">return</span> dataset[offset : offset+hashWords]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hashimoto(hash, nonce, <span class="type">uint64</span>(<span class="built_in">len</span>(dataset))*<span class="number">4</span>, lookup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现实际上<code>hashimotoFull</code>函数做的工作就是将原始数据集进行了读取分割，然后传给<code>hashimoto</code>函数。接下来重点分析<code>hashimoto</code>函数：</p>
<p>3.1根据seed获取区块头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rows := <span class="type">uint32</span>(size / mixBytes) ①</span><br><span class="line">seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">40</span>) ②</span><br><span class="line"><span class="built_in">copy</span>(seed, hash) ③</span><br><span class="line">binary.LittleEndian.PutUint64(seed[<span class="number">32</span>:], nonce)④</span><br><span class="line">seed = crypto.Keccak512(seed)⑤</span><br><span class="line">seedHead := binary.LittleEndian.Uint32(seed)⑥</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数据集的行数</li>
<li>合并<code>header+nonce</code>到一个 40 字节的<code>seed</code></li>
<li>将区块头的<code>hash</code>拷贝到<code>seed</code>中</li>
<li>将<code>nonce</code>值填入<code>seed</code>的后（40-32&#x3D;8）字节中去，（nonce本身就是<code>uint64</code>类型，是 64 位，对应 8 字节大小），正好把<code>hash</code>和<code>nonce</code>完整的填满了 40 字节的 seed </li>
<li><code>Keccak512</code>加密<code>seed</code></li>
<li>从<code>seed</code>中获取区块头</li>
</ol>
<p>3.2 从复制的种子开始混合</p>
<ul>
<li><code>mixBytes</code>常量&#x3D; 128，<code>mix</code>的长度为 32，元素为<code>uint32</code>，是 32位，对应为 4 字节大小。所以<code>mix</code>总共大小为 4*32&#x3D;128 字节大小</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">uint32</span>, mixBytes/<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">		mix[i] = binary.LittleEndian.Uint32(seed[i%<span class="number">16</span>*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 混合随机数据集节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temp := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="built_in">len</span>(mix))<span class="comment">//与mix结构相同，长度相同</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; loopAccesses; i++ &#123;</span><br><span class="line">		parent := fnv(<span class="type">uint32</span>(i)^seedHead, mix[i%<span class="built_in">len</span>(mix)]) % rows</span><br><span class="line">		<span class="keyword">for</span> j := <span class="type">uint32</span>(<span class="number">0</span>); j &lt; mixBytes/hashBytes; j++ &#123;</span><br><span class="line">			<span class="built_in">copy</span>(temp[j*hashWords:], lookup(<span class="number">2</span>*parent+j))</span><br><span class="line">		&#125;</span><br><span class="line">		fnvHash(mix, temp)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 压缩混合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i += <span class="number">4</span> &#123;</span><br><span class="line">		mix[i/<span class="number">4</span>] = fnv(fnv(fnv(mix[i], mix[i+<span class="number">1</span>]), mix[i+<span class="number">2</span>]), mix[i+<span class="number">3</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	mix = mix[:<span class="built_in">len</span>(mix)/<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	digest := <span class="built_in">make</span>([]<span class="type">byte</span>, common.HashLength)</span><br><span class="line">	<span class="keyword">for</span> i, val := <span class="keyword">range</span> mix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(digest[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digest, crypto.Keccak256(<span class="built_in">append</span>(seed, digest...))</span><br></pre></td></tr></table></figure>

<p>最终返回的是<code>digest</code>和<code>digest</code>与<code>seed</code>的哈希；而<code>digest</code>其实就是<code>mix</code>的<code>[]byte</code>形式。在前面<code>Ethash.mine</code>的代码中我们已经看到使用第二个返回值与<code>target</code>变量进行比较，以确定这是否是一个有效的哈希值。</p>
<hr>
<h3 id="验证pow"><a href="#验证pow" class="headerlink" title="验证pow"></a>验证pow</h3><p>挖矿信息的验证有两部分：</p>
<ol>
<li>验证<code>Header.Difficulty</code>是否正确</li>
<li>验证<code>Header.MixDigest</code>和<code>Header.Nonce</code>是否正确</li>
</ol>
<p>①：验证<code>Header.Difficulty</code>的代码主要在<code>Ethash.verifyHeader</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeader(chain consensus.ChainReader, header, parent *types.Header, uncle <span class="type">bool</span>, seal <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过区块高度和时间差作为参数来计算<code>Difficulty</code>值，然后与待验证的区块的<code>Header.Difficulty</code>字段进行比较，如果相等则认为是正确的。</p>
<p>②：<code>MixDigest</code>和<code>Nonce</code>的验证主要是在<code>Header.verifySeal</code>中：</p>
<p>验证的方式:使用<code>Header.Nonce</code>和头部哈希通过<code>hashimoto</code>重新计算一遍<code>MixDigest</code>和<code>result</code>哈希值,并且验证的节点是不需要dataset数据的。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> </p>
<p>公众号：区块链技术栈  （推荐哦）</p>
<p><a target="_blank" rel="noopener" href="https://eth.wiki/concepts/ethash/design-rationale">https://eth.wiki/concepts/ethash/design-rationale</a></p>
<p><a target="_blank" rel="noopener" href="https://eth.wiki/concepts/ethash/dag">https://eth.wiki/concepts/ethash/dag</a></p>
<p><a target="_blank" rel="noopener" href="https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/">https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/" class="post-title-link" itemprop="url">死磕以太坊源码分析之downloader同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:15 / Modified: 13:11:05" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:15+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之downloader同步</p>
<p><strong>需要配合注释代码看</strong>：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> 给个star哦</p>
<p><em>这篇文章篇幅较长，能看下去的是条汉子，建议收藏</em></p>
<p>希望读者在阅读过程中，指出问题，给个关注，一起探讨。</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>downloader</code> 模块的代码位于 <code>eth/downloader</code> 目录下。主要的功能代码分别是：</p>
<ul>
<li><p><code>downloader.go</code> ：实现了区块同步逻辑</p>
</li>
<li><p><code>peer.go</code> ：对区块各个阶段的组装，下面的各个<code>FetchXXX</code> 就是很依赖这个模块。</p>
</li>
<li><p><code>queue.go</code> ：对<code>eth/peer.go</code>的封装</p>
</li>
<li><p><code>statesync.go</code> ：同步<code>state</code>对象</p>
</li>
</ul>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="full-sync"><a href="#full-sync" class="headerlink" title="full  sync"></a>full  sync</h3><p>full 模式会在数据库中保存所有区块数据，同步时从远程节点同步 header 和 body 数据，而state 和 receipt 数据则是在本地计算出来的。</p>
<p>在 full 模式下，downloader 会同步区块的 header 和 body 数据组成一个区块，然后通过 blockchain 模块的 <code>BlockChain.InsertChain</code> 向数据库中插入区块。在 <code>BlockChain.InsertChain</code> 中，会逐个计算和验证每个块的 <code>state</code> 和 <code>recepit</code> 等数据，如果一切正常就将区块数据以及自己计算得到的 <code>state</code>、<code>recepit</code> 数据一起写入到数据库中。</p>
<h3 id="fast-sync"><a href="#fast-sync" class="headerlink" title="fast sync"></a>fast sync</h3><p> <code>fast</code> 模式下，<code>recepit</code> 不再由本地计算，而是和区块数据一样，直接由 <code>downloader</code> 从其它节点中同步；<code>state</code> 数据并不会全部计算和下载，而是选一个较新的区块（称之为 <code>pivot</code>）的 <code>state</code> 进行下载，以这个区块为分界，之前的区块是没有 <code>state</code> 数据的，之后的区块会像 <code>full</code> 模式下一样在本地计算 <code>state</code>。因此在 <code>fast</code> 模式下，同步的数据除了 <code>header</code> 和 body，还有 <code>receipt</code>，以及 <code>pivot</code> 区块的 <code>state</code>。</p>
<p>因此 <code>fast</code> 模式忽略了大部分 <code>state</code> 数据，并且使用网络直接同步 <code>receipt</code> 数据的方式替换了 full 模式下的本地计算，所以比较快。</p>
<h3 id="light-sync"><a href="#light-sync" class="headerlink" title="light sync"></a>light sync</h3><p>light 模式也叫做轻模式，它只对区块头进行同步，而不同步其它的数据。</p>
<p>SyncMode:</p>
<ul>
<li>FullSync:从完整区块同步整个区块链历史</li>
<li>FastSync:快速下载标题，仅在链头处完全同步</li>
<li>LightSync:仅下载标题，然后终止</li>
</ul>
<h2 id="区块下载流程"><a href="#区块下载流程" class="headerlink" title="区块下载流程"></a>区块下载流程</h2><blockquote>
<p>图片只是大概的描述一下，实际还是要结合代码，<strong>所有区块链相关文章合集</strong>，<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>同时希望结识更多区块链圈子的人，可以star上面项目，持续更新</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glwzmv4zyej30zh0u0dps.jpg" alt="image-20201222221031797"></p>
<p>首先根据<code>Synchronise</code>开始区块同步，通过<code>findAncestor</code>找到指定节点的共同祖先，并在此高度进行同步，同时开启多个<code>goroutine</code>同步不同的数据：<code>header</code>、<code>receipt</code>、<code>body</code>。假如同步高度为 100 的区块，必须先<code>header</code>同步成功同步完成才可以唤醒<code>body</code>和<code>receipts</code>的同步。</p>
<p>而每个部分的同步大致都是由<code>FetchParts</code>来完成的，里面包含了各个<code>Chan</code>的配合，也会涉及不少的回调函数，总而言之多读几遍每次都会有不同的理解。接下来就逐步分析这些关键内容。</p>
<hr>
<h2 id="synchronise"><a href="#synchronise" class="headerlink" title="synchronise"></a>synchronise</h2><p>①：确保对方的TD高于我们自己的TD</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">	td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line">	pHead, pTd := peer.Head()</span><br><span class="line">	<span class="keyword">if</span> pTd.Cmp(td) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启<code>downloader</code>的同步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.downloader.Synchronise(peer.id, pHead, pTd, mode)</span><br></pre></td></tr></table></figure>

<p>进入函数：主要做了以下几件事：</p>
<ol>
<li><code>d.synchronise(id, head, td, mode)</code> ：同步过程</li>
<li>错误日志输出， 并删除此<code>peer</code>。</li>
</ol>
<p>进入到<code>d.synchronise</code>，走到最后一步<code>d.syncWithPeer(p, hash, td)</code>真正开启同步。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> synchronise(id <span class="type">string</span>, hash common.Hash, td *big.Int, mode SyncMode) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> d.syncWithPeer(p, hash, td)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syncWithPeer大概做了以下几件事：</p>
<ol>
<li>查找祖先<code>findAncestor</code></li>
<li>开启单独<code>goroutine</code>分别运行以下几个函数：<ul>
<li>fetchHeaders</li>
<li>processHeaders</li>
<li>fetchbodies</li>
<li>fetchReceipts</li>
<li>processFastSyncContent</li>
<li>processFullSyncContent</li>
</ul>
</li>
</ol>
<p>接下来的文章，以及整个<code>Downloader</code>模块主要内容就是围绕这几个部分进行展开。</p>
<hr>
<h2 id="findAncestor"><a href="#findAncestor" class="headerlink" title="findAncestor"></a>findAncestor</h2><p>同步首要的是<strong>确定同步区块的区间</strong>：顶部为远程节点的最高区块，底部为两个节点都拥有的相同区块的最高高度（祖先区块）。<code>findAncestor</code>就是用来找祖先区块。函数分析如下：</p>
<p>①：确定本地高度和远程节点的最高高度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		floor        = <span class="type">int64</span>(<span class="number">-1</span>) <span class="comment">// 底部</span></span><br><span class="line">		localHeight  <span class="type">uint64</span>  <span class="comment">// 本地最高高度</span></span><br><span class="line">		remoteHeight = remoteHeader.Number.Uint64() <span class="comment">// 远程节点最高高度</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">switch</span> d.mode &#123;</span><br><span class="line">	<span class="keyword">case</span> FullSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentBlock().NumberU64()</span><br><span class="line">	<span class="keyword">case</span> FastSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentFastBlock().NumberU64()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		localHeight = d.lightchain.CurrentHeader().Number.Uint64()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：计算同步的高度区间和间隔</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from, count, skip, max := calculateRequestSpan(remoteHeight, localHeight) </span><br></pre></td></tr></table></figure>

<ul>
<li><code>from</code>:：表示从哪个高度开始获取区块</li>
<li><code>count</code>：表示从远程节点获取多少个区块</li>
<li><code>skip</code>：表示间隔，比如<code>skip</code> 为 2 ，获取第一个高度为 5，则第二个就是 8</li>
<li><code>max</code>：表示最大高度</li>
</ul>
<p>③：发送获取<code>header</code>的请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> p.peer.RequestHeadersByNumber(<span class="type">uint64</span>(from), count, skip, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>④：处理上面请求接收到的<code>header</code>  :<code>case packet := &lt;-d.headerCh</code></p>
<ol>
<li>丢弃掉不是来自我们请求节的内容</li>
<li>确保返回的<code>header</code>数量不为空</li>
<li>验证返回的<code>headers</code>的高度是我们所请求的</li>
<li>检查是否找到共同祖先</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----①</span></span><br><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received headers from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----②</span></span><br><span class="line">headers := packet.(*headerPack).headers</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">				p.log.Warn(<span class="string">&quot;Empty head header set&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//-----③</span></span><br><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">				expectNumber := from + <span class="type">int64</span>(i)*<span class="type">int64</span>(skip+<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span> number := header.Number.Int64(); number != expectNumber &#123; <span class="comment">// 验证这些返回的header是否是我们上面请求的headers</span></span><br><span class="line">					p.log.Warn(<span class="string">&quot;Head headers broke chain ordering&quot;</span>, <span class="string">&quot;index&quot;</span>, i, <span class="string">&quot;requested&quot;</span>, expectNumber, <span class="string">&quot;received&quot;</span>, number)</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>, errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----④</span></span><br><span class="line"><span class="comment">// 检查是否找到共同祖先</span></span><br><span class="line">			finished = <span class="literal">true</span></span><br><span class="line">			<span class="comment">//注意这里是从headers最后一个元素开始查找，也就是高度最高的区块。</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="built_in">len</span>(headers) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">				<span class="comment">// 跳过不在我们请求的高度区间内的区块</span></span><br><span class="line">				<span class="keyword">if</span> headers[i].Number.Int64() &lt; from || headers[i].Number.Uint64() &gt; max &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// //检查我们本地是否已经有某个区块了，如果有就算是找到了共同祖先，</span></span><br><span class="line">				<span class="comment">//并将共同祖先的哈希和高度设置在number和hash变量中。</span></span><br><span class="line">				h := headers[i].Hash()</span><br><span class="line">				n := headers[i].Number.Uint64()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>⑤：如果通过固定间隔法找到了共同祖先则返回祖先，会对其高度与 <code>floor</code> 变量进行验证, <code>floor</code> 变量代表的是共同祖先的高度的最小值,如果找到共同祖先的高度比这个值还小，就认为是两个节点之间分叉太大了，不再允许进行同步。如果一切正常，就返回找到的共同祖先的高度 <code>number</code> 变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hash != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">int64</span>(number) &lt;= floor &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, errInvalidAncestor</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>⑥：如果固定间隔法没有找到祖先则通过二分法来查找祖先，这部分可以思想跟二分法算法类似，有兴趣的可以细看。</p>
<hr>
<h2 id="queue详解"><a href="#queue详解" class="headerlink" title="queue详解"></a>queue详解</h2><p><code>queue</code>对象和<code>Downloader</code>对象是相互作用的，<code>Downloader</code>的很多功能离不开他，接下来我们介绍一下这部分内容，但是本节，<strong>可以先行跳过</strong>，等到了阅读下面的关于<code>Queue</code>调用的一些函数部分再回过来阅读这部分讲解。</p>
<h3 id="queue结构体"><a href="#queue结构体" class="headerlink" title="queue结构体"></a>queue结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> queue <span class="keyword">struct</span> &#123;</span><br><span class="line">  mode SyncMode <span class="comment">// 同步模式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// header处理相关</span></span><br><span class="line">  headerHead      common.Hash   <span class="comment">//最后一个排队的标头的哈希值以验证顺序</span></span><br><span class="line">  headerTaskPool  <span class="keyword">map</span>[<span class="type">uint64</span>]*types.Header  <span class="comment">//待处理的标头检索任务，将起始索引映射到框架标头</span></span><br><span class="line">  headerTaskQueue *prque.Prque  <span class="comment">//骨架索引的优先级队列，以获取用于的填充标头</span></span><br><span class="line">  headerPeerMiss <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已知不可用的对等头批处理集</span></span><br><span class="line">  headerPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前挂起的头检索操作</span></span><br><span class="line">  headerResults []*types.Header <span class="comment">//结果缓存累积完成的头</span></span><br><span class="line">  headerProced <span class="type">int</span> <span class="comment">//从结果中拿出来已经处理的header</span></span><br><span class="line">  headerContCh <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">//header下载完成时通知的频道</span></span><br><span class="line">  </span><br><span class="line">  blockTaskPool  <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的块（body）检索任务，将哈希映射到header</span></span><br><span class="line">  blockTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取块（bodies）</span></span><br><span class="line">  blockPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的块（body)检索操作</span></span><br><span class="line">  blockDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的块（body)</span></span><br><span class="line">  </span><br><span class="line">	receiptTaskPool <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的收据检索任务，将哈希映射到header</span></span><br><span class="line">	receiptTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取收据</span></span><br><span class="line">	receiptPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的收据检索操作</span></span><br><span class="line">	receiptDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的收据</span></span><br><span class="line">	</span><br><span class="line">	resultCache []*fetchResult <span class="comment">//下载但尚未交付获取结果</span></span><br><span class="line">	resultOffset <span class="type">uint64</span> <span class="comment">//区块链中第一个缓存的获取结果的偏移量</span></span><br><span class="line">	resultSize common.StorageSize <span class="comment">// 块的近似大小</span></span><br><span class="line"></span><br><span class="line">	lock   *sync.Mutex</span><br><span class="line">	active *sync.Cond</span><br><span class="line">	closed <span class="type">bool</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要细分功能"><a href="#主要细分功能" class="headerlink" title="主要细分功能"></a>主要细分功能</h3><h4 id="数据下载开始安排任务"><a href="#数据下载开始安排任务" class="headerlink" title="数据下载开始安排任务"></a>数据下载开始安排任务</h4><ul>
<li><code>ScheduleSkeleton</code>:<em>将一批<code>header</code>检索任务添加到队列中，以填充已检索的<code>header skeleton</code></em></li>
<li><code>Schedule</code>:<em>用来准备对一些 <code>body</code> 和 <code>receipt</code> 数据的下载</em></li>
</ul>
<h4 id="数据下载中的各类状态"><a href="#数据下载中的各类状态" class="headerlink" title="数据下载中的各类状态"></a>数据下载中的各类状态</h4><ul>
<li><p><code>pending</code></p>
<p><code>pending</code>表示待检索的XXX请求的数量，包括了：<code>PendingHeaders</code>、<code>PendingBlocks</code>、<code>PendingReceipts</code>，分别都是对应取<code>XXXTaskQueue</code>的长度。</p>
</li>
<li><p><code>InFlight</code></p>
<p><code>InFlight</code>表示是否有正在获取XXX的请求，包括：<code>InFlightHeaders</code>、<code>InFlightBlocks</code>、<code>InFlightReceipts</code>，都是通过判断<code>len(q.receiptPendPool) &gt; 0</code> 来确认。</p>
</li>
<li><p><code>ShouldThrottle</code></p>
<p><code>ShouldThrottle</code>表示检查是否应该限制下载XXX，包括:<code>ShouldThrottleBlocks</code>、<code>ShouldThrottleReceipts</code>，主要是为了防止下载过程中本地内存占用过大。</p>
</li>
<li><p><code>Reserve</code></p>
<p><code>Reserve</code>通过构造一个 <code>fetchRequest</code> 结构并返回，向调用者提供指定数量的待下载的数据的信息（<code>queue</code> 内部会将这些数据标记为「正在下载」）。调用者使用返回的 <code>fetchRequest</code> 数据向远程节点发起新的获取数据的请求。包括：<code>ReserveHeaders</code>、<code>ReserveBodies</code>、<code>ReserveReceipts</code>。</p>
</li>
<li><p><code>Cancel</code></p>
<p><code>Cance</code>用来撤消对 <code>fetchRequest</code> 结构中的数据的下载（<code>queue</code> 内部会将这些数据重新从「正在下载」的状态更改为「等待下载」）。包括：<code>CancelHeaders</code>、<code>CancelBodies</code>、<code>CancelReceipts</code>。</p>
</li>
<li><p><code>expire</code></p>
<p><code>expire</code>检查正在执行中的请求是否超过了超时限制，包括：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>。</p>
</li>
<li><p><code>Deliver</code></p>
<p>当有数据下载成功时，调用者会使用 <code>deliver</code> 功能用来通知 <code>queue</code> 对象。包括：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。</p>
</li>
</ul>
<h4 id="数据下载完成获取区块数据"><a href="#数据下载完成获取区块数据" class="headerlink" title="数据下载完成获取区块数据"></a>数据下载完成获取区块数据</h4><ul>
<li><code>RetrieveHeaders</code><br>在填充 <code>skeleton</code> 完成后，<code>queue.RetrieveHeaders</code> 用来获取整个 <code>skeleton</code> 中的所有 <code>header</code>。</li>
<li><code>Results</code><br><code>queue.Results</code> 用来获取当前的 <code>header</code>、<code>body</code> 和 <code>receipt</code>（只在 <code>fast</code> 模式下） 都已下载成功的区块（并将这些区块从 <code>queue</code> 内部移除）</li>
</ul>
<hr>
<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><h4 id="ScheduleSkeleton"><a href="#ScheduleSkeleton" class="headerlink" title="ScheduleSkeleton"></a>ScheduleSkeleton</h4><p>queue.ScheduleSkeleton主要是为了填充skeleton，它的参数是要下载区块的起始高度和所有 <code>skeleton</code> 区块头，最核心的内容则是下面这段循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ScheduleSkeleton(from <span class="type">uint64</span>, skeleton []*types.Header) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> i, header := <span class="keyword">range</span> skeleton &#123;</span><br><span class="line">        index := from + <span class="type">uint64</span>(i*y)</span><br><span class="line">        q.headerTaskPool[index] = header</span><br><span class="line">        q.headerTaskQueue.Push(index, -<span class="type">int64</span>(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设已确定需要下载的区块高度区间是从 10 到 46，<code>MaxHeaderFetch</code> 的值为 10，那么这个高度区块就会被分成 3 组：10 - 19，20 - 29，30 - 39，而 skeleton 则分别由高度为 19、29、39 的区块头组成。循环中的 <code>index</code> 变量实际上是每一组区块中的第一个区块的高度（比如 10、20、30），<code>queue.headerTaskPool</code> 实际上是一个<strong>每一组区块中第一个区块的高度到最后一个区块的 header 的映射</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headerTaskPool = &#123;</span><br><span class="line">  <span class="number">10</span>: headerOf_19,</span><br><span class="line">	<span class="number">20</span>: headerOf_20,</span><br><span class="line">	<span class="number">30</span>: headerOf_39,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ReserveHeaders"><a href="#ReserveHeaders" class="headerlink" title="ReserveHeaders"></a>ReserveHeaders</h4><p><code>reserve</code> 用来获取可下载的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reserve  = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, count <span class="type">int</span>)</span></span> (*fetchRequest, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> d.queue.ReserveHeaders(p, count), <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ReserveHeaders(p *peerConnection, count <span class="type">int</span>) *fetchRequest &#123;</span><br><span class="line">  <span class="keyword">if</span> _, ok := q.headerPendPool[p.id]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="comment">//①</span></span><br><span class="line">  ...</span><br><span class="line">  send, skip := <span class="type">uint64</span>(<span class="number">0</span>), []<span class="type">uint64</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> send == <span class="number">0</span> &amp;&amp; !q.headerTaskQueue.Empty() &#123;</span><br><span class="line">		from, _ := q.headerTaskQueue.Pop()</span><br><span class="line">		<span class="keyword">if</span> q.headerPeerMiss[p.id] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := q.headerPeerMiss[p.id][from.(<span class="type">uint64</span>)]; ok &#123;</span><br><span class="line">				skip = <span class="built_in">append</span>(skip, from.(<span class="type">uint64</span>))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		send = from.(<span class="type">uint64</span>) <span class="comment">// ②</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">for</span> _, from := <span class="keyword">range</span> skip &#123;</span><br><span class="line">		q.headerTaskQueue.Push(from, -<span class="type">int64</span>(from))</span><br><span class="line">	&#125; <span class="comment">// ③</span></span><br><span class="line">  ...</span><br><span class="line">  request := &amp;fetchRequest&#123;</span><br><span class="line">		Peer: p,</span><br><span class="line">		From: send,</span><br><span class="line">		Time: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	q.headerPendPool[p.id] = request <span class="comment">// ④</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①：根据<code>headerPendPool</code>来判断远程节点是否正在下载数据信息。</p>
<p>②：从<code>headerTaskQueue</code>取出值作为本次请求的起始高度，赋值给<code>send</code>变量，在这个过程中会排除headerPeerMiss所记录的节点下载数据失败的信息。</p>
<p>③：将失败的任务再重新写回<code>task queue</code></p>
<p>④：利用<code>send</code>变量构造<code>fetchRequest</code>结构，此结构是用来作为<code>FetchHeaders</code>来使用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, req *fetchRequest)</span></span> <span class="type">error</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> p.FetchHeaders(req.From, MaxHeaderFetch) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>ReserveHeaders</code>会从任务队列里选择最小的起始高度并构造<code>fetchRequest</code>传递给<code>fetch</code>获取数据。</p>
<hr>
<h4 id="DeliverHeaders"><a href="#DeliverHeaders" class="headerlink" title="DeliverHeaders"></a>DeliverHeaders</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deliver = <span class="function"><span class="keyword">func</span><span class="params">(packet dataPack)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			pack := packet.(*headerPack)</span><br><span class="line">			<span class="keyword">return</span> d.queue.DeliverHeaders(pack.peerID, pack.headers, d.headerProcCh)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>①：如果发现下载数据的节点没有在 <code>queue.headerPendPool</code> 中，就直接返回错误；否则就继续处理，并将节点记录从 <code>queue.headerPendPool</code> 中删除。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request := q.headerPendPool[id]</span><br><span class="line">	<span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errNoFetchesPending</span><br><span class="line">	&#125;</span><br><span class="line">	headerReqTimer.UpdateSince(request.Time)</span><br><span class="line">	<span class="built_in">delete</span>(q.headerPendPool, id)</span><br></pre></td></tr></table></figure>

<p>②：验证<code>headers</code> </p>
<p>包括三方面验证：</p>
<ol>
<li>检查起始区块的高度和哈希</li>
<li>检查高度的连接性</li>
<li>检查哈希的连接性</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="comment">//检查起始区块的高度和哈希</span></span><br><span class="line">		<span class="keyword">if</span> headers[<span class="number">0</span>].Number.Uint64() != request.From &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>].Hash() != target &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="keyword">for</span> i, header := <span class="keyword">range</span> headers[<span class="number">1</span>:] &#123;</span><br><span class="line">			hash := header.Hash() <span class="comment">// 检查高度的连接性</span></span><br><span class="line">			<span class="keyword">if</span> want := request.From + <span class="number">1</span> + <span class="type">uint64</span>(i); header.Number.Uint64() != want &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> headers[i].Hash() != header.ParentHash &#123; <span class="comment">// 检查哈希的连接性</span></span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③： 将无效数据存入<code>headerPeerMiss</code>，并将这组区块起始高度重新放入<code>headerTaskQueue</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !accepted &#123;</span><br><span class="line">	...</span><br><span class="line">		miss := q.headerPeerMiss[id]</span><br><span class="line">		<span class="keyword">if</span> miss == <span class="literal">nil</span> &#123;</span><br><span class="line">			q.headerPeerMiss[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			miss = q.headerPeerMiss[id]</span><br><span class="line">		&#125;</span><br><span class="line">		miss[request.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		q.headerTaskQueue.Push(request.From, -<span class="type">int64</span>(request.From))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;delivery not accepted&quot;</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：保存数据，并通知<code>headerProcCh</code>处理新的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ready &gt; <span class="number">0</span> &#123;</span><br><span class="line">		process := <span class="built_in">make</span>([]*types.Header, ready)</span><br><span class="line">		<span class="built_in">copy</span>(process, q.headerResults[q.headerProced:q.headerProced+ready])</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> headerProcCh &lt;- process:</span><br><span class="line">			q.headerProced += <span class="built_in">len</span>(process)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：发送消息给.<code>headerContCh</code>，通知<code>skeleton</code> 都被下载完了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">		q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>DeliverHeaders</code> 会对数据进行检验和保存，并发送 channel 消息给 <code>Downloader.processHeaders</code> 和 <code>Downloader.fetchParts</code>的 <code>wakeCh</code> 参数。</p>
<hr>
<h4 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h4><p><code>processHeaders</code>在处理<code>header</code>数据的时候，会调用<code>queue.Schedule</code> 为下载 <code>body</code> 和 <code>receipt</code> 作准备。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inserts := d.queue.Schedule(chunk, origin)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> Schedule(headers []*types.Header, from <span class="type">uint64</span>) []*types.Header &#123;</span><br><span class="line">	inserts := <span class="built_in">make</span>([]*types.Header, <span class="number">0</span>, <span class="built_in">len</span>(headers))</span><br><span class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    ...</span><br><span class="line">		q.blockTaskPool[hash] = header</span><br><span class="line">		q.blockTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">			q.receiptTaskPool[hash] = header</span><br><span class="line">			q.receiptTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">		inserts = <span class="built_in">append</span>(inserts, header)</span><br><span class="line">		q.headerHead = hash</span><br><span class="line">		from++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inserts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要就是将信息写入到body和receipt队列，等待调度。</p>
<hr>
<h4 id="ReserveBody-Receipt"><a href="#ReserveBody-Receipt" class="headerlink" title="ReserveBody&amp;Receipt"></a>ReserveBody&amp;Receipt</h4><p>在 <code>queue</code> 中准备好了 <strong>body</strong> 和 <strong>receipt</strong> 相关的数据， <code>processHeaders</code>最后一段，是唤醒下载Bodyies和Receipts的关键代码，会通知 <code>fetchBodies</code> 和 <code>fetchReceipts</code> 可以对各自的数据进行下载了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>fetchXXX</code> 会调用<code>fetchParts</code>，逻辑类似上面的的，<code>reserve</code>最终则会调用<code>reserveHeaders</code>，<code>deliver</code> 最终调用的是 <code>queue.deliver</code>.</p>
<p>先来分析<code>reserveHeaders</code>：</p>
<p>①：如果没有可处理的任务，直接返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> taskQueue.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②：如果参数给定的节点正在下载数据，返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := pendPool[p.id]; ok &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>③：计算 queue 对象中的缓存空间还可以容纳多少条数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">space := q.resultSlots(pendPool, donePool)</span><br></pre></td></tr></table></figure>

<p>④：从 「task queue」 中依次取出任务进行处理</p>
<p>主要实现以下功能：</p>
<ul>
<li>计算当前 header 在 <code>queue.resultCache</code> 中的位置，然后填充 <code>queue.resultCache</code> 中相应位置的元素</li>
<li>处理空区块的情况，若为空不下载。</li>
<li>处理远程节点缺少这个当前区块数据的情况，如果发现这个节点曾经下载当前数据失败过，就不再让它下载了。</li>
</ul>
<p>注意：<code>resultCache</code> 字段用来记录所有正在被处理的数据的处理结果，它的元素类型是 <code>fetchResult</code> 。它的 <code>Pending</code> 字段代表当前区块还有几类数据需要下载。这里需要下载的数据最多有两类：body 和 receipt，<code>full</code> 模式下只需要下载 <code>body</code> 数据，而 <code>fast</code> 模式要多下载一个 <code>receipt</code> 数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> proc := <span class="number">0</span>; proc &lt; space &amp;&amp; <span class="built_in">len</span>(send) &lt; count &amp;&amp; !taskQueue.Empty(); proc++ &#123;</span><br><span class="line">		header := taskQueue.PopItem().(*types.Header)</span><br><span class="line">		hash := header.Hash()</span><br><span class="line">		index := <span class="type">int</span>(header.Number.Int64() - <span class="type">int64</span>(q.resultOffset))</span><br><span class="line">		<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(q.resultCache) || index &lt; <span class="number">0</span> &#123;</span><br><span class="line">			....</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> q.resultCache[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">			components := <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">				components = <span class="number">2</span></span><br><span class="line">			&#125;</span><br><span class="line">			q.resultCache[index] = &amp;fetchResult&#123;</span><br><span class="line">				Pending: components,</span><br><span class="line">				Hash:    hash,</span><br><span class="line">				Header:  header,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> isNoop(header) &#123;</span><br><span class="line">			donePool[hash] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="built_in">delete</span>(taskPool, hash)</span><br><span class="line"></span><br><span class="line">			space, proc = space<span class="number">-1</span>, proc<span class="number">-1</span></span><br><span class="line">			q.resultCache[index].Pending--</span><br><span class="line">			progress = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.Lacks(hash) &#123;</span><br><span class="line">			skip = <span class="built_in">append</span>(skip, header)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			send = <span class="built_in">append</span>(send, header)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是构造 <code>fetchRequest</code> 结构并返回。</p>
<hr>
<h4 id="DeliverBodies-Receipts"><a href="#DeliverBodies-Receipts" class="headerlink" title="DeliverBodies&amp;Receipts"></a>DeliverBodies&amp;Receipts</h4><p><code>body</code> 或 <code>receipt</code> 数据都已经通过 <code>reserve</code> 操作构造了 <code>fetchRequest</code> 结构并传给 <code>fetch</code>，接下来就是等待数据的到达,数据下载成功后，会调用 <code>queue</code> 对象的 <code>deliver</code> 方法进行传递，包括 <code>queue.DeliverBodies</code> 和 <code>queue.DeliverReceipts</code>。这两个方法都以不同的参数调用了 <code>queue.deliver</code> 方法:</p>
<p>①：如果下载的数据数量为 0，则把所有此节点此次下载的数据标记为「缺失」</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> results == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">			request.Peer.MarkLacking(header.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：循环处理数据，通过调用<code>reconstruct</code> 填充 <code>resultCache[index]</code> 中的相应的字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err := reconstruct(header, i, q.resultCache[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			failure = err</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：验证<code>resultCache</code> 中的数据，其对应的 <code>request.Headers</code> 中的 <code>header</code> 都应为 nil，若不是则说明验证未通过，需要假如到task queue重新下载</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">		<span class="keyword">if</span> header != <span class="literal">nil</span> &#123;</span><br><span class="line">			taskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果有数据被验证通过且写入 <code>queue.resultCache</code> 中了（<code>accepted</code> &gt; 0），发送 <code>queue.active</code> 消息。<code>Results</code> 会等待这这个信号。</p>
<hr>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h4><p>当(header、body、receipt)都下载完，就要将区块写入到数据库了，<code>queue.Results</code> 就是用来返回所有目前已经下载完成的数据，它在 <code>Downloader.processFullSyncContent</code> 和 <code>Downloader.processFastSyncContent</code> 中被调用。代码比较简单就不多说了。</p>
<p>到此为止<code>queue</code>对象就分析的差不多了。</p>
<hr>
<h2 id="同步headers"><a href="#同步headers" class="headerlink" title="同步headers"></a>同步headers</h2><p>继续回到<code>syncWithPeer</code>函数中，来讲下面比较关键的几个点。</p>
<h3 id="fetchHeaders"><a href="#fetchHeaders" class="headerlink" title="fetchHeaders"></a>fetchHeaders</h3><p>同步<code>headers</code> 是是由函数<code>fetchHeaders</code>来完成的。</p>
<p><code>fetchHeaders</code>的大致思想：</p>
<p> 同步<code>header</code>的数据会被填充到<code>skeleton</code>，每次从远程节点获取区块数据最大为<code>MaxHeaderFetch</code>（192），所以要获取的区块数据如果大于192 ，会被分成组，每组<code>MaxHeaderFetch</code>，剩余的不足192个的不会填充进<code>skeleton</code>，具体步骤如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glszpqzeuwj313u0msq73.jpg" alt="image-20201219111103965"></p>
<p>此种方式可以<strong>避免从同一节点下载过多错误数据</strong>，如果我们连接到了一个恶意节点，它可以创造一个链条很长且<code>TD</code>值也非常高的区块链数据。如果我们的区块从 0 开始全部从它那同步，也就下载了一些根本不被别人承认的数据。如果我只从它那同步 <code>MaxHeaderFetch</code> 个区块，然后发现这些区块无法正确填充我之前的 <code>skeleton</code>（可能是 <code>skeleton</code> 的数据错了，或者用来填充 <code>skeleton</code> 的数据错了），就会丢掉这些数据。</p>
<p>接下来查看下代码如何实现：</p>
<p>①：发起获取<code>header</code>的请求</p>
<p>如果是下载<code>skeleton</code>，则会从高度 <code>from+MaxHeaderFetch-1</code> 开始（包括），每隔 <code>MaxHeaderFetch-1</code> 的高度请求一个 <code>header</code>，最多请求 <code>MaxSkeletonSize</code> 个。如果不是的话，则要获取完整的<code>headers</code> 。</p>
<p>②：等待并处理<code>headerCh</code>中的<code>header</code>数据</p>
<p>2.1 确保远程节点正在返回我们需要填充<code>skeleton</code>所需的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received skeleton from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果<code>skeleton</code>已经下载完毕，则需要继续填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &amp;&amp; skeleton &#123;</span><br><span class="line">				skeleton = <span class="literal">false</span></span><br><span class="line">				getHeaders(from)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 整个<code>skeleton</code>填充完成，并且没有要获取的<code>header</code>了，要通知<code>headerProcCh</code>全部完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//下载pivot时不要中止标头的提取</span></span><br><span class="line">				<span class="keyword">if</span> atomic.LoadInt32(&amp;d.committed) == <span class="number">0</span> &amp;&amp; pivot &lt;= from &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;No headers, waiting for pivot commit&quot;</span>)</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">						getHeaders(from)</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">						<span class="keyword">return</span> errCanceled</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//完成Pivot操作（或不进行快速同步），并且没有头文件，终止该过程</span></span><br><span class="line">				p.log.Debug(<span class="string">&quot;No more headers available&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- <span class="literal">nil</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 当<code>header</code>有数据并且是在获取<code>skeleton</code>的时候，调用<code>fillHeaderSkeleton</code>填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> skeleton &#123;</span><br><span class="line">				filled, proced, err := d.fillHeaderSkeleton(from, headers)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;Skeleton chain invalid&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">				headers = filled[proced:]</span><br><span class="line">				from += <span class="type">uint64</span>(proced)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.5 如果当前处理的不是 <code>skeleton</code>，表明区块同步得差不多了，处理尾部的一些区块</p>
<p>判断本地的主链高度与新收到的 header 的最高高度的高度差是否在 <code>reorgProtThreshold</code> 以内，如果不是，就将高度最高的 <code>reorgProtHeaderDelay</code> 个 header 丢掉。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> head+<span class="type">uint64</span>(reorgProtThreshold) &lt; headers[n<span class="number">-1</span>].Number.Uint64() &#123;</span><br><span class="line">						delay := reorgProtHeaderDelay</span><br><span class="line">						<span class="keyword">if</span> delay &gt; n &#123;</span><br><span class="line">							delay = n</span><br><span class="line">						&#125;</span><br><span class="line">						headers = headers[:n-delay]</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 如果还有 <code>header</code> 未处理，发给 <code>headerProcCh</code> 进行处理，<code>Downloader.processHeaders</code> 会等待这个 channel 的消息并进行处理；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- headers:</span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">				from += <span class="type">uint64</span>(<span class="built_in">len</span>(headers))</span><br><span class="line">  getHeaders(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 如果没有发送标头，或者所有标头等待 <code>fsHeaderContCheck</code> 秒，再次调用 <code>getHeaders</code> 请求区块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.log.Trace(<span class="string">&quot;All headers delayed, waiting&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">					getHeaders(from)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码后来才加上的，其 commit 的记录在<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/commit/6ee3b26f447459d3f3a316dbb572e461a273e193#diff-c2fa15e758e986688c646459d8970a50">这里</a>，而 「pull request」 在<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/pull/17839">这里</a>。从 「pull request」 中作者的解释我们可以了解这段代码的逻辑和功能：这个修改主要是为了解决经常出现的 「invalid hash chain」 错误，出现这个错误的原因是因为在我们上一次从远程节点获取到一些区块并将它们加入到本地的主链的过程中，远程节点发生了 reorg 操作（参见<a target="_blank" rel="noopener" href="https://yangzhe.me/2019/03/24/ethereum-blockchain/">这篇文章</a>里关于「主链与侧链」的介绍 ）；当我们再次根据高度请求新的区块时，对方返回给我们的是它的新的主链上的区块，而我们没有这个链上的历史区块，因此在本地写入区块时就会返回 「invalid hash chain」 错误。</p>
<p>要想发生 「reorg」 操作，就需要有新区块加入。在以太坊主网上，新产生一个区块的间隔是 10 秒到 20 秒左右。一般情况下，如果仅仅是区块数据，它的同步速度还是很快的，每次下载也有最大数量的限制。所以在新产生一个区块的这段时间里，足够同步完成一组区块数据而对方节点不会发生 「reorg」 操作。但是注意刚才说的「仅仅是区块数据」的同步较快，<strong>state 数据的同步就非常慢了</strong>。简单来说在完成同步之前可能会有多个 「pivot」 区块，这些区块的 state 数据会从网络上下载，这就大大拖慢了整个区块的同步速度，使得本地在同步一组区块的同时对方发生 「reorg」 操作的机率大大增加。</p>
<p>作者认为这种情况下发生的 「reorg」 操作是由新产生的区块的竞争引起的，所以最新的几个区块是「不稳定的」，如果本次同步的区块数量较多（也就是我们同步时消耗的时间比较长）（在这里「本次同步的区数数量较多」的表现是新收到的区块的最高高度与本地数据库中的最高高度的差距大于 <code>reorgProtThreshold</code>），那么在同步时可以先避免同步最新区块，这就是 <code>reorgProtThreshold</code> 和 <code>reorgProtHeaderDelay</code> 这个变量的由来。</p>
<p>至此，<code>Downloader.fetchHeaders</code> 方法就结束了，所有的区块头也就同步完成了。在上面我们提到填充<code>skeleton</code>的时候，是由<code>fillHeaderSkeleton</code>函数来完成，接下来就要细讲填充<code>skeleton</code>的细节。</p>
<hr>
<h3 id="fillHeaderSkeleton"><a href="#fillHeaderSkeleton" class="headerlink" title="fillHeaderSkeleton"></a>fillHeaderSkeleton</h3><p>首先我们知道以太坊在同步区块时，先确定要下载的区块的高度区间，然后将这个区间按 <code>MaxHeaderFetch</code> 切分成很多组，每一组的最后一个区块组成了 「skeleton」（最后一组不满 <code>MaxHeaderFetch</code> 个区块不算作一组）。不清楚的可以查看上面的图。</p>
<p>①：将一批<code>header</code>检索任务添加到队列中，以填充<code>skeleton</code>。</p>
<p>这个函数参照上面<strong>queue详解</strong>的分析</p>
<blockquote>
<p>func (q *queue) ScheduleSkeleton(from uint64, skeleton []*types.Header) {}</p>
</blockquote>
<p>②：调用<code>fetchParts</code> 获取<code>headers</code>数据</p>
<p><code>fetchParts</code>是很核心的函数，下面的<code>Fetchbodies</code>和<code>FetchReceipts</code>都会调用。先来大致看一下<code>fetchParts</code>的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> fetchParts(...) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">		<span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">		<span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">		<span class="keyword">case</span> &lt;-update:</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化下来就是这 5 个<code>channel</code>在处理，前面 4 个<code>channel</code>负责循环等待消息，<code>update</code>用来等待其他 4 个<code>channel</code>的通知来处理逻辑，先分开分析一个个的<code>channel</code>。</p>
<p>2.1 deliveryCh 传递下载的数据</p>
<p><code>deliveryCh</code> 作用就是传递下载的数据，当有数据被真正下载下来时，就会给这个 <code>channel</code> 发消息将数据传递过来。这个 channel 对应的分别是：<code>d.headerCh</code>、<code>d.bodyCh</code>、<code>d.receiptCh</code>，而这三个 <code>channel</code> 分别在以下三个方法中被写入数据：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。 看下<code>deliveryCh</code>如何处理数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">			<span class="keyword">if</span> peer := d.peers.Peer(packet.PeerId()); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">				accepted, err := deliver(packet)<span class="comment">//传递接收到的数据块并检查链有效性</span></span><br><span class="line">				<span class="keyword">if</span> err == errInvalidChain &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> err != errStaleDelivery &#123;</span><br><span class="line">					setIdle(peer, accepted)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span> &amp;&amp; packet.Items() == <span class="number">0</span>:</span><br><span class="line">					...</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>收到下载数据后判断节点是否有效，如果节点没有被移除，则会通过<code>deliver</code>传递接收到的下载数据。如果没有任何错误，则通知<code>update</code>处理。</p>
<p>要注意<code>deliver</code>是一个回调函数，它调用了 queue 对象的 Deliver 方法：<code>queue.DeliverHeaders</code>、<code>queue.DeliverBodies</code>、<code>queue.DeliverReceipts</code>，在收到下载数据就会调用此回调函数（<strong>queue相关函数分析参照queue详解部分</strong>）。</p>
<p>在上面处理错误部分，有一个<code>setIdle</code>函数，它也是回调函数，其实现都是调用了 <code>peerConnection</code> 对象的相关方法：<code>SetHeadersIdle</code>、<code>SetBodiesIdle</code>、<code>SetReceiptsIdle</code>。它这个函数是指某些节点针对某类数据是空闲的，比如<code>header</code>、<code>bodies</code>、<code>receipts</code>，如果需要下载这几类数据，就可以从空闲的节点下载这些数据。</p>
<p>2.2 <code>wakeCh</code> 唤醒<code>fetchParts</code> ，下载新数据或下载已完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">			<span class="keyword">if</span> !cont &#123;</span><br><span class="line">				finished = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们通过调用fetchParts传递的参数知道，<code>wakeCh</code> 的值其实是 <code>queue.headerContCh</code>。在 <code>queue.DeliverHeaders</code> 中发现所有需要下戴的 header 都下载完成了时，才会发送 false 给这个 channel。<code>fetchParts</code> 在收到这个消息时，就知道没有 header 需要下载了。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> DeliverHeaders(......) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">        q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样如此，<code>body</code>和<code>receipt</code>则是<code>bodyWakeCh</code>和<code>receiptWakeCh</code>，在 <code>processHeaders</code> 中，如果所有 <code>header</code> 已经下载完成了，那么发送 <code>false</code> 给这两个 <code>channel</code>，通知它们没有新的 <code>header</code> 了。 <code>body</code> 和 <code>receipt</code> 的下载依赖于 <code>header</code>,需要 <code>header</code> 先下载完成才能下载，所以对于下戴 <code>body</code> 或 <code>receipt</code> 的 <code>fetchParts</code> 来说，收到这个 <code>wakeCh</code> 就代表不会再有通知让自己下载数据了.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processHeaders(origin <span class="type">uint64</span>, pivot <span class="type">uint64</span>, td *big.Int) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> headers := &lt;-d.headerProcCh:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">                    <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">						...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 ticker 负责周期性的激活 <code>update</code>进行消息处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4 <code>update</code> （处理此前几个<code>channel</code>的数据）(<strong>重要</strong>)</p>
<p>2.4.1 判断是否有效节点，并获取超时数据的信息</p>
<p>获取超时数据的节点ID和数据数量，如果大于两个的话，就将这个节点设置为空闲状态(<code>setIdle</code>)，小于两个的话直接断开节点连接。</p>
<p><code>expire</code> 是一个回调函数，会返回当前所有的超时数据信息。这个函数的实际实现都是调用了 <code>queue</code> 对象的 <code>Expire</code> 方法：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>,此函数会统计当前正在下载的数据中，起始时间与当前时间的差距超过给定阈值（<code>downloader.requestTTL</code> 方法的返回值）的数据，并将其返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.peers.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errNoPeers</span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> pid, fails := <span class="keyword">range</span> expire() &#123;</span><br><span class="line">  <span class="keyword">if</span> peer := d.peers.Peer(pid); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fails &gt; <span class="number">2</span> &#123;</span><br><span class="line">						...</span><br><span class="line">						setIdle(peer, <span class="number">0</span>)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					...</span><br><span class="line">						<span class="keyword">if</span> d.dropPeer == <span class="literal">nil</span> &#123;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							d.dropPeer(pid)</span><br><span class="line">							....</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.4.2 处理完超时数据，判断是否还有下载的数据</p>
<p>如果没有其他可下载的内容，请等待或终止，这里<code>pending()</code>和<code>inFlight()</code>都是回调函数，<code>pending</code>分别对应了<code>queue.PendingHeaders</code>、<code>queue.PendingBlocks</code>、<code>queue.PendingReceipts</code>,用来返回各自要下载的任务数量。<code>inFlight()</code>分别对应了<code>queue.InFlightHeaders</code>、<code>queue.InFlightBlocks</code>、<code>queue.InFlightReceipts</code>,用来返回正在下载的数据数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !inFlight() &amp;&amp; finished &#123;</span><br><span class="line">				...</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4.3 使用空闲节点，调用<code>fetch</code>函数发送数据请求</p>
<p><code>Idle()</code>回调函数在上面已经提过了，<code>throttle()</code>回调函数则分别对<code>queue.ShouldThrottleBlocks</code>、<code>queue.ShouldThrottleReceipts</code>,用来表示是否应该下载<code>bodies</code>或者<code>receipts</code>。</p>
<p><code>reserve</code>函数分别对应<code>queue.ReserveHeaders</code>、<code>queue.ReserveBodies</code>、<code>queue.ReserveReceipts</code>,用来从从下载任务中选取一些可以下载的任务，并构造一个 <code>fetchRequest</code> 结构。它还返回一个 <code>process</code> 变量，标记着是否有空的数据正在被处理。比如有可能某区块中未包含任何一条交易，因此它的 <code>body</code> 和 <code>receipt</code> 都是空的，这种数据其实是不需要下载的。在 <code>queue</code> 对象的 <code>Reserve</code> 方法中，会对这种情况进行识别。如果遇到空的数据，这些数据会被直接标记为下载成功。在方法返回时，就将是否发生过「直接标记为下载成功」的情况返回。</p>
<p><code>capacity</code>回调函数分别对应<code>peerConnection.HeaderCapacity</code>、<code>peerConnection.BlockCapacity</code>、<code>peerConnection.ReceiptCapacity</code>,用来决定下载需要请求数据的个数。</p>
<p><code>fetch</code>回调函数分别对应<code>peer.FetchHeaders</code>、<code>peer.Fetchbodies</code>、<code>peer.FetchReceipts</code>,用来发送获取各类数据的请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">progressed, throttled, running := <span class="literal">false</span>, <span class="literal">false</span>, inFlight()</span><br><span class="line">			idles, total := idle()</span><br><span class="line">			<span class="keyword">for</span> _, peer := <span class="keyword">range</span> idles &#123;</span><br><span class="line">				<span class="keyword">if</span> throttle() &#123;</span><br><span class="line">					...</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				request, progress, err := reserve(peer, capacity(peer))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> progress &#123;</span><br><span class="line">					progressed = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">        <span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> request.From &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">if</span> err := fetch(peer, request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !progressed &amp;&amp; !throttled &amp;&amp; !running &amp;&amp; <span class="built_in">len</span>(idles) == total &amp;&amp; pending() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errPeersUnavailable</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>简单来概括这段代码就是：使用空闲节点下载数据，判断是否需要暂停，或者数据是否已经下载完成；之后选取数据进行下载；最后，如果没有遇到空块需要下载、且没有暂停下载和所有有效节点都空闲和确实有数据需要下载，但下载没有运行起来，就返回 <code>errPeersUnavailable</code> 错误。</p>
<p>到此为止<code>fetchParts</code>函数就分析的差不多了。里面涉及的跟<code>queue.go</code>相关的一些函数都在<strong>queue详解</strong>小节里介绍了。</p>
<hr>
<h3 id="processHeaders"><a href="#processHeaders" class="headerlink" title="processHeaders"></a>processHeaders</h3><p>通过<code>headerProcCh</code>接收<code>header</code>数据，并处理的过程是在<code>processHeaders</code>函数中完成的。整个处理过程集中在：<code>case headers := &lt;-d.headerProcCh中</code>:</p>
<p>①：如果<code>headers</code>的长度为0 ，则会有以下操作：</p>
<p>1.1 通知所有人<code>header</code>已经处理完毕</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 若没有检索到任何<code>header</code>，说明他们的<code>TD</code>小于我们的，或者已经通过我们的<code>fetcher</code>模块进行了同步。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode != LightSync &#123;</span><br><span class="line">					head := d.blockchain.CurrentBlock()</span><br><span class="line">					<span class="keyword">if</span> !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.3 如果是<code>fast</code>或者<code>light</code> 同步，确保传递了<code>header</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">					head := d.lightchain.CurrentHeader()</span><br><span class="line">					<span class="keyword">if</span> td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果<code>headers</code>的长度大于 0</p>
<p>2.1 如果是fast或者light 同步，调用**ightchain.InsertHeaderChain()**写入<code>header</code>到<code>leveldb</code>数据库；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line">  d.lightchain.InsertHeaderChain(chunk, frequency);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果是<code>fast</code>或者<code>full sync</code>模式，则调用 d.queue.Schedule进行内容(body和receipt)检索。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FullSync || d.mode == FastSync &#123;</span><br><span class="line">  ...</span><br><span class="line">  inserts := d.queue.Schedule(chunk, origin)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：如果找到更新的块号，则要发信号通知新任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> d.syncStatsChainHeight &lt; origin &#123;</span><br><span class="line">				d.syncStatsChainHeight = origin - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此处理<code>Headers</code>的分析就完成了。</p>
<hr>
<h2 id="同步bodies"><a href="#同步bodies" class="headerlink" title="同步bodies"></a>同步bodies</h2><p>同步<code>bodies</code> 则是由<code>fetchBodies</code>函数完成的。</p>
<h3 id="fetchBodies"><a href="#fetchBodies" class="headerlink" title="fetchBodies"></a>fetchBodies</h3><p>同步bodies的过程跟同步header类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code></li>
<li><code>ReserveBodies</code>()从<code>bodyTaskPool</code>中取出要同步的<code>body</code>；</li>
<li>调用<code>fetch</code>，也就是调用这里的<code>FetchBodies</code>从节点获取<code>body</code>，发送<code>GetBlockBodiesMsg</code>消息；</li>
<li>收到<code>bodyCh</code>的数据后，调用<code>deliver</code>函数，将Transactions和<code>Uncles</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步Receipts"><a href="#同步Receipts" class="headerlink" title="同步Receipts"></a>同步Receipts</h2><h3 id="fetchReceipts"><a href="#fetchReceipts" class="headerlink" title="fetchReceipts"></a>fetchReceipts</h3><p>同步<code>receipts</code>的过程跟同步<code>header</code>类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code>()</li>
<li><code>ReserveBodies</code>()从<code>ReceiptTaskPool</code>中取出要同步的<code>Receipt</code></li>
<li>调用这里的<code>FetchReceipts</code>从节点获取<code>receipts</code>，发送<code>GetReceiptsMsg</code>消息；</li>
<li>收到<code>receiptCh</code>的数据后，调用<code>deliver</code>函数，将<code>Receipts</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h2><p>这里我们讲两种模式下的状态同步：</p>
<ul>
<li><strong>fullSync</strong>: <code>processFullSyncContent</code>，<code>full</code>模式下<code>Receipts</code>没有缓存到<code>resultCache</code>中，直接先从缓存中取出<code>body</code>数据，然后执行交易生成状态，最后写入区块链。</li>
<li><strong>fastSync</strong>:<code>processFastSyncContent</code>：fast模式的Receipts、Transaction、Uncles都在resultCache中，所以还需要下载”state”，进行校验，再写入区块链。</li>
</ul>
<p>接下来大致的讨论下这两种方式。</p>
<h3 id="processFullSyncContent"><a href="#processFullSyncContent" class="headerlink" title="processFullSyncContent"></a>processFullSyncContent</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processFullSyncContent() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		results := d.queue.Results(<span class="literal">true</span>)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> err := d.importBlockResults(results); err != <span class="literal">nil</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">...</span><br><span class="line">	blocks := <span class="built_in">make</span>([]*types.Block, <span class="built_in">len</span>(results))</span><br><span class="line">	<span class="keyword">for</span> i, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		blocks[i] = types.NewBlockWithHeader(result.Header).WithBody(result.Transactions, result.Uncles)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接从<code>result</code>中获取数据并生成<code>block</code>，直接插入区块链中，就结束了。</p>
<hr>
<h3 id="processFastSyncContent"><a href="#processFastSyncContent" class="headerlink" title="processFastSyncContent"></a>processFastSyncContent</h3><p>fast模式同步状态内容比较多，大致也就如下几部分，我们开始简单分析以下。</p>
<p>①：下载最新的区块状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync := d.syncState(latest.Root)</span><br></pre></td></tr></table></figure>

<p>我们直接用一张图来表示整个大致流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glxk6y6zhjj31180jstcl.jpg" alt="image-20201223100153241"></p>
<p>具体的代码读者自己翻阅，大致就是这么个简单过程。</p>
<p>②：计算出pivot块</p>
<p><code>pivot</code>为<code>latestHeight - 64</code>，调用<code>splitAroundPivot</code>()方法以pivot为中心，将<code>results</code>分为三个部分：<code>beforeP</code>，<code>P</code>，<code>afterP</code>；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pivot := <span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> height := latest.Number.Uint64(); height &gt; <span class="type">uint64</span>(fsMinFullBlocks) &#123;</span><br><span class="line">		pivot = height - <span class="type">uint64</span>(fsMinFullBlocks)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P, beforeP, afterP := splitAroundPivot(pivot, results)</span><br></pre></td></tr></table></figure>

<p>③： 对<code>beforeP</code>的部分调用<code>commitFastSyncData</code>，将<code>body</code>和<code>receipt</code>都写入区块链</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.commitFastSyncData(beforeP, sync); </span><br></pre></td></tr></table></figure>

<p>④：对<strong>P</strong>的部分更新状态信息为<code>P block</code>的状态，把<strong>P</strong>对应的<strong>result</strong>（包含<strong>body</strong>和<strong>receipt</strong>）调用<strong>commitPivotBlock</strong>插入本地区块链中，并调用<strong>FastSyncCommitHead</strong>记录这个<strong>pivot</strong>的<strong>hash</strong>值，存在<strong>downloader</strong>中，标记为快速同步的最后一个区块<strong>hash</strong>值；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.commitPivotBlock(P); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：对<code>afterP</code>调用<code>d.importBlockResults</code>，将<code>body</code>插入区块链，而不插入<code>receipt</code>。因为是最后 64 个区块，所以此时数据库中只有<code>header</code>和<code>body</code>，没有<code>receipt</code>和状态，要通过<code>fullSync</code>模式进行最后的同步。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.importBlockResults(afterP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个Downloader同步完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/pull/1889">https://github.com/ethereum/go-ethereum/pull/1889</a></p>
<p><a target="_blank" rel="noopener" href="https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts">https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/" class="post-title-link" itemprop="url">死磕以太坊源码分析之blockChain分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:14 / Modified: 13:10:53" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:14+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之blockChain分析</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="blockchain关键元素"><a href="#blockchain关键元素" class="headerlink" title="blockchain关键元素"></a>blockchain关键元素</h2><ul>
<li><code>db</code>：持久化到底层数据储存，即<code>leveldb</code>；</li>
<li><code>genesisBlock</code>：创始区块</li>
<li><code>currentBlock</code>：当前区块，<code>blockchain</code>中并不是储存链所有的<code>block</code>，而是通过<code>currentBlock</code>向前回溯直到<code>genesisBlock</code>，这样就构成了区块链</li>
<li><code>bodyCache</code>、<code>bodyRLPCache</code>、<code>blockCache</code>、<code>futureBlocks</code>：区块链中的缓存结构，用于加快区块链的读取和构建；</li>
<li><code>hc</code>：<code>headerchain</code>区块头链，由<code>blockchain</code>额外维护的另一条链，由于<code>Header</code>和<code>Block</code>的储存空间是有很大差别的，但同时<code>Block</code>的<code>Hash</code>值就是<code>Header</code>（RLP）的<code>Hash</code>值，所以维护一个<code>headerchain</code>可以用于快速延长链，验证通过后再下载<code>blockchain</code>，或者可以与<code>blockchain</code>进行相互验证；</li>
<li><code>processor</code>：执行区块链交易的接口，收到一个新的区块时，要对区块中的所有交易执行一遍，一方面是验证，一方面是更新世界状态；</li>
<li><code>validator</code>：验证数据有效性的接口</li>
<li><code>futureBlocks</code>：收到的区块时间大于当前头区块时间15s而小于30s的区块，可作为当前节点待处理的区块。</li>
</ul>
<hr>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BadBlocks 处理客户端从网络上获取的最近的bad block列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> BadBlocks() []*types.Block &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addBadBlock 把bad block放入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> addBadBlock(block *types.Block) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CurrentBlock取回主链的当前头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentBlock() *types.Block &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentHeader检索规范链的当前头区块header。从HeaderChain的内部缓存中检索标头。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentHeader() *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentFastBlock取回主链的当前fast-sync头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentFastBlock() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将活动链或其子集写入给定的编写器.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Export(w io.Writer) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ExportN(w io.Writer, first <span class="type">uint64</span>, last <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FastSyncCommitHead快速同步，将当前头块设置为特定hash的区块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FastSyncCommitHead(hash common.Hash) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GasLimit返回当前头区块的gas limit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GasLimit() <span class="type">uint64</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Genesis 取回genesis区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Genesis() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过hash从数据库或缓存中取到一个区块体(transactions and uncles)或RLP数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBody(hash common.Hash) *types.Body &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBodyRLP(hash common.Hash) rlp.RawValue &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetBlock 通过hash和number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlock(hash common.Hash, number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByHash 通过hash取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByHash(hash common.Hash) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByNumber 通过number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByNumber(number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash和number区块的header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeader(hash common.Hash, number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定hash的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByHash(hash common.Hash) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定number的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByNumber(number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HasBlock检验hash对应的区块是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlock(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查给定hash和number的区块的区块头是否存在数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasHeader(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasState检验state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasState(hash common.Hash) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasBlockAndState检验hash对应的block和state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlockAndState(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash的区块的总难度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetTd(hash common.Hash, number <span class="type">uint64</span>) *big.Int&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取从给定hash的区块到genesis区块的所有hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockHashesFromHash(hash common.Hash, max <span class="type">uint64</span>) []common.Hash&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetReceiptsByHash 在特定的区块中取到所有交易的收据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetReceiptsByHash(hash common.Hash) types.Receipts &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetBlocksFromHash 取到特定hash的区块及其n-1个父区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlocksFromHash(hash common.Hash, n <span class="type">int</span>) (blocks []*types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetUnclesInChain 取回从给定区块到向前回溯特定距离到区块上的所有叔区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetUnclesInChain(block *types.Block, length <span class="type">int</span>) []*types.Header &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 将新的头块注入当前块链。 该方法假设该块确实是真正的头。</span></span><br><span class="line"><span class="comment">// 如果它们较旧或者它们位于不同的侧链上，它还会将头部标题和头部快速同步块重置为同一个块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insert(block *types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertChain尝试将给定批量的block插入到规范链中，否则，创建一个分叉。 如果返回错误，它将返回失败块的索引号以及描述错误的错误。</span></span><br><span class="line"><span class="comment">//插入完成后，将触发所有累积的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertChain(chain types.Blocks) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// insertChain将执行实际的链插入和事件聚合。 </span></span><br><span class="line"><span class="comment">// 此方法作为单独方法存在的唯一原因是使用延迟语句使锁定更清晰。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks) (<span class="type">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertHeaderChain尝试将给定的headerchain插入到本地链中，可能会创建一个重组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertHeaderChain(chain []*types.Header, checkFreq <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertReceiptChain 使用交易和收据数据来完成已经存在的headerchain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loadLastState从数据库加载最后一个已知的链状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> loadLastState() <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor 返回当前current processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Processor() Processor &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset重置清除整个区块链，将其恢复到genesis state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Reset() <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ResetWithGenesisBlock 清除整个区块链, 用特定的genesis state重塑，被Reset所引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ResetWithGenesisBlock(genesis *types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// repair尝试通过回滚当前块来修复当前的区块链，直到找到具有关联状态的块。</span></span><br><span class="line"><span class="comment">// 用于修复由崩溃/断电或简单的非提交尝试导致的不完整的数据库写入。</span></span><br><span class="line"><span class="comment">//此方法仅回滚当前块。 当前标头和当前快速块保持不变。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> repair(head **types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reorgs需要两个块、一个旧链以及一个新链，并将重新构建块并将它们插入到新的规范链中，并累积潜在的缺失事务并发布有关它们的事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> reorg(oldBlock, newBlock *types.Block) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Rollback 旨在从数据库中删除不确定有效的链片段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Rollback(chain []common.Hash) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SetReceiptsData 计算收据的所有非共识字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetReceiptsData</span><span class="params">(config *params.ChainConfig, block *types.Block, receipts types.Receipts)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetHead将本地链回滚到指定的头部。</span></span><br><span class="line"><span class="comment">// 通常可用于处理分叉时重选主链。对于Header，新Header上方的所有内容都将被删除，新的头部将被设置。</span></span><br><span class="line"><span class="comment">// 但如果块体丢失，则会进一步回退（快速同步后的非归档节点）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetHead(head <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetProcessor设置状态修改所需要的processor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetProcessor(processor Processor) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetValidator 设置用于验证未来区块的validator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetValidator(validator Validator) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// State 根据当前头区块返回一个可修改的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> State() (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// StateAt 根据特定时间点返回新的可变状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> StateAt(root common.Hash) (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Stop 停止区块链服务，如果有正在import的进程，它会使用procInterrupt来取消。</span></span><br><span class="line"><span class="comment">// it will abort them using the procInterrupt.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Stop() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TrieNode从memory缓存或storage中检索与trie节点hash相关联的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> TrieNode(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Validator返回当前validator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Validator() Validator &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteBlockWithoutState仅将块及其元数据写入数据库，但不写入任何状态。 这用于构建竞争方叉，直到超过规范总难度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithoutState(block *types.Block, td *big.Int) (err <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// WriteBlockWithState将块和所有关联状态写入数据库。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// writeHeader将标头写入本地链，因为它的父节点已知。 如果新插入的报头的总难度变得大于当前已知的TD，则重新路由规范链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> writeHeader(header *types.Header) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理未来区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="blockchain初始化"><a href="#blockchain初始化" class="headerlink" title="blockchain初始化"></a>blockchain初始化</h2><p>主要步骤：</p>
<p>①：创建一个新的headerChain结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</span><br></pre></td></tr></table></figure>

<ol>
<li>根据number（0）获取genesisHeader</li>
<li>从rawdb中读取HeadBlock并存储在currentHeader中</li>
</ol>
<p>②：获取genesisBlock</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>③：如果链不为空，则用老的链数据初始化链</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> bc.empty() &#123;</span><br><span class="line">		rawdb.InitDatabaseFromFreezer(bc.db)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：加载最新的状态数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：检查区块哈希的当前状态，并确保链中没有任何坏块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</span><br><span class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Found bad hash, rewinding chain&quot;</span>, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.ParentHash)</span><br><span class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>)</span><br><span class="line">				log.Error(<span class="string">&quot;Chain rewind was successful, resuming normal operation&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：定时处理future block</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br><span class="line">	-&gt;procFutureBlocks</span><br><span class="line">		-&gt;InsertChain</span><br></pre></td></tr></table></figure>

<p>总的来说做了以下几件事：</p>
<ol>
<li>配置<code>cacheConfig</code>，创建各种lru缓存</li>
<li>初始化<code>triegc</code></li>
<li>初始化<code>stateDb</code>：<strong>state.NewDatabase(db)</strong></li>
<li>初始化区块和状态验证：<strong>NewBlockValidator()</strong></li>
<li>初始化状态处理器：<strong>NewStateProcessor()</strong></li>
<li>初始化区块头部链：<strong>NewHeaderChain()</strong></li>
<li>查找创世区块：<strong>bc.genesisBlock &#x3D; bc.GetBlockByNumber(0)</strong></li>
<li>加载最新的状态数据：<strong>bc.loadLastState()</strong></li>
<li>检查区块哈希的当前状态，并确保链中没有任何坏块</li>
<li><code>go bc.update()</code> 定时处理<code>future block</code></li>
</ol>
<h2 id="加载区块链状态"><a href="#加载区块链状态" class="headerlink" title="加载区块链状态"></a>加载区块链状态</h2><p>①：从数据库中恢复headblock，如果空的话，触发reset chain</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head := rawdb.ReadHeadBlockHash(bc.db)</span><br><span class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Empty database, resetting chain&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：确保整个head block是可以获取的，若为空，则触发reset chain</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentBlock := bc.GetBlockByHash(head)</span><br><span class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Corrupt or empty database, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head block missing, resetting chain&quot;</span>, <span class="string">&quot;hash&quot;</span>, head)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：从stateDb中打开最新区块的状态trie，如果打开失败调用bc.repair(&amp;currentBlock)方法进行修复。修复方法就是从当前区块一个个的往前面找，直到找到好的区块，然后赋值给currentBlock。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Dangling block without a state associated, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head state missing, repairing chain&quot;</span>, <span class="string">&quot;number&quot;</span>, currentBlock.Number(), <span class="string">&quot;hash&quot;</span>, currentBlock.Hash())</span><br><span class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：存储当前的headblock和设置当前的headHeader以及头部快速块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.currentBlock.Store(currentBlock)</span><br><span class="line">....</span><br><span class="line">bc.hc.SetCurrentHeader(currentHeader)</span><br><span class="line">...</span><br><span class="line">bc.currentFastBlock.Store(currentBlock)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/" class="post-title-link" itemprop="url">死磕以太坊源码分析之挖矿流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:14 / Modified: 13:10:42" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:14+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之挖矿流程</p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> (文章资料在此，给个Star哦)</p>
</blockquote>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以太坊挖矿的主要流程是由<code>miner</code>包负责的，下面是基本的一个架构：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glkzcyd6xhj31am0u0qe0.jpg" alt="image-20201212125409326"></p>
<p>首先外部是通过<code>miner</code>对象进行了操作，<code>miner</code>里面则是实用<code>worker</code>对象来实现挖矿的整体功能。miner决定着是否停止挖矿或者是否可以开始挖矿，同时还可以设置矿工的地址来获取奖励。</p>
<p>真正调度处理挖矿相关细节的则是在worker.go里面，我们先来看一张总体的图。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllc2fgu1gj31cw0rwdlc.jpg" alt="image-20201212201358073"></p>
<p>上图我们看到有四个循环，分别通过几个<code>channel</code>负责不同的事：</p>
<h3 id="newWorkLoop"><a href="#newWorkLoop" class="headerlink" title="newWorkLoop"></a>newWorkLoop</h3><ol>
<li><code>startCh</code>：接收<code>startCh</code>信号，开始挖矿</li>
<li><code>chainHeadCh</code>：表示接收到新区块，需要终止当前的挖矿工作，开始新的挖矿。</li>
<li><code>timer.C</code>：默认每三秒检查一次是否有新交易需要处理。如果有则需要重新开始挖矿。以便将加高的交易优先打包到区块中。</li>
</ol>
<p>在 <code>newWorkLoop</code> 中还有一个辅助信号，<code>resubmitAdjustCh</code> 和 <code>resubmitIntervalCh</code>。运行外部修改timer计时器的时钟。<code>resubmitAdjustCh</code>是根据历史情况重新计算一个合理的间隔时间。而<code>resubmitIntervalCh</code>则允许外部，实时通过 <code>Miner</code> 实例方法 <code>SetRecommitInterval</code> 修改间隔时间。</p>
<h3 id="mainLoop"><a href="#mainLoop" class="headerlink" title="mainLoop"></a>mainLoop</h3><ol>
<li><code>newWorkCh</code>:接收生成新的挖矿任务信号</li>
<li><code>chainSideCh</code>:接收区块链中加入了一个新区块作为当前链头的旁支的信号</li>
<li><code>txsCh</code>:接收交易池的Pending中新加入了交易事件的信号</li>
</ol>
<p><code>TaskLoop</code>则是提交新的挖矿任务，而<code>resultLoop</code>则是成功出块之后做的一些处理。</p>
<hr>
<h2 id="启动挖矿"><a href="#启动挖矿" class="headerlink" title="启动挖矿"></a>启动挖矿</h2><h3 id="挖矿的参数设置"><a href="#挖矿的参数设置" class="headerlink" title="挖矿的参数设置"></a>挖矿的参数设置</h3><p><code>geth</code>挖矿的参数设置定义在 <code>cmd/utils/flags.go</code> 文件中</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–mine</td>
<td align="left">false</td>
<td align="center">是否开启自动挖矿</td>
</tr>
<tr>
<td align="left">–miner.threads</td>
<td align="left">0</td>
<td align="center">挖矿时可用并行PoW计算的协程（轻量级线程）数。 兼容过时参数 —minerthreads。</td>
</tr>
<tr>
<td align="left">–miner.notify</td>
<td align="left">空</td>
<td align="center">挖出新块时用于通知远程服务的任意数量的远程服务地址。 是用 <code>,</code>分割的多个远程服务器地址。 如：”<a target="_blank" rel="noopener" href="http://api.miner.com,http//api2.miner.com%E2%80%9C">http://api.miner.com,http://api2.miner.com“</a></td>
</tr>
<tr>
<td align="left">–miner.noverify</td>
<td align="left">false</td>
<td align="center">是否禁用区块的PoW工作量校验。</td>
</tr>
<tr>
<td align="left">–miner.gasprice</td>
<td align="left">1000000000 wei</td>
<td align="center">矿工可接受的交易Gas价格， 低于此GasPrice的交易将被拒绝写入交易池和不会被矿工打包到区块。</td>
</tr>
<tr>
<td align="left">–miner.gastarget</td>
<td align="left">8000000 gas</td>
<td align="center">动态计算新区块燃料上限（gaslimit）的下限值。 兼容过时参数 —targetgaslimit。</td>
</tr>
<tr>
<td align="left">–miner.gaslimit</td>
<td align="left">8000000 gas</td>
<td align="center">动态技术新区块燃料上限的上限值。</td>
</tr>
<tr>
<td align="left">–miner.etherbase</td>
<td align="left">第一个账户</td>
<td align="center">用于接收挖矿奖励的账户地址， 默认是本地钱包中的第一个账户地址。</td>
</tr>
<tr>
<td align="left">–miner.extradata</td>
<td align="left">geth版本号</td>
<td align="center">允许矿工自定义写入区块头的额外数据。</td>
</tr>
<tr>
<td align="left">–miner.recommit</td>
<td align="left">3s</td>
<td align="center">重新开始挖掘新区块的时间间隔。 将自动放弃进行中的挖矿后，重新开始一次新区块挖矿。</td>
</tr>
</tbody></table>
<h3 id="常见的启动挖矿的方式"><a href="#常见的启动挖矿的方式" class="headerlink" title="常见的启动挖矿的方式"></a>常见的启动挖矿的方式</h3><h4 id="参数设置挖矿"><a href="#参数设置挖矿" class="headerlink" title="参数设置挖矿"></a>参数设置挖矿</h4><blockquote>
<p>dgeth –dev –mine</p>
</blockquote>
<h4 id="控制台启动挖矿"><a href="#控制台启动挖矿" class="headerlink" title="控制台启动挖矿"></a>控制台启动挖矿</h4><blockquote>
<p>miner.start(1)</p>
</blockquote>
<h4 id="rpc-启动挖矿"><a href="#rpc-启动挖矿" class="headerlink" title="rpc 启动挖矿"></a>rpc 启动挖矿</h4><p>这是部署节点使用的方式，一般设置如下：</p>
<blockquote>
<p>&#x2F;geth –datadir “&#x2F;data0” –nodekeyhex “27aa615f5fa5430845e4e99229def5f23e9525a20640cc49304f40f3b43824dc” –bootnodes $enodeid –mine –debug –metrics –syncmode&#x3D;”full” –gcmode&#x3D;archive –istanbul.blockperiod 5 –gasprice 0 –port 30303 –rpc –rpcaddr “0.0.0.0” –rpcport 8545 –rpcapi “db,eth,net,web3,personal” –nat any –allow-insecure-unlock </p>
</blockquote>
<hr>
<p>开始源码分析，进入到<code>miner.go</code>的<code>New</code>函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(eth Backend, config *Config, chainConfig *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine, isLocalBlock <span class="keyword">func</span>(block *types.Block)</span></span> <span class="type">bool</span>) *Miner &#123;</span><br><span class="line">	miner := &amp;Miner&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> miner.update()</span><br><span class="line">	<span class="keyword">return</span> miner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> update() &#123;</span><br><span class="line">  <span class="keyword">switch</span> ev.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> downloader.StartEvent:</span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> miner.Mining() &#123;</span><br><span class="line">					miner.Stop()</span><br><span class="line">					atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">1</span>)</span><br><span class="line">					log.Info(<span class="string">&quot;Mining aborted due to sync&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> downloader.DoneEvent, downloader.FailedEvent:</span><br><span class="line">				shouldStart := atomic.LoadInt32(&amp;miner.shouldStart) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">1</span>)</span><br><span class="line">				atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> shouldStart &#123;</span><br><span class="line">					miner.Start(miner.coinbase)</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们初始化的<code>canStart=1</code> ， 如果<code>Downloader</code>模块正在同步，则<code>canStart=0</code>,并且停止挖矿，如果<code>Downloader</code>模块<code>Done</code>或者<code>Failed</code>，则<code>canStart=1</code>,且同时<code>shouldStart=0</code>,miner将启动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">miner.Start(miner.coinbase)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> Start(coinbase common.Address) &#123;</span><br><span class="line">...</span><br><span class="line">	miner.worker.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> start() &#123;</span><br><span class="line">...</span><br><span class="line">	w.startCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将会进入到<code>mainLoop</code>中去处理<code>startCh</code>：</p>
<p>①：清除过旧的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearPending(w.chain.CurrentBlock().NumberU64())</span><br></pre></td></tr></table></figure>

<p>②：提交新的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit := <span class="function"><span class="keyword">func</span><span class="params">(noempty <span class="type">bool</span>, s <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">		w.newWorkCh &lt;- &amp;newWorkReq&#123;interrupt: interrupt, noempty: noempty, timestamp: timestamp&#125;</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成新的挖矿任务"><a href="#生成新的挖矿任务" class="headerlink" title="生成新的挖矿任务"></a>生成新的挖矿任务</h2><p>根据<code>newWorkCh</code>生成新的挖矿任务，进入到<code>CommitNewWork</code>中：</p>
<p>①：组装<code>header</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">header := &amp;types.Header&#123; <span class="comment">//组装header</span></span><br><span class="line">		ParentHash: parent.Hash(),</span><br><span class="line">		Number:     num.Add(num, common.Big1), <span class="comment">//num+1</span></span><br><span class="line">		GasLimit:   core.CalcGasLimit(parent, w.config.GasFloor, w.config.GasCeil),</span><br><span class="line">		Extra:      w.extra,</span><br><span class="line">		Time:       <span class="type">uint64</span>(timestamp),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：根据共识引擎吃初始化header的共识字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.engine.Prepare(w.chain, header); </span><br></pre></td></tr></table></figure>

<p>③：为当前挖矿新任务创建环境</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.makeCurrent(parent, header)</span><br></pre></td></tr></table></figure>

<p>④：添加叔块</p>
<p>叔块集分本地矿工打包区块和其他挖矿打包的区块。优先选择自己挖出的区块。选择时，将先删除太旧的区块，只从最近的7(staleThreshold)个高度中选择，最多<strong>选择两个叔块</strong>放入新区块中.在真正添加叔块的同时会进行校验，包括如下：</p>
<ul>
<li>叔块存在报错</li>
<li>添加的uncle是父块的兄弟报错</li>
<li>叔块的父块未知报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitUncles(w.localUncles)</span><br><span class="line">commitUncles(w.remoteUncles)</span><br></pre></td></tr></table></figure>

<p>⑤：如果noempty为false，则提交空块，不填充交易进入到区块中,表示提前挖矿</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !noempty &#123;</span><br><span class="line">  w.commit(uncles, <span class="literal">nil</span>, <span class="literal">false</span>, tstart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：填充交易到新区块中</p>
<p>6.1 从交易池中获取交易，并把交易分为本地交易和远程交易，本地交易优先，先将本地交易提交，再将外部交易提交。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">localTxs, remoteTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions), pending</span><br><span class="line">	<span class="keyword">for</span> _, account := <span class="keyword">range</span> w.eth.TxPool().Locals() &#123;</span><br><span class="line">		<span class="keyword">if</span> txs := remoteTxs[account]; <span class="built_in">len</span>(txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(remoteTxs, account)</span><br><span class="line">			localTxs[account] = txs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(localTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   txs := types.NewTransactionsByPriceAndNonce(w.current.signer, localTxs)</span><br><span class="line">   <span class="keyword">if</span> w.commitTransactions(txs, w.coinbase, interrupt) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remoteTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.2提交交易 </p>
<ul>
<li>首先校验有没有可用的<code>Gas</code></li>
<li>如果碰到以下情况要进行交易执行的中断<ul>
<li>新的头块事件到达，中断信号为 1     (整个任务会被丢弃)</li>
<li><code>worker</code> 开启或者重启，中断信号为 1     （整个任务会被丢弃）</li>
<li><code>worker</code>重新创建挖矿任务根据新的交易，中断信号为 2 （任务还是会被送入到共识引擎）</li>
</ul>
</li>
</ul>
<p>6.3开始执行交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logs, err := w.commitTransaction(tx, coinbase)</span><br></pre></td></tr></table></figure>

<p>6.4执行交易获取收据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br></pre></td></tr></table></figure>

<p>如果执行出错，直接回退上一个快照</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>出错的原因大概有以下几个：</p>
<ul>
<li>超出当前块的<code>gas limit</code></li>
<li><code>Nonce</code> 太低</li>
<li><code>Nonce</code> 太高</li>
</ul>
<p>执行成功的话讲交易和收据存入到<code>w.current</code>中。</p>
<p>⑦：执行交易的状态更改，并组装成最终块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.commit(uncles, w.fullTaskHook, <span class="literal">true</span>, tstart)</span><br></pre></td></tr></table></figure>

<p>执行交易的状态更改，并组装成最终块是由下面的共识引擎所完成的事情：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block, err := w.engine.FinalizeAndAssemble(w.chain, w.current.header, s, w.current.txs, uncles, w.current.receipts)</span><br></pre></td></tr></table></figure>

<p>底层会调用 <code>state.IntermediateRoot</code>执行状态更改。组装成最终块意味着到这打包任务完成。接着就是要提交新的挖矿任务。</p>
<hr>
<h2 id="提交新的挖矿任务"><a href="#提交新的挖矿任务" class="headerlink" title="提交新的挖矿任务"></a>提交新的挖矿任务</h2><p>①：获取<code>sealHash</code>（挖矿前的区块哈希），重复提交则跳过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sealHash := w.engine.SealHash(task.block.Header()) <span class="comment">// 返回挖矿前的块的哈希</span></span><br><span class="line">			<span class="keyword">if</span> sealHash == prev &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②:生成新的挖矿请求，结果返回到<code>reultCh</code>或者<code>StopCh</code>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.engine.Seal(w.chain, task.block, w.resultCh, stopCh);</span><br></pre></td></tr></table></figure>

<p>挖矿的结果会返回到<code>resultCh</code>中或者<code>stopCh</code>中，<code>resultCh</code>有数据成功出块，<code>stopCh</code>不为空，则中断挖矿线程。</p>
<hr>
<h2 id="成功出块"><a href="#成功出块" class="headerlink" title="成功出块"></a>成功出块</h2><p><code>resultCh</code>有区块数据，则成功挖出了块，到最后的成功出块我们还需要进行相应的验证判断。</p>
<p>①：块为空或者链上已经有块或者<code>pendingTasks</code>不存在相关的<code>sealhash</code>,跳过处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> block == <span class="literal">nil</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> w.chain.HasBlock(block.Hash(), block.NumberU64()) &#123;&#125;</span><br><span class="line">task, exist := w.pendingTasks[sealhash] <span class="keyword">if</span> !exist &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：更新<code>receipts</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> task.receipts &#123;</span><br><span class="line">  receipt.BlockHash = hash</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：提交块和状态到数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err := w.chain.WriteBlockWithState(block, receipts, logs, task.state, <span class="literal">true</span>) <span class="comment">// 互斥</span></span><br></pre></td></tr></table></figure>

<p>④：广播区块并宣布链插入事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.mux.Post(core.NewMinedBlockEvent&#123;Block: block&#125;)</span><br></pre></td></tr></table></figure>

<p>⑤：等待规范确认本地挖出的块</p>
<p>新区块并非立即稳定，暂时存入到未确认区块集中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.unconfirmed.Insert(block.NumberU64(), block.Hash())</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><p>整个挖矿流程还是比较的简单，通过 4 个<code>Loop</code>互相工作，从开启挖矿到生成新的挖矿任务到提交新的挖矿任务到最后的成功出块，这里面的共识处理细节不会提到，接下来的文章会说到。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://learnblockchain.cn/books/geth/part2/mine/design.html">https://learnblockchain.cn/books/geth/part2/mine/design.html</a></p>
<p><a target="_blank" rel="noopener" href="https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8">https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/" class="post-title-link" itemprop="url">死磕以太坊源码分析之区块上链入库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:10:14 / Modified: 13:10:35" itemprop="dateCreated datePublished" datetime="2024-08-26T13:10:14+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之区块上链入库</p>
<p>配合以下代码进行阅读：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>不管是矿工挖矿还是<code>Fetcher</code>同步，<code>Downloader</code>同步，或者是导入本地文件等等，最中都是将区块上链入库。接下来我们就详细分析这部分的动作。</p>
<h2 id="几处可能调用的地方"><a href="#几处可能调用的地方" class="headerlink" title="几处可能调用的地方"></a>几处可能调用的地方</h2><p>①：在Downloader同步最后会将区块插入到区块链中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：创建一个新的以太坊协议管理器，也会将区块插入到链中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProtocolManager</span><span class="params">(...)</span></span> (*ProtocolManager, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  n, err := manager.blockchain.InsertChain(blocks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：插入侧链数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertSideChain(block *types.Block, it *insertIterator) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> _, err := bc.insertChain(blocks, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④：从本地文件导入链</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateAdminAPI)</span></span> ImportChain(file <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> _, err := api.eth.BlockChain().InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：fetcher同步导入块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span></span> insert(peer <span class="type">string</span>, block *types.Block) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是比较常见的需要将区块上链的动作。调用的核心方法就是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks, verifySeals <span class="type">bool</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>获取区块链所有相关文章以及资料，请参阅：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<h2 id="插入数据到blockchain中"><a href="#插入数据到blockchain中" class="headerlink" title="插入数据到blockchain中"></a>插入数据到blockchain中</h2><p>①：如果链正在中断，直接返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;bc.procInterrupt) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启并行的签名恢复</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[<span class="number">0</span>].Number()), chain)</span><br></pre></td></tr></table></figure>

<p>③：开启并行校验header</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br></pre></td></tr></table></figure>

<p>校验<code>header</code>是共识引擎所要做的事情，我们这里只分析<code>ethash</code>它的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyHeaders(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">  errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeaderWorker(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>, index <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> parent *types.Header</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">		parent = chain.GetHeader(headers[<span class="number">0</span>].ParentHash, headers[<span class="number">0</span>].Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[index<span class="number">-1</span>].Hash() == headers[index].ParentHash &#123;</span><br><span class="line">		parent = headers[index<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chain.GetHeader(headers[index].Hash(), headers[index].Number.Uint64()) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// known block</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ethash.verifyHeader(chain, headers[index], parent, <span class="literal">false</span>, seals[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用<code>verifyHeaderWorker</code>进行校验，主要检验块的祖先是否已知以及块是否已知，接着会调用<code>verifyHeader</code>进行更深的校验，也是最核心的校验，大概做了以下几件事：</p>
<ol>
<li>header.Extra<em>不可超过32字节</em></li>
<li>header.Time<em>不能超过15秒，15秒以后的就被认定为未来的块</em></li>
<li><em>当前header的时间戳不可以等于父块的时间戳</em></li>
<li><em>根据难度计算算法得出的expected必须和header.Difficulty 一致。</em></li>
<li><em>Gas limit 要 &lt;&#x3D; 2 ^ 63-1</em></li>
<li><em>gasUsed&lt;&#x3D; gasLimit</em></li>
<li><em>Gas limit 要在允许范围内</em></li>
<li><em>块号必须是父块加1</em></li>
<li><em>根据 ethash.VerifySeal去验证块是否满足POW难度要求</em></li>
</ol>
<p>到此验证header的事情就做完了。</p>
<p>④：循环校验body</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block, err := it.next()</span><br><span class="line">	-&gt; ValidateBody</span><br><span class="line">		-&gt; VerifyUncles</span><br></pre></td></tr></table></figure>

<p>包括以下错误：</p>
<ul>
<li><strong>block</strong>已知</li>
<li><strong>uncle</strong>太多</li>
<li>重复的<strong>uncle</strong></li>
<li><strong>uncle</strong>是祖先块</li>
<li><strong>uncle</strong>哈希不匹配</li>
<li>交易哈希不匹配</li>
<li>未知祖先</li>
<li>祖先块的状态无法获取</li>
</ul>
<p>4.1 如果<code>block</code>存在，且是已知块，则写入已知块。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.writeKnownBlock(block)</span><br></pre></td></tr></table></figure>

<p>4.2 如果是祖先块的状态无法获取的错误，则作为侧链插入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.insertSideChain(block, it)</span><br></pre></td></tr></table></figure>

<p>4.3 如果是未来块或者未知祖先，则添加未来块：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.addFutureBlock(block);</span><br></pre></td></tr></table></figure>

<p>注意这里的添加 futureBlock，会被扔进futureBlocks里面去，在NewBlockChain的时候会开启新的goroutine:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;</span><br><span class="line">  futureTimer := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-futureTimer.C:</span><br><span class="line">			bc.procFutureBlocks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> procFutureBlocks() &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">for</span> _, hash := <span class="keyword">range</span> bc.futureBlocks.Keys() &#123;</span><br><span class="line">		<span class="keyword">if</span> block, exist := bc.futureBlocks.Peek(hash); exist &#123;</span><br><span class="line">			blocks = <span class="built_in">append</span>(blocks, block.(*types.Block))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">			bc.InsertChain(blocks[i : i+<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会开启一个计时器，每5秒就会去执行插入这些未来的块。</p>
<p>4.4 如果是其他错误，直接中断，并且报告坏块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bc.futureBlocks.Remove(block.Hash())</span><br><span class="line">...</span><br><span class="line">bc.reportBlock(block, <span class="literal">nil</span>, err)</span><br></pre></td></tr></table></figure>

<p>⑤：没有校验错误</p>
<p>5.1 如果是坏块，则报告；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> BadHashes[block.Hash()] &#123;</span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, ErrBlacklistedHash)</span><br><span class="line">			<span class="keyword">return</span> it.index, ErrBlacklistedHash</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.2 如果是未知块，则写入未知块；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrKnownBlock &#123;</span><br><span class="line">			logger := log.Debug</span><br><span class="line">			<span class="keyword">if</span> bc.chainConfig.Clique == <span class="literal">nil</span> &#123;</span><br><span class="line">				logger = log.Warn</span><br><span class="line">			&#125;</span><br><span class="line">		...</span><br><span class="line">			<span class="keyword">if</span> err := bc.writeKnownBlock(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> it.index, err</span><br><span class="line">			&#125;</span><br><span class="line">			stats.processed++</span><br><span class="line">			lastCanon = block</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.3 根据给定trie，创建状态；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parent := it.previous()</span><br><span class="line">		<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">			parent = bc.GetHeader(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		statedb, err := state.New(parent.Root, bc.stateCache)</span><br></pre></td></tr></table></figure>

<p>5.4执行块中的交易： (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>5.5 使用默认的validator校验状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.validator.ValidateState(block, statedb, receipts, usedGas);</span><br></pre></td></tr></table></figure>

<p>5.6 将块写入到区块链中并获取状态：  (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status, err := bc.writeBlockWithState(block, receipts, logs, statedb, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：校验写入区块的状态</p>
<ul>
<li><code>CanonStatTy</code> ： 插入成功新的block</li>
<li><code>SideStatTy</code>：插入成功新的分叉区块</li>
<li><code>Default</code>：插入未知状态的block</li>
</ul>
<p>⑦：如果还有块，并且是未来块的话，那么将块添加到未来块的缓存中去</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.addFutureBlock(block)</span><br></pre></td></tr></table></figure>

<p>至此<code>insertChain</code> 大概介绍清楚。</p>
<hr>
<h3 id="执行块中交易"><a href="#执行块中交易" class="headerlink" title="执行块中交易"></a>执行块中交易</h3><p>在我们将区块上链，有一个关键步骤就是执行区块交易：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>进入函数，具体分析：</p>
<p>①：准备要用的字段，循环执行交易</p>
<p>关键函数：<code>ApplyTransaction</code>,根据此函数返回收据。</p>
<p>1.1 将交易结构转成<code>Message</code>结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))</span><br></pre></td></tr></table></figure>

<p>1.2 创建要在EVM环境中使用的新上下文</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context := NewEVMContext(msg, header, bc, author)</span><br></pre></td></tr></table></figure>

<p>1.3 创建一个新环境，其中包含有关事务和调用机制的所有相关信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmenv := vm.NewEVM(context, statedb, config, cfg)</span><br></pre></td></tr></table></figure>

<p>1.4 将交易应用到当前状态(包含在env中)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</span><br></pre></td></tr></table></figure>

<p>这部分代码继续跟进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyMessage</span><span class="params">(evm *vm.EVM, msg Message, gp *GasPool)</span></span> ([]<span class="type">byte</span>, <span class="type">uint64</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewStateTransition</code> 是一个状态转换对象，<code>TransitionDb()</code> 负责转换交易状态，继续跟进：<br>先进行<code>preCheck</code>，用来校验<code>nonce</code>是否正确</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st.preCheck()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> st.msg.CheckNonce() &#123;</span><br><span class="line">		nonce := st.state.GetNonce(st.msg.From())</span><br><span class="line">		<span class="keyword">if</span> nonce &lt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooHigh</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nonce &gt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooLow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>计算所需<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gas, err := IntrinsicGas(st.data, contractCreation, homestead, istanbul)</span><br></pre></td></tr></table></figure>

<p>扣除<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = st.useGas(gas); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span></span> useGas(amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> st.gas &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> vm.ErrOutOfGas</span><br><span class="line">	&#125;</span><br><span class="line">	st.gas -= amount</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是合约交易,则新建一个合约</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>如果不是合约交易，则增加<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>重点关注<code>evm.call</code>方法：</p>
<p><em>检查账户是否有足够的气体进行转账</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果stateDb不存在此账户，则新建账户</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">  evm.StateDB.CreateAccount(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>执行转账操作</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br></pre></td></tr></table></figure>

<p><em>创建合约</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract := NewContract(caller, to, value, gas)</span><br></pre></td></tr></table></figure>

<p><em>执行合约</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret, err = run(evm, contract, input, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>添加余额</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st.state.AddBalance(st.evm.Coinbase, <span class="built_in">new</span>(big.Int).Mul(<span class="built_in">new</span>(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</span><br></pre></td></tr></table></figure>

<p>回到<code>ApplyTransaction</code></p>
<p>1.5 调用<code>IntermediateRoot</code>计算状态<code>trie</code>的当前根哈希值。</p>
<p>最终确定所有肮脏的存储状态，并把它们写进<code>trie</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.Finalise(deleteEmptyObjects)</span><br></pre></td></tr></table></figure>

<p>将trie根设置为当前的根哈希并将给定的<code>object</code>写入到<code>trie</code>中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.updateRoot(s.db)</span><br><span class="line">s.updateStateObject(obj)</span><br></pre></td></tr></table></figure>

<p>1.6 创建收据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">receipt := types.NewReceipt(root, failed, *usedGas)</span><br><span class="line">	receipt.TxHash = tx.Hash()</span><br><span class="line">	receipt.GasUsed = gas</span><br><span class="line">	<span class="keyword">if</span> msg.To() == <span class="literal">nil</span> &#123;</span><br><span class="line">		receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the receipt logs and create a bloom for filtering</span></span><br><span class="line">	receipt.Logs = statedb.GetLogs(tx.Hash())</span><br><span class="line">	receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</span><br><span class="line">	receipt.BlockHash = statedb.BlockHash()</span><br><span class="line">	receipt.BlockNumber = header.Number</span><br><span class="line">	receipt.TransactionIndex = <span class="type">uint</span>(statedb.TxIndex())</span><br></pre></td></tr></table></figure>

<p>②：最后完成区块，应用任何共识引擎特定的额外功能(例如区块奖励)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Finalize(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header) &#123;</span><br><span class="line">	<span class="comment">// Accumulate any block and uncle rewards and commit the final state root</span></span><br><span class="line">	<span class="comment">//累积任何块和叔叔的奖励并提交最终状态树根</span></span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止<code>bc.processor.Process</code>执行完毕，返回<code>receipts</code>.</p>
<hr>
<h3 id="校验状态"><a href="#校验状态" class="headerlink" title="校验状态"></a>校验状态</h3><p>大致包括4部分的校验：</p>
<p>①：校验使用的<code>gas</code>是否相等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> block.GasUsed() != usedGas &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gas used (remote: %d local: %d)&quot;</span>, block.GasUsed(), usedGas)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：校验bloom是否相等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rbloom := types.CreateBloom(receipts)</span><br><span class="line">	<span class="keyword">if</span> rbloom != header.Bloom &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid bloom (remote: %x  local: %x)&quot;</span>, header.Bloom, rbloom)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：校验收据哈希是否相等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line">	<span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>, header.ReceiptHash, receiptSha)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：校验merkleroot 是否相等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> root := statedb.IntermediateRoot(v.config.IsEIP158(header.Number)); header.Root != root &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid merkle root (remote: %x local: %x)&quot;</span>, header.Root, root)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将块和关联状态写入到数据库"><a href="#将块和关联状态写入到数据库" class="headerlink" title="将块和关联状态写入到数据库"></a>将块和关联状态写入到数据库</h3><p>函数：<strong>WriteBlockWithState</strong></p>
<p>①：计算块的<code>total td</code> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptd := bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>②：添加待插入块本身的<code>td</code> ,并将此时最新的<code>total td</code> 存储到数据库中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd)</span><br></pre></td></tr></table></figure>

<p>③：将块的<code>header</code>和<code>body</code>分别序列化到数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rawdb.WriteBlock(bc.db, block)</span><br><span class="line">	-&gt;WriteBody(db, block.Hash(), block.NumberU64(), block.Body())</span><br><span class="line">	-&gt;WriteHeader(db, block.Header())</span><br></pre></td></tr></table></figure>

<p>④：将状态写入底层内存<code>Trie</code>数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.Commit(bc.chainConfig.IsEIP158(block.Number()))</span><br></pre></td></tr></table></figure>

<p>⑤：遍历节点数据写入到磁盘</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triedb.Commit(header.Root, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：存储一个块的所有交易数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts)</span><br></pre></td></tr></table></figure>

<p>⑦：将新的<code>head</code>块注入到当前链中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.insert(block)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储分配给规范块的哈希</li>
<li>存储头块的哈希</li>
<li>存储最新的快</li>
<li>更新<code>currentFastBlock</code></li>
</ul>
<p>⑧：发送<code>chainEvent</code>事件或者<code>ChainSideEvent</code>事件或者<code>ChainHeadEvent</code>事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.chainFeed.Send(ChainEvent&#123;Block: block, Hash: block.Hash(), Logs: logs&#125;)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			bc.logsFeed.Send(logs)</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span> emitHeadEvent &#123;</span><br><span class="line">			bc.chainHeadFeed.Send(ChainHeadEvent&#123;Block: block&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bc.chainSideFeed.Send(ChainSideEvent&#123;Block: block&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此writeBlockWithState 结束，从上面可以知道，insertChain的最终还是调用了<code>writeBlockWithState</code>的insert方法完成了最终的上链入库动作。</p>
<p>最后整个<code>insertChain</code> <em>函数，如果已经完成了插入，就发送<code>chain head</code>事件</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</span><br><span class="line">		bc.chainHeadFeed.Send(ChainHeadEvent&#123;lastCanon&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>比较常见的有这么几处会进行订阅<code>chain head</code> 事件：</p>
<ol>
<li><p>在tx_pool.go中，收到此事件会进行换head的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在worker.go中,其他节点的矿工收到此事件就会停止当前的挖矿，继续下一个挖矿任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>到此整个区块上链入库就完成了，最后再送上一张总结的图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glyqxrr9p0j31530u0jz0.jpg" alt="image-20201224104046731"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/" class="post-title-link" itemprop="url">死磕以太坊源码分析之rlpx协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:08:56 / Modified: 13:09:19" itemprop="dateCreated datePublished" datetime="2024-08-26T13:08:56+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之rlpx协议</p>
</blockquote>
<p>本文主要参考自eth官方文档：<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide">rlpx协议</a></p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><ul>
<li><code>X || Y</code>：表示X和Y的串联</li>
<li><code>X ^ Y</code>： X和Y按位异或</li>
<li><code>X[:N]</code>：X的前N个字节</li>
<li><code>[X, Y, Z, ...]</code>：[X, Y, Z, …]的RLP递归编码</li>
<li><code>keccak256(MESSAGE)</code>：以太坊使用的keccak256哈希算法</li>
<li><code>ecies.encrypt(PUBKEY, MESSAGE, AUTHDATA)</code>：RLPx使用的非对称身份验证加密函数     AUTHDATA是身份认证的数据，并非密文的一部分     但是AUTHDATA会在生成消息tag前，写入HMAC-256哈希函数</li>
<li><code>ecdh.agree(PRIVKEY, PUBKEY)</code>：是PRIVKEY和PUBKEY之间的椭圆曲线Diffie-Hellman协商函数</li>
</ul>
<hr>
<h2 id="ECIES加密"><a href="#ECIES加密" class="headerlink" title="ECIES加密"></a>ECIES加密</h2><p>ECIES (Elliptic Curve Integrated Encryption Scheme) 非对称加密用于RLPx握手。RLPx使用的加密系统：</p>
<ul>
<li>椭圆曲线secp256k1基点<code>G</code></li>
<li><code>KDF(k, len)</code>：密钥推导函数 NIST SP 800-56 Concatenation</li>
<li><code>MAC(k, m)</code>：HMAC函数，使用了SHA-256哈希</li>
<li><code>AES(k, iv, m)</code>：AES-128对称加密函数，CTR模式</li>
</ul>
<p>假设Alice想发送加密消息给Bob，并且希望Bob可以用他的静态私钥<code>kB</code>解密。Alice知道Bob的静态公钥<code>KB</code>。</p>
<p>Alice为了对消息<code>m</code>进行加密：</p>
<ol>
<li>生成一个随机数<code>r</code>并生成对应的椭圆曲线公钥<code>R = r * G</code></li>
<li>计算共享密码<code>S = Px</code>，其中 <code>(Px, Py) = r * KB</code></li>
<li>推导加密及认证所需的密钥<code>kE || kM = KDF(S, 32)</code>以及随机向量<code>iv</code></li>
<li>使用AES加密 <code>c = AES(kE, iv, m)</code></li>
<li>计算MAC校验 <code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>发送完整密文<code>R || iv || c || d</code>给Bob</li>
</ol>
<p>Bob对密文<code>R || iv || c || d</code>进行解密：</p>
<ol>
<li>推导共享密码<code>S = Px</code>, 其中<code>(Px, Py) = r * KB = kB * R</code></li>
<li>推导加密认证用的密钥<code>kE || kM = KDF(S, 32)</code></li>
<li>验证MAC<code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>获得明文<code>m = AES(kE, iv || c)</code></li>
</ol>
<hr>
<h2 id="节点身份"><a href="#节点身份" class="headerlink" title="节点身份"></a>节点身份</h2><p>所有的加密操作都基于<strong>secp256k1</strong>椭圆曲线。每个节点维护一个静态的<strong>secp256k1</strong>私钥。建议该私钥只能进行手动重置（例如删除文件或数据库条目）。</p>
<hr>
<h2 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h2><p>RLPx连接基于TCP通信，并且每次通信都会生成随机的临时密钥用于加密和验证。生成临时密钥的过程被称作“握手” (handshake)，握手在发起端（initiator, 发起TCP连接请求的节点）和接收端（recipient, 接受连接的节点）之间进行。</p>
<ol>
<li>发起端向接收端发起TCP连接，发送<code>auth</code>消息</li>
<li>接收端接受连接，解密、验证<code>auth</code>消息（检查recovery of signature &#x3D;&#x3D; <code>keccak256(ephemeral-pubk)</code>）</li>
<li>接收端通过<code>remote-ephemeral-pubk</code> 和 <code>nonce</code>生成<code>auth-ack</code>消息</li>
<li>接收端推导密钥，发送首个包含<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息的数据帧 (frame)</li>
<li>发起端接收到<code>auth-ack</code>消息，导出密钥</li>
<li>发起端发送首个加密后的数据帧，包含发起端<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息</li>
<li>接收端接收并验证首个加密后的数据帧</li>
<li>发起端接收并验证首个加密后的数据帧</li>
<li>如果两边的首个加密数据帧的MAC都验证通过，则加密握手完成</li>
</ol>
<p>如果首个数据帧的验证失败，则任意一方都可以断开连接。</p>
<h3 id="握手消息"><a href="#握手消息" class="headerlink" title="握手消息"></a>握手消息</h3><p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auth = auth-size || enc-auth-body</span><br><span class="line">auth-size = size of enc-auth-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">auth-vsn = <span class="number">4</span></span><br><span class="line">auth-body = [sig, initiator-pubk, initiator-nonce, auth-vsn, ...]</span><br><span class="line">enc-auth-body = ecies.encrypt(recipient-pubk, auth-body || auth-padding, auth-size)</span><br><span class="line">auth-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ack = ack-size || enc-ack-body</span><br><span class="line">ack-size = size of enc-ack-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">ack-vsn = <span class="number">4</span></span><br><span class="line">ack-body = [recipient-ephemeral-pubk, recipient-nonce, ack-vsn, ...]</span><br><span class="line">enc-ack-body = ecies.encrypt(initiator-pubk, ack-body || ack-padding, ack-size)</span><br><span class="line">ack-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p>实现必须忽略<code>auth-vsn</code> 和 <code>ack-vsn</code>中的所有不匹配。</p>
<p>实现必须忽略<code>auth-body</code> 和 <code>ack-body</code>中的所有额外列表元素。</p>
<p>握手消息互换后，密钥生成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static-shared-secret = ecdh.agree(privkey, remote-pubk)</span><br><span class="line">ephemeral-key = ecdh.agree(ephemeral-privkey, remote-ephemeral-pubk)</span><br><span class="line">shared-secret = keccak256(ephemeral-key || keccak256(nonce || initiator-nonce))</span><br><span class="line">aes-secret = keccak256(ephemeral-key || shared-secret)</span><br><span class="line">mac-secret = keccak256(ephemeral-key || aes-secret)</span><br></pre></td></tr></table></figure>

<h2 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h2><p>握手后所有的消息都按帧 (frame) 传输。一帧数据携带属于某一功能的一条加密消息。</p>
<p>分帧传输的主要目的是在单一连接上实现可靠的支持多路复用协议。其次，因数据包分帧，为消息认证码产生了适当的分界点，使得加密流变得简单了。通过握手生成的密钥对数据帧进行加密和验证。</p>
<p>帧头提供关于消息大小和消息源功能的信息。填充字节用于防止缓存区不足，使得帧组件按指定区块字节大小对齐。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frame = header-ciphertext || header-mac || frame-ciphertext || frame-mac</span><br><span class="line">header-ciphertext = aes(aes-secret, header)</span><br><span class="line">header = frame-size || header-data || header-padding</span><br><span class="line">header-data = [capability-id, context-id]</span><br><span class="line">capability-id = integer, always zero</span><br><span class="line">context-id = integer, always zero</span><br><span class="line">header-padding = zero-fill header to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br><span class="line">frame-ciphertext = aes(aes-secret, frame-data || frame-padding)</span><br><span class="line">frame-padding = zero-fill frame-data to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>RLPx中的消息认证 (Message authentication) 使用了两个keccak256状态，分别用于两个传输方向。<code>egress-mac</code>和<code>ingress-mac</code>分别代表发送和接收状态，每次发送或者接收密文，其状态都会更新。初始握手后，MAC状态初始化如下:</p>
<p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br></pre></td></tr></table></figure>

<p>当发送一帧数据时，通过即将发送的数据更新<code>egress-mac</code>状态，然后计算相应的MAC值。通过将帧头与其对应MAC值的加密输出异或来进行更新。这样做是为了确保对明文MAC和密文执行统一操作。所有的MAC值都以明文发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ header-ciphertext</span><br><span class="line">egress-mac = keccak256.update(egress-mac, header-mac-seed)</span><br><span class="line">header-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p><strong>计算 <code>frame-mac</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">egress-mac = keccak256.update(egress-mac, frame-ciphertext)</span><br><span class="line">frame-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ keccak256.digest(egress-mac)[:16]</span><br><span class="line">egress-mac = keccak256.update(egress-mac, frame-mac-seed)</span><br><span class="line">frame-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p>只要发送者和接受者按相同方式更新<code>egress-mac</code>和<code>ingress-mac</code>，并且在ingress帧中比对<code>header-mac</code> 和 <code>frame-mac</code>的值，就能对ingress帧中的MAC值进行校验。这一步应当在解密<code>header-ciphertext</code> 和 <code>frame-ciphertext</code>之前完成。</p>
<hr>
<h2 id="功能消息"><a href="#功能消息" class="headerlink" title="功能消息"></a>功能消息</h2><p>初始握手后的所有消息均与“功能”相关。单个RLPx连接上就可以同时使用任何数量的功能。</p>
<p>功能由简短的ASCII名称和版本号标识。连接两端都支持的功能在隶属于“ p2p”功能的<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息中进行交换，p2p功能需要在所有连接中都可用。</p>
<h3 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h3><p>初始Hello消息编码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame-data = msg-id || msg-data</span><br><span class="line">frame-size = length of frame-data, encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<p>其中，<code>msg-id</code>是标识消息的由RLP编码的整数，<code>msg-data</code>是包含消息数据的RLP列表。</p>
<p>Hello之后的所有消息均使用Snappy算法压缩。请注意，压缩消息的<code>frame-size</code>指<code>msg-data</code>压缩前的大小。消息的压缩编码为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame-data = msg-id || snappyCompress(msg-data)</span><br><span class="line">frame-size = length of (msg-id || msg-data) encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<h2 id="基于msg-id的复用"><a href="#基于msg-id的复用" class="headerlink" title="基于msg-id的复用"></a>基于<code>msg-id</code>的复用</h2><p>frame中虽然支持<code>capability-id</code>，但是在本RLPx版本中并没有将该字段用于不同功能之间的复用（当前版本仅使用msg-id来实现复用）。</p>
<p>每种功能都会根据需要分配尽可能多的msg-id空间。所有这些功能所需的msg-id空间都必须通过静态指定。在连接和接收<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息时，两端都具有共享功能（包括版本）的对等信息，并且能够就msg-id空间达成共识。</p>
<p>msg-id应当大于0x11(0x00-0x10保留用于“ p2p”功能）。</p>
<hr>
<h2 id="p2p功能"><a href="#p2p功能" class="headerlink" title="p2p功能"></a>p2p功能</h2><p>所有连接都具有“p2p”功能。初始握手后，连接的两端都必须发送<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>或<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。在接收到Hello消息后，会话就进入激活状态，并且可以开始发送其他消息。由于前向兼容性，实现必须忽略协议版本中的所有差异。与处于较低版本的节点通信时，实现应尝试靠近该版本。</p>
<p>任何时候都可能会收到<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。</p>
<h3 id="Hello-0x00"><a href="#Hello-0x00" class="headerlink" title="Hello (0x00)"></a>Hello (0x00)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocolVersion: P, clientId: B, capabilities, listenPort: P, nodeKey: B_64, ...]</span><br></pre></td></tr></table></figure>

<p>握手完成后，双方发送的第一包数据。在收到Hello消息前，不能发送任何其他消息。实现必须忽略Hello消息中所有其他列表元素，因为可能会在未来版本中用到。</p>
<ul>
<li><code>protocolVersion</code>当前p2p功能版本为第5版</li>
<li><code>clientId</code>表示客户端软件身份，人类可读字符串, 比如”Ethereum(++)&#x2F;1.0.0“</li>
<li><code>capabilities</code>支持的子协议列表，名称及其版本：<code>[[cap1, capVersion1], [cap2, capVersion2], ...]</code></li>
<li><code>listenPort</code>节点的收听端口 (位于当前连接路径的接口)，0表示没有收听</li>
<li><code>nodeId</code>secp256k1的公钥，对应节点私钥</li>
</ul>
<h3 id="Disconnect-0x01"><a href="#Disconnect-0x01" class="headerlink" title="Disconnect (0x01)"></a>Disconnect (0x01)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[reason: P]</span><br></pre></td></tr></table></figure>

<p>通知节点断开连接。收到该消息后，节点应当立即断开连接。如果是发送，正常的主机会给节点2秒钟读取时间，使其主动断开连接。</p>
<p><code>reason</code> 一个可选整数，表示断开连接的原因：</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x00</code></td>
<td>Disconnect requested</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>TCP sub-system error</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>Breach of protocol, e.g. a malformed message, bad RLP, …</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td>Useless peer</td>
</tr>
<tr>
<td><code>0x04</code></td>
<td>Too many peers</td>
</tr>
<tr>
<td><code>0x05</code></td>
<td>Already connected</td>
</tr>
<tr>
<td><code>0x06</code></td>
<td>Incompatible P2P protocol version</td>
</tr>
<tr>
<td><code>0x07</code></td>
<td>Null node identity received - this is automatically invalid</td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>Client quitting</td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>Unexpected identity in handshake</td>
</tr>
<tr>
<td><code>0x0a</code></td>
<td>Identity is the same as this node (i.e. connected to itself)</td>
</tr>
<tr>
<td><code>0x0b</code></td>
<td>Ping timeout</td>
</tr>
<tr>
<td><code>0x10</code></td>
<td>Some other reason specific to a subprotocol</td>
</tr>
</tbody></table>
<h3 id="Ping-0x02"><a href="#Ping-0x02" class="headerlink" title="Ping (0x02)"></a>Ping (0x02)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>要求节点立即进行<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#pong-0x03">Pong</a>回复。</p>
<h3 id="Pong-0x03"><a href="#Pong-0x03" class="headerlink" title="Pong (0x03)"></a>Pong (0x03)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>回复节点的<a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#ping-0x02">Ping</a>包。</p>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="返回传输对象"><a href="#返回传输对象" class="headerlink" title="返回传输对象"></a>返回传输对象</h4><blockquote>
<p>返回一个transport对象,连接持续5秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handshakeTimeout 5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRLPX</span><span class="params">(fd net.Conn)</span></span> transport &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><blockquote>
<p>返回Msg对象,调用读写器的ReadMsg,连接持续30秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> ReadMsg() (Msg, <span class="type">error</span>) &#123;</span><br><span class="line">  ..</span><br><span class="line">	t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入消息"><a href="#写入消息" class="headerlink" title="写入消息"></a>写入消息</h4><blockquote>
<p>调用读写器的WriteMsg写信息,连接持续20秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> WriteMsg(msg Msg) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议版本握手"><a href="#协议版本握手" class="headerlink" title="协议版本握手"></a>协议版本握手</h4><blockquote>
<p>协议握手,输入输出均是protoHandshake对象,包含了版本号、名称、容量、端口号、ID和一个扩展属性,握手时会对这些信息进行验证</p>
</blockquote>
<h4 id="加密握手"><a href="#加密握手" class="headerlink" title="加密握手"></a>加密握手</h4><blockquote>
<p>握手时主动发起者叫<strong>initiator</strong></p>
<p>接收方叫<strong>receiver</strong></p>
<p>分别对应两种处理方式<strong>initiatorEncHandshake</strong>和receiverEncHandshake</p>
<p>两种处理方式成功以后都会得到一个<strong>secrets</strong>对象,保存了共享密钥信息,它会跟原有的<strong>net.Conn</strong>对象一起生成一个帧处理器:<strong>rlpxFrameRW</strong></p>
<p>握手双方使用到的信息有:各自的公私钥地址对**(iPrv,iPub,rPrv,rPub)<strong>、各自生成的随机公私钥对</strong>(iRandPrv,iRandPub,rRandPrv,rRandPub)<strong>、各自生成的临时随机数</strong>(initNonce,respNonce).**<br> 其中i开头的表示发起方**(initiator)<strong>信息,r开头的表示接收方</strong>(receiver)**信息.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> doEncHandshake(prv *ecdsa.PrivateKey, dial *ecdsa.PublicKey) (*ecdsa.PublicKey, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sec secrets</span><br><span class="line">		err <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> dial == <span class="literal">nil</span> &#123;</span><br><span class="line">		sec, err = receiverEncHandshake(t.fd, prv) <span class="comment">// 接收者</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sec, err = initiatorEncHandshake(t.fd, prv, dial) <span class="comment">//主动发起者</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	t.rw = newRLPXFrameRW(t.fd, sec)</span><br><span class="line">	t.wmu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> sec.Remote.ExportECDSA(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就讲解一下主动握手部分源码<code>initiatorEncHandshake</code>：</p>
<p>①：初始化握手对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;encHandshake&#123;initiator: <span class="literal">true</span>, remote: ecies.ImportECDSAPublic(remote)&#125;</span><br></pre></td></tr></table></figure>

<p>②：生成验证信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authMsg, err := h.makeAuthMsg(prv) </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *encHandshake)</span></span> makeAuthMsg(prv *ecdsa.PrivateKey) (*authMsgV4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 生成己方随机数initNonce</span></span><br><span class="line">	h.initNonce = <span class="built_in">make</span>([]<span class="type">byte</span>, shaLen)</span><br><span class="line">	_, err := rand.Read(h.initNonce)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 生成随机的一组公私钥对</span></span><br><span class="line">	h.randomPrivKey, err = ecies.GenerateKey(rand.Reader, crypto.S256(), <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成静态共享秘密token(用己方私钥和对方公钥进行有限域乘法)</span></span><br><span class="line">	token, err := h.staticSharedSecret(prv)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//  和己方随机数异或后用随机生成的私钥签名</span></span><br><span class="line">	signed := xor(token, h.initNonce)</span><br><span class="line">	signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：封包,将验证信息和握手进行rlp编码并拼接前缀信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authPacket, err := sealEIP8(authMsg, h)</span><br></pre></td></tr></table></figure>

<p>④：通过conn发送消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.Write(authPacket)</span><br></pre></td></tr></table></figure>

<p>⑤：处理接收的信息,得到响应包</p>
<blockquote>
<p><code>readHandshakeMsg</code>比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 </p>
<p>结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authRespMsg := <span class="built_in">new</span>(authRespV4)</span><br><span class="line">authRespPacket, err := readHandshakeMsg(authRespMsg, encAuthRespLen, prv, conn)</span><br></pre></td></tr></table></figure>

<p>⑥：填充响应的respNonce(对方随机数,生成共享私钥用)和remoteRandomPub(对方的随机公钥)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h.handleAuthResp(authRespMsg)</span><br></pre></td></tr></table></figure>

<p>⑦：将请求包和响应包封装成共享秘密(secrets)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h.secrets(authPacket, authRespPacket)</span><br></pre></td></tr></table></figure>

<p>到此RLPX 相关的比较重要的内容就解读差不多了。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn/</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md">https://github.com/ethereum/devp2p/blob/master/rlpx.md</a> </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/" class="post-title-link" itemprop="url">死磕以太坊源码分析之p2p网络启动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:03:20 / Modified: 13:04:37" itemprop="dateCreated datePublished" datetime="2024-08-26T13:03:20+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之p2p网络启动</p>
<p>资料代码及文章:<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>持续输出区块链相关技术文章，喜欢作者可以持续关注，文章有问题，可以随时指出。</p>
</blockquote>
<h2 id="p2p源码目录"><a href="#p2p源码目录" class="headerlink" title="p2p源码目录"></a>p2p源码目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">discover/          基于UDP的节点发现V4协议</span><br><span class="line">  discv5/            节点发现V5协议</span><br><span class="line">  enode/             节点信息</span><br><span class="line">  enr/               以太坊节点记录（ethereum node records)</span><br><span class="line">  nat/               网络地址转换，用于内网穿透</span><br><span class="line">  netutil/</span><br><span class="line">  protocol/</span><br><span class="line">  simulations/       本地p2p网络的模拟器</span><br><span class="line">  dial.go            建立连接请求，以任务的形式 </span><br><span class="line">  message.go         定义了读写的接口</span><br><span class="line">  metrics.go         计时器和计量器工具</span><br><span class="line">  peer.go            节点</span><br><span class="line">  protocol.go        子协议</span><br><span class="line">  rlpx.go            加密传输协议 </span><br><span class="line">  server.go          底层p2p网络的函数入口 </span><br></pre></td></tr></table></figure>



<h2 id="启动p2p网络"><a href="#启动p2p网络" class="headerlink" title="启动p2p网络"></a>启动p2p网络</h2><p>启动p2p网络主要会做以下几件事：</p>
<ol>
<li>发现远程节点，建立相邻节点列表</li>
<li>监听远程节点发过来的建立TCP请求</li>
<li>向远程节点发送建立TCP连接请求</li>
</ol>
<p>首先找到p2p网络启动的入口：</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p><code>start</code>函数主要做了以下6件事：</p>
<ol>
<li>初始化server的字段</li>
<li>设置本地节点setupLocalNode</li>
<li>设置监听TCP连接请求setupListening</li>
<li>设置节点发现（setupDiscovery）V4版本</li>
<li>设置最大可以主动发起的连接为50&#x2F;3</li>
<li>srv.run(dialer) 发起建立TCP连接请求</li>
</ol>
<p>其中setupLocalNode、setupListening、setupDiscovery、newDialState、srv.run(dialer)是我们要重点分析的函数。</p>
<h4 id="设置本地节点"><a href="#设置本地节点" class="headerlink" title="设置本地节点"></a>设置本地节点</h4><p>进入到setupLocalNode中：</p>
<p>①：创建devp2p握手</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pubkey := crypto.FromECDSAPub(&amp;srv.PrivateKey.PublicKey)</span><br><span class="line">	srv.ourHandshake = &amp;protoHandshake&#123;Version: baseProtocolVersion, Name: srv.Name, ID: pubkey[<span class="number">1</span>:]&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		srv.ourHandshake.Caps = <span class="built_in">append</span>(srv.ourHandshake.Caps, p.<span class="built_in">cap</span>())</span><br><span class="line">	&#125;</span><br><span class="line">sort.Sort(capsByNameAndVersion(srv.ourHandshake.Caps))</span><br></pre></td></tr></table></figure>

<p>握手协议包括协议版本号，节点名称和节点的公钥，存入到Caps中要根据名称和协议排序。</p>
<p>②：创建本地节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db, err := enode.OpenDB(srv.Config.NodeDatabase)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	srv.nodedb = db</span><br><span class="line">	srv.localnode = enode.NewLocalNode(db, srv.PrivateKey)</span><br><span class="line">	srv.localnode.SetFallbackIP(net.IP&#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> check conflicts</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">			srv.localnode.Set(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先从节点数据库中去获取节点信息，如果不存在则新建本地节点并设置默认IP，同时将节点记录的协议特定信息存入到本地节点中。</p>
<hr>
<h4 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h4><p>进入到<code>setupListening</code>:</p>
<p>①：启动监听器</p>
<p>②：如果配置了NAT，则更新本地节点记录并映射TCP监听端口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tcp, ok := listener.Addr().(*net.TCPAddr); ok &#123;</span><br><span class="line">		srv.localnode.Set(enr.TCP(tcp.Port))</span><br><span class="line">		<span class="keyword">if</span> !tcp.IP.IsLoopback() &amp;&amp; srv.NAT != <span class="literal">nil</span> &#123;</span><br><span class="line">			srv.loopWG.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				nat.Map(srv.NAT, srv.quit, <span class="string">&quot;tcp&quot;</span>, tcp.Port, tcp.Port, <span class="string">&quot;ethereum p2p&quot;</span>)</span><br><span class="line">				srv.loopWG.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：开启P2P监听，接收<code>inbound</code>连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv.listenLoop()</span><br></pre></td></tr></table></figure>

<p>这个函数需要进一步分析：</p>
<p>主要有以下逻辑：</p>
<ul>
<li><p>首先<code>defaultMaxPendingPeers</code>这个字段指的是<code>inbound</code> 和<code>outbound</code>连接，默认最大值为50</p>
</li>
<li><p>将监听的连接返回给<code>listener</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd, err = srv.listener.Accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取监听的连接的地址并检查这个连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remoteIP := netutil.AddrIP(fd.RemoteAddr())</span><br><span class="line"><span class="keyword">if</span> err := srv.checkInboundConn(fd, remoteIP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkInboundConn</code>主要是做了以下的判断：</p>
<ul>
<li>拒绝不符合NetRestrict的连接（NetRestrict是指已经限定了某些连接，除此之外会拒绝）</li>
<li>拒绝尝试过多的节点</li>
</ul>
</li>
<li><p>最后真正建立连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			srv.SetupConn(fd, inboundConn, <span class="literal">nil</span>)<span class="comment">// 连接建立过程（将连接添加为peer）</span></span><br><span class="line">			slots &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;()</span><br></pre></td></tr></table></figure>

<p>要注意setupConn的第三个字段传入的是nil，表示还没有拨号，如果正在拨号的话需要节点公钥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dialPubkey *ecdsa.PublicKey</span><br><span class="line">	<span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		dialPubkey = <span class="built_in">new</span>(ecdsa.PublicKey)</span><br><span class="line">		<span class="keyword">if</span> err := dialDest.Load((*enode.Secp256k1)(dialPubkey)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;dial destination doesn&#x27;t have a secp256k1 public key&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是进行RLPX（RLPX会单独讲）握手</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remotePubkey, err := c.doEncHandshake(srv.PrivateKey, dialPubkey)</span><br></pre></td></tr></table></figure>

<p>如果dialDest 不为nil，检查公钥是否匹配，如果为nil,就从连接中返回一个node出来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// For dialed connections, check that the remote public key matches.</span></span><br><span class="line">		<span class="comment">//对于拨号连接，请检查远程公钥是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> dialPubkey.X.Cmp(remotePubkey.X) != <span class="number">0</span> || dialPubkey.Y.Cmp(remotePubkey.Y) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> DiscUnexpectedIdentity</span><br><span class="line">		&#125;</span><br><span class="line">		c.node = dialDest</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.node = nodeFromConn(remotePubkey, c.fd)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正执行握手了 ,这部分也属于RLPX，跳过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phs, err := c.doProtoHandshake(srv.ourHandshake)</span><br></pre></td></tr></table></figure>

<p>之后要进行检查，如果成功了的话，连接就会作为节点被添加，并且启动了runPeer.</p>
<p>到此为止，整个listenLoop 就完成了。</p>
<hr>
</li>
</ul>
<h4 id="设置节点发现"><a href="#设置节点发现" class="headerlink" title="设置节点发现"></a>设置节点发现</h4><p>进入到<code>srv.setupDiscovery()</code></p>
<p>①：添加特定于协议的发现源</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">added := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">if</span> proto.DialCandidates != <span class="literal">nil</span> &amp;&amp; !added[proto.Name] &#123;</span><br><span class="line">			srv.discmix.AddSource(proto.DialCandidates)</span><br><span class="line">			added[proto.Name] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果DHT禁用的话，就不要在UDP上监听</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> srv.NoDiscovery &amp;&amp; !srv.DiscoveryV5 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：监听给定的socket 上的发现的包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<h4 id="创建DialState"><a href="#创建DialState" class="headerlink" title="创建DialState"></a>创建DialState</h4><p>dialstate负责拨号和查找发现。</p>
<p>①：初始化dialstate</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;dialstate&#123;</span><br><span class="line">   maxDynDials: maxdyn,</span><br><span class="line">   self:        self,</span><br><span class="line">   netrestrict: cfg.NetRestrict,</span><br><span class="line">   log:         cfg.Logger,</span><br><span class="line">   static:      <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]*dialTask),</span><br><span class="line">   dialing:     <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]connFlag),</span><br><span class="line">   bootnodes:   <span class="built_in">make</span>([]*enode.Node, <span class="built_in">len</span>(cfg.BootstrapNodes)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：加入初始引导节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s.bootnodes, cfg.BootstrapNodes)</span><br><span class="line"><span class="keyword">if</span> s.log == <span class="literal">nil</span> &#123;</span><br><span class="line">	s.log = log.Root()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③： 加入静态节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> cfg.StaticNodes &#123;</span><br><span class="line">		s.addStatic(n)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>bootnodes</code>是初始引导节点，在节点没有接收到任何节点的连接请求，也没有节点可以给我们邻居节点的时候，就去连接<code>bootnodes</code>，它硬编码在了以太坊的源码中。</p>
<p><code>static</code>是静态节点，如果我们想和某些节点保持长期的连接，就把它们加入到静态节点的列表中</p>
<p>接下来就是到了运行p2p网络的时候了，主要的函数是：<code>go srv.run(dialer)</code></p>
<hr>
<h2 id="运行p2p网络"><a href="#运行p2p网络" class="headerlink" title="运行p2p网络"></a>运行p2p网络</h2><h3 id="srv-run-dialer"><a href="#srv-run-dialer" class="headerlink" title="srv.run(dialer)"></a>srv.run(dialer)</h3><p>在p2p网络启动时候，我们会监听远程节点发送过来的TCP请求，到了运行p2p网络的时候，我们则会向远程节点发起TCP的连接请求。首先我们要知道我们所说的发起TCP连接请求可以形容成拨号，每个拨号都是以任务的形式存在，进入到<code>srv.run(dialer)</code>分析</p>
<p>整个函数就是一个循环，介绍下它的主要功能：</p>
<h4 id="发起TCP连接任务"><a href="#发起TCP连接任务" class="headerlink" title="发起TCP连接任务"></a>发起TCP连接任务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleTasks()</span><br></pre></td></tr></table></figure>

<p><code>scheduleTasks</code>主要是从queued task 中去获取任务，通过查询dialer以查找新任务并立即启动尽可能多的任务，我们这里要注意个变量<code>maxActiveDialTasks</code>,它的默认值为16 ，而安排任务的核心方法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nt := dialstate.newTasks(<span class="built_in">len</span>(runningTasks)+<span class="built_in">len</span>(queuedTasks), peers, time.Now())</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<p>①：为没有连接的静态节点创建拨号任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> id, t := <span class="keyword">range</span> s.static &#123;</span><br><span class="line">		err := s.checkDial(t.dest, peers)</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> errNotWhitelisted, errSelf:</span><br><span class="line">			s.log.Warn(<span class="string">&quot;Removing static dial candidate&quot;</span>, <span class="string">&quot;id&quot;</span>, t.dest.ID, <span class="string">&quot;addr&quot;</span>, &amp;net.TCPAddr&#123;IP: t.dest.IP(), Port: t.dest.TCP()&#125;, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="built_in">delete</span>(s.static, t.dest.ID())</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			s.dialing[id] = t.flags</span><br><span class="line">			newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先对拨号节点进行校验：正在连接，已经连接，是本身，不在白名单中，最近连接过的都会报错，并且不是在白名单中的和自身的节点会直接从静态节点列表中删除，校验通过的创建任务。</p>
<p>②：计算所需的动态拨号数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">needDynDials := s.maxDynDials</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		<span class="keyword">if</span> p.rw.is(dynDialedConn) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, flag := <span class="keyword">range</span> s.dialing &#123;</span><br><span class="line">		<span class="keyword">if</span> flag&amp;dynDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们主动发起的TCP连接请求是由节点最大连接数除以拨号比率得出的，即<code>maxPeers/radio</code>，同时我们会判断节点中是否已经有建立了连接的节点和正在拨号的节点，有的话会needDynDials会减去。</p>
<p>③：如果找不到任何的peers,就去随机找bootnode，发起连接</p>
<p>不过这个一般适用在<strong>测试网或者私链</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(peers) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(s.bootnodes) &gt; <span class="number">0</span> &amp;&amp; needDynDials &gt; <span class="number">0</span> &amp;&amp; now.Sub(s.start) &gt; fallbackInterval &#123;</span><br><span class="line">		bootnode := s.bootnodes[<span class="number">0</span>]</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes[:<span class="number">0</span>], s.bootnodes[<span class="number">1</span>:]...)</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes, bootnode)</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, bootnode) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：从节点发现结果中创建动态拨号任务</p>
<p>如果不满足最大任务数量的话，就去<code>s.lookupBuf</code>中寻找，<code>lookupBuf</code>通过KAD算法获取的节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(s.lookupBuf) &amp;&amp; needDynDials &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, s.lookupBuf[i]) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.lookupBuf = s.lookupBuf[:<span class="built_in">copy</span>(s.lookupBuf, s.lookupBuf[i:])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.lookupBuf) &lt; needDynDials &amp;&amp; !s.lookupRunning &#123;</span><br><span class="line">		s.lookupRunning = <span class="literal">true</span></span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, &amp;discoverTask&#123;want: needDynDials - <span class="built_in">len</span>(s.lookupBuf)&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：没有需要执行的任务，保持拨号逻辑继续运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nRunning == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(newtasks) == <span class="number">0</span> &amp;&amp; s.hist.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t := &amp;waitExpireTask&#123;s.hist.nextExpiry().Sub(now)&#125;</span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此创建新任务结束，返回<code>newTasks</code></p>
<hr>
<h4 id="执行TCP连接任务"><a href="#执行TCP连接任务" class="headerlink" title="执行TCP连接任务"></a>执行TCP连接任务</h4><p>直到满足最大活动任务数才开始任务执行，具体的执行过程在以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">startTasks := <span class="function"><span class="keyword">func</span><span class="params">(ts []task)</span></span> (rest []task) &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> ; <span class="built_in">len</span>(runningTasks) &lt; maxActiveDialTasks &amp;&amp; i &lt; <span class="built_in">len</span>(ts); i++ &#123;</span><br><span class="line">			t := ts[i]</span><br><span class="line">			srv.log.Trace(<span class="string">&quot;New dial task&quot;</span>, <span class="string">&quot;task&quot;</span>, t)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.Do(srv); taskdone &lt;- t &#125;()</span><br><span class="line">			runningTasks = <span class="built_in">append</span>(runningTasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ts[i:]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Do(srv);</span><br></pre></td></tr></table></figure>

<p>执行的主要任务包括下面几种：</p>
<ol>
<li>dialTask</li>
<li>discoverTask</li>
<li>waitExpireTask</li>
</ol>
<p>最关键的就是<code>dialTask</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> Do(srv *Server) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.dest.Incomplete() &#123;</span><br><span class="line">		<span class="keyword">if</span> !t.resolve(srv) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err := t.dial(srv, t.dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		srv.log.Trace(<span class="string">&quot;Dial error&quot;</span>, <span class="string">&quot;task&quot;</span>, t, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="comment">// Try resolving the ID of static nodes if dialing failed.</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(*dialError); ok &amp;&amp; t.flags&amp;staticDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> t.resolve(srv) &#123;</span><br><span class="line">				t.dial(srv, t.dest)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的连接是在<code>t.dail</code>中做的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际的网络连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> dial(srv *Server, dest *enode.Node) <span class="type">error</span> &#123;</span><br><span class="line">	fd, err := srv.Dialer.Dial(dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;dialError&#123;err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mfd := newMeteredConn(fd, <span class="literal">false</span>, &amp;net.TCPAddr&#123;IP: dest.IP(), Port: dest.TCP()&#125;)</span><br><span class="line">	<span class="keyword">return</span> srv.SetupConn(mfd, t.flags, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下面就没必要深究了，实际的网络连接操作到此为止了。</p>
<hr>
<h4 id="管理TCP连接任务"><a href="#管理TCP连接任务" class="headerlink" title="管理TCP连接任务"></a>管理TCP连接任务</h4><p>在TCP连接任务完成后，会对连接有各种处理，如下：</p>
<p>①：停止p2p服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-srv.quit:</span><br><span class="line"><span class="keyword">break</span> running</span><br></pre></td></tr></table></figure>

<p>②：添加静态节点到peer列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addstatic:</span><br><span class="line">srv.log.Trace(<span class="string">&quot;Adding static node&quot;</span>, <span class="string">&quot;node&quot;</span>, n)</span><br><span class="line">dialstate.addStatic(n)</span><br></pre></td></tr></table></figure>

<p>③：发送断开连接请求，并断开连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removestatic:</span><br><span class="line">dialstate.removeStatic(n)</span><br><span class="line">			<span class="keyword">if</span> p, ok := peers[n.ID()]; ok &#123;</span><br><span class="line">				p.Disconnect(DiscRequested)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>断开连接会立即返回，并且不会等连接关闭。</p>
<p>④：标记可信节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addtrusted:</span><br><span class="line">trusted[n.ID()] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>⑤：从信任节点中删除一个节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removetrusted:</span><br><span class="line"><span class="built_in">delete</span>(trusted, n.ID())</span><br></pre></td></tr></table></figure>

<p>⑥：拨号任务完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-taskdone:newTasks</span><br><span class="line">dialstate.taskDone(t, time.Now())</span><br><span class="line">delTask(t)</span><br></pre></td></tr></table></figure>

<p>⑦：连接已通过加密握手,远程身份是已知的（但尚未经过验证）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> c := &lt;-srv.checkpointPostHandshake:</span><br><span class="line">c.cont &lt;- srv.postHandshakeChecks(peers, inboundCount, c)</span><br></pre></td></tr></table></figure>

<p>⑧：连接已通过协议握手，已知其功能并验证了远程身份</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">err := srv.addPeerChecks(peers, inboundCount, c)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 握手完成，所有检查完毕</span></span><br><span class="line">				p := newPeer(srv.log, c, srv.Protocols)</span><br><span class="line">			<span class="comment">//启用了消息事件就把peerfeed传给peer</span></span><br><span class="line">				<span class="keyword">if</span> srv.EnableMsgEvents &#123;</span><br><span class="line">					p.events = &amp;srv.peerFeed</span><br><span class="line">				&#125;</span><br><span class="line">				name := truncateName(c.name)</span><br><span class="line">	p.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)+<span class="number">1</span>, <span class="string">&quot;name&quot;</span>, name)</span><br><span class="line">				<span class="keyword">go</span> srv.runPeer(p) <span class="comment">// 重点</span></span><br><span class="line">				peers[c.node.ID()] = p</span><br><span class="line">				<span class="keyword">if</span> p.Inbound() &#123;</span><br><span class="line">					inboundCount++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> conn, ok := c.fd.(*meteredConn); ok &#123;</span><br><span class="line">					conn.handshakeDone(p)<span class="comment">// </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p><code>addPeerChecks</code>会删除没有匹配协议的连接，并且会重复握手后检查，因为自执行这些检查后可能已更改。连接通过握手后，将调用<code>handshakeDone</code></p>
<p>⑨：Peer断开连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> pd := &lt;-srv.delpeer:</span><br><span class="line">d := common.PrettyDuration(mclock.Now() - pd.created)</span><br><span class="line">			pd.log.Debug(<span class="string">&quot;Removing p2p peer&quot;</span>, <span class="string">&quot;addr&quot;</span>, pd.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)<span class="number">-1</span>, <span class="string">&quot;duration&quot;</span>, d, <span class="string">&quot;req&quot;</span>, pd.requested, <span class="string">&quot;err&quot;</span>, pd.err)</span><br><span class="line">			<span class="built_in">delete</span>(peers, pd.ID())</span><br><span class="line">			<span class="keyword">if</span> pd.Inbound() &#123;</span><br><span class="line">				inboundCount--</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个主要的处理TCP连接的循环讲解结束。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><ol>
<li>开启p2p网络主要包括：设置本地节点，监听TCP连接以及设置节点发现</li>
<li>运行P2P网络之后主要包括：发起TCP连接并执行连接，以及相关的连接处理。</li>
</ol>
<blockquote>
<p>公众号：区块链技术栈     </p>
<p><a target="_blank" rel="noopener" href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="mindcarver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mindcarver's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/" class="post-title-link" itemprop="url">死磕以太坊源码分析之p2p节点发现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-08-26 13:03:20 / Modified: 13:04:20" itemprop="dateCreated datePublished" datetime="2024-08-26T13:03:20+08:00">2024-08-26</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>死磕以太坊源码分析之p2p节点发现</p>
</blockquote>
<p>在阅读节点发现源码之前必须要理解kadmilia算法，<a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">可以参考：KAD算法详解</a>。</p>
<h2 id="节点发现概述"><a href="#节点发现概述" class="headerlink" title="节点发现概述"></a>节点发现概述</h2><p>节点发现，使本地节点得知其他节点的信息，进而加入到p2p网络中。</p>
<p>以太坊的节点发现基于类似的kademlia算法，源码中有两个版本，v4和v5。v4适用于全节点，通过<code>discover.ListenUDP</code>使用，v5适用于轻节点通过<code>discv5.ListenUDP</code>使用，本文介绍的是v4版本。</p>
<p>节点发现功能主要涉及 <strong>Server</strong> <strong>Table</strong> <strong>udp</strong> 这几个数据结构，它们有独自的事件响应循环，节点发现功能便是它们互相协作完成的。其中，每个以太坊客户端启动后都会在本地运行一个<strong>Server</strong>，并将网络拓扑中相邻的节点视为<strong>Node</strong>，而<strong>Table</strong>是<strong>Node</strong>的容器，<strong>udp</strong>则是负责维持底层的连接。这些结构的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzetbpzowj30z00egtbh.jpg" alt="image-20201123210628944"></p>
<h2 id="p2p服务开启节点发现"><a href="#p2p服务开启节点发现" class="headerlink" title="p2p服务开启节点发现"></a>p2p服务开启节点发现</h2><p>在P2p的server.go 的start方法中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := srv.setupDiscovery(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>setupDiscovery</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discovery V4</span></span><br><span class="line">	<span class="keyword">var</span> unhandled <span class="keyword">chan</span> discover.ReadPacket</span><br><span class="line">	<span class="keyword">var</span> sconn *sharedUDPConn</span><br><span class="line">	<span class="keyword">if</span> !srv.NoDiscovery &#123;</span><br><span class="line">		...</span><br><span class="line">		ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover.ListenUDP</code>方法即开启了节点发现的功能.</p>
<p>首先解析出监听地址的UDP端口，根据端口返回与之相连的UDP连接，之后返回连接的本地网络地址，接着设置最后一个UDP-on-IPv4端口。到此为止节点发现的一些准备工作做好，接下下来开始UDP的监听：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<p>然后进行UDP 的监听，下面是监听的过程：</p>
<h3 id="监听UDP"><a href="#监听UDP" class="headerlink" title="监听UDP"></a>监听UDP</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听给定的socket 上的发现的包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenUDP</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> ListenV4(c, ln, cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenV4</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	closeCtx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	t := &amp;UDPv4&#123;</span><br><span class="line">		conn:            c,</span><br><span class="line">		priv:            cfg.PrivateKey,</span><br><span class="line">		netrestrict:     cfg.NetRestrict,</span><br><span class="line">		localNode:       ln,</span><br><span class="line">		db:              ln.Database(),</span><br><span class="line">		gotreply:        <span class="built_in">make</span>(<span class="keyword">chan</span> reply),</span><br><span class="line">		addReplyMatcher: <span class="built_in">make</span>(<span class="keyword">chan</span> *replyMatcher),</span><br><span class="line">		closeCtx:        closeCtx,</span><br><span class="line">		cancelCloseCtx:  cancel,</span><br><span class="line">		log:             cfg.Log,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.log == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.log = log.Root()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.tab = tab</span><br><span class="line">	<span class="keyword">go</span> tab.loop() <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	t.wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> t.loop() <span class="comment">//</span></span><br><span class="line">	<span class="keyword">go</span> t.readLoop(cfg.Unhandled) <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<h4 id="1-新建路由表"><a href="#1-新建路由表" class="headerlink" title="1.新建路由表"></a>1.新建路由表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) </span><br></pre></td></tr></table></figure>

<p>新建路由表做了以下几件事：</p>
<ul>
<li>初始化table对象</li>
<li>设置bootnode（setFallbackNodes）<ul>
<li>节点第一次启动的时候，节点会与硬编码在以太坊源码中的<code>bootnode</code>进行连接，所有的节点加入几乎都先连接了它。连接上<code>bootnode</code>后，获取<code>bootnode</code>部分的邻居节点，然后进行节点发现，获取更多的活跃的邻居节点</li>
<li>nursery 是在 Table 为空并且数据库中没有存储节点时的初始连接节点（上文中的 6 个节点），通过 bootnode 可以发现新的邻居</li>
</ul>
</li>
<li>tab.seedRand：使用提供的种子值将生成器初始化为确定性状态</li>
<li>loadSeedNodes：加载种子节点；从保留已知节点的数据库中随机的抽取30个节点，再加上引导节点列表中的节点，放置入k桶中，如果K桶没有空间，则假如到替换列表中。</li>
</ul>
<h4 id="2-测试邻居节点连通性"><a href="#2-测试邻居节点连通性" class="headerlink" title="2.测试邻居节点连通性"></a>2.测试邻居节点连通性</h4><p>首先知道UDP协议是没有连接的概念的，所以需要不断的ping 来测试对端节点是否正常，在新建路由表之后，就来到下面的循环，不断的去做上面的事。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tab.loop()</span><br></pre></td></tr></table></figure>

<p>定时运行<code>doRefresh</code>、<code>doRevalidate</code>、<code>copyLiveNodes</code>进行刷新K桶。</p>
<p>以太坊的k桶设置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	alpha           = <span class="number">3</span>  <span class="comment">// Kademlia并发参数, 是系统内一个优化参数,控制每次从K桶最多取出节点个数,ethereum取值3</span></span><br><span class="line">  </span><br><span class="line">	bucketSize      = <span class="number">16</span> <span class="comment">// K桶大小(可容纳节点数)</span></span><br><span class="line">  </span><br><span class="line">	maxReplacements = <span class="number">10</span> <span class="comment">// 每桶更换列表的大小</span></span><br><span class="line">	hashBits          = <span class="built_in">len</span>(common.Hash&#123;&#125;) * <span class="number">8</span> <span class="comment">//每个节点ID长度,32*8=256, 32位16进制</span></span><br><span class="line">	nBuckets          = hashBits / <span class="number">15</span>       <span class="comment">//  K桶个数</span></span><br><span class="line">  ）</span><br></pre></td></tr></table></figure>

<p>首先搞清楚这三个定时器运行的时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refreshInterval    = <span class="number">30</span> * time.Minute</span><br><span class="line">revalidateInterval = <span class="number">10</span> * time.Second</span><br><span class="line">copyNodesInterval  = <span class="number">30</span> * time.Second</span><br></pre></td></tr></table></figure>

<h5 id="doRefresh"><a href="#doRefresh" class="headerlink" title="doRefresh"></a><code>doRefresh</code></h5><p>doRefresh对随机目标执行查找以保持K桶已满。如果表为空（初始引导程序或丢弃的有故障），则插入种子节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>从数据库加载随机节点和引导节点。这应该会产生一些以前见过的节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab.loadSeedNodes()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地节点ID作为目标节点进行查找最近的邻居节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab.net.lookupSelf()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> lookupSelf() []*enode.Node &#123;</span><br><span class="line">	<span class="keyword">return</span> t.newLookup(t.closeCtx, encodePubkey(&amp;t.priv.PublicKey)).run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> newLookup(ctx context.Context, targetKey encPubkey) *lookup &#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">return</span> t.findnode(n.ID(), n.addr(), targetKey)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向这些节点发起<code>findnode</code>操作查询离target节点最近的节点列表,将查询得到的节点进行<code>ping-pong</code>测试,将测试通过的节点落库保存</p>
<p>经过这个流程后,节点的K桶就能够比较均匀地将不同网络节点更新到本地K桶中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">unc (t *UDPv4) findnode(toid enode.ID, toaddr *net.UDPAddr, target encPubkey) ([]*node, <span class="type">error</span>) &#123;</span><br><span class="line">	t.ensureBond(toid, toaddr)</span><br><span class="line">	nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>, bucketSize)</span><br><span class="line">	nreceived := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 设置回应回调函数，等待类型为neighborsPacket的邻近节点包，如果类型对，就执行回调请求</span></span><br><span class="line">	rm := t.pending(toid, toaddr.IP, p_neighborsV4, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> (matched <span class="type">bool</span>, requestDone <span class="type">bool</span>) &#123;</span><br><span class="line">		reply := r.(*neighborsV4)</span><br><span class="line">		<span class="keyword">for</span> _, rn := <span class="keyword">range</span> reply.Nodes &#123;</span><br><span class="line">			nreceived++</span><br><span class="line">      <span class="comment">// 得到一个简单的node结构</span></span><br><span class="line">			n, err := t.nodeFromRPC(toaddr, rn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				t.log.Trace(<span class="string">&quot;Invalid neighbor node received&quot;</span>, <span class="string">&quot;ip&quot;</span>, rn.IP, <span class="string">&quot;addr&quot;</span>, toaddr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nreceived &gt;= bucketSize</span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="comment">//上面了一个管道事件，下面开始发送真正的findnode报文，然后进行等待了</span></span><br><span class="line">	t.send(toaddr, toid, &amp;findnodeV4&#123;</span><br><span class="line">		Target:     target,</span><br><span class="line">		Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix()),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> nodes, &lt;-rm.errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>查找3个随机的目标节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		tab.net.lookupRandom()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="doRevalidate"><a href="#doRevalidate" class="headerlink" title="doRevalidate"></a><code>doRevalidate</code></h5><p>doRevalidate检查随机存储桶中的最后一个节点是否仍然存在，如果不是，则替换或删除该节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>返回随机的非空K桶中的最后一个节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last, bi := tab.nodeToRevalidate()</span><br></pre></td></tr></table></figure>
</li>
<li><p>对最后的节点执行Ping操作，然后等待Pong</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteSeq, err := tab.net.ping(unwrapNode(last))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果节点ping通了的话，将节点移动到最前面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab.bumpInBucket(b, last)</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有收到回复，选择一个替换节点，或者如果没有任何替换节点，则删除该节点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab.replace(b, last)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="copyLiveNodes"><a href="#copyLiveNodes" class="headerlink" title="copyLiveNodes"></a><code>copyLiveNodes</code></h5><p>copyLiveNodes将表中的节点添加到数据库,如果节点在表中的时间超过了5分钟。</p>
<p>这部分代码比较简单，就伸展阐述。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n.livenessChecks &gt; <span class="number">0</span> &amp;&amp; now.Sub(n.addedAt) &gt;= seedMinTableTime &#123;</span><br><span class="line">				tab.db.UpdateNode(unwrapNode(n))</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-检测各类信息"><a href="#3-检测各类信息" class="headerlink" title="3.检测各类信息"></a>3.检测各类信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> t.loop()</span><br></pre></td></tr></table></figure>

<p>loop循环主要监听以下几类消息：</p>
<ul>
<li>case &lt;-t.closeCtx.Done()：检测是否停止</li>
<li>p :&#x3D; &lt;-t.addReplyMatcher：检测是否有添加新的待处理消息</li>
<li>r :&#x3D; &lt;-t.gotreply：检测是否接收到其他节点的回复消息</li>
</ul>
<h4 id="4-处理UDP数据包"><a href="#4-处理UDP数据包" class="headerlink" title="4. 处理UDP数据包"></a>4. 处理UDP数据包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> t.readLoop(cfg.Unhandled)</span><br></pre></td></tr></table></figure>

<p>主要有以下两件事：</p>
<ol>
<li><p>循环接收其他节点发来的udp消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbytes, from, err := t.conn.ReadFromUDP(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理接收到的UDP消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.handlePacket(from, buf[:nbytes])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来对这两个函数进行进一步的解析。</p>
<h5 id="接收UDP消息"><a href="#接收UDP消息" class="headerlink" title="接收UDP消息"></a>接收UDP消息</h5><p>接收UDP消息比较的简单，就是不断的从连接中读取Packet数据，它有以下几种消息：</p>
<ul>
<li><p><code>ping</code>：用于判断远程节点是否在线。</p>
</li>
<li><p><code>pong</code>：用于回复<code>ping</code>消息的响应。</p>
</li>
<li><p><code>findnode</code>：查找与给定的目标节点相近的节点。</p>
</li>
<li><p><code>neighbors</code>：用于回复<code>findnode</code>的响应，与给定的目标节点相近的节点列表</p>
</li>
</ul>
<hr>
<h5 id="处理UDP消息"><a href="#处理UDP消息" class="headerlink" title="处理UDP消息"></a>处理UDP消息</h5><p>主要做了以下几件事：</p>
<ol>
<li><p>数据包解码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packet, fromKey, hash, err := decodeV4(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查数据包是否有效，是否可以处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packet.preverify(t, from, fromID, fromKey)</span><br></pre></td></tr></table></figure>

<p>在校验这一块，涉及不同的消息类型不同的校验，我们来分别对各种消息进行分析。</p>
<p>①：<code>ping</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验公钥是否有效</li>
</ul>
<p>②：<code>pong</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验回复是否正确</li>
</ul>
<p>③：<code>findNodes</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验节点是否是最近的节点</li>
</ul>
<p>④：<code>neighbors</code></p>
<ul>
<li>校验消息是否过期</li>
<li>用于回复<code>findnode</code>的响应，校验回复是否正确</li>
</ul>
</li>
<li><p>处理packet数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packet.handle(t, from, fromID, hash)</span><br></pre></td></tr></table></figure>

<p>相同的，也会有4种消息，但是我们这边重点讲处理findNodes的消息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里就稍微介绍下如何处理<code>findnode</code>的消息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// 确定最近的节点</span></span><br><span class="line">	target := enode.ID(crypto.Keccak256Hash(req.Target[:]))</span><br><span class="line">	t.tab.mutex.Lock()</span><br><span class="line">	<span class="comment">//最接近的返回表中最接近给定id的n个节点</span></span><br><span class="line">	closest := t.tab.closest(target, bucketSize, <span class="literal">true</span>).entries</span><br><span class="line">	t.tab.mutex.Unlock()</span><br><span class="line">	<span class="comment">// 以每个数据包最多maxNeighbors的块的形式发送邻居，以保持在数据包大小限制以下。</span></span><br><span class="line">	p := neighborsV4&#123;Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix())&#125;</span><br><span class="line">	<span class="keyword">var</span> sent <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> closest &#123; <span class="comment">//扫描这些最近的节点列表，然后一个包一个包的发送给对方</span></span><br><span class="line">		<span class="keyword">if</span> netutil.CheckRelayIP(from.IP, n.IP()) == <span class="literal">nil</span> &#123;</span><br><span class="line">			p.Nodes = <span class="built_in">append</span>(p.Nodes, nodeToRPC(n))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) == maxNeighbors &#123;</span><br><span class="line">			t.send(from, fromID, &amp;p)<span class="comment">//给对方发送 neighborsPacket 包，里面包含节点列表</span></span><br><span class="line">			p.Nodes = p.Nodes[:<span class="number">0</span>]</span><br><span class="line">			sent = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) &gt; <span class="number">0</span> || !sent &#123;</span><br><span class="line">		t.send(from, fromID, &amp;p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先先确定最近的节点，再一个包一个包的发给对方，并校验节点的IP，最后把有效的节点发送给请求方。</p>
</li>
</ol>
<hr>
<h2 id="涉及的结构体："><a href="#涉及的结构体：" class="headerlink" title="涉及的结构体："></a>涉及的结构体：</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>conn ：接口，包括了从UDP中读取和写入，关闭UDP连接以及获取本地地址。</li>
<li>netrestrict：IP网络列表</li>
<li>localNode：本地节点</li>
<li>tab：路由表</li>
</ul>
<hr>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul>
<li><p>buckets：所有节点都加到这个里面，按照距离</p>
</li>
<li><p>nursery：启动节点</p>
</li>
<li><p>rand：随机来源</p>
</li>
<li><p>ips：跟踪IP，确保IP中最多N个属于同一网络范围</p>
</li>
<li><p>net: UDP 传输的接口</p>
<ul>
<li>返回本地节点</li>
<li>将enrRequest发送到给定的节点并等待响应</li>
<li>findnode向给定节点发送一个findnode请求，并等待该节点最多发送了k个邻居</li>
<li>返回查找最近的节点</li>
<li>将ping消息发送到给定的节点，然后等待答复</li>
</ul>
</li>
</ul>
<p>以下是table的结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkm6yzncc3j30t00ggdim.jpg" alt="image-20201112104254003"></p>
<hr>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/blockchainguide/tree/main/%E4%B8%BB%E6%B5%81%E5%8C%BA%E5%9D%97%E9%93%BE/ethereum/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/p2p">思维导图获取地址</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzexhy1kqj31d80mqafh.jpg" alt="image-20201123211034861"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://mindcarver.cn/">http://mindcarver.cn/</a>     ⭐️⭐️⭐️⭐️</p>
<p><a target="_blank" rel="noopener" href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> ⭐️⭐️⭐️⭐️</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">https://www.cnblogs.com/xiaolincoding/p/12571184.html</a> </p>
<p><a target="_blank" rel="noopener" href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b232c870dcd2">https://www.jianshu.com/p/b232c870dcd2</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/113684">https://bbs.huaweicloud.com/blogs/113684</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94d02a41a146">https://www.jianshu.com/p/94d02a41a146</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mindcarver"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">mindcarver</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mindcarver" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mindcarver" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/626984947@qq.com" title="E-Mail → 626984947@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/mindcarver001" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;mindcarver001" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mindcarver</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">199k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:01</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'mvGWtuPpkVTSqWCt8xxQ8x8p-gzGzoHsz',
      appKey     : 'IYnOZJ2Y6xvBXl8J1LtKZ59G',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
