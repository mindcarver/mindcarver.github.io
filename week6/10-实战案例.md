---
layout: default
section: Week6
title: 10-å®æˆ˜æ¡ˆä¾‹
---

# 10. å®æˆ˜æ¡ˆä¾‹ ğŸ®

> "çº¸ä¸Šå¾—æ¥ç»ˆè§‰æµ…ï¼Œç»çŸ¥æ­¤äº‹è¦èº¬è¡Œ" ~ é™†æ¸¸

æœ¬èŠ‚è¯¾é€šè¿‡**çœŸå®æ¡ˆä¾‹**å±•ç¤ºå¦‚ä½•åº”ç”¨Week 6æ‰€å­¦çš„çŸ¥è¯†ï¼

---

## ğŸ¬ æ¡ˆä¾‹1: é«˜çº§é‡åŒ–ç³»ç»Ÿå®ç°

### èƒŒæ™¯

æ„å»ºä¸€ä¸ªå®Œæ•´çš„é‡åŒ–äº¤æ˜“ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š
- æ•°æ®è·å–
- ç‰¹å¾å·¥ç¨‹
- æ¨¡å‹è®­ç»ƒ
- é£é™©æ§åˆ¶
- äº¤æ˜“æ‰§è¡Œ
- ç»©æ•ˆè¯„ä¼°

### å®ç°ä»£ç 

```python
import pandas as pd
import numpy as np
from typing import Dict, List
from datetime import datetime
import logging

# ==================== é…ç½® ====================
CONFIG = {
    'data': {
        'symbols': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA'],
        'start_date': '2020-01-01',
        'end_date': '2024-01-01'
    },
    'model': {
        'window_size': 252,  # 1å¹´
        'retrain_frequency': 'monthly'
    },
    'risk': {
        'max_single_position': 0.20,
        'max_total_position': 0.95,
        'stop_loss': 0.10
    },
    'trading': {
        'commission': 0.001,
        'slippage': 0.0001
    }
}

# ==================== æ•°æ®æ¨¡å— ====================
class DataManager:
    """æ•°æ®ç®¡ç†å™¨"""
    
    def __init__(self, config: dict):
        """
        åˆå§‹åŒ–æ•°æ®ç®¡ç†å™¨
        
        Args:
            config: é…ç½®å­—å…¸
        """
        self.config = config
        self.logger = logging.getLogger('DataManager')
    
    def fetch_data(self) -> pd.DataFrame:
        """
        è·å–æ•°æ®
        
        Returns:
            ä»·æ ¼æ•°æ®
        """
        # æ¨¡æ‹Ÿæ•°æ®è·å–
        # å®é™…åº”ç”¨ä¸­ä»APIæˆ–æ•°æ®åº“è·å–
        
        np.random.seed(42)
        dates = pd.date_range(
            start=CONFIG['data']['start_date'],
            end=CONFIG['data']['end_date'],
            freq='D'
        )
        
        data = []
        for symbol in CONFIG['data']['symbols']:
            # ç”Ÿæˆæ¨¡æ‹Ÿä»·æ ¼
            returns = np.random.randn(len(dates)) * 0.02
            prices = 100 * (1 + returns).cumprod()
            
            symbol_data = pd.DataFrame({
                'symbol': symbol,
                'date': dates,
                'close': prices,
                'volume': np.random.randint(1000000, 10000000, len(dates))
            })
            
            data.append(symbol_data)
        
        df = pd.concat(data, ignore_index=True)
        df = df.set_index(['date', 'symbol'])
        
        self.logger.info(f"è·å–æ•°æ®: {df.shape}")
        
        return df

# ==================== ç‰¹å¾å·¥ç¨‹æ¨¡å— ====================
class FeatureEngineer:
    """ç‰¹å¾å·¥ç¨‹å¸ˆ"""
    
    def __init__(self):
        """åˆå§‹åŒ–ç‰¹å¾å·¥ç¨‹å¸ˆ"""
        self.logger = logging.getLogger('FeatureEngineer')
    
    def extract_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        æå–ç‰¹å¾
        
        Args:
            data: ä»·æ ¼æ•°æ®
            
        Returns:
            ç‰¹å¾æ•°æ®
        """
        features = data.copy()
        
        # æŒ‰è‚¡ç¥¨åˆ†ç»„
        symbols = features.index.get_level_values('symbol').unique()
        
        all_features = []
        for symbol in symbols:
            symbol_data = features.loc[slice(None), symbol].copy()
            
            # ä»·æ ¼ç›¸å…³ç‰¹å¾
            symbol_data['returns'] = symbol_data['close'].pct_change()
            symbol_data['ma5'] = symbol_data['close'].rolling(5).mean()
            symbol_data['ma20'] = symbol_data['close'].rolling(20).mean()
            symbol_data['ma60'] = symbol_data['close'].rolling(60).mean()
            
            # ç›¸å¯¹å¼ºå¼±æŒ‡æ ‡
            symbol_data['rsi'] = self._calculate_rsi(symbol_data['close'])
            
            # æ³¢åŠ¨ç‡
            symbol_data['volatility'] = symbol_data['returns'].rolling(20).std()
            
            # åŠ¨é‡æŒ‡æ ‡
            symbol_data['momentum_5'] = symbol_data['close'] / symbol_data['close'].shift(5) - 1
            symbol_data['momentum_20'] = symbol_data['close'] / symbol_data['close'].shift(20) - 1
            
            all_features.append(symbol_data)
        
        features_df = pd.concat(all_features)
        
        # åˆ é™¤ç¼ºå¤±å€¼
        features_df = features_df.dropna()
        
        self.logger.info(f"æå–ç‰¹å¾: {features_df.shape}")
        
        return features_df
    
    def _calculate_rsi(self, prices: pd.Series, 
                        period: int = 14) -> pd.Series:
        """
        è®¡ç®—RSI
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            period: å‘¨æœŸ
            
        Returns:
            RSIåºåˆ—
        """
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi

# ==================== æ¨¡å‹è®­ç»ƒæ¨¡å— ====================
class ModelManager:
    """æ¨¡å‹ç®¡ç†å™¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–æ¨¡å‹ç®¡ç†å™¨"""
        self.model = None
        self.logger = logging.getLogger('ModelManager')
    
    def train(self, features: pd.DataFrame, 
              target_col: str = 'future_return'):
        """
        è®­ç»ƒæ¨¡å‹
        
        Args:
            features: ç‰¹å¾æ•°æ®
            target_col: ç›®æ ‡åˆ—
            
        Returns:
            è®­ç»ƒå¥½çš„æ¨¡å‹
        """
        # å‡†å¤‡æ•°æ®
        X = features.drop(columns=['close', 'volume', 'returns', target_col])
        y = features[target_col]
        
        # ç®€å•æ¨¡å‹ï¼šçº¿æ€§å›å½’
        from sklearn.linear_model import LinearRegression
        from sklearn.preprocessing import StandardScaler
        
        # æ ‡å‡†åŒ–
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # è®­ç»ƒ
        self.model = LinearRegression()
        self.model.fit(X_scaled, y)
        
        # è¯„ä¼°
        score = self.model.score(X_scaled, y)
        
        self.logger.info(f"è®­ç»ƒæ¨¡å‹: RÂ²={score:.4f}")
        
        return self.model
    
    def predict(self, features: pd.DataFrame) -> np.ndarray:
        """
        é¢„æµ‹
        
        Args:
            features: ç‰¹å¾æ•°æ®
            
        Returns:
            é¢„æµ‹ç»“æœ
        """
        if self.model is None:
            raise ValueError("æ¨¡å‹å°šæœªè®­ç»ƒ")
        
        # å‡†å¤‡æ•°æ®
        X = features.drop(columns=['close', 'volume', 'returns'])
        
        # æ ‡å‡†åŒ–
        from sklearn.preprocessing import StandardScaler
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        # é¢„æµ‹
        predictions = self.model.predict(X_scaled)
        
        return predictions

# ==================== é£é™©æ§åˆ¶æ¨¡å— ====================
class RiskController:
    """é£é™©æ§åˆ¶å™¨"""
    
    def __init__(self, config: dict):
        """
        åˆå§‹åŒ–é£é™©æ§åˆ¶å™¨
        
        Args:
            config: é…ç½®å­—å…¸
        """
        self.config = config
        self.positions = {}
        self.logger = logging.getLogger('RiskController')
    
    def check_position_limit(self, portfolio: Dict[str, float]) -> bool:
        """
        æ£€æŸ¥ä»“ä½é™åˆ¶
        
        Args:
            portfolio: æŠ•èµ„ç»„åˆ
            
        Returns:
            æ˜¯å¦ç¬¦åˆé™åˆ¶
        """
        # æ£€æŸ¥å•ä¸€è‚¡ç¥¨ä»“ä½
        for symbol, weight in portfolio.items():
            if weight > self.config['risk']['max_single_position']:
                self.logger.warning(
                    f"{symbol}ä»“ä½è¿‡é«˜: {weight:.2%} > "
                    f"{self.config['risk']['max_single_position']:.2%}"
                )
                return False
        
        # æ£€æŸ¥æ€»ä»“ä½
        total = sum(portfolio.values())
        if total > self.config['risk']['max_total_position']:
            self.logger.warning(
                f"æ€»ä»“ä½è¿‡é«˜: {total:.2%} > "
                f"{self.config['risk']['max_total_position']:.2%}"
            )
            return False
        
        return True
    
    def apply_stop_loss(self, symbol: str, 
                        entry_price: float,
                        current_price: float) -> bool:
        """
        åº”ç”¨æ­¢æŸ
        
        Args:
            symbol: è‚¡ç¥¨ä»£ç 
            entry_price: å¼€ä»“ä»·æ ¼
            current_price: å½“å‰ä»·æ ¼
            
        Returns:
            æ˜¯å¦è§¦å‘æ­¢æŸ
        """
        loss = (current_price - entry_price) / entry_price
        
        if loss < -self.config['risk']['stop_loss']:
            self.logger.warning(
                f"è§¦å‘æ­¢æŸ: {symbol}, äºæŸ={loss:.2%}"
            )
            return True
        
        return False

# ==================== äº¤æ˜“æ‰§è¡Œæ¨¡å— ====================
class TradeExecutor:
    """äº¤æ˜“æ‰§è¡Œå™¨"""
    
    def __init__(self, config: dict):
        """
        åˆå§‹åŒ–äº¤æ˜“æ‰§è¡Œå™¨
        
        Args:
            config: é…ç½®å­—å…¸
        """
        self.config = config
        self.logger = logging.getLogger('TradeExecutor')
        self.trades = []
    
    def execute(self, portfolio: Dict[str, float],
                current_prices: Dict[str, float]) -> List[dict]:
        """
        æ‰§è¡Œäº¤æ˜“
        
        Args:
            portfolio: ç›®æ ‡æŠ•èµ„ç»„åˆ
            current_prices: å½“å‰ä»·æ ¼
            
        Returns:
            äº¤æ˜“åˆ—è¡¨
        """
        trades = []
        
        for symbol, target_weight in portfolio.items():
            if target_weight == 0:
                continue
            
            # è®¡ç®—äº¤æ˜“æ•°é‡
            target_value = 1_000_000 * target_weight  # å‡è®¾æ€»èµ„äº§100ä¸‡
            price = current_prices[symbol]
            quantity = int(target_value / price)
            
            # è®¡ç®—æˆæœ¬
            trade_value = quantity * price
            commission = trade_value * self.config['trading']['commission']
            slippage = trade_value * self.config['trading']['slippage']
            total_cost = commission + slippage
            
            trade = {
                'symbol': symbol,
                'action': 'BUY',
                'quantity': quantity,
                'price': price,
                'value': trade_value,
                'commission': commission,
                'slippage': slippage,
                'total_cost': total_cost
            }
            
            trades.append(trade)
            self.trades.append(trade)
            
            self.logger.info(
                f"æ‰§è¡Œäº¤æ˜“: {symbol} ä¹°å…¥{quantity}è‚¡ "
                f"@{price:.2f}, æˆæœ¬={total_cost:.2f}"
            )
        
        return trades

# ==================== ç»©æ•ˆè¯„ä¼°æ¨¡å— ====================
class PerformanceAnalyzer:
    """ç»©æ•ˆåˆ†æå™¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–ç»©æ•ˆåˆ†æå™¨"""
        self.logger = logging.getLogger('PerformanceAnalyzer')
    
    def analyze(self, returns: pd.Series) -> dict:
        """
        åˆ†æç»©æ•ˆ
        
        Args:
            returns: æ”¶ç›Šåºåˆ—
            
        Returns:
            ç»©æ•ˆæŒ‡æ ‡
        """
        # ç´¯è®¡æ”¶ç›Š
        cumulative = (1 + returns).cumprod()
        total_return = cumulative.iloc[-1] - 1
        
        # å¹´åŒ–æ”¶ç›Š
        n_days = len(returns)
        annual_return = (1 + total_return) ** (252 / n_days) - 1
        
        # æ³¢åŠ¨ç‡
        volatility = returns.std() * np.sqrt(252)
        
        # å¤æ™®æ¯”ç‡
        risk_free_rate = 0.03
        sharpe_ratio = (annual_return - risk_free_rate) / volatility
        
        # æœ€å¤§å›æ’¤
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        max_drawdown = drawdown.min()
        
        metrics = {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }
        
        self.logger.info(
            f"ç»©æ•ˆåˆ†æ: æ”¶ç›Š={total_return:.2%}, "
            f"å¤æ™®={sharpe_ratio:.2f}, "
            f"å›æ’¤={max_drawdown:.2%}"
        )
        
        return metrics

# ==================== ä¸»ç³»ç»Ÿ ====================
class QuantTradingSystem:
    """é‡åŒ–äº¤æ˜“ä¸»ç³»ç»Ÿ"""
    
    def __init__(self, config: dict):
        """
        åˆå§‹åŒ–ç³»ç»Ÿ
        
        Args:
            config: é…ç½®å­—å…¸
        """
        self.config = config
        
        # åˆå§‹åŒ–æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # åˆå§‹åŒ–æ¨¡å—
        self.data_manager = DataManager(config)
        self.feature_engineer = FeatureEngineer()
        self.model_manager = ModelManager()
        self.risk_controller = RiskController(config)
        self.trade_executor = TradeExecutor(config)
        self.performance_analyzer = PerformanceAnalyzer()
        
        self.logger = logging.getLogger('QuantTradingSystem')
    
    def run(self):
        """è¿è¡Œç³»ç»Ÿ"""
        self.logger.info("ğŸš€ å¯åŠ¨é‡åŒ–äº¤æ˜“ç³»ç»Ÿ")
        
        # 1. è·å–æ•°æ®
        data = self.data_manager.fetch_data()
        
        # 2. ç‰¹å¾å·¥ç¨‹
        features = self.feature_engineer.extract_features(data)
        
        # 3. å‡†å¤‡æ ‡ç­¾ï¼ˆæœªæ¥æ”¶ç›Šï¼‰
        features['future_return'] = features.groupby(level='symbol')['returns'].shift(-1)
        features = features.dropna()
        
        # 4. è®­ç»ƒæ¨¡å‹
        self.model_manager.train(features)
        
        # 5. é¢„æµ‹
        latest_features = features.loc[features.index.get_level_values('date').max()]
        predictions = self.model_manager.predict(latest_features)
        
        # 6. æ„å»ºæŠ•èµ„ç»„åˆ
        portfolio = self._build_portfolio(predictions, latest_features)
        
        # 7. é£é™©æ§åˆ¶
        if not self.risk_controller.check_position_limit(portfolio):
            self.logger.error("é£é™©æ§åˆ¶å¤±è´¥")
            return
        
        # 8. æ‰§è¡Œäº¤æ˜“
        current_prices = latest_features['close'].to_dict()
        trades = self.trade_executor.execute(portfolio, current_prices)
        
        # 9. ç»©æ•ˆè¯„ä¼°
        returns = features['returns']
        metrics = self.performance_analyzer.analyze(returns)
        
        # 10. æ‰“å°ç»“æœ
        self._print_results(portfolio, trades, metrics)
        
        self.logger.info("âœ… ç³»ç»Ÿè¿è¡Œå®Œæˆ")
    
    def _build_portfolio(self, predictions: np.ndarray,
                         features: pd.DataFrame) -> Dict[str, float]:
        """
        æ„å»ºæŠ•èµ„ç»„åˆ
        
        Args:
            predictions: é¢„æµ‹åˆ†æ•°
            features: ç‰¹å¾æ•°æ®
            
        Returns:
            æŠ•èµ„ç»„åˆæƒé‡
        """
        # æ ¹æ®é¢„æµ‹åˆ†é…æƒé‡
        symbols = features.index.get_level_values('symbol')
        portfolio = dict(zip(symbols, predictions))
        
        # å½’ä¸€åŒ–
        total = sum(portfolio.values())
        portfolio = {k: v/total for k, v in portfolio.items()}
        
        # åªä¿ç•™æ­£é¢„æµ‹
        portfolio = {k: v for k, v in portfolio.items() if v > 0}
        
        # é‡æ–°å½’ä¸€åŒ–
        total = sum(portfolio.values())
        if total > 0:
            portfolio = {k: v/total for k, v in portfolio.items()}
        
        return portfolio
    
    def _print_results(self, portfolio: Dict[str, float],
                       trades: List[dict],
                       metrics: dict):
        """
        æ‰“å°ç»“æœ
        
        Args:
            portfolio: æŠ•èµ„ç»„åˆ
            trades: äº¤æ˜“
            metrics: ç»©æ•ˆæŒ‡æ ‡
        """
        print("\n" + "="*60)
        print("ğŸ“Š è¿è¡Œç»“æœ")
        print("="*60)
        
        print("\næŠ•èµ„ç»„åˆ:")
        for symbol, weight in sorted(portfolio.items(), 
                                     key=lambda x: x[1], 
                                     reverse=True):
            print(f"  {symbol}: {weight:.2%}")
        
        print(f"\näº¤æ˜“æ•°é‡: {len(trades)}")
        
        print("\nç»©æ•ˆæŒ‡æ ‡:")
        print(f"  æ€»æ”¶ç›Šç‡: {metrics['total_return']:.2%}")
        print(f"  å¹´åŒ–æ”¶ç›Šç‡: {metrics['annual_return']:.2%}")
        print(f"  å¹´åŒ–æ³¢åŠ¨ç‡: {metrics['volatility']:.2%}")
        print(f"  å¤æ™®æ¯”ç‡: {metrics['sharpe_ratio']:.2f}")
        print(f"  æœ€å¤§å›æ’¤: {metrics['max_drawdown']:.2%}")
        
        print("\n" + "="*60)

# ==================== è¿è¡Œç¤ºä¾‹ ====================
if __name__ == '__main__':
    # åˆ›å»ºç³»ç»Ÿ
    system = QuantTradingSystem(CONFIG)
    
    # è¿è¡Œç³»ç»Ÿ
    system.run()
```

---

## ğŸ¯ æ¡ˆä¾‹2: å¤šç­–ç•¥å¹¶è¡Œå›æµ‹

### èƒŒæ™¯

åŒæ—¶è¿è¡Œå¤šä¸ªç­–ç•¥ï¼Œå¯¹æ¯”è¡¨ç°ã€‚

```python
import concurrent.futures
from typing import Callable, Dict

class MultiStrategyBacktester:
    """å¤šç­–ç•¥å›æµ‹å™¨"""
    
    def __init__(self, strategies: Dict[str, Callable]):
        """
        åˆå§‹åŒ–å¤šç­–ç•¥å›æµ‹å™¨
        
        Args:
            strategies: ç­–ç•¥å­—å…¸ {åç§°: ç­–ç•¥å‡½æ•°}
        """
        self.strategies = strategies
        self.results = {}
    
    def run(self, data: pd.DataFrame, 
            n_workers: int = 4):
        """
        å¹¶è¡Œè¿è¡Œæ‰€æœ‰ç­–ç•¥
        
        Args:
            data: å†å²æ•°æ®
            n_workers: å·¥ä½œçº¿ç¨‹æ•°
        """
        print(f"\n{'='*60}")
        print(f"ğŸš€ å¼€å§‹å¤šç­–ç•¥å¹¶è¡Œå›æµ‹ ({n_workers} ä¸ªçº¿ç¨‹)")
        print(f"{'='*60}\n")
        
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=n_workers
        ) as executor:
            # æäº¤æ‰€æœ‰ç­–ç•¥
            future_to_strategy = {
                executor.submit(strategy_func, data): name
                for name, strategy_func in self.strategies.items()
            }
            
            # æ”¶é›†ç»“æœ
            for future in concurrent.futures.as_completed(
                future_to_strategy
            ):
                strategy_name = future_to_strategy[future]
                
                try:
                    result = future.result()
                    self.results[strategy_name] = result
                    
                    print(f"âœ… {strategy_name}: "
                          f"æ”¶ç›Š={result['total_return']:.2%}, "
                          f"å¤æ™®={result['sharpe_ratio']:.2f}")
                
                except Exception as e:
                    print(f"âŒ {strategy_name} å¤±è´¥: {e}")
        
        self._print_comparison()
    
    def _print_comparison(self):
        """æ‰“å°å¯¹æ¯”ç»“æœ"""
        print(f"\n{'='*60}")
        print("ğŸ“Š ç­–ç•¥å¯¹æ¯”")
        print(f"{'='*60}\n")
        
        # åˆ›å»ºå¯¹æ¯”è¡¨
        comparison = pd.DataFrame(self.results).T
        
        # æ’åº
        comparison = comparison.sort_values('sharpe_ratio', 
                                          ascending=False)
        
        print(comparison.round(4))
        
        # æ‰¾å‡ºæœ€ä½³ç­–ç•¥
        best_strategy = comparison.index[0]
        best_sharpe = comparison['sharpe_ratio'][best_strategy]
        
        print(f"\nğŸ† æœ€ä½³ç­–ç•¥: {best_strategy}")
        print(f"   å¤æ™®æ¯”ç‡: {best_sharpe:.2f}")

# ç¤ºä¾‹ç­–ç•¥
def strategy_momentum(data):
    """åŠ¨é‡ç­–ç•¥"""
    # ç®€å•å®ç°
    returns = data['returns'].mean()
    return {
        'total_return': returns * len(data),
        'sharpe_ratio': returns / data['returns'].std() * np.sqrt(252)
    }

def strategy_mean_reversion(data):
    """å‡å€¼å›å½’ç­–ç•¥"""
    # ç®€å•å®ç°
    returns = data['returns'].mean() * 0.8
    return {
        'total_return': returns * len(data),
        'sharpe_ratio': returns / data['returns'].std() * np.sqrt(252)
    }

def strategy_value(data):
    """ä»·å€¼ç­–ç•¥"""
    # ç®€å•å®ç°
    returns = data['returns'].mean() * 1.2
    return {
        'total_return': returns * len(data),
        'sharpe_ratio': returns / data['returns'].std() * np.sqrt(252)
    }

# è¿è¡Œç¤ºä¾‹
strategies = {
    'åŠ¨é‡ç­–ç•¥': strategy_momentum,
    'å‡å€¼å›å½’ç­–ç•¥': strategy_mean_reversion,
    'ä»·å€¼ç­–ç•¥': strategy_value
}

backtester = MultiStrategyBacktester(strategies)
backtester.run(data, n_workers=4)
```

---

## âš¡ æ¡ˆä¾‹3: ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–

### èƒŒæ™¯

ç³»ç»Ÿè¿è¡Œæ…¢ï¼Œéœ€è¦ä¼˜åŒ–æ€§èƒ½ã€‚

```python
import time
import cProfile
import pstats
from io import StringIO

class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–æ€§èƒ½ä¼˜åŒ–å™¨"""
        self.baseline_time = None
        self.optimized_time = None
    
    def profile_function(self, func, *args, **kwargs):
        """
        æ€§èƒ½åˆ†æå‡½æ•°
        
        Args:
            func: è¦åˆ†æçš„å‡½æ•°
            args: ä½ç½®å‚æ•°
            kwargs: å…³é”®å­—å‚æ•°
        """
        # åˆ›å»ºprofiler
        pr = cProfile.Profile()
        pr.enable()
        
        # æ‰§è¡Œå‡½æ•°
        result = func(*args, **kwargs)
        
        pr.disable()
        
        # æ‰“å°ç»“æœ
        s = StringIO()
        ps = pstats.Stats(pr, stream=s).sort_stats('cumulative')
        ps.print_stats(20)  # æ‰“å°å‰20ä¸ªæœ€è€—æ—¶çš„å‡½æ•°
        
        print(s.getvalue())
        
        return result
    
    def compare_performance(self, baseline_func, 
                          optimized_func,
                          *args, **kwargs):
        """
        å¯¹æ¯”åŸºå‡†å’Œä¼˜åŒ–åçš„æ€§èƒ½
        
        Args:
            baseline_func: åŸºå‡†å‡½æ•°
            optimized_func: ä¼˜åŒ–åçš„å‡½æ•°
            args: ä½ç½®å‚æ•°
            kwargs: å…³é”®å­—å‚æ•°
        """
        # æµ‹è¯•åŸºå‡†
        start = time.time()
        baseline_result = baseline_func(*args, **kwargs)
        self.baseline_time = time.time() - start
        
        # æµ‹è¯•ä¼˜åŒ–å
        start = time.time()
        optimized_result = optimized_func(*args, **kwargs)
        self.optimized_time = time.time() - start
        
        # æ‰“å°å¯¹æ¯”
        speedup = self.baseline_time / self.optimized_time
        
        print(f"\n{'='*60}")
        print("âš¡ æ€§èƒ½å¯¹æ¯”")
        print(f"{'='*60}\n")
        
        print(f"åŸºå‡†å‡½æ•°: {self.baseline_time:.4f}ç§’")
        print(f"ä¼˜åŒ–å‡½æ•°: {self.optimized_time:.4f}ç§’")
        print(f"åŠ é€Ÿæ¯”: {speedup:.2f}x")
        
        return baseline_result, optimized_result

# ç¤ºä¾‹ï¼šä¼˜åŒ–ç‰¹å¾è®¡ç®—
def calculate_features_baseline(data):
    """åŸºå‡†ç‰¹å¾è®¡ç®—ï¼ˆæ…¢ï¼‰"""
    features = data.copy()
    
    # é€è¡Œè®¡ç®—ï¼ˆæ…¢ï¼‰
    for i in range(len(features)):
        features.loc[i, 'ma5'] = features.loc[:i, 'close'].mean()
        features.loc[i, 'ma20'] = features.loc[:i, 'close'].mean()
        features.loc[i, 'volatility'] = features.loc[:i, 'close'].std()
    
    return features

def calculate_features_optimized(data):
    """ä¼˜åŒ–åçš„ç‰¹å¾è®¡ç®—ï¼ˆå¿«ï¼‰"""
    features = data.copy()
    
    # å‘é‡åŒ–è®¡ç®—ï¼ˆå¿«ï¼‰
    features['ma5'] = features['close'].rolling(5).mean()
    features['ma20'] = features['close'].rolling(20).mean()
    features['volatility'] = features['close'].rolling(20).std()
    
    return features

# è¿è¡Œç¤ºä¾‹
optimizer = PerformanceOptimizer()
optimizer.compare_performance(
    calculate_features_baseline,
    calculate_features_optimized,
    data
)
```

---

## ğŸ“Š æ¡ˆä¾‹4: é£é™©äº‹ä»¶åº”å¯¹

### èƒŒæ™¯

å¸‚åœºå‰§çƒˆæ³¢åŠ¨ï¼Œéœ€è¦åº”å¯¹é£é™©äº‹ä»¶ã€‚

```python
class RiskEventManager:
    """é£é™©ç®¡ç†å™¨"""
    
    def __init__(self, config: dict):
        """
        åˆå§‹åŒ–é£é™©ç®¡ç†å™¨
        
        Args:
            config: é…ç½®å­—å…¸
        """
        self.config = config
        self.volatility_threshold = 0.05  # æ—¥æ³¢åŠ¨ç‡é˜ˆå€¼
        self.drawdown_threshold = 0.10     # å›æ’¤é˜ˆå€¼
        self.current_drawdown = 0.0
    
    def monitor(self, market_data: pd.DataFrame):
        """
        ç›‘æ§å¸‚åœº
        
        Args:
            market_data: å¸‚åœºæ•°æ®
        """
        # 1. è®¡ç®—å¸‚åœºæ³¢åŠ¨ç‡
        market_returns = market_data['returns'].mean()
        market_volatility = abs(market_returns)
        
        # 2. æ£€æŸ¥æ³¢åŠ¨ç‡å¼‚å¸¸
        if market_volatility > self.volatility_threshold:
            print(f"\nğŸš¨ æ³¢åŠ¨ç‡å¼‚å¸¸: {market_volatility:.2%}")
            self._handle_high_volatility()
        
        # 3. è®¡ç®—å›æ’¤
        portfolio_value = market_data['close'].mean()
        running_max = portfolio_value.expanding().max()
        drawdown = (portfolio_value - running_max) / running_max
        
        self.current_drawdown = drawdown.iloc[-1]
        
        # 4. æ£€æŸ¥å›æ’¤å¼‚å¸¸
        if self.current_drawdown < -self.drawdown_threshold:
            print(f"\nğŸš¨ å›æ’¤å¼‚å¸¸: {self.current_drawdown:.2%}")
            self._handle_large_drawdown()
    
    def _handle_high_volatility(self):
        """å¤„ç†é«˜æ³¢åŠ¨"""
        print("  åº”å¯¹æªæ–½:")
        print("  1. é™ä½ä»“ä½")
        print("  2. å¢åŠ æ­¢æŸ")
        print("  3. æš‚åœæ–°å¼€ä»“")
        
        # å®é™…åº”ç”¨ä¸­æ‰§è¡Œè¿™äº›æªæ–½
    
    def _handle_large_drawdown(self):
        """å¤„ç†å¤§å›æ’¤"""
        print("  åº”å¯¹æªæ–½:")
        print("  1. å®¡æŸ¥æŒä»“")
        print("  2. æ£€æŸ¥æ¨¡å‹æœ‰æ•ˆæ€§")
        print("  3. è€ƒè™‘å¹³ä»“æ­¢æŸ")
        
        # å®é™…åº”ç”¨ä¸­æ‰§è¡Œè¿™äº›æªæ–½
```

---

## ğŸ“ æœ¬èŠ‚å°ç»“

**æ ¸å¿ƒè¦ç‚¹**ï¼š

1. âœ… å®Œæ•´ç³»ç»Ÿéœ€è¦å¤šä¸ªæ¨¡å—ååŒ
2. âœ… å¤šç­–ç•¥å¹¶è¡Œå›æµ‹æå‡æ•ˆç‡
3. âœ… æ€§èƒ½ä¼˜åŒ–æ˜¯ç³»ç»Ÿå·¥ç¨‹
4. âœ… é£é™©äº‹ä»¶éœ€è¦é¢„æ¡ˆå’Œåº”å¯¹
5. âœ… å®æˆ˜æ˜¯æœ€å¥½çš„è€å¸ˆ

**Week 6 å­¦ä¹ å›é¡¾**ï¼š

```python
week6_summary = {
    "æ»šåŠ¨é‡è®­ç»ƒ": "æ¨¡å‹æŒç»­è¿›åŒ–çš„ç§˜æŠ€",
    "é£é™©æ§åˆ¶": "å®ˆæŠ¤æŠ•èµ„çš„æŠ¤ç›¾",
    "é›†æˆç­–ç•¥": "ç»„åˆæ‹³çš„è‰ºæœ¯",
    "ç³»ç»Ÿæ¶æ„": "æ‰“é€ é‡åŒ–å ¡å’",
    "æ€§èƒ½ç›‘æ§": "æ´å¯Ÿä¸€åˆ‡çš„çœ¼ç›",
    "å¼‚å¸¸å¤„ç†": "ä¸´å±ä¸ä¹±çš„æ™ºæ…§",
    "æœ€ä½³å®è·µ": "ç»éªŒçš„ç»“æ™¶",
    "å¸¸è§é—®é¢˜": "é¿å‘æŒ‡å—",
    "å®æˆ˜æ¡ˆä¾‹": "ç†è®ºè”ç³»å®é™…"
}
```

---

**ğŸ‰ æ­å–œä½ å®ŒæˆWeek 6çš„å­¦ä¹ ï¼**

ä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… æ»šåŠ¨é‡è®­ç»ƒçš„åŸç†å’Œå®ç°
- âœ… é£é™©æ§åˆ¶çš„å¤šç§æ–¹æ³•
- âœ… é›†æˆç­–ç•¥çš„é€‰æ‹©å’Œåº”ç”¨
- âœ… ç³»ç»Ÿæ¶æ„çš„è®¾è®¡åŸåˆ™
- âœ… æ€§èƒ½ç›‘æ§å’Œè¯„ä¼°
- âœ… å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
- âœ… å¼€å‘æœ€ä½³å®è·µ
- âœ… å¸¸è§é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
- âœ… çœŸå®æ¡ˆä¾‹çš„å®æˆ˜ç»éªŒ

**ä¸‹ä¸€æ­¥å»ºè®®**ï¼š

1. ğŸš€ åŠ¨æ‰‹å®ç°ä¸€ä¸ªå®Œæ•´çš„é‡åŒ–ç³»ç»Ÿ
2. ğŸ“Š å›æµ‹ä¸åŒå‚æ•°é…ç½®
3. ğŸ›¡ï¸ å®Œå–„é£é™©æ§åˆ¶æœºåˆ¶
4. âš¡ æŒç»­ä¼˜åŒ–æ€§èƒ½
5. ğŸ“– æ·±å…¥å­¦ä¹ æ›´é«˜çº§çš„ä¸»é¢˜

**ç¥ä½ åœ¨é‡åŒ–äº¤æ˜“çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼** ğŸ’ªğŸš€
