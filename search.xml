<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Deliver区块分发</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Deliver%E5%8C%BA%E5%9D%97%E5%88%86%E5%8F%91-5/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Deliver区块分发</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0uq99cf2j31hc0u0k1k.jpg" alt="00a1ba6f145942b3fdb1a7b63964967e"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Orderer</code>排序服务器提供了区块分发服务接口，接收客户端提交的区块请求消息（<code>Envelope</code>类型，通道头部类型是<code>DELIVER_SEEK_INFO</code>、<code>CONFIG_UPDATE</code>等），根据该消息封装的区块搜索信息对象（<code>SeekInfo</code>类型），包括查找最旧区块SeekOldest类型、查找最新区块<code>SeekNewest</code>类型、查找指定位置区块<code>SeekSpecified</code>类型等，构造对应请求范围的范围查询结果迭代器，读取<code>Orderer</code>节点指定通道账本上的区块数据，同时，建立消息处理循环，基于该结果迭代器依次读取请求的区块数据结果，<strong>发送给组织的Leader主节点等请求节点。</strong></p>
<p><code>Orderer</code>节点启动时在本地<code>gRPC</code>服务器上注册了<code>Orderer</code>排序服务器，并创建了Deliver服务处理句柄。当客户端发起<code>Deliver</code>服务请求时，<code>Orderer</code>排序服务器就调用<code>Deliver()</code>方法处理消息请求。</p>
<h2 id="Diliver消息服务处理"><a href="#Diliver消息服务处理" class="headerlink" title="Diliver消息服务处理"></a>Diliver消息服务处理</h2><p>入口在<code>orderer/common/server/server.go/Deliver()</code>方法中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Deliver(srv ab.AtomicBroadcast_DeliverServer) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	policyChecker := <span class="function"><span class="keyword">func</span><span class="params">(env *cb.Envelope, channelID <span class="type">string</span>)</span></span> <span class="type">error</span> &#123; <span class="comment">// 定义策略检查器</span></span><br><span class="line">		chain, ok := s.GetChain(channelID) <span class="comment">// 获取指定通道的链支持对象</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;channel %s not found&quot;</span>, channelID)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建消息过滤器</span></span><br><span class="line">		sf := msgprocessor.NewSigFilter(policies.ChannelReaders, chain)</span><br><span class="line">		<span class="keyword">return</span> sf.Apply(env) <span class="comment">// 过滤消息</span></span><br><span class="line">	&#125;</span><br><span class="line">	server := &amp;deliverMsgTracer&#123;</span><br><span class="line">		DeliverSupport: &amp;deliverHandlerSupport&#123;AtomicBroadcast_DeliverServer: srv&#125;,</span><br><span class="line">		msgTracer: msgTracer&#123;</span><br><span class="line">			debug:    s.debug,</span><br><span class="line">			function: <span class="string">&quot;Deliver&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Deliver服务消息处理</span></span><br><span class="line">	<span class="keyword">return</span> s.dh.Handle(deliver.NewDeliverServer(server, policyChecker, s.sendProducer(srv)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概做了以下几件事：</p>
<ul>
<li>定义策略检查器：用于检查接收的区块请求消息必须满足指定通道上的访问控制权限策略的要求</li>
<li>获取指定通道的链支持对象</li>
<li>创建消息过滤器，过滤消息</li>
<li>Deliver服务消息处理区块请求</li>
</ul>
<p>我们来看是如何处理的，进入到<code>s.dh.Handle</code>:  </p>
<blockquote>
<p>&#x2F;common&#x2F;deliver&#x2F;deliver.go&#x2F;Handle</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *deliverHandler)</span></span> Handle(srv *DeliverServer) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 等待消息请求并进行处理</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		envelope, err := srv.Recv() <span class="comment">// 等待接收客户端发送的区块消息请求</span></span><br><span class="line">	...</span><br><span class="line">		<span class="comment">// 从Orderer节点本地指定通道的区块账本中获取指定区块，并向客户端发送请求</span></span><br><span class="line">		<span class="keyword">if</span> err := ds.deliverBlocks(srv, envelope); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不言而喻，直接进入到<code>deliverBlocks</code>,这部分的内容是最核心的，逐步分析如下：</p>
<p>①：<em>解析PayLoad,检查header和ChannelHeader的合法性</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">payload, err := utils.UnmarshalPayload(envelope.Payload) <span class="comment">// 解析消息负载</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> payload.Header == <span class="literal">nil</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 解析通道头部</span></span><br><span class="line">	chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br><span class="line">err = ds.validateChannelHeader(srv, chdr) <span class="comment">// 验证通道头部合法性</span></span><br></pre></td></tr></table></figure>

<p>②：<em>从chains字典中获取指定通道（chainID）的链支持对象chain，并检查该对象是否存在错误信息</em> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chain, ok := ds.sm.GetChain(chdr.ChannelId) <span class="comment">// 获取指定通道的链支持对象</span></span><br></pre></td></tr></table></figure>

<p>③：<em>创建访问控制对象,并</em>检查消息签名是否符合指定的通道读权限策略**</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">accessControl, err := newSessionAC(chain, envelope, srv.PolicyChecker, chdr.ChannelId, crypto.ExpiresAt)</span><br><span class="line">...</span><br><span class="line">err := accessControl.evaluate()</span><br></pre></td></tr></table></figure>

<p>④：<em>解析区块搜索信息SeekInfo结构对象</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seekInfo := &amp;ab.SeekInfo&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = proto.Unmarshal(payload.Data, seekInfo); err != <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：<em>检查起始位置与结束位置的合法性</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seekInfo.Start == <span class="literal">nil</span> || seekInfo.Stop == <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：<em>创建区块账本迭代器并获取起始区块号，同时设置起始位置</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cursor, number := chain.Reader().Iterator(seekInfo.Start)</span><br></pre></td></tr></table></figure>

<p><code>Iterator</code>根据<code>startPosition.Type</code>起始位置对象的类型计算起始区块号<code>startingBlockNumbe</code>,类型如下：</p>
<ul>
<li><p>SeekPosition_Oldest：搜索最旧的区块，将起始区块号<code>startingBlockNumber</code>设置为 0； </p>
</li>
<li><p>SeekPosition_Newest：搜索最新的区块，将起始区块号<code>startingBlockNumber</code>设置为当前通道账本的最新区块号<code>info.Height-1</code>，即账本高度减1； </p>
</li>
<li><p>SeekPosition_Specified：搜索指定位置的区块，将起始区块号<code>startingBlockNumber</code>设置为指定起始位置的区块号<code>start.Specified.Number</code>。</p>
</li>
</ul>
<p><code>Iterator</code> 方法的大致功能如下： <code>common/ledger/blockledger/file/impl.go/Iterator</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl *FileLedger)</span></span> Iterator(startPosition *ab.SeekPosition) (blockledger.Iterator, <span class="type">uint64</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> startingBlockNumber <span class="type">uint64</span></span><br><span class="line">	<span class="keyword">switch</span> start := startPosition.Type.(<span class="keyword">type</span>) &#123; <span class="comment">// 分析起始位置类型</span></span><br><span class="line">	<span class="keyword">case</span> *ab.SeekPosition_Oldest: <span class="comment">// 搜索最旧区块，区块号为0</span></span><br><span class="line">		startingBlockNumber = <span class="number">0</span></span><br><span class="line">	<span class="keyword">case</span> *ab.SeekPosition_Newest: <span class="comment">// 搜索最新区块</span></span><br><span class="line">		info, err := fl.blockStore.GetBlockchainInfo() <span class="comment">// 获取区块链信息</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		newestBlockNumber := info.Height - <span class="number">1</span> <span class="comment">// 最新区块号</span></span><br><span class="line">		startingBlockNumber = newestBlockNumber</span><br><span class="line">	<span class="keyword">case</span> *ab.SeekPosition_Specified: <span class="comment">// 搜索指定位置区块</span></span><br><span class="line">		startingBlockNumber = start.Specified.Number</span><br><span class="line">		height := fl.Height()</span><br><span class="line">		<span class="keyword">if</span> startingBlockNumber &gt; height &#123; <span class="comment">// 若超过高度，则报错</span></span><br><span class="line">			<span class="keyword">return</span> &amp;blockledger.NotFoundErrorIterator&#123;&#125;, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;blockledger.NotFoundErrorIterator&#123;&#125;, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构造区块迭代器</span></span><br><span class="line">	iterator, err := fl.blockStore.RetrieveBlocks(startingBlockNumber)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;blockledger.NotFoundErrorIterator&#123;&#125;, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构造账本区块迭代器</span></span><br><span class="line">	<span class="keyword">return</span> &amp;fileLedgerIterator&#123;ledger: fl, blockNumber: startingBlockNumber, commonIterator: iterator&#125;, startingBlockNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑦：循环读取区块数据，从本地区块账本中获取指定区块号范围内的区块数据，并依次顺序发送给请求客户端</p>
<p>7.1 未找到数据返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seekInfo.Behavior == ab.SeekInfo_FAIL_IF_NOT_READY &#123;</span><br><span class="line">			<span class="keyword">if</span> number &gt; chain.Reader().Height()<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> sendStatusReply(srv, cb.Status_NOT_FOUND)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>7.2 获取下一个数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block, status := nextBlock(cursor, erroredChan) <span class="comment">// 从本地账本获取下一个区块</span></span><br><span class="line"><span class="keyword">if</span> status != cb.Status_SUCCESS &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>7.3  再次检查是否满足访问控制策略要求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := accessControl.evaluate(); err != <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>7.4  发送区块数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := sendBlockReply(srv, block); err != <span class="literal">nil</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>7.5 <em>循环结束，发送成功状态</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := sendStatusReply(srv, cb.Status_SUCCESS);</span><br></pre></td></tr></table></figure>

<h2 id="Deliver服务客户端"><a href="#Deliver服务客户端" class="headerlink" title="Deliver服务客户端"></a>Deliver服务客户端</h2><p>以<code>Leader</code>主节点为例，分析<code>Deliver</code>服务客户端从<code>Orderer</code>节点请求获取区块的流程。</p>
<h3 id="初始化Deliver服务实例"><a href="#初始化Deliver服务实例" class="headerlink" title="初始化Deliver服务实例"></a>初始化Deliver服务实例</h3><p>入口：<code>gossip/service/gossip_service.go/InitializeChannel</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span></span> InitializeChannel(chainID <span class="type">string</span>, endpoints []<span class="type">string</span>, support Support) &#123;</span><br><span class="line">	...</span><br><span class="line">	g.chains[chainID] = state.NewGossipStateProvider(chainID, servicesAdapter, coordinator)</span><br><span class="line">	<span class="keyword">if</span> g.deliveryService[chainID] == <span class="literal">nil</span> &#123; <span class="comment">// 检查是否已经存在Deliver服务实例</span></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		g.deliveryService[chainID], err = g.deliveryFactory.Service(g, endpoints, g.mcs) <span class="comment">// 检查是否已经存在Deliver服务实例</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// peer.gossip.useLeaderElection与peer.gossip.orgLeader是互斥的两个配置参数，</span></span><br><span class="line">		<span class="comment">// 如果将两个都设置为true且没有被定义，则会引起Peer节点错误</span></span><br><span class="line">		<span class="comment">// 启用Leader主节点动态选举机制</span></span><br><span class="line">		leaderElection := viper.GetBool(<span class="string">&quot;peer.gossip.useLeaderElection&quot;</span>)</span><br><span class="line">		<span class="comment">// 静态设置为组织Leader主节点</span></span><br><span class="line">		isStaticOrgLeader := viper.GetBool(<span class="string">&quot;peer.gossip.orgLeader&quot;</span>)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> leaderElection &#123; <span class="comment">// 启用了动态Leader主节点选举机制</span></span><br><span class="line">			logger.Debug(<span class="string">&quot;Delivery uses dynamic leader election mechanism, channel&quot;</span>, chainID)</span><br><span class="line">			g.leaderElection[chainID] = g.newLeaderElectionComponent(chainID, g.onStatusChangeFactory(chainID, support.Committer))</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> isStaticOrgLeader &#123;</span><br><span class="line">			<span class="comment">// 若静态指定了Leader主节点，则连接 Orderer节点请求区块数据</span></span><br><span class="line">			<span class="comment">// 启动指定通道上的Deliver服务实例请求获取区块数据</span></span><br><span class="line">			g.deliveryService[chainID].StartDeliverForChannel(chainID, support.Committer, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;)</span><br><span class="line">		&#125; ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查是否已经存在<code>Deliver</code>实例，然后根据<code>Leader</code>主节点动态选举机制还是静态指定了<code>Leader</code>主节点分别进入不同的分支，如果是静态指定了<code>Leader</code>主节点，则连接 <code>Orderer</code>节点请求区块数据,启动指定通道上的<code>Deliver</code>服务实例请求获取区块数据。接下来关注启动<code>Deliver</code>服务实例。</p>
<h3 id="启动Deliver服务实例"><a href="#启动Deliver服务实例" class="headerlink" title="启动Deliver服务实例"></a>启动Deliver服务实例</h3><p>主要做了以下事：</p>
<p>①：<em>获取绑定指定通道的区块提供者</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, exist := d.blockProviders[chainID];</span><br></pre></td></tr></table></figure>

<p>②：<em>不存在区块提供者</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := d.newClient(chainID, ledgerInfo)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *deliverServiceImpl)</span></span> newClient(chainID <span class="type">string</span>, ledgerInfoProvider blocksprovider.LedgerInfo) *broadcastClient &#123;</span><br><span class="line">	requester := &amp;blocksRequester&#123; <span class="comment">//定义区块请求者blocksRequester结构对象</span></span><br><span class="line">		tls:     comm.TLSEnabled(),</span><br><span class="line">		chainID: chainID,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义broadcastSetup()方法</span></span><br><span class="line">	broadcastSetup := <span class="function"><span class="keyword">func</span><span class="params">(bd blocksprovider.BlocksDeliverer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> requester.RequestBlocks(ledgerInfoProvider) <span class="comment">// 请求区块数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建connProducer对象</span></span><br><span class="line">	connProd := comm.NewConnectionProducer(d.conf.ConnFactory(chainID), d.conf.Endpoints)</span><br><span class="line">	<span class="comment">//// 创建broadcastClient客户端</span></span><br><span class="line">	bClient := NewBroadcastClient(connProd, d.conf.ABCFactory, broadcastSetup, backoffPolicy)</span><br><span class="line">	requester.client = bClient <span class="comment">// 设置到区块请求者对象的客户端</span></span><br><span class="line">	<span class="keyword">return</span> bClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1 创建Deliver服务实例上的 broadcastClient客户端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := d.newClient(chainID, ledgerInfo)</span><br></pre></td></tr></table></figure>

<p>2.2 创建指定通道关联的区块提供者</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.blockProviders[chainID] = blocksprovider.NewBlocksProvider(chainID, client, d.conf.Gossip, d.conf.CryptoSvc)</span><br></pre></td></tr></table></figure>

<p>2.3 启动goroutine开始从Orderer节点请求获取区块，并发送到组织内其他Peer节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			d.blockProviders[chainID].DeliverBlocks() <span class="comment">// 请求获取区块数据</span></span><br><span class="line">			finalizer()</span><br><span class="line">		&#125;()</span><br></pre></td></tr></table></figure>

<p>接下来就是调用区块提供者对象的<code>DeliverBlocks()</code>方法，向<code>Orderer</code>节点发送消息请求的区块数据。</p>
<h3 id="请求获取区块数据"><a href="#请求获取区块数据" class="headerlink" title="请求获取区块数据"></a>请求获取区块数据</h3><p>入口在：<code>core/deliverservice/blocksprovider/blocksprovider.go/DeliverBlocks()</code>,具体分析如下：</p>
<p>①：接收消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg, err := b.client.Recv() </span><br></pre></td></tr></table></figure>

<p>② ：根据消息类型进行处理</p>
<p>大致有以下几种消息类型：</p>
<ul>
<li>DeliverResponse_Status:用于描述<code>Deliver</code>服务请求执行状态。</li>
<li>DeliverResponse_Block：包含请求获取的区块数据。</li>
</ul>
<p>2.1 DeliverResponse_Status分支</p>
<p>如果DeliverBlocks()方法接收到Status_SUCCESS状态，则说明本次区块请求处理成功，表示已经接收完毕区块请求消息指定范围内的区块数据。除此以外的其他状态消息都是非成功的执行状态消息，包括Status_BAD_REQUEST、Status_FORBIDDEN等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> t.Status == common.Status_SUCCESS &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> t.Status == common.Status_BAD_REQUEST || t.Status == common.Status_FORBIDDEN &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> t.Status == common.Status_BAD_REQUEST &#123;</span><br><span class="line">				b.client.Disconnect(<span class="literal">false</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				b.client.Disconnect(<span class="literal">true</span>)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 DeliverResponse_Block分支</p>
<p>2.2.1 <em>获取区块号</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seqNum := t.Block.Header.Number</span><br></pre></td></tr></table></figure>

<p>2.2.2<em>获取经过序列化的区块字节数组</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">marshaledBlock, err := proto.Marshal(t.Block)</span><br></pre></td></tr></table></figure>

<p>2.2.3<em>验证区块</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := b.mcs.VerifyBlock(gossipcommon.ChainID(b.chainID), seqNum, marshaledBlock);</span><br></pre></td></tr></table></figure>

<p>2.2.4<em>获取通道Peer节点数量</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numberOfPeers := <span class="built_in">len</span>(b.gossip.PeersOfChannel(gossipcommon.ChainID(b.chainID)))</span><br></pre></td></tr></table></figure>

<p>2.2.5<em>创建消息负载和Gossip消息</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">payload := createPayload(seqNum, marshaledBlock) </span><br><span class="line">gossipMsg := createGossipMsg(b.chainID, payload)</span><br></pre></td></tr></table></figure>

<p>2.2.6<em>添加消息负载到本地消息负载缓冲区，等待提交账本</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := b.gossip.AddPayload(b.chainID, payload)</span><br></pre></td></tr></table></figure>

<p>2.2.7<em>通过Gossip消息协议发送区块消息到组织内的其他节点</em></p>
<p>基于<code>Gossip</code>消息协议将<code>DataMsg</code>类型数据消息（只含有区块数据）分发到组织内的其他<code>Peer</code>节点上，并保存到该节点的消息存储器上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b.gossip.Gossip(gossipMsg)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> (文章图片代码资料)</p>
<p>微信公众号：区块链技术栈</p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Endorser节点背书服务</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Endorser%E8%8A%82%E7%82%B9%E8%83%8C%E4%B9%A6%E6%9C%8D%E5%8A%A1-7/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Endorser节点背书服务</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn2cdssqtrj30zk0m8dhn.jpg" alt="77613ebad5a9eb5ea42dbb3b323fdaf5"></p>
<h2 id="背书概述"><a href="#背书概述" class="headerlink" title="背书概述"></a>背书概述</h2><p>Endorser背书节点提供<code>ProcessProposal()</code>服务接口用于接收与处理签名提案消息的请求，启动用户链码容器，执行调用链码，并对模拟执行结果进行签名背书，。<code>Peer</code>节点启动时解析<code>core.yaml</code>文件中的<code>peer.handlers</code>配置项，并构造认证过滤器列表。如果存在合法类型的认证过滤器，则需要先经过所有认证过滤器调用<code>ProcessProposal</code>()方法进行验证过滤，例如检查身份证书是否过期，然后再提交给背书服务器的<code>serverEndorser.ProcessProposal</code>()方法进行处理。 方法功能如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span></span> ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//检查并检验签名提案消息的合法性</span></span><br><span class="line">	vr, err := e.preProcess(signedProp)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 创建交易模拟器与历史查询执行器</span></span><br><span class="line">	<span class="keyword">var</span> txsim ledger.TxSimulator</span><br><span class="line">	<span class="keyword">var</span> historyQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 创建交易模拟器对象</span></span><br><span class="line">		<span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 创建历史查询器对象</span></span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将历史查询执行器添加到context中的KV键值对</span></span><br><span class="line">		ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 模拟交易执行</span></span><br><span class="line">	cd, res, simulationResult, ccevent, err := e.simulateProposal(ctx, chainID, txid, signedProp, prop, hdrExt.ChaincodeId, txsim)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 检查交易模拟运行结果的响应消息</span></span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">			<span class="comment">// 创建背书失败的提案响应消息</span></span><br><span class="line">			pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> pResp, &amp;chaincodeError&#123;res.Status, res.Message&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用ESCC系统链码对模拟执行结果进行背书，并回复提案响应消息</span></span><br><span class="line">	<span class="keyword">var</span> pResp *pb.ProposalResponse</span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 签名背书</span></span><br><span class="line">		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pResp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> res.Status &gt;= shim.ERRORTHRESHOLD &#123; <span class="comment">// 检查响应消息是否存在错误</span></span><br><span class="line">				endorserLogger.Debugf(<span class="string">&quot;[%s][%s] endorseProposal() resulted in chaincode %s error for txid: %s&quot;</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, txid)</span><br><span class="line">				<span class="keyword">return</span> pResp, &amp;chaincodeError&#123;res.Status, res.Message&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pResp.Response.Payload = res.Payload <span class="comment">// 设置链码提案响应消息负载字节数组,含有链码调用返回值</span></span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<ol>
<li>调用<code>preProcess()</code>方法预处理签名提案消息，验证消息合法性</li>
<li>调用<code>simulateProposal()</code>方法启动链码容器并模拟执行提案，将结果读写集记录到模拟交易器中。</li>
<li>调用<code>endorseProposal()</code>方法对模拟执行结果进行签名背书，并返回提案响应消息。</li>
</ol>
<p>下面的内容将会紧紧围绕这几部分来进行分析。</p>
<h2 id="预处理签名提案消息"><a href="#预处理签名提案消息" class="headerlink" title="预处理签名提案消息"></a>预处理签名提案消息</h2><p>进入到<code>preProcess</code>函数：</p>
<p>①： <em>验证签名提案消息格式与签名的合法性</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br></pre></td></tr></table></figure>

<p>②:  <em>检查提案消息是否允许外部调用的系统链码</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析消息通道头部ChannelHeader结构</span></span><br><span class="line">	chdr, err := putils.UnmarshalChannelHeader(hdr.ChannelHeader)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//解析消息签名头部SignatureHeader结构</span></span><br><span class="line">	shdr, err := putils.GetSignatureHeader(hdr.SignatureHeader)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//如果是系统链码，则检查是否为允许从外部调用的系统链码：cscc、lscc或qscc</span></span><br><span class="line">	<span class="keyword">if</span> e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">&quot;Error: an attempt was made by %#v to invoke system chaincode %s&quot;</span>,</span><br><span class="line">			shdr.Creator, hdrExt.ChaincodeId.Name)</span><br><span class="line">		err = errors.Errorf(<span class="string">&quot;chaincode %s cannot be invoked through a proposal&quot;</span>, hdrExt.ChaincodeId.Name)</span><br><span class="line">		<span class="comment">//构造提案响应消息对象：状态码为500（错误）与错误信息</span></span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：<em>检查签名提案消息的唯一性以及是否满足指定通道的访问权限策略</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chainID := chdr.ChannelId <span class="comment">//获取通道标识号ChannelID，即链chainID</span></span><br><span class="line">	<span class="comment">//// 检查账本中交易ID的唯一性。注意ValidateProposalMessage()方法已经验证了交易号ID的合法性</span></span><br><span class="line">	txid := chdr.TxId</span><br><span class="line">	<span class="keyword">if</span> txid == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;invalid txID. It must be different from the empty string&quot;</span>)</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line">	endorserLogger.Debugf(<span class="string">&quot;[%s][%s] processing txid: %s&quot;</span>, chainID, shorttxid(txid), txid)</span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 根据交易ID从账本中获取指定的交易对象，检查账本中交易对象的唯一性，</span></span><br><span class="line">		<span class="comment">// 若找到该对象则说明重复发起了交易，此时应报错</span></span><br><span class="line">		<span class="keyword">if</span> _, err = e.s.GetTransactionByID(chainID, txid); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> vr, errors.Errorf(<span class="string">&quot;duplicate transaction found [%s]. Creator [%x]&quot;</span>, txid, shdr.Creator)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/// 检查是否为系统链码，确保是用户链码</span></span><br><span class="line">		<span class="keyword">if</span> !e.s.IsSysCC(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">			<span class="comment">//// 检查提案是否符合WRITER写通道权限策略</span></span><br><span class="line">			<span class="keyword">if</span> err = e.s.CheckACL(signedProp, chdr, shdr, hdrExt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">				<span class="keyword">return</span> vr, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上3个部分内容还需要进一步的细化，看接下来的分析。</p>
<h3 id="验证消息格式与签名合法性"><a href="#验证消息格式与签名合法性" class="headerlink" title="验证消息格式与签名合法性"></a>验证消息格式与签名合法性</h3><p>①：调用<code>validation.ValidateProposalMessage()</code>函数，以检查签名提案消息格式与签名的合法性，解析获取提案消息、消息头部及其扩展域。</p>
<p>1.1  校验header</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chdr, shdr, err := validateCommonHeader(hdr)</span><br></pre></td></tr></table></figure>

<p>校验header里面大概做了这几件事：</p>
<ul>
<li><p><code>validateChannelHeader(chdr</code>)函数检查通道头部<code>chdr</code>的合法性，其通道头部类型应该属于<code>ENDORSER_TRANSACTION</code>、<code>CONFIG_UPDATE</code>、<code>CONFIG</code>或<code>PEER_RESOURCE_UPDATE</code>，并且<code>Epoch</code>字段应该为0； </p>
</li>
<li><p><code>validateSignatureHeader(shdr)</code>函数检查签名头部<code>shdr</code>的合法性，随机数<code>Nonce</code>和消息 </p>
<p>签名者<code>Creator</code>不应该为<code>nil</code>，并且该对象字节数不为0</p>
</li>
</ul>
<p>1.2 检查消息签名的合法性</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br></pre></td></tr></table></figure>

<p>该方法先获取当前通道的身份反序列化组件<code>mspObj</code>，解析出该签名头部的签名者<code>creator</code>，并调用<code>creator.Validate()</code>方法，验证<code>creator</code>是否为MSP有效的X.509合法证书。然后，调用<code>creator.Verify()</code>方法获取哈希方法及消息摘要（哈希值），通过所属<code>MSP</code>组件的<code>BCCSP</code>加密安全组件调用<code>id.msp.bccsp.Verify()</code>方法，验证消息签名的真实性</p>
<p>1.3 验证提案消息头部中的交易ID是否计算正确</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = utils.CheckProposalTxID(</span><br><span class="line">		chdr.TxId,</span><br><span class="line">		shdr.Nonce,</span><br><span class="line">		shdr.Creator)</span><br></pre></td></tr></table></figure>

<p>重新计算消息随机数<code>Nonce</code>（防止重放攻击）与签名者<code>Creator</code>组合信息后的哈希值，并且与交易ID进行比较。如果两者匹配相同，则说明交易ID是正确的。</p>
<h3 id="检查是否为允许外部调用的系统链码"><a href="#检查是否为允许外部调用的系统链码" class="headerlink" title="检查是否为允许外部调用的系统链码"></a>检查是否为允许外部调用的系统链码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">&quot;Error: an attempt was made by %#v to invoke system chaincode %s&quot;</span>,</span><br><span class="line">			shdr.Creator, hdrExt.ChaincodeId.Name)</span><br><span class="line">		err = errors.Errorf(<span class="string">&quot;chaincode %s cannot be invoked through a proposal&quot;</span>, hdrExt.ChaincodeId.Name)</span><br><span class="line">		<span class="comment">//构造提案响应消息对象：状态码为500（错误）与错误信息</span></span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查签名提案消息的唯一性"><a href="#检查签名提案消息的唯一性" class="headerlink" title="检查签名提案消息的唯一性"></a>检查签名提案消息的唯一性</h3><p>preProcess()方法继续检查签名提案消息的唯一性，以防止重放攻击。该方法从提案消息通道头部提取链与交易ID，包括两种情况:</p>
<ul>
<li>如果链ID不是空字符串，则需要检查该交易ID的唯一性，确保之前没有提交过该交易到账本中。即根据交易ID从账本的区块文件以及区块索引数据库获取交易数据与交易验证码，并构造成已处理的交易对象 。如果获取交易数据成功且没有错误，则说明账本中已经保存了指定交易ID的交易数据。因此，当前提案消息属于重复提交，报错返回。否则，就说明该签名提案消息通过了消息唯一性的检查；</li>
<li>如果链ID是空字符串，则不需要检查签名提案消息的唯一性与验证通道访问权限策略，只需要通过<code>ValidateProposalMessage()</code>函数验证该提案消息的合法性即可。</li>
</ul>
<h3 id="检查是否满足通道的访问权限策略"><a href="#检查是否满足通道的访问权限策略" class="headerlink" title="检查是否满足通道的访问权限策略"></a>检查是否满足通道的访问权限策略</h3><p>首先调用<code>IsSysCC</code>函数，检查链码是否为系统链码。如果是用户链码，则调用 <code>CheckACL</code>方法，检查签名提案消息是否满足通道<code>PROPOSE</code>权限策略要求，以允许提交该消息到指定通道上继续进行处理。<code>CheckACL</code>方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *defaultACLProvider)</span></span> CheckACL(resName <span class="type">string</span>, channelID <span class="type">string</span>, idinfo <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">  policy := d.defaultPolicy(resName, <span class="literal">true</span>)</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">case</span> *pb.SignedProposal:</span><br><span class="line">		<span class="keyword">return</span> d.policyChecker.CheckPolicy(channelID, policy, idinfo.(*pb.SignedProposal))</span><br><span class="line">	<span class="keyword">case</span> *common.Envelope:</span><br><span class="line">		sd, err := idinfo.(*common.Envelope).AsSignedData()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d.policyChecker.CheckPolicyBySignedData(channelID, policy, sd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法先调用<code>defaultPolicy()</code>方法，从全局通道资源策略字典<code>cResourcePolicyMap</code>中获取指定策略名称resources.PROPOSE的默认策略。对于<code>SignedProposal</code>类型的签名提案消息，<code>CheckACL()</code>方法调用<code>d.policyChecker.CheckPolicy()</code>方法，检查该签名提案消息是否满足该通道上的<code>Writers</code>写权限策略要求。</p>
<h2 id="模拟执行提案"><a href="#模拟执行提案" class="headerlink" title="模拟执行提案"></a>模拟执行提案</h2><p>ProcessProposal()方法启动<strong>链码容器</strong>与<strong>初始化链码执行环境</strong>，模拟执行合法的签名提案消息，并将模拟执行结果记录在交易模拟器中。其中，对公有数据（包含公共数据与隐私数据哈希值）继续签名背书，并提交给<code>Orderer</code>节点请求排序出块，同时将隐私数据通过<code>Gossip</code>消息协议发送到组织内的其他授权节点上。核心函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span></span> simulateProposal(ctx context.Context, chainID <span class="type">string</span>, txid <span class="type">string</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, cid *pb.ChaincodeID, txsim ledger.TxSimulator) (resourcesconfig.ChaincodeDefinition, *pb.Response, []<span class="type">byte</span>, *pb.ChaincodeEvent, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 解析获取链码调用规范对象</span></span><br><span class="line">	cis, err := putils.GetChaincodeInvocationSpec(prop)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//1 检查是否为系统链码</span></span><br><span class="line">	<span class="keyword">if</span> !e.s.IsSysCC(cid.Name) &#123; <span class="comment">// 如果是调用用户链码，则需要保证该链码已经实例化了</span></span><br><span class="line">		<span class="comment">// === 用户链码，通过调用LSCC系统链码获取账本中保存的链码数据对象ChaincodeData结构</span></span><br><span class="line">		<span class="comment">// 如果链上有链码数据对象，则说明链码已经成功实例化</span></span><br><span class="line">		cdLedger, err = e.s.GetChaincodeDefinition(ctx, chainID, txid, signedProp, prop, cid.Name, txsim)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">&quot;make sure the chaincode %s has been successfully instantiated and try again&quot;</span>, cid.Name))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取已保存的链码版本</span></span><br><span class="line">		version = cdLedger.CCVersion()</span><br><span class="line">		<span class="comment">// 检查提案中的实例化策略与调用账本中的实例化策略是否匹配</span></span><br><span class="line">		err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// === 执行系统链码，如lscc等</span></span><br><span class="line">		version = util.GetSysCCVersion() <span class="comment">// 获取系统链码版本</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 2 启动链码容器调用链码</span></span><br><span class="line">	res, ccevent, err = e.callChaincode(ctx, chainID, version, txid, signedProp, prop, cis, cid, txsim)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">&quot;[%s][%s] failed to invoke chaincode %s, error: %+v&quot;</span>, chainID, shorttxid(txid), cid, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3 获取并处理交易模拟执行结果</span></span><br><span class="line">	<span class="keyword">if</span> txsim != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> simResult, err = txsim.GetTxSimulationResults(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> simResult.PvtSimulationResults != <span class="literal">nil</span> &#123; <span class="comment">// 检查模拟结果隐私数据的合法性</span></span><br><span class="line">			<span class="keyword">if</span> cid.Name == <span class="string">&quot;lscc&quot;</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> remove once we can store collection configuration outside of LSCC</span></span><br><span class="line">				<span class="comment">// 分发隐私数据</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;Private data is forbidden to be used in instantiate&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := e.distributePrivateData(chainID, txid, simResult.PvtSimulationResults); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 分发隐私数据</span></span><br><span class="line">		<span class="keyword">if</span> pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cdLedger, res, pubSimResBytes, ccevent, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="根据链码类型执行不同实例化策略"><a href="#根据链码类型执行不同实例化策略" class="headerlink" title="根据链码类型执行不同实例化策略"></a>根据链码类型执行不同实例化策略</h3><p>首先调用<code>GetChaincodeInvocationSpec</code>函数，从提案消息中解析提取出链码调用规范对象，然后调用<code>IsSysCC(cid.Name)</code>方法，依次匹配默认的系统链码名称，以判断当前链码类型是用户链码还是系统链码，分为用户链码和系统链码两种情况检查实例化策略。</p>
<p>①：<em>用户链码</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !e.s.IsSysCC(cid.Name) &#123; <span class="comment">// 如果是调用用户链码，则需要保证该链码已经实例化了</span></span><br><span class="line">		<span class="comment">// === 用户链码，通过调用LSCC系统链码获取账本中保存的链码数据对象ChaincodeData结构</span></span><br><span class="line">		<span class="comment">// 如果链上有链码数据对象，则说明链码已经成功实例化</span></span><br><span class="line">		cdLedger, err = e.s.GetChaincodeDefinition(ctx, chainID, txid, signedProp, prop, cid.Name, txsim)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">&quot;make sure the chaincode %s has been successfully instantiated and try again&quot;</span>, cid.Name))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取已保存的链码版本</span></span><br><span class="line">		version = cdLedger.CCVersion()</span><br><span class="line">		<span class="comment">// 检查提案中的实例化策略与调用账本中的实例化策略是否匹配</span></span><br><span class="line">		err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>②：系统链码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// === 执行系统链码，如lscc等</span></span><br><span class="line">		version = util.GetSysCCVersion() <span class="comment">// 获取系统链码版本</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="启动链码容器"><a href="#启动链码容器" class="headerlink" title="启动链码容器"></a>启动链码容器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, ccevent, err = e.callChaincode(ctx, chainID, version, txid, signedProp, prop, cis, cid, txsim)</span><br></pre></td></tr></table></figure>

<p>①：<em>设置context上下文对象中交易模拟器的KV键值对，其中，键为TXSimulatorKey，值为交易模拟器txsim</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> txsim != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctxt = context.WithValue(ctxt, chaincode.TXSimulatorKey, txsim)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>根据链码名称检查是否为系统链码</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scc := e.s.IsSysCC(cid.Name)</span><br></pre></td></tr></table></figure>

<p>③：<em>执行链码调用</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">res, ccevent, err = e.s.Execute(ctxt, chainID, cid.Name, version, txid, scc, signedProp, prop, cis)</span><br></pre></td></tr></table></figure>

<p>④：<em>检查调用链码名称lscc</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第1个参数为deploy部署或upgrade升级，第2个参数是链ID，第3个是链码部署规范对象</span></span><br><span class="line">	<span class="keyword">if</span> cid.Name == <span class="string">&quot;lscc&quot;</span> &amp;&amp; <span class="built_in">len</span>(cis.ChaincodeSpec.Input.Args) &gt;= <span class="number">3</span> &amp;&amp; (<span class="type">string</span>(cis.ChaincodeSpec.Input.Args[<span class="number">0</span>]) == <span class="string">&quot;deploy&quot;</span> || <span class="type">string</span>(cis.ChaincodeSpec.Input.Args[<span class="number">0</span>]) == <span class="string">&quot;upgrade&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> cds *pb.ChaincodeDeploymentSpec</span><br><span class="line">		<span class="comment">// 获取并验证链码部署规范</span></span><br><span class="line">		cds, err = putils.GetChaincodeDeploymentSpec(cis.ChaincodeSpec.Input.Args[<span class="number">2</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//this should not be a system chaincode</span></span><br><span class="line">		<span class="comment">// 若试图部署/升级系统链码，则报错</span></span><br><span class="line">		<span class="keyword">if</span> e.s.IsSysCC(cds.ChaincodeSpec.ChaincodeId.Name) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;attempting to deploy a system chaincode %s/%s&quot;</span>, cds.ChaincodeSpec.ChaincodeId.Name, chainID)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 执行部署/升级链码</span></span><br><span class="line">		_, _, err = e.s.Execute(ctxt, chainID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txid, <span class="literal">false</span>, signedProp, prop, cds)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>启动的真正过程正是在<code>e.s.Execute</code>中完成的,分析如下：</p>
<blockquote>
<p>&#x2F;core&#x2F;chaincode&#x2F;exectransaction.go&#x2F;Execute()</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Execute</span><span class="params">(ctxt context.Context, cccid *ccprovider.CCContext, spec <span class="keyword">interface</span>&#123;&#125;)</span></span> (*pb.Response, *pb.ChaincodeEvent, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// === 设置初始链码消息对象</span></span><br><span class="line">	<span class="comment">// 部署（实例化）deploy命令或升级upgrade命令：调用链码Init()接口方法</span></span><br><span class="line">	cctyp := pb.ChaincodeMessage_INIT</span><br><span class="line">	<span class="comment">//// 检查链码规范对象类型为ChaincodeDeploymentSpec或ChaincodeInvocationSpec</span></span><br><span class="line">	<span class="keyword">if</span> cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;Execute should be called with deployment or invocation spec&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 调用invoke或查询query命令等：调用链码Invoke()接口方法</span></span><br><span class="line">		cctyp = pb.ChaincodeMessage_TRANSACTION</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// === 启动链码容器，返回链码输入参数等</span></span><br><span class="line">	<span class="comment">// created-&gt;established-&gt;ready状态</span></span><br><span class="line">	_, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// === 模拟执行交易链码并等待完成，监听并返回resp响应结果消息</span></span><br><span class="line">	resp, err := theChaincodeSupport.Execute(ctxt, cccid, ccMsg, theChaincodeSupport.executetimeout)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// === 处理模拟执行结果</span></span><br><span class="line">	<span class="keyword">if</span> resp.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动的动作在下面这个方法中完成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">, cMsg, err := theChaincodeSupport.Launch(ctxt, cccid, spec)</span><br></pre></td></tr></table></figure>

<p>此方法的核心又是：<code>launchAndWaitForRegister()</code>，负责具体的链码容器工作,代码位置：**&#x2F;core&#x2F;chaincode&#x2F;chaincode_support.go&#x2F;launchAndWaitForRegister**</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span></span> launchAndWaitForRegister(ctxt context.Context, cccid *ccprovider.CCContext, cds *pb.ChaincodeDeploymentSpec, launcher launcherIntf) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果chaincodeMap字典中已经存在对应的链码规范名称，则说明已经启动链码容器，此时直接返回即可</span></span><br><span class="line">	<span class="keyword">if</span> _, hasBeenLaunched := chaincodeSupport.chaincodeHasBeenLaunched(canName); hasBeenLaunched &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 检查该链码容器是否已经正常运行，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> chaincodeSupport.launchStarted(canName) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="comment">// 核心方法：启动容器，实际调用的是ccLauncherImpl方法</span></span><br><span class="line">		resp, err := launcher.launch(ctxt, notfy)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// === 阻塞等待处理响应消息，等待REGISTER链码消息</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ok := &lt;-notfy:</span><br><span class="line">		<span class="comment">// Peer侧接收到链码容器侧发来的REGISTER注册链码消息，触发Handler的FSM运行，</span></span><br><span class="line">		<span class="comment">// 在回调方法beforeregister()中将外层Handler传递的notfy通道注册到Peer侧Handler中，</span></span><br><span class="line">		<span class="comment">// 根据链码注册成功结果，将结果消息放入notfy通道，触发此处的select语句。</span></span><br><span class="line">		<span class="comment">// 若notfy为flase，则说明注册失败。反之，则说明注册成功</span></span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>chaincode.Execute()</code>函数检查并启动了链码容器，执行完成链码请求操作.</p>
<h3 id="处理模拟执行结果"><a href="#处理模拟执行结果" class="headerlink" title="处理模拟执行结果"></a>处理模拟执行结果</h3><p>处理模拟执行结果是由下面几段代码实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=== 获取并处理交易模拟执行结果</span></span><br><span class="line">	<span class="keyword">if</span> txsim != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> simResult, err = txsim.GetTxSimulationResults(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> simResult.PvtSimulationResults != <span class="literal">nil</span> &#123; <span class="comment">// 检查模拟结果隐私数据的合法性</span></span><br><span class="line">			<span class="keyword">if</span> cid.Name == <span class="string">&quot;lscc&quot;</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> remove once we can store collection configuration outside of LSCC</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;Private data is forbidden to be used in instantiate&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 分发隐私数据</span></span><br><span class="line">			<span class="keyword">if</span> err := e.distributePrivateData(chainID, txid, simResult.PvtSimulationResults); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>两个关键函数：一个是<code>GetTxSimulationResults</code>，还有一个就是<code>distributePrivateData</code>。</p>
<p><code>GetTxSimulationResults</code>主要获取交易模拟执行结果的隐私数据读写集，然后遍历计算集合隐私数据的哈希值，然后获取交易模拟执行结果的公有数据读写集，最后构造交易模拟执行结果<code>TxSimulationResults</code>结构对象并返回。</p>
<p> <code>distributePrivateData</code>首先会<em>获取指定通道上的隐私数据处理句柄</em>，然后通过<code>handler.distributor.Distribute</code>分发隐私数据，</p>
<p>最后通过<code>coordinator</code>模块将指定交易<code>txID</code>的隐私数据读写集<code>privData</code>暂时保存到本地<code>transient</code>隐私数据库中。<code>Committer</code>记账节点在提交区块数据与隐私数据之后，主动删除<code>transient</code>隐私数据库中关联的隐私数据，以及时清理过期数据。</p>
<h2 id="对模拟执行结果签名背书"><a href="#对模拟执行结果签名背书" class="headerlink" title="对模拟执行结果签名背书"></a>对模拟执行结果签名背书</h2><p><code>endorseProposal()</code>方法对模拟执行结果进行签名背书，并返回提案响应消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span></span> endorseProposal(...) (*pb.ProposalResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 调用ESCC系统链码进行背书</span></span><br><span class="line">	res, _, err := e.callChaincode(ctx, chainID, version, txid, signedProp, proposal, ecccis, &amp;pb.ChaincodeID&#123;Name: escc&#125;, txsim)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callChaincode()</code>方法调用<code>ESCC</code>系统链码的<code>EndorserOneValidSignature.Invoke</code>()方法，对模拟结果执行签名背书操作。代码如下：</p>
<p>位置：<code>/core/scc/escc/endorser_onevalidsignature.go/Invoke</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *EndorserOneValidSignature)</span></span> Invoke(stub shim.ChaincodeStubInterface) pb.Response &#123;</span><br><span class="line">	args := stub.GetArgs() <span class="comment">// 获取参数列表</span></span><br><span class="line">	<span class="comment">// 检测参数个数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">6</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Incorrect number of arguments (expected a minimum of 5, provided %d)&quot;</span>, <span class="built_in">len</span>(args)))</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">8</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(fmt.Sprintf(<span class="string">&quot;Incorrect number of arguments (expected a maximum of 7, provided %d)&quot;</span>, <span class="built_in">len</span>(args)))</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取执行链码响应消息</span></span><br><span class="line">	response, err := putils.GetResponse(args[<span class="number">4</span>])</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取模拟执行结果</span></span><br><span class="line">	results = args[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">	/..</span><br><span class="line">	<span class="comment">// 获取本地MSP组件</span></span><br><span class="line">	localMsp := mspmgmt.GetLocalMSP()</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取本地默认签名者身份实体（即背书成员）</span></span><br><span class="line">	signingEndorser, err := localMsp.GetDefaultSigningIdentity()</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 创建签名的提案响应消息</span></span><br><span class="line">	presp, err := utils.CreateProposalResponse(hdr, payl, response, results, events, ccid, visibility, signingEndorser)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 序列化提案响应字节数组</span></span><br><span class="line">	prBytes, err := utils.GetBytesProposalResponse(presp)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 回复执行成功消息</span></span><br><span class="line">	<span class="keyword">return</span> shim.Success(prBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，<code>Endorser</code>背书节点处理签名提案消息的流程结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Order节点启动</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Order%E8%8A%82%E7%82%B9%E5%90%AF%E5%8A%A8-2/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Order节点启动</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmytqt8ef1g30zk0m7dn6.gif" alt="207f698ab0d8c69266fb6fe4c8f85def"></p>
<h2 id="Orderer节点启动流程"><a href="#Orderer节点启动流程" class="headerlink" title="Orderer节点启动流程"></a>Orderer节点启动流程</h2><p>节点启动开始在<code>/orderer/common/server/main.go</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fullCmd := kingpin.MustParse(app.Parse(os.Args[<span class="number">1</span>:]))  <span class="comment">// 解析用户命令行</span></span><br><span class="line">	...</span><br><span class="line">	conf, err := config.Load() <span class="comment">//  加载orderer.yaml配置文件</span></span><br><span class="line">	...</span><br><span class="line">	initializeLoggingLevel(conf) <span class="comment">//初始化日志级别</span></span><br><span class="line">	initializeLocalMsp(conf) <span class="comment">//初始化本地MSP组件</span></span><br><span class="line"></span><br><span class="line">	prettyPrintStruct(conf) <span class="comment">// 打印配置信息</span></span><br><span class="line">	Start(fullCmd, conf) <span class="comment">// 启动Orderer排序服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<ul>
<li>解析用户命令行</li>
<li>加载orderer.yaml配置文件</li>
<li>初始化日志级别</li>
<li>初始化本地MSP组件</li>
<li>打印配置信息</li>
<li>启动Orderer排序服务器</li>
</ul>
<p>接下来将会展开的去讲上面比较重要的一些内容。</p>
<h2 id="加载orderer-yaml配置文件"><a href="#加载orderer-yaml配置文件" class="headerlink" title="加载orderer.yaml配置文件"></a>加载orderer.yaml配置文件</h2><p>是由<code>config.Load()</code>开启的，进入到<code>/orderer/common/localconfig/config.go/Load()</code></p>
<p>①：初始化viper</p>
<p>调用<code>InitViper()</code>函数设置配置文件路径，并默认在<code>$FABRIC_CFG_PATH</code>（如<code>/etc/hyperledger/fabric</code>）路径下查找配置文件，找不到文件时再依次查找当前目录、默认开发配置目录 （<code>$GOPATH/src/github.com/hyperledger/fabric/sampleconfig</code>）和系统默认配置路径 （<code>/etc/hyperledger/fabric</code>）。接着开启匹配系统环境变量的模式，即为Viper组件配置项（以.分割的格式）添加指定前缀“ORDERER_”，转换为大写字母形式，再将“.”替换为<code>_</code>。这样，Viper组件就能在查找配置项时，与以“ORDERER_”前缀开头的环境变量进行匹配，获取其在环境变量中的配置值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config := viper.New()</span><br><span class="line">	cf.InitViper(config, configName)</span><br><span class="line">	config.SetEnvPrefix(Prefix)</span><br><span class="line">	config.AutomaticEnv()</span><br><span class="line">	replacer := strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>)</span><br><span class="line">	config.SetEnvKeyReplacer(replacer)</span><br></pre></td></tr></table></figure>

<p>②：加载Orderer.yaml配置文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := config.ReadInConfig()</span><br></pre></td></tr></table></figure>

<p>③：解析配置文件成Orderer配置对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uconf TopLevel</span><br><span class="line">err = viperutil.EnhancedExactUnmarshal(config, &amp;uconf)</span><br></pre></td></tr></table></figure>

<p>此配置对象为TopLevel型，结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TopLevel <span class="keyword">struct</span> &#123;</span><br><span class="line">	General    General    <span class="comment">//通用配置对象</span></span><br><span class="line">	FileLedger FileLedger <span class="comment">//文本账本配置对象</span></span><br><span class="line">	RAMLedger  RAMLedger  <span class="comment">//RAM账本配置对象</span></span><br><span class="line">	Kafka      Kafka      <span class="comment">// Kafka共识组件配置对象</span></span><br><span class="line">	Debug      Debug      <span class="comment">// 调试信息配置对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④：检查Orderer配置对象conf配置项并设置默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">uconf.completeInitialization(filepath.Dir(config.ConfigFileUsed()))</span><br></pre></td></tr></table></figure>

<h2 id="初始化日志与本地MSP组件"><a href="#初始化日志与本地MSP组件" class="headerlink" title="初始化日志与本地MSP组件"></a>初始化日志与本地MSP组件</h2><p>①：初始化日志</p>
<p><code>initializeLoggingLevel</code>设置<code>Orderer</code>节点上的日志后端输出流、输出格 式与默认日志级别（<code>INFO</code>级别）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeLoggingLevel</span><span class="params">(conf *config.TopLevel)</span></span> &#123;</span><br><span class="line">	flogging.InitBackend(flogging.SetFormat(conf.General.LogFormat), os.Stderr)</span><br><span class="line">	flogging.InitFromSpec(conf.General.LogLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：初始化本地MSP组件</p>
<p>首先加载本地的<code>MSP</code>组件，根据MSP配置文件路径、<code>BCCSP</code>密码服务组件配置、<code>MSP</code>名称初始化本地<code>MSP</code>组件 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeLocalMsp</span><span class="params">(conf *config.TopLevel)</span></span> &#123;</span><br><span class="line">	err := mspmgmt.LoadLocalMsp(conf.General.LocalMSPDir, conf.General.BCCSP, conf.General.LocalMSPID)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地<code>MSP</code>组件默认使用<code>bccspmsp</code>类型对象。该类型的<code>MSP</code>组件是基于<code>BCCSP</code>组件提供密码套件服务的，封装了<code>MSP</code>组件（通常对应于一个组织）信任的相关证书列表（包含根<code>CA</code>证书、中间<code>CA</code>证书等）、<code>MSP</code>名称、签名者身份实体与管理员身份实体列表等。MSP组件的关键内容后面会有专门去讲解。</p>
<h2 id="启动Orderer排序节点"><a href="#启动Orderer排序节点" class="headerlink" title="启动Orderer排序节点"></a>启动Orderer排序节点</h2><p>启动函数在<code>/orderer/common/server/main.go/Start()函数</code>中，接下来一步步的解析：</p>
<p>①：创建本地MSP签名者实体 signer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">signer := localmsp.NewSigner()       </span><br></pre></td></tr></table></figure>

<p>②：初始化TLS认证的安全服务器配置项和gRPC服务器</p>
<p>本地gRPC服务器grpcServer默认端口为7050</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverConfig := initializeServerConfig(conf)       </span><br><span class="line">grpcServer := initializeGrpcServer(conf, serverConfig) </span><br></pre></td></tr></table></figure>

<p>③：设置TLS连接认证的回调函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tlsCallback := <span class="function"><span class="keyword">func</span><span class="params">(bundle *channelconfig.Bundle)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> grpcServer.MutualTLSRequired() &#123; <span class="comment">// 检测是否需要认证TLS客户端证书</span></span><br><span class="line">			logger.Debug(<span class="string">&quot;Executing callback to update root CAs&quot;</span>)</span><br><span class="line">			updateTrustedRoots(grpcServer, caSupport, bundle) <span class="comment">//执行回调函数更新根CA证书</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：创建多通道注册管理器</p>
<p>多通道注册管理器<code>Registrar</code>对象，用于注册<code>Orderer</code>节点上的所有通道（包括系统通道和应用通道），负责维护通道配置、账本等重要资源。 </p>
<p>多通道注册管理器<code>Registrar</code>对象相当于<code>Orderer</code>节点上的“资源管理器”，为每个通道创建关联的共识组件链对象，负责交易排序、打包出块、提交账本以及通道管理等工作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">manager := initializeMultichannelRegistrar(conf, signer, tlsCallback)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeMultichannelRegistrar</span><span class="params">(conf *config.TopLevel, signer crypto.LocalSigner,</span></span></span><br><span class="line"><span class="params"><span class="function">	callbacks ...<span class="keyword">func</span>(bundle *channelconfig.Bundle)</span></span>) *multichannel.Registrar &#123;</span><br><span class="line">	lf, _ := createLedgerFactory(conf) <span class="comment">//创建通道的账本工厂对象</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lf.ChainIDs()) == <span class="number">0</span> &#123;</span><br><span class="line">		initializeBootstrapChannel(conf, lf) <span class="comment">//初始化系统通道</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logger.Info(<span class="string">&quot;Not bootstrapping because of existing chains&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建并设置共识组件字典</span></span><br><span class="line">	consenters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]consensus.Consenter)</span><br><span class="line">	consenters[<span class="string">&quot;solo&quot;</span>] = solo.New()</span><br><span class="line">	consenters[<span class="string">&quot;kafka&quot;</span>] = kafka.New(conf.Kafka) <span class="comment">//// Kafka类型共识组件</span></span><br><span class="line">	<span class="keyword">return</span> multichannel.NewRegistrar(lf, consenters, signer, callbacks...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.1 创建通道的账本工厂对象</p>
<p>代码路径<code>/orderer/common/server/util.go</code>，大概做了以下几件事：</p>
<ul>
<li>获取<code>Orderer</code>节点上的区块账本存储目录ld，包括默认目录<code>/var/hyperledger/production/orderer</code>或临时目录中的子目录<code>hyperledger-fabric-ordererledger</code>+随机数后缀（默认目录不存在时使用）</li>
<li>创建基于文件的区块账本工厂对象lf（<code>fileLedgerFactory</code>类型）</li>
<li>在区块账本目录下建立以chains命名的子目录（<code>/var/hyperledger/production/orderer/chains</code>），由每个通道账本的区块数据存储对象负责在<code>chains</code>子目录下创建维护以通道ID（即链ID）命名的通道账本子目录，用于保存该通道账本的所有区块数据文件。其中，区块数据文件名都是以<code>blockfile_num</code>命名，<code>num</code>是6位区块文件编号，左侧不足位数用0补齐。</li>
</ul>
<p>4.2 初始化系统通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initializeBootstrapChannel</span><span class="params">(conf *config.TopLevel, lf blockledger.Factory)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> conf.General.GenesisMethod &#123; <span class="comment">// 分析创世区块的生成方式</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;provisional&quot;</span>: <span class="comment">// 根据配置文件生成创世区块</span></span><br><span class="line">		genesisBlock = encoder.New(genesisconfig.Load(conf.General.GenesisProfile)).GenesisBlockForChannel(conf.General.SystemChannel)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;file&quot;</span>: <span class="comment">// 根据创世区块文件生成创世区块</span></span><br><span class="line">		genesisBlock = file.New(conf.General.GenesisFile).GenesisBlock()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chainID, err := utils.GetChainIDFromBlock(genesisBlock) <span class="comment">// 从创世区块中解析获取通道ID</span></span><br><span class="line">	...</span><br><span class="line">	gl, err := lf.GetOrCreate(chainID) <span class="comment">// 创建系统通道的区块账本对象</span></span><br><span class="line">	...</span><br><span class="line">	err = gl.Append(genesisBlock) <span class="comment">// 添加区块到系统通道账本上</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：创建Orderer排序服务器</p>
<p><code>Orderer</code>排序服务器，提供<code>Orderer</code>服务与管理所有通道资源及其账本、共识组件等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server := NewServer(manager, signer, &amp;conf.Debug, conf.General.Authentication.TimeWindow, mutualTLS)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(r *multichannel.Registrar, _ crypto.LocalSigner, debug *localconfig.Debug, timeWindow time.Duration, mutualTLS <span class="type">bool</span>)</span></span> ab.AtomicBroadcastServer &#123;</span><br><span class="line">	s := &amp;server&#123;</span><br><span class="line">		dh:        deliver.NewHandlerImpl(deliverSupport&#123;Registrar: r&#125;, timeWindow, mutualTLS),</span><br><span class="line">		bh:        broadcast.NewHandlerImpl(broadcastSupport&#123;Registrar: r&#125;),</span><br><span class="line">		debug:     debug,</span><br><span class="line">		Registrar: r,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>bh：Broadcast</code>服务处理句柄（<code>deliverHandler</code>类型）。该对象实现了<code>Broadcast</code>交易广播服务的<code>Handle(srv ab.AtomicBroadcast_BroadcastServer)</code>消息处理接口，负责接收客户端提交的普通交易消息与配置交易消息，并分别进行处理，过滤后转发给通道绑定的共识组件链对象进行处理； </p>
</li>
<li><p><code>dh：Deliver</code>服务处理句柄（<code>handlerImpl</code>类型）。该对象实现了<code>Deliver</code>区块分发服务的<code>Handle(srv*DeliverServer)</code>消息处理接口，负责接收客户端提交的区块请求消息，从<code>Orderer</code>节点区块账本中读取指定的区块数据，并返回给请求节点。如果请求的指定区块还没有生成，则默认阻塞等待直到该区块创建和提交完毕； </p>
</li>
<li><p><code>Registrar：Orderer</code>节点的多通道注册管理器（<code>Registrar</code>类型）。该对象封装了<code>Orderer</code>节点上所有通道的链支持对象字典<code>chains</code>、共识组件字典<code>consenters</code>、区块账本工厂对象<code>ledgerFactory</code>、系统通道链支持对象与ID、本地签名者实体<code>signer</code>等，用于管理通道配置、区块账本对象、共识组件等核心资源，相当于<code>Orderer</code>节点上的“资源管理器”。</p>
</li>
</ul>
<p>⑥：解析执行子命令</p>
<ul>
<li>start子命令：启动<code>profile</code>服务与<code>Orderer</code>排序服务器，支持<code>go tool pprof</code>命令查看与分析程序性能瓶颈</li>
<li>benchmark子命令：用于启动测试服务器</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> cmd &#123; <span class="comment">//分析命令类型</span></span><br><span class="line">	<span class="keyword">case</span> start.FullCommand(): <span class="comment">// &quot;start&quot; command // start启动子命令</span></span><br><span class="line">		logger.Infof(<span class="string">&quot;Starting %s&quot;</span>, metadata.GetVersionInfo())</span><br><span class="line">		initializeProfilingService(conf) <span class="comment">// goroutine启动go profile服务</span></span><br><span class="line">		ab.RegisterAtomicBroadcastServer(grpcServer.Server(), server)</span><br><span class="line">		logger.Info(<span class="string">&quot;Beginning to serve requests&quot;</span>)</span><br><span class="line">		grpcServer.Start() <span class="comment">// 启动gRPC服务器提供Orderer服务</span></span><br><span class="line">	<span class="keyword">case</span> benchmark.FullCommand(): <span class="comment">// &quot;benchmark&quot; command // &quot;benchmark&quot; 测试用例子命令</span></span><br><span class="line">		logger.Info(<span class="string">&quot;Starting orderer in benchmark mode&quot;</span>)</span><br><span class="line">		benchmarkServer := performance.GetBenchmarkServer()</span><br><span class="line">		benchmarkServer.RegisterService(server)</span><br><span class="line">		benchmarkServer.Start()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Peer节点启动</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Peer%E8%8A%82%E7%82%B9%E5%90%AF%E5%8A%A8-6/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Peer节点启动</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn1cycj35uj31c00u0gww.jpg" alt="b43356d6533644cca27da75d63f275fa"></p>
<h2 id="启动流程概述"><a href="#启动流程概述" class="headerlink" title="启动流程概述"></a>启动流程概述</h2><p>入口：peer&#x2F;main.go:</p>
<p><code>main</code>()函数负责初始化<code>peer</code>主命令对象，注册子命令与初始化环境配置，解析用户输入子命令<code>start</code>并启动Peer节点，包括如下流程步骤：</p>
<ul>
<li>定义、注册命令与初始化基本配置。基于<code>Cobra</code>组件定义peer主命令对象<code>mainCmd</code>，并通过<code>Viper</code>组件调用<code>InitConfig</code>()函数，从本地<code>core.yaml</code>配置文件、环境变量、命令行选项等读取与解析<code>peer</code>命令的相关配置。同时，初始化主命令<code>mainCmd</code>的标志位选项 <code>version</code>、<code>logging-level</code>等，然后在主命令<code>mainCmd</code>上注册<code>version、node、chaincode、channel</code>等子命令，设置最大可用<code>CPU</code>核数与日志后端； </li>
<li>初始化本地<code>MSP</code>组件。通过<code>Viper</code>组件获取<code>MSP</code>组件的配置文件路径<code>mspMgrConfigDir</code>、<code>BCCSP</code>配置项<code>bccspConfig</code>、MSP名称ID即localMSPID、<code>MSP</code>组件类型<code>localMSPType</code>等，基于这4个参数构造本地<code>MSP</code>配置对象，接着创建默认的<code>bccspmsp</code>结构对象作为本地<code>MSP</code>组件，并解析<code>MSP</code>配置对象与初始化本地<code>MSP</code>组件； </li>
<li>执行mainCmd.Execute()方法启动<code>Peer</code>节点</li>
</ul>
<p>接下来将会分别对这几个关键部分进行细说。</p>
<h2 id="定义、注册命令与初始化基本配置"><a href="#定义、注册命令与初始化基本配置" class="headerlink" title="定义、注册命令与初始化基本配置"></a>定义、注册命令与初始化基本配置</h2><h3 id="定义主命令"><a href="#定义主命令" class="headerlink" title="定义主命令"></a>定义主命令</h3><p>代码分析 如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainCmd = &amp;cobra.Command&#123; <span class="comment">// 基于Cobra组件构造主命令</span></span><br><span class="line">	Use: <span class="string">&quot;peer&quot;</span>, <span class="comment">// 定义命令使用方法</span></span><br><span class="line">	<span class="comment">//// 定义执行函数</span></span><br><span class="line">	PersistentPreRunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">//检查CORE_LOGGING_LEVEL环境变量，覆盖所有其他日志设置值。否则，使用core.yaml文件中的配置值</span></span><br><span class="line">		<span class="keyword">var</span> loggingSpec <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> viper.GetString(<span class="string">&quot;logging_level&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			loggingSpec = viper.GetString(<span class="string">&quot;logging_level&quot;</span>) <span class="comment">// 获取配置文件中的日志级别</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			loggingSpec = viper.GetString(<span class="string">&quot;logging.level&quot;</span>) <span class="comment">// 获取配置文件中的日志级别</span></span><br><span class="line">		&#125;</span><br><span class="line">		flogging.InitFromSpec(loggingSpec) <span class="comment">// 根据配置的日志级别初始化日志记录器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;,</span><br><span class="line">	Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123; <span class="comment">// 定义执行函数</span></span><br><span class="line">		<span class="keyword">if</span> versionFlag &#123;</span><br><span class="line">			fmt.Print(version.GetInfo()) <span class="comment">// 打印peer程序版本信息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cmd.HelpFunc()(cmd, args) <span class="comment">// 直接打印命令帮助信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="注册子命令"><a href="#注册子命令" class="headerlink" title="注册子命令"></a>注册子命令</h3><p>将几类子命令注册到主命令上，种类如下：</p>
<ul>
<li>channel通道子命令：用于创建应用通道、获取区块、Peer节点加入应用通道、获取节点所加入的应用通道列表、更新应用通道配置、签名配置交易文件、获取指定的应用通道信息等，包括<code>create、fetch、join、list、update、signconfigtx、getinfo</code>等子命令；</li>
<li>chaincode链码子命令：用于安装链码、实例化（部署）链码、调用链码、打包链码、查询链码、签名链码包、升级链码、获取通道链码列表等，包括<code>install、instantiate、invoke、package、query、signpackage、upgrade、list</code>等子命令； </li>
<li>node节点子命令：用于管理节点服务进程与查询服务状态，包括<code>start、status</code>等子命令；</li>
<li>logging日志子命令：用于获取、设置与恢复日志级别功能，包括<code>getlevel、setlevel、 revertlevels</code>等子命令；</li>
<li>version版本子命令：用于打印<code>Fabric</code>中的<code>Peer</code>节点服务器版本信息。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetEnvPrefix(cmdRoot)               <span class="comment">// 设置环境变量前缀core</span></span><br><span class="line">	viper.AutomaticEnv()                      <span class="comment">// 查找匹配环境变量</span></span><br><span class="line">	replacer := strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>) <span class="comment">// 创建替换符</span></span><br><span class="line">	viper.SetEnvKeyReplacer(replacer)         <span class="comment">// 设置环境变量替换符</span></span><br><span class="line">	<span class="comment">// 定义命令行选项集合，对所有peer及其子命令都有效</span></span><br><span class="line">	mainFlags := mainCmd.PersistentFlags()</span><br><span class="line">	<span class="comment">// 设置绑定version与logging-level选项</span></span><br><span class="line">	mainFlags.BoolVarP(&amp;versionFlag, <span class="string">&quot;version&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Display current version of fabric peer server&quot;</span>)</span><br><span class="line">	mainFlags.String(<span class="string">&quot;logging-level&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Default logging level and overrides, see core.yaml for full syntax&quot;</span>)</span><br><span class="line">	<span class="comment">// Viper配置绑定命令行选项</span></span><br><span class="line">	viper.BindPFlag(<span class="string">&quot;logging_level&quot;</span>, mainFlags.Lookup(<span class="string">&quot;logging-level&quot;</span>))</span><br><span class="line">	<span class="comment">// 注册子命令</span></span><br><span class="line">	mainCmd.AddCommand(version.Cmd())       <span class="comment">// version子命令</span></span><br><span class="line">	mainCmd.AddCommand(node.Cmd())          <span class="comment">// node子命令start、status</span></span><br><span class="line">	mainCmd.AddCommand(chaincode.Cmd(<span class="literal">nil</span>))  <span class="comment">// chaincode子命令install等</span></span><br><span class="line">	mainCmd.AddCommand(clilogging.Cmd(<span class="literal">nil</span>)) <span class="comment">// cli日志子命令 getlevel</span></span><br><span class="line">	mainCmd.AddCommand(channel.Cmd(<span class="literal">nil</span>))    <span class="comment">// channel子命令 create等</span></span><br><span class="line">	<span class="comment">// 加载配置文件core.yaml</span></span><br><span class="line">	err := common.InitConfig(cmdRoot)</span><br><span class="line">	...</span><br><span class="line">	runtime.GOMAXPROCS(viper.GetInt(<span class="string">&quot;peer.gomaxprocs&quot;</span>)) <span class="comment">// 设置最大可用的CPU核数</span></span><br><span class="line">	<span class="comment">// setup system-wide logging backend based on settings from core.yaml</span></span><br><span class="line">	<span class="comment">// 初始化系统日志后端</span></span><br><span class="line">	flogging.InitBackend(flogging.SetFormat(viper.GetString(<span class="string">&quot;logging.format&quot;</span>)), logOutput)</span><br></pre></td></tr></table></figure>

<h2 id="初始化本地MSP组件"><a href="#初始化本地MSP组件" class="headerlink" title="初始化本地MSP组件"></a>初始化本地MSP组件</h2><p><code>MSP</code>组件是管理本地成员身份的重要安全模块，封装了根<code>CA</code>证书、本地签名者实体等.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化本地MSP组件对象</span></span><br><span class="line">	<span class="keyword">var</span> mspMgrConfigDir = config.GetPath(<span class="string">&quot;peer.mspConfigPath&quot;</span>) <span class="comment">// 获取MSP配置文件路径</span></span><br><span class="line">	<span class="keyword">var</span> mspID = viper.GetString(<span class="string">&quot;peer.localMspId&quot;</span>)             <span class="comment">// 获取本地MSP名称</span></span><br><span class="line">	<span class="keyword">var</span> mspType = viper.GetString(<span class="string">&quot;peer.localMspType&quot;</span>)         <span class="comment">// 获取本地MSP组件类型</span></span><br><span class="line">	<span class="keyword">if</span> mspType == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 默认设置MSP组件类型为FABRIC类型</span></span><br><span class="line">		mspType = msp.ProviderTypeToString(msp.FABRIC)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取BCCSP组件配置信息，初始化MSP组件对象</span></span><br><span class="line">	err = common.InitCrypto(mspMgrConfigDir, mspID, mspType)</span><br></pre></td></tr></table></figure>



<h2 id="执行主命令"><a href="#执行主命令" class="headerlink" title="执行主命令"></a>执行主命令</h2><p>函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> mainCmd.Execute() != <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进入到<code>Execute()</code>函数中继续分析： &#x2F;vendor&#x2F;github.com&#x2F;spf13&#x2F;cobra&#x2F;command.go&#x2F;ExecuteC()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Command)</span></span> ExecuteC() (cmd *Command, err <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Cobra</code>组件调用主命令<code>Execute</code>()方法，执行<code>peer node start</code>命令启动<code>Peer</code>节点。其中，<code>Cobra</code>组件解析完用户输入的命令行选项之后，依次执行节点启动命令nodeStartCmd对象中定义的所有相关的执行方法，并按照<code>cobra.Command</code>命令中定义的如下顺序来执行</p>
<ul>
<li>PersistentPreRunE()&#x2F;PersistentPreRun()； </li>
<li>PreRunE()&#x2F;PreRun()； </li>
<li>RunE()&#x2F;Run()； </li>
<li>PostRunE()&#x2F;PostRun()； </li>
<li>PersistentPostRunE()&#x2F;PersistentPostRun();</li>
</ul>
<p>到这里为止节点命令开启执行，因为这部分主要是讲的节点启动，所以下面集中将节点启动命令执行的运行流程。</p>
<h2 id="节点启动命令执行"><a href="#节点启动命令执行" class="headerlink" title="节点启动命令执行"></a>节点启动命令执行</h2><p>节点启动的命令可以根据以下代码路径查找：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mainCmd.AddCommand(node.Cmd()) </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cmd</span><span class="params">()</span></span> *cobra.Command &#123;</span><br><span class="line">	nodeCmd.AddCommand(startCmd())</span><br><span class="line">	nodeCmd.AddCommand(statusCmd())</span><br><span class="line">	<span class="keyword">return</span> nodeCmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只讨论节点启动命令</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startCmd</span><span class="params">()</span></span> *cobra.Command &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> nodeStartCmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeStartCmd = &amp;cobra.Command&#123;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">return</span> serve(args)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式进入到serve函数讨论：</p>
<h3 id="初始化资源"><a href="#初始化资源" class="headerlink" title="初始化资源"></a>初始化资源</h3><p>①：<em>获取本地MSP组件类型并检查MSP组件类型</em></p>
<p>目前，<code>Hyperledger Fabric</code>支持<code>FABRIC</code>类型和<code>IDEMIX</code>类型两种<code>MSP</code>组件，默认采用基于<code>BCCSP</code>组件构建的<code>FABRIC</code>类型<code>MSP</code>组件.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mspType := mgmt.GetLocalMSP().GetType() <span class="comment">// 获取本地MSP组件类型</span></span><br><span class="line">	<span class="keyword">if</span> mspType != msp.FABRIC &#123;              <span class="comment">// 检查MSP组件类型</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;Unsupported msp type &quot;</span> + msp.ProviderTypeToString(mspType))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>初始化资源访问策略提供者</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">aclmgmt.RegisterACLProvider(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>③：<em>初始化本地账本管理器</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ledgermgmt.Initialize(peer.ConfigTxProcessors) 	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>core&#x2F;ledger&#x2F;ledgermgmt&#x2F;ledger_mgmt.go&#x2F;initialize</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initialize</span><span class="params">(customTxProcessors customtx.Processors)</span></span> &#123;</span><br><span class="line">	logger.Info(<span class="string">&quot;Initializing ledger mgmt&quot;</span>)</span><br><span class="line">	lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> lock.Unlock() <span class="comment">// 设置Peer节点初始化标志位为true</span></span><br><span class="line">	initialized = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 创建已打开的账本字典openedLedgers</span></span><br><span class="line">	openedLedgers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]ledger.PeerLedger)</span><br><span class="line">	<span class="comment">// 初始化配置交易消息处理器字典，设置给全局变量processors字典</span></span><br><span class="line">	customtx.Initialize(customTxProcessors)</span><br><span class="line">	cceventmgmt.Initialize()                <span class="comment">// 初始化链码事件管理器</span></span><br><span class="line">	provider, err := kvledger.NewProvider() <span class="comment">// 创建本地Peer节点账本提供者</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Error in instantiating ledger provider: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	provider.Initialize(kvLedgerStateListeners) <span class="comment">// 初始化状态监听器</span></span><br><span class="line">	ledgerProvider = provider                   <span class="comment">// 设置为全局默认的Peer节点账本提供者</span></span><br><span class="line">	logger.Info(<span class="string">&quot;ledger mgmt initialized&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正本提供者有以下几种：</p>
<ul>
<li><p>账本ID数据库（idStore类型）：提供存储账本ID（即链ID）与创世区块键值对的<code>LevelDB</code>数据库； </p>
</li>
<li><p>账本数据存储对象提供者（ledgerstorage.Provider类型）：创建账本数据存储对象，负责管理区块数据文件、隐私数据库、区块索引数据库等； </p>
</li>
<li><p>历史数据库提供者（HistoryDBProvider类型）：创建历史数据库，存储每个状态数据的历史信息； </p>
</li>
<li><p>状态数据库提供者（CommonStorageDBProvider类型）：创建状态数据库（<code>LevelDB</code>或<code>CouchDB</code>类型），存储世界状态（<code>world state</code>），包括有效交易的公有数据与隐私数据。</p>
</li>
</ul>
<p>④：<em>初始化服务器参数</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> chaincodeDevMode &#123;</span><br><span class="line">		<span class="comment">//设置链码模式</span></span><br><span class="line">		viper.Set(<span class="string">&quot;chaincode.mode&quot;</span>, chaincode.DevModeUserRunsChaincode)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取配置并缓存Peer节点地址与端点</span></span><br><span class="line">	<span class="keyword">if</span> err := peer.CacheConfiguration(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取缓存的Peer端点</span></span><br><span class="line">	peerEndpoint, err := peer.GetPeerEndpoint()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> peerHost <span class="type">string</span></span><br><span class="line">	<span class="comment">// 获取Peer节点IP地址，注意IP地址与端口已经被分离</span></span><br><span class="line">	peerHost, _, err = net.SplitHostPort(peerEndpoint.Address)</span><br></pre></td></tr></table></figure>

<h3 id="创建GRPC服务器"><a href="#创建GRPC服务器" class="headerlink" title="创建GRPC服务器"></a>创建GRPC服务器</h3><p>①：<em>创建gRPC服务器</em></p>
<p><code>serve()</code>函数创建了至少 3 个<code>gRPC</code>服务器（独立端口），用于注册<code>Peer</code>节点功能服务器，如下所示：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>端口</th>
<th>功能服务器</th>
<th>说明</th>
<th>服务接口</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7051</td>
<td>DeliverEvents事件服务器</td>
<td>处理区块请求消息</td>
<td>Deliver()</td>
</tr>
<tr>
<td></td>
<td>7051</td>
<td>Admin服务器</td>
<td>获取节点状态、维护日志等</td>
<td>GetStatus()</td>
</tr>
<tr>
<td></td>
<td>7051</td>
<td>Endorser背书服务器</td>
<td>提供背书服务</td>
<td>ProcessProposal()</td>
</tr>
<tr>
<td></td>
<td>7051</td>
<td>Gossip消息服务器</td>
<td>组织内节点分发数据与同步状态等</td>
<td>GossipStream()</td>
</tr>
<tr>
<td>2</td>
<td>7052</td>
<td>chaincodeSupport链码支持服务器</td>
<td>提供Peer节点链码支持服务</td>
<td>Register()</td>
</tr>
<tr>
<td>3</td>
<td>7053</td>
<td>EventHub事件服务器</td>
<td>提供订阅事件服务(1.3.0废弃)</td>
<td>Chat()</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverConfig, err := peer.GetServerConfig()</span><br><span class="line">	...</span><br><span class="line">peerServer, err := peer.CreatePeerServer(listenAddr, serverConfig)</span><br></pre></td></tr></table></figure>

<p>②：<em>创建EventHub事件服务器</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> serverConfig.SecOpts.UseTLS &#123;</span><br><span class="line">	...</span><br><span class="line">	cs := comm.GetCredentialSupport() <span class="comment">// 创建证书支持对象CredentialSupport结构对象</span></span><br><span class="line">	cs.ServerRootCAs = serverConfig.SecOpts.ServerRootCAs</span><br><span class="line">	<span class="comment">//// 获取gRPC客户端证书用于TLS连接认证</span></span><br><span class="line">	clientCert, err := peer.GetClientCertificate()</span><br><span class="line">	<span class="comment">// 设置客户端证书</span></span><br><span class="line">	comm.GetCredentialSupport().SetClientCertificate(clientCert)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//// 创建事件EventHub服务器（7053端口）</span></span><br><span class="line">ehubGrpcServer, err := createEventHubServer(serverConfig)</span><br></pre></td></tr></table></figure>

<p>③：<em>创建DeliverEvents事件服务器</em></p>
<p><code>serve()</code>函数检查如果开启了双向的<code>TLS</code>安全认证，则设置<code>mutualTLS</code>标志位为<code>true</code>，并定义获取资源策略检查器即<code>policyCheckerProvider</code>()函数。该函数将直接调用全局变量<code>aclProvider</code>对象的<code>CheckACL</code>()方法，检查签名消息在通道（channelID）上是否满足指定资源的访问控制权限策略。 </p>
<p>接着，<code>serve</code>()函数调用<code>peer.NewDeliverEventsServer()</code>函数，基于<code>mutualTLS</code>、<code>policy-CheckerProvider</code>等参数创建<code>DeliverEvents</code>事件服务器<code>abServer</code>，提供<code>Deliver()</code>与<code>DeliverFiltered</code>()服务接口，分别用于处理请求正常区块与过滤区块的消息。</p>
<p>然后调用<code>pb.RegisterDeliverServer()</code>方法，将<code>DeliverEvents</code>事件服务器<code>abServer</code>注册到默认的<code>gRPC</code>服务器上（7051端口），以提供本地事件服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 检查是否开启了双向的TLS安全认证</span></span><br><span class="line">	mutualTLS := serverConfig.SecOpts.UseTLS &amp;&amp; serverConfig.SecOpts.RequireClientCert</span><br><span class="line">	<span class="comment">//// 定义资源访问权限策略检查函数</span></span><br><span class="line">	policyCheckerProvider := <span class="function"><span class="keyword">func</span><span class="params">(resourceName <span class="type">string</span>)</span></span> deliver.PolicyChecker &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(env *cb.Envelope, channelID <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> aclmgmt.GetACLProvider().CheckACL(resourceName, channelID, env)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建DeliverEvents事件服务器，并注册到Peer节点gRPC服务器上（7051端口）</span></span><br><span class="line">	abServer := peer.NewDeliverEventsServer(mutualTLS, policyCheckerProvider, &amp;peer.DeliverSupportManager&#123;&#125;)</span><br><span class="line">	pb.RegisterDeliverServer(peerServer.Server(), abServer)</span><br></pre></td></tr></table></figure>

<p>④：<em>创建ChaincodeSupport链码支持服务器</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建链码支持服务专用gRPC服务器与链码支持服务实例ChaincodeSupport（专用端口或7052端口）</span></span><br><span class="line">	ccSrv, ccEndpoint, err := createChaincodeServer(ca, peerHost)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Panicf(<span class="string">&quot;Failed to create chaincode server: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将链码支持服务器实例ChaincodeSupoort对象注册到Peer节点gRPC服务器上</span></span><br><span class="line">	<span class="comment">// 同时注册系统链码以支持部署调用系统链码</span></span><br><span class="line">	registerChaincodeSupport(ccSrv, ccEndpoint, ca)</span><br><span class="line">	<span class="keyword">go</span> ccSrv.Start() <span class="comment">//启动gRPC服务器提供链码支持服务</span></span><br></pre></td></tr></table></figure>

<p>⑤：<em>创建Admin管理服务器与Endorser背书服务器</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Admin管理服务器与</span></span><br><span class="line">pb.RegisterAdminServer(peerServer.Server(), core.NewAdminServer())</span><br><span class="line"><span class="comment">// 定义Gossip协议分发隐私数据函数</span></span><br><span class="line">privDataDist := <span class="function"><span class="keyword">func</span><span class="params">(channel <span class="type">string</span>, txID <span class="type">string</span>, privateData *rwset.TxPvtReadWriteSet)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> service.GetGossipService().DistributePrivateData(channel, txID, privateData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建新的EndorserServer背书节点服务器</span></span><br><span class="line">serverEndorser := endorser.NewEndorserServer(privDataDist, &amp;endorser.SupportImpl&#123;&#125;)</span><br><span class="line">libConf := library.Config&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err = viperutil.EnhancedExactUnmarshalKey(<span class="string">&quot;peer.handlers&quot;</span>, &amp;libConf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;could not load YAML config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//// 创建消息过滤器列表</span></span><br><span class="line">authFilters := library.InitRegistry(libConf).Lookup(library.Auth).([]authHandler.Filter)</span><br><span class="line"><span class="comment">// 将所有消息过滤器均构造成消息过滤器链，并返回第1个过滤器（Filter类型，实现了EndorserServer // 接口）</span></span><br><span class="line">auth := authHandler.ChainFilters(serverEndorser, authFilters...)</span><br><span class="line"><span class="comment">// Register the Endorser server</span></span><br><span class="line"><span class="comment">//// 注册EndorserServer背书服务器到gRPC服务器</span></span><br><span class="line">pb.RegisterEndorserServer(peerServer.Server(), auth)</span><br></pre></td></tr></table></figure>

<p>⑥：<em>创建Gossip消息服务器</em>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Bootstrap连接的初始节点地址列表，默认为127.0.0.1:7051</span></span><br><span class="line">bootstrap := viper.GetStringSlice(<span class="string">&quot;peer.gossip.bootstrap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">////获取本地MSP签名者身份实体 并序列化</span></span><br><span class="line">serializedIdentity, err := mgmt.GetLocalSigningIdentityOrPanic().Serialize()</span><br><span class="line">...</span><br><span class="line">messageCryptoService := peergossip.NewMCS( <span class="comment">// 构造Gossip消息加密服务组件</span></span><br><span class="line">	peer.NewChannelPolicyManagerGetter(), <span class="comment">// 通道策略管理器获取组件</span></span><br><span class="line">	localmsp.NewSigner(),                 <span class="comment">// 本地签名者</span></span><br><span class="line">	mgmt.NewDeserializersManager())       <span class="comment">// 身份反序列化组件管理器</span></span><br><span class="line">secAdv := peergossip.NewSecurityAdvisor(mgmt.NewDeserializersManager())</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback function for secure dial options for gossip service</span></span><br><span class="line"><span class="comment">//定义Gossip服务器回调函数，用于创建Gossip服务器安全配置的gRPC拨号连接选项</span></span><br><span class="line">secureDialOpts := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> []grpc.DialOption &#123;</span><br><span class="line">	<span class="keyword">var</span> dialOpts []grpc.DialOption</span><br><span class="line">	<span class="comment">// set max send/recv msg sizes</span></span><br><span class="line">	dialOpts = <span class="built_in">append</span>(dialOpts, grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(comm.MaxRecvMsgSize()),</span><br><span class="line">		grpc.MaxCallSendMsgSize(comm.MaxSendMsgSize()))) <span class="comment">// 设置最大发送和接收消息字节数</span></span><br><span class="line">	<span class="comment">// set the keepalive options</span></span><br><span class="line">	kaOpts := comm.DefaultKeepaliveOptions() <span class="comment">// 获取默认的心跳消息keepalive选项</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//在gRPC通信拨号连接选项中设置心跳通信keepalive选项</span></span><br><span class="line">	dialOpts = <span class="built_in">append</span>(dialOpts, comm.ClientKeepaliveOptions(kaOpts)...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> comm.TLSEnabled() &#123; <span class="comment">// 启用TLS安全认证，设置客户端TLS通信证书</span></span><br><span class="line">		dialOpts = <span class="built_in">append</span>(dialOpts, grpc.WithTransportCredentials(comm.GetCredentialSupport().GetPeerCredentials()))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dialOpts = <span class="built_in">append</span>(dialOpts, grpc.WithInsecure()) <span class="comment">// 否则，关闭TLS安全认证</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dialOpts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查gRPC服务器端是否启用TLS安全认证，获取并设置服务器端与客户端身份证书</span></span><br><span class="line"><span class="keyword">var</span> certs *common2.TLSCertificates</span><br><span class="line"><span class="keyword">if</span> peerServer.TLSEnabled() &#123;</span><br><span class="line">	serverCert := peerServer.ServerCertificate()</span><br><span class="line">	clientCert, err := peer.GetClientCertificate()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;failed obtaining client certificates&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	certs = &amp;common2.TLSCertificates&#123;&#125;</span><br><span class="line">	certs.TLSServerCert.Store(&amp;serverCert)</span><br><span class="line">	certs.TLSClientCert.Store(&amp;clientCert)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Gossip消息服务器实例gossipServiceInstance</span></span><br><span class="line">err = service.InitGossipService(serializedIdentity, peerEndpoint.Address, peerServer.Server(), certs,</span><br><span class="line">	messageCryptoService, secAdv, secureDialOpts, bootstrap...)</span><br></pre></td></tr></table></figure>

<h3 id="部署系统链码与初始化现存通道的链结构"><a href="#部署系统链码与初始化现存通道的链结构" class="headerlink" title="部署系统链码与初始化现存通道的链结构"></a>部署系统链码与初始化现存通道的链结构</h3><p>①：<em>部署系统链码</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部署系统链码</span></span><br><span class="line">initSysCCs()</span><br></pre></td></tr></table></figure>

<p>②：<em>初始化现存通道上的链结构</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化现存通道上的链结构</span></span><br><span class="line">	peer.Initialize(<span class="function"><span class="keyword">func</span><span class="params">(cid <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>core&#x2F;peer&#x2F;peer.go&#x2F;Initialize</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Initialize</span><span class="params">(init <span class="keyword">func</span>(<span class="type">string</span>)</span></span>) &#123;</span><br><span class="line">	nWorkers := viper.GetInt(<span class="string">&quot;peer.validatorPoolSize&quot;</span>) <span class="comment">// 获取交易验证线程数量</span></span><br><span class="line">	<span class="keyword">if</span> nWorkers &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		nWorkers = runtime.NumCPU()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//// 设置信号量并发访问数量</span></span><br><span class="line">	validationWorkersSemaphore = semaphore.NewWeighted(<span class="type">int64</span>(nWorkers))</span><br><span class="line"></span><br><span class="line">	chainInitializer = init <span class="comment">// 设置初始化函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cb *common.Block</span><br><span class="line">	<span class="keyword">var</span> ledger ledger.PeerLedger</span><br><span class="line">	<span class="comment">//// 初始化账本管理器</span></span><br><span class="line">	ledgermgmt.Initialize(ConfigTxProcessors)</span><br><span class="line">	<span class="comment">//// 获取当前账本管理器下的账本ID列表</span></span><br><span class="line">	ledgerIds, err := ledgermgmt.GetLedgerIDs()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Error in initializing ledgermgmt: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, cid := <span class="keyword">range</span> ledgerIds &#123;</span><br><span class="line">		peerLogger.Infof(<span class="string">&quot;Loading chain %s&quot;</span>, cid)</span><br><span class="line">		<span class="comment">//创建本地Peer节点账本</span></span><br><span class="line">		<span class="keyword">if</span> ledger, err = ledgermgmt.OpenLedger(cid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			peerLogger.Warningf(<span class="string">&quot;Failed to load ledger %s(%s)&quot;</span>, cid, err)</span><br><span class="line">			peerLogger.Debugf(<span class="string">&quot;Error while loading ledger %s with message %s. We continue to the next ledger rather than abort.&quot;</span>, cid, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//// 从指定通道账本中获取最新配置区块</span></span><br><span class="line">		<span class="keyword">if</span> cb, err = getCurrConfigBlockFromLedger(ledger); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			peerLogger.Warningf(<span class="string">&quot;Failed to find config block on ledger %s(%s)&quot;</span>, cid, err)</span><br><span class="line">			peerLogger.Debugf(<span class="string">&quot;Error while looking for config block on ledger %s with message %s. We continue to the next ledger rather than abort.&quot;</span>, cid, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Create a chain if we get a valid ledger with config block</span></span><br><span class="line">		<span class="comment">//// 在Peer节点上创建指定通道的链结构</span></span><br><span class="line">		<span class="keyword">if</span> err = createChain(cid, ledger, cb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			peerLogger.Warningf(<span class="string">&quot;Failed to load chain %s(%s)&quot;</span>, cid, err)</span><br><span class="line">			peerLogger.Debugf(<span class="string">&quot;Error reloading chain %s with message %s. We continue to the next chain rather than abort.&quot;</span>, cid, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 用自定义函数初始化通道链结构，如部署系统链码</span></span><br><span class="line">		InitChain(cid)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动gRPC服务器与profile服务器"><a href="#启动gRPC服务器与profile服务器" class="headerlink" title="启动gRPC服务器与profile服务器"></a>启动gRPC服务器与profile服务器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立传递错误消息的通道</span></span><br><span class="line">	serve := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// 传递信号的通道</span></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 设置本进程信号通道的通知信号，包括中断/终止信号</span></span><br><span class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">// 设置本进程阻塞等待的特定通知信号</span></span><br><span class="line">		sig := &lt;-sigs <span class="comment">// 从sigs通道读取信号值，阻塞等待方式</span></span><br><span class="line">		logger.Debugf(<span class="string">&quot;sig: %s&quot;</span>, sig)</span><br><span class="line">		serve &lt;- <span class="literal">nil</span></span><br><span class="line">	&#125;()</span><br><span class="line">		<span class="comment">// 利用goroutine 启动gRPC服务器（7051端口，注册了Admin管理服务器、Endorser背书服务器等）</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> grpcErr <span class="type">error</span></span><br><span class="line">		<span class="keyword">if</span> grpcErr = peerServer.Start(); grpcErr != <span class="literal">nil</span> &#123; <span class="comment">// 监听端口（7051）提供服务</span></span><br><span class="line">			grpcErr = fmt.Errorf(<span class="string">&quot;grpc server exited with error: %s&quot;</span>, grpcErr)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			logger.Info(<span class="string">&quot;peer server exited&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		serve &lt;- grpcErr <span class="comment">// 若因发生错误而退出，则发送错误到serve通道</span></span><br><span class="line">	&#125;()</span><br><span class="line">		<span class="comment">// 向进程文件中写入运行进程ID</span></span><br><span class="line">	<span class="keyword">if</span> err := writePid(config.GetPath(<span class="string">&quot;peer.fileSystemPath&quot;</span>)+<span class="string">&quot;/peer.pid&quot;</span>, os.Getpid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the event hub server</span></span><br><span class="line">	<span class="comment">// 启动基于专用事件监听端口的gRPC服务器（7053端口，已注册EventHub事件服务器）</span></span><br><span class="line">	<span class="keyword">if</span> ehubGrpcServer != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> ehubGrpcServer.Start()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start profiling http endpoint if enabled</span></span><br><span class="line">	<span class="comment">// 如果打开profile使能标志位，则启动提供服务</span></span><br><span class="line">	<span class="keyword">if</span> viper.GetBool(<span class="string">&quot;peer.profile.enabled&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 启动go profile服务器，如果出错，则不会发送错误信息，只是记录到日志里</span></span><br><span class="line">			<span class="comment">// 获取profile监听地址</span></span><br><span class="line">			profileListenAddress := viper.GetString(<span class="string">&quot;peer.profile.listenAddress&quot;</span>)</span><br><span class="line">			logger.Infof(<span class="string">&quot;Starting profiling server with listenAddress = %s&quot;</span>, profileListenAddress)</span><br><span class="line">			<span class="keyword">if</span> profileErr := http.ListenAndServe(profileListenAddress, <span class="literal">nil</span>); profileErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				logger.Errorf(<span class="string">&quot;Error starting profiler: %s&quot;</span>, profileErr)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，Peer节点及其功能服务器启动完毕.</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Order节点概述</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Order%E8%8A%82%E7%82%B9%E6%A6%82%E8%BF%B0-1/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Order节点概述</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn15th0ollj31c00u0qcl.jpg" alt="bcc633a6c26528720cf16ed170f6a141"></p>
<h2 id="前言及源码目录"><a href="#前言及源码目录" class="headerlink" title="前言及源码目录"></a>前言及源码目录</h2><p><code>Orderer</code>排序节点这块内容主要包括了节点启动流程、<code>Broadcast</code>广播交易服务、<code>Orderer</code>共识排序服务以及<code>Deliver</code>区块分发服务。其相关源码目录文件如下：</p>
<blockquote>
<p>&#x2F;orderer</p>
<p>|-common</p>
<p>​	|-blockcutter:交易切割打包模块  ✨✨✨✨✨✨</p>
<p>​	|-bootstrap:引导启动模块，生成创世块  ✨✨✨✨✨✨</p>
<p>​	|-broadcast:交易广播服务模块 ✨✨✨✨✨✨</p>
<p>​	|-localconfig:本地配置模块</p>
<p>​	|-metadata：获取元数据模块</p>
<p>​	|-msgprocessor:消息处理器模块 </p>
<p>​	|-multichannel：多管道注册管理器模块</p>
<p>​	|-performance：性能测量模块</p>
<p>​	|-server：Order排序服务器模块  ✨✨✨✨✨✨</p>
<p>|-consensus</p>
<p>​	|-kafka:kafka共识组件模块 ✨✨✨✨✨✨</p>
<p>​	|-solo:solo共识组件模块 </p>
<p>​	|-consensus.go:定义共识组件相关接口 </p>
<p>|-main.go:orderer主程序</p>
</blockquote>
<blockquote>
<p>&#x2F;common</p>
<p>|-deliver:定义Deliver服务器及处理器接口 ✨✨✨✨✨✨</p>
</blockquote>
<blockquote>
<p>&#x2F;core</p>
<p>|-deliverservice</p>
<p>​	|-blocksprovider:区块提供者模块 ✨✨✨✨✨✨</p>
<p>​	|-client.go:提供broadcastClient客户端 ✨✨✨✨✨✨</p>
<p>​	|-deliveryClient：Deliver服务客户端 ✨✨✨✨✨✨</p>
<p>​	|-requester.go:请求区块数据 ✨✨✨✨✨✨</p>
</blockquote>
<blockquote>
<p>&#x2F;protos</p>
<p>|-orderer:protobuf消息定义模块</p>
</blockquote>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p><code>Orderer</code>排序节点在<code>Hyperledger Fabric</code>系统架构中处于核心角色地位，管理着系统通道与所有应用通道，负责通道创建、通道配置更新等操作，并处理客户端提交的交易消息请求，对交易进行排序并按规则打包成新区块，提交账本并维护通道账本数据，为全网节点提供<code>Broadcast</code>交易广播服务、<code>Orderer</code>共识排序服务、<code>Deliver</code>区块分发服务等。通常，Hyperledger Fabric启动时需要先启动Orderer排序节点，创建系统通道提供正常服务后，再启动其他角色的<code>Peer</code>节点进入正常工作状态。其服务模块关系与架构示如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn16qf76aaj31ev0u0top.jpg" alt="image-20210126163847049"></p>
<p><code>Orderer</code>节点启动后基于创世区块初始化系统通道，创建<code>Orderer</code>排序服务器，封装了<code>Broadcast</code>服务处理句柄、<code>Deliver</code>服务处理句柄与多通道注册管理器对象，并提供<code>Broadcast</code>()交易广播服务接口与 <code>Deliver</code>()区块分发服务接口。</p>
<p>其中，<code>Orderer</code>排序服务器基于<code>Broadcast</code>()接口接收交易广播服务请求，调用<code>Broadcast</code>服务处理句柄的<code>Handle</code>()方法进行处理，建立消息处理循环，接收与处理客户端提交的普通交易消息、配置交易消息等请求消息，经过滤后发送至通道绑定的共识组件链对象（<code>Solo</code>类型、<code>Kafka</code>类型等）进行排序。接着，再将排序后的交易添加到本地待处理的缓存交易消息列表，并按照交易出块规则构造新区块，提交到<code>Orderer</code>节点指定通道账本的区块数据文件中，同时负责创建新的应用通道、更新通道配置等通道管理工作。目前，<code>Orderer</code>排序服务器负责接收与处理两类交易消息，具体如下。</p>
<ul>
<li><p>配置交易消息（ConfigMsg）：通道头部类型是<code>CONFIG_UPDATE</code>的通道配置交易消息，含有最新的通道配置信息，经过通道消息处理器过滤后，转换为通道头部类型为 <code>ORDERER_TRANSACTION</code>或<code>CONFIG</code>的配置交易消息（<code>Envelope</code>类型），分别用于创建新的应用通道或更新通道配置，同时，将通道配置交易消息单独打包成新区块，并提交到系统通道账本与应用通道账本。 </p>
</li>
<li><p>普通交易消息（NormalMsg）：通道头部类型是<code>ENDORSER_TRANSACTION</code>等的标准交易消息（经过<code>Endorser</code>背书的交易消息或其他非配置交易消息），含有改变世界状态的模拟执行结果读写集，经过<code>Endorser</code>节点签名背书后打包发送到<code>Orderer</code>节点请求处 </p>
<p>理，经过通道消息处理器过滤后，将合法交易提交到共识组件链对象进行排序，再按照交易出块规则（出块时间周期、打包最大交易数量、区块字节数限制等）生成新区块，并提交到通道账本。</p>
</li>
</ul>
<p>同时，<code>Orderer</code>排序服务器提供<code>Deliver</code>()区块分发服务接口，将接收的服务请求交由Deliver服务处理句柄的<code>Handle</code>()方法处理，建立消息处理循环，负责接收与处理客户端提交的区块请求消息，封装了指定区块请求范围的区块搜索信息（SeekInfo类型）。接着，Deliver服务处理句柄循环从本地账本获取区块数据，依次发送给请求节点（如<code>Leader</code>主节点）。如果账本中还未生成指定区块，则Deliver服务处理句柄默认一直阻塞等待，直到该区块创建完成并提交账本后再回复给请求节点。</p>
<p>另外，<code>Orderer</code>排序服务器还提供了多通道注册管理器<code>Registrar</code>对象，负责管理系统通道与所有应用通道，封装了所有通道的链支持对象字典、共识组件字典、区块账本工厂对象等组件，维护所有通道上的通道配置、区块账本对象、共识组件等核心资源，创建通道上的共识组件链对象提供<code>Orderer</code>共识排序服务，负责对交易消息排序，切割打包构造新区块并提交账本，同时负责创建新的应用通道与更新通道配置，其相当于<code>Orderer</code>节点上的“资源管理器”。 </p>
<p>实际上，<code>Orderer</code>排序服务器上的通道共识组件链对象利用<code>Golang</code>通道（<code>Solo</code>共识组件）或<code>Kafka</code>集群（<code>Kafka</code>共识组件）作为共识排序后端，对经过通道消息处理器过滤的合法交易消息进行排序，对交易顺序等达成一致性观点。同时，在新通道创建时或启动恢复现有通道时，启动通道绑定的链支持对象以及共识组件链对象，构建交易消息处理循环，接收共识组件已经完成排序的交易消息，并添加到本地待处理的缓存交易消息列表中，包括配置交易消息、普通交易消息等，采用相互独立的消息处理流程分别处理 。</p>
<p>注意，目前<code>Orderer</code>节点账本只包括区块数据文件与区块索引数据库，负责保存区块数据即公有数据（包含公共数据与隐私数据哈希值），不存在状态数据库、历史数据库、隐私数据库等。不同于<code>Peer</code>节点，<code>Orderer</code>节点在提交区块到本地账本前不需要验证交易背书策略与执行<code>MVCC</code>检查，也不保存任何隐私数据（明文），只负责存储所有通道账本上的区块数据。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|kafka共识排序</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_kafka%E5%85%B1%E8%AF%86%E6%8E%92%E5%BA%8F-4/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|kafka共识排序</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzuqmak04j30zk0m8weu.jpg" alt="d1e794177969e09552b173b7d6eaea19"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Orderer共识组件提供HandleChain()方法创建通道绑定的共识组件链对象（<code>consensus.Chain</code>接口），包括<code>Solo</code>（<code>solo.chain</code>类型）、<code>Kafka</code>（<code>kafka.chainImpl</code>类型）等类型，属于通道共识组件的重要实现模块，并设置到链支持对象的<code>cs.Chain</code>字段。共识组件链对象提供Orderer共识排序服务，负责关联通道上交易排序、打包出块、提交账本、通道管理等工作，目前采用<code>Golang</code>通道或<code>Kafka</code>集群作为共识排序后端，<strong>接收来自<code>Broadcast</code>服务过滤转发的交易消息</strong>并进行排序。  </p>
<h2 id="kafka共识排序服务"><a href="#kafka共识排序服务" class="headerlink" title="kafka共识排序服务"></a>kafka共识排序服务</h2><h3 id="orderer服务集群"><a href="#orderer服务集群" class="headerlink" title="orderer服务集群"></a>orderer服务集群</h3><p><code>Orderer</code>节点采用<code>Sarama</code>开源的<code>Kafka</code>第三方库构建<code>Kafka</code>共识组件，可以同时接受处理多个客户端发送的交易消息请求，能够有效提高<code>Orderer</code>节点处理交易消息的并发能力。同时，可利用<code>Kafka</code>集群在<strong>单一分区内</strong>按序收集相同主题消息（<strong>消息序号唯一</strong>）的功能，来保证交易消息具有确定性的顺序（以消息序号排序），从而实现对交易排序达成全局共识的目的。 </p>
<p><code>Kafka</code>生产者按照主题（<code>Topic</code>）生产消息并进行发布，<code>Kafka</code>服务器集群自动对消息主题进行分类。同一个主题的消息都会被收集到一个或多个分区文件中，按照<code>FIFO</code>的顺序追加到文件尾部，并且每个消息在分区中都会有一个<code>OFFSET</code>位置偏移量作为该消息的唯一标识ID。目前，<code>Hyperledger Fabric</code>基于<code>Kafka</code>集群为<strong>每个通道</strong>创建绑定了一个主题（即链ID，<code>chainID</code>），并且只设置一个分区（分区号为0）。Kafka消费者管理多个分区消费者并订阅指定分区的主题消息，包括主题（即<code>chainID</code>）、分区号（目前只有1个分区号为0的分区）、起始偏移量（开始订阅的消息位置<code>offset</code>）等。</p>
<p>Hyperledger Fabric采用<code>Kafka</code>集群对单个或多个<code>Orderer</code>排序节点提交的交易消息进行排序。此时，<code>Orderer</code>排序节点同时充当<code>Kafka</code>集群的消息生产者（分区）和消费者，发布消息与订阅消息到Kafka集群上的同一个主题分区，即先将<code>Peer</code>节点提交的交易消息转发给Kafka服务端，同时，从指定主题的<code>Kafka</code>分区上按顺序获取排序后的交易消息并自动过滤重启的交易消息。这期间可能会存在网络时延造成获取消息时间的差异。如果不考虑丢包造成消息丢失的情况，则所有<code>Orderer</code>节点获取消息的顺序与数量应该是确定的和一致的。同时，采用相同的Kafka共识组件链对象与出块规则等，以保证所有Orderer节点都可以创建与更新相同配置的通道，并切割生成相同的批量交易集合出块，再“同步”构造出相同的区块数据，从而基于<code>Kafka</code>集群达成全局共识，以保证区块数据的全局一致性。</p>
<h3 id="启动共识组件链对象"><a href="#启动共识组件链对象" class="headerlink" title="启动共识组件链对象"></a>启动共识组件链对象</h3><p>启动入口：</p>
<blockquote>
<p>orderer&#x2F;consensus&#x2F;kafka&#x2F;chain.go&#x2F;Start()</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> startThread(chain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startThread</span><span class="params">(chain *chainImpl)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建kafka生产者</span></span><br><span class="line">	chain.producer, err = setupProducerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Kafka生产者发送CONNECT消息建立连接</span></span><br><span class="line">	<span class="keyword">if</span> err = sendConnectMessage(chain.consenter.retryOptions(), chain.haltChan, chain.producer, chain.channel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Panicf(<span class="string">&quot;[channel: %s] Cannot post CONNECT message = %s&quot;</span>, chain.channel.topic(), err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建Kafka消费者</span></span><br><span class="line">	chain.parentConsumer, err = setupParentConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建Kafka分区消费者</span></span><br><span class="line">	chain.channelConsumer, err = setupChannelConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.parentConsumer, chain.channel, chain.lastOffsetPersisted+<span class="number">1</span>)</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">close</span>(chain.startChan) <span class="comment">// 已经启动共识组件链对象，不阻塞Broadcast</span></span><br><span class="line">	chain.errorChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 创建errorChan通道，不阻塞Deliver服务处理句柄</span></span><br><span class="line">	...</span><br><span class="line">	chain.processMessagesToBlocks() <span class="comment">//创建消息处理循环，循环处理订阅分区上接收到的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>startThread</code>函数首先创建<code>kafka</code>生产者，发布消息到指定主题（即通道ID）和分区号的通道分区（chain.channel）上。</p>
<p> 然后发送<code>CONNECT</code>消息建立连接，该消息指定了主题<code>Topic</code>字段为链ID、<code>Key</code>字段为分区号0、<code>Value</code>字段为<code>CONNECT</code>类型消息负载等。订阅该主题的<code>Kafka</code>（分区）消费者会接收到该消息。</p>
<p>接着创建指定<code>Kafka</code>分区和<code>Broker</code>服务器配置的<code>Kafka</code>消费者对象，并设置从指定主题（链ID）和分区号（0）的<code>Kafka</code>分区上获取消息。</p>
<p>最后，调用<code>processMessagesToBlocks()</code>方法创建消息处理循环，负责处理从<code>Kafka</code>集群中接收到的订阅消息。</p>
<h3 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h3><p><code>processMessagesToBlocks</code>接收到正常的<code>Kafka</code>分区消费者消息会根据<code>kafka</code>的消息类型进行处理，包括以下几种类型：</p>
<ul>
<li>Kafka- Message_Regular</li>
<li>KafkaMessage_TimeToCut</li>
<li>KafkaMessage_Connect</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> processMessagesToBlocks() ([]<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 消息处理循环</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">case</span> in, ok := &lt;-chain.channelConsumer.Messages(): <span class="comment">//接收到正常的Kafka分区消费者消息</span></span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-chain.errorChan: <span class="comment">// If this channel was closed...  // 如果该通道已经关闭，则重新创建该通道</span></span><br><span class="line">				...</span><br><span class="line">			<span class="keyword">switch</span> msg.Type.(<span class="keyword">type</span>) &#123; <span class="comment">//分析Kafka消息类型</span></span><br><span class="line">			<span class="keyword">case</span> *ab.KafkaMessage_Connect: <span class="comment">//Kafka连接消息  由于错误而重新恢复Kafka消费者分区订阅流程</span></span><br><span class="line">				_ = chain.processConnect(chain.ChainID()) <span class="comment">//处理CONNECT连接消息， 不做任何事情</span></span><br><span class="line">				counts[indexProcessConnectPass]++         <span class="comment">// 成功处理消息计数增1</span></span><br><span class="line">			<span class="keyword">case</span> *ab.KafkaMessage_TimeToCut: <span class="comment">// Kafka定时切割生成区块消息</span></span><br><span class="line">				<span class="keyword">if</span> err := chain.processTimeToCut(msg.GetTimeToCut(), in.Offset); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					logger.Warningf(<span class="string">&quot;[channel: %s] %s&quot;</span>, chain.ChainID(), err)</span><br><span class="line">					logger.Criticalf(<span class="string">&quot;[channel: %s] Consenter for channel exiting&quot;</span>, chain.ChainID())</span><br><span class="line">					counts[indexProcessTimeToCutError]++</span><br><span class="line">					<span class="keyword">return</span> counts, err <span class="comment">// TODO Revisit whether we should indeed stop processing the chain at this point</span></span><br><span class="line">				&#125;</span><br><span class="line">				counts[indexProcessTimeToCutPass]++ <span class="comment">// 成功处理消息计数增1</span></span><br><span class="line">			<span class="keyword">case</span> *ab.KafkaMessage_Regular: <span class="comment">// Kafka常规消息</span></span><br><span class="line">				<span class="keyword">if</span> err := chain.processRegular(msg.GetRegular(), in.Offset); err != <span class="literal">nil</span> &#123; <span class="comment">// 处理Kafka常 规消息</span></span><br><span class="line">					...</span><br><span class="line">					counts[indexProcessRegularError]++</span><br><span class="line">        &#125;...</span><br><span class="line">      &#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-chain.timer: <span class="comment">// 超时定时器</span></span><br><span class="line">			<span class="keyword">if</span> err := sendTimeToCut(chain.producer, chain.channel, chain.lastCutBlockNumber+<span class="number">1</span>, &amp;chain.timer); err != <span class="literal">nil</span> &#123; <span class="comment">//发送TimeToCut类型消息，请求打包出块</span></span><br><span class="line">			...</span><br><span class="line">				counts[indexSendTimeToCutError]++</span><br><span class="line">			&#125; ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①：KafkaMessage_Connect类型消息</p>
<p><code>Kafka</code>连接消息用于测试连通<code>Kafka</code>分区消费者的工作状态，用于验证<code>Kafka</code>共识组件的正常工作状态与排除故障，并调用<code>chain.processConnect(chain.ChainID())</code>方法处理该消息。</p>
<p>②：KafkaMessage_TimeToCut类型消息</p>
<p><code>processMessagesToBlocks</code>()方法可调用<code>chain.processTimeToCut()</code>方法处理<code>TIMETOCUT</code>类型消息。如果消息中的区块号<code>ttcNumber</code>不是当前<code>Orderer</code>节点当前通道账本中下一个打包出块的区块号（最新区块号<code>lastCutBlockNumber</code>+1），则直接丢弃不处理。否则，调用<code>BlockCutter().Cut()</code>方法，切割当前该通道上待处理的缓存交易消息列表为批量交易集合<code>batch（[]*cb.Envelope）</code>，再调用<code>CreateNextBlock(batch)</code>方法构造新区块并提交账本。最后，调用<code>WriteBlock(block，metadata)</code>方法，更新区块元数据并提交账本，同时更新Kafka共识组件链对象的最新区块号<code>lastCutBlockNumber</code>增1。</p>
<p>事实上，<code>Orderer</code>服务集群节点独立打包出块的时间点通常不是完全同步的，同时还可能会重复接收其他Orderer节点提交的TIMETOCUT类型消息（重复区块号）。此时，<code>Orderer</code>节点以接收到的第一个<code>TIMETOCUT</code>类型消息为准，打包出块并提交到账本，再更新当前通道的最新区块号<code>lastCutBlockNumber</code>。这样，<code>processTimeToCut</code>()方法就能利用最新的<code>lastCutBlockNumber</code>过滤掉其他重复的<code>TIMETOCUT</code>类型消息，以保证所有<code>Orderer</code>节点上账本区块文件的数据同步，实际上是将原先的时间同步机制转换为消息同步机制。</p>
<p>③：KafkaMessage_Regular类型消息</p>
<p>包括通道配置交易消息（KafkaMessageRegular_CONFIG类型）和普通交易消息（KafkaMessageRegular_NORMAL类型）。 详细的分析将会在<code>processRegular</code>方法中体现。</p>
<h2 id="处理配置交易消息"><a href="#处理配置交易消息" class="headerlink" title="处理配置交易消息"></a>处理配置交易消息</h2><p>我们先大概的看一下ProcessRegular中关于处理配置交易消息的代码部分,因为这部分相当的长，必须先看个概览：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> processRegular(regularMessage *ab.KafkaMessageRegular, receivedOffset <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  commitConfigMsg := <span class="function"><span class="keyword">func</span><span class="params">(message *cb.Envelope, newOffset <span class="type">int64</span>)</span></span>&#123;...&#125;</span><br><span class="line">  seq := chain.Sequence() <span class="comment">// 获取当前通道的最新配置序号</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> regularMessage.Class &#123;</span><br><span class="line">	<span class="keyword">case</span> ab.KafkaMessageRegular_UNKNOWN: <span class="comment">// 未知消息类型</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> ab.KafkaMessageRegular_NORMAL: <span class="comment">// 普通交易消息类型</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">case</span> ab.KafkaMessageRegular_CONFIG: <span class="comment">// 通道配置交易消息</span></span><br><span class="line">	...</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接跳转到<code>case ab.KafkaMessageRegular_CONFIG</code>进行分析：</p>
<p>①：如果regularMessage.OriginalOffset 不为 0</p>
<p>说明这是重新过滤验证和排序的通道配置交易消息。</p>
<p>1.1 过滤重复提交的消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> regularMessage.OriginalOffset &lt;= chain.lastOriginalOffsetProcessed &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 确认是否是最近重新验证且重新排序的配置交易消息，并且通道配置序号是最新的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> regularMessage.OriginalOffset == chain.lastResubmittedConfigOffset &amp;&amp;regularMessage.ConfigSeq == seq &#123;</span><br><span class="line">  <span class="comment">// 因此，关闭通道并解除Broadcast服务处理句柄阻塞等待，通知重新接收消息进行处理</span></span><br><span class="line">  <span class="built_in">close</span>(chain.doneReprocessingMsgInFlight) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.3 主动更新本通道的最近重新提交排序的配置交易消息初始偏移量lastResubmitted</p>
<p>存在其他<code>Orderer</code>节点重新提交了配置消息，但是本地<code>Orderer</code>节点没有重新提交该消息。因此这里需要更新本通道的最近重新提交排序的配置交易消息初始偏移量lastResubmitted。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> chain.lastResubmittedConfigOffset &lt; regularMessage.OriginalOffset &#123;</span><br><span class="line">				chain.lastResubmittedConfigOffset = regularMessage.OriginalOffset</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②：regularMessage.OriginalOffset为 0</p>
<p>说明是第一次提交通道配置交易消息，而不是重新验证和重新排序的。</p>
<p>2.1 如果消息中的配置序号regularMessage.ConfigSeq小于当前通道的最新配置序号seq</p>
<p>则说明已经更新了通道配置（配置序号较高），然后再处理当前配置交易消息（配置序号较低）。将会调用<code>ProcessConfigMsg</code>重新过滤和处理该消息。</p>
<p>接着通过<code>configure</code>重新提交该配置消息进行排序，重置消息初始偏移量。然后再更新最近重新提交消息的偏移量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq &#123;</span><br><span class="line">  ...</span><br><span class="line">	configEnv, configSeq, err := chain.ProcessConfigMsg(env)</span><br><span class="line">  <span class="keyword">if</span> err := chain.configure(configEnv, configSeq, receivedOffset); err != <span class="literal">nil</span> &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻塞接收消息处理，更新最近重新提交消息的偏移量</span></span><br><span class="line">  chain.lastResubmittedConfigOffset = receivedOffset </span><br><span class="line">  <span class="comment">//创建通道阻塞Broadcast服务接收处理消息</span></span><br><span class="line">  chain.doneReprocessingMsgInFlight = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：提交配置交易消息执行通道管理操作</p>
<p>经过上面的①和②过滤掉不符合条件的情况，接下来就提交配置交易消息执行通道管理操作，核心函数：<code>commitConfigMsg(env, offset)</code></p>
<p>3.1 将当前缓存交易消息切割成批量交易集合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">batch := chain.BlockCutter().Cut()</span><br></pre></td></tr></table></figure>

<p>3.2 创建新区块block</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block := chain.CreateNextBlock(batch)</span><br></pre></td></tr></table></figure>

<p>3.3 构造Kafka元数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123; <span class="comment">//构造Kafka元数据</span></span><br><span class="line">				LastOffsetPersisted:         receivedOffset - <span class="number">1</span>, <span class="comment">// 偏移量减1</span></span><br><span class="line">				LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">				LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>

<p>3.4 写入区块</p>
<p>通过区块写组件提交新区块到账本，更新当前通道的最新区块号chain.lastCutBlockNumber增1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chain.WriteBlock(block, metadata)</span><br><span class="line">chain.lastCutBlockNumber++  </span><br></pre></td></tr></table></figure>

<p>接着更新本链的lastOriginal- OffsetProcessed为newOffset参数，然后做和上面差不多的事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">		block := chain.CreateNextBlock([]*cb.Envelope&#123;message&#125;) <span class="comment">// 构造新区块</span></span><br><span class="line">		metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;     <span class="comment">// 构造Kafka元数据</span></span><br><span class="line">			LastOffsetPersisted:         receivedOffset,</span><br><span class="line">			LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">			LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">		&#125;)</span><br><span class="line">		chain.WriteConfigBlock(block, metadata) <span class="comment">// 写入配置区块</span></span><br><span class="line">		chain.lastCutBlockNumber++              <span class="comment">// 最新区块号增1</span></span><br></pre></td></tr></table></figure>

<p>不管是上面的<code>WriteBlock</code>还是<code>WriteConfigBlock</code>底层都是调用的<code>commitBlock</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span></span> commitBlock(encodedMetadataValue []<span class="type">byte</span>) &#123;</span><br><span class="line">	... <span class="comment">// 添加块签名</span></span><br><span class="line">	bw.addBlockSignature(bw.lastBlock)</span><br><span class="line">  <span class="comment">// 添加最新的配置签名</span></span><br><span class="line">	bw.addLastConfigSignature(bw.lastBlock)</span><br><span class="line">	<span class="comment">// 写入新块</span></span><br><span class="line">	err := bw.support.Append(bw.lastBlock)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再讨论kafka共识组件如何处理普通交易消息的。</p>
<h2 id="处理普通交易消息"><a href="#处理普通交易消息" class="headerlink" title="处理普通交易消息"></a>处理普通交易消息</h2><p>还是先回到 <code>processRegular</code>方法，关于处理普通消息的方法大概如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> processRegular(regularMessage *ab.KafkaMessageRegular, receivedOffset <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> ab.KafkaMessageRegular_NORMAL: <span class="comment">// 普通交易消息类型</span></span><br><span class="line">		<span class="comment">// 如果OriginalOffset不是0，则说明该消息是重新验证且重新提交排序的</span></span><br><span class="line">		<span class="keyword">if</span> regularMessage.OriginalOffset != <span class="number">0</span> &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 如果消息偏移量不大于lastOriginalOffsetProcessed最近已处理消息的偏移量，</span></span><br><span class="line">			<span class="comment">// 则说明已经处理过该消息，此时应丢弃返回，防止重复处理其他Orderer提交的相同偏移 量的普通交易消息</span></span><br><span class="line">			<span class="keyword">if</span> regularMessage.OriginalOffset &lt;= chain.lastOriginalOffsetProcessed &#123;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// // 检查通道的配置序号是否更新</span></span><br><span class="line">		<span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">//// 消息的配置序号低，需要重新验证过滤消息</span></span><br><span class="line">			configSeq, err := chain.ProcessNormalMsg(env)</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">//重新提交普通交易消息</span></span><br><span class="line">      <span class="keyword">if</span> err := chain.order(env, configSeq, receivedOffset); err != <span class="literal">nil</span> &#123;&#125;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// advance lastOriginalOffsetProcessed iff message is re-validated and re-ordered</span></span><br><span class="line">		<span class="comment">//当且仅当消息重新验证和重新排序时，才需要修正lastOriginalOffsetProcessed偏移量</span></span><br><span class="line">		offset := regularMessage.OriginalOffset</span><br><span class="line">		<span class="keyword">if</span> offset == <span class="number">0</span> &#123;</span><br><span class="line">			offset = chain.lastOriginalOffsetProcessed</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 提交处理普通交易消息，offset为最近处理的普通交易消息偏移量</span></span><br><span class="line">		commitNormalMsg(env, offset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理普通交易消息的流程与处理配置交易消息的流程基本类似，主要看最后的<code>commitNormalMsg(env, offset)</code>，我们来继续分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commitNormalMsg := <span class="function"><span class="keyword">func</span><span class="params">(message *cb.Envelope, newOffset <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">		<span class="comment">//// 添加所接收的消息到缓存交易消息列表，并切割成批量交易集合列表batches</span></span><br><span class="line">		batches, pending := chain.BlockCutter().Ordered(message)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(batches) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不存在批量交易集合，则启动定时器周期性地发送切割出块消息n</span></span><br><span class="line">			chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">			<span class="keyword">if</span> chain.timer == <span class="literal">nil</span> &#123;</span><br><span class="line">				chain.timer = time.After(chain.SharedConfig().BatchTimeout())</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		chain.timer = <span class="literal">nil</span></span><br><span class="line">		offset := receivedOffset <span class="comment">// 设置当前消息偏移量</span></span><br><span class="line">		<span class="keyword">if</span> pending || <span class="built_in">len</span>(batches) == <span class="number">2</span> &#123;</span><br><span class="line">			offset-- <span class="comment">// 计算第1个批量交易消息的偏移量是offset减1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 只有1个批量交易集合构成1个区块</span></span><br><span class="line">			<span class="comment">//// 设置第1个批量交易集合的消息偏移量为newOffset</span></span><br><span class="line">			chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//// 构造并提交第1个区块</span></span><br><span class="line">		block := chain.CreateNextBlock(batches[<span class="number">0</span>])</span><br><span class="line">		metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">			LastOffsetPersisted:         offset,</span><br><span class="line">			LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">			LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">		&#125;)</span><br><span class="line">		chain.WriteBlock(block, metadata) <span class="comment">// 更新区块元数据，并提交区块到账本</span></span><br><span class="line">		chain.lastCutBlockNumber++ <span class="comment">// 更新当前通道上最近出块的区块号增1</span></span><br><span class="line">	...</span><br><span class="line">		<span class="comment">// Commit the second block if exists</span></span><br><span class="line">		<span class="comment">//// 检查第2个批量交易集合，构造并提交第2个区块</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(batches) == <span class="number">2</span> &#123;</span><br><span class="line">			chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">			offset++ <span class="comment">// 设置第2个批量交易集合的消息偏移量offset加1</span></span><br><span class="line"></span><br><span class="line">			block := chain.CreateNextBlock(batches[<span class="number">1</span>])</span><br><span class="line">			metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata&#123;</span><br><span class="line">				LastOffsetPersisted:         offset,</span><br><span class="line">				LastOriginalOffsetProcessed: newOffset,</span><br><span class="line">				LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">			&#125;)</span><br><span class="line">			chain.WriteBlock(block, metadata)</span><br><span class="line">			chain.lastCutBlockNumber++</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先将新的普通交易消息添加到当前的缓存交易列表，并切割成批量交易集合列表batches ,但最多只能包含2个批量交易集合，并且第2个批量交易集合最多包含1个交易。最终也是调用的<code>WriteBlock</code>写入到账本。</p>
<p>到此为止整个<code>processRegular</code>()方法处理消息结束。</p>
<h2 id="总结及参考"><a href="#总结及参考" class="headerlink" title="总结及参考"></a>总结及参考</h2><p>kafka共识排序的逻辑其实是比较简单的，大概的流程如下 ：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn0u9hflmfj318e0u0wj5.jpg" alt="image-20210126092717144"></p>
<blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> (文章图片代码资料在里面)</p>
<p>微信公众号：区块链技术栈</p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|交易广播</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_%E4%BA%A4%E6%98%93%E5%B9%BF%E6%92%AD-3/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|交易广播</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmz2lvzbprj31ao0t6n61.jpg" alt="40fe3d4a84cc46e22caf5e06071c3aa7"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Hyperledger Fabric</code>提供了<code>Broadcast(srv ab.AtomicBroadcast_BroadcastServer)</code>交易广播服务接口，接收客户端提交的签名交易消息请求，交由共识组件链对象对交易进行排序与执行通道管理，按照交易出块规则切割打包，构造新区块并提交账本。同时，通过<code>Deliver()</code>区块分发服务接口，将区块数据发送给通道组织内发起请求的<code>Leader</code>主节点，再基于<code>Gossip</code>消息协议广播到组织内的其他节点上，从而实现广播交易消息的目的。 </p>
<h2 id="Broadcast服务消息处理"><a href="#Broadcast服务消息处理" class="headerlink" title="Broadcast服务消息处理"></a>Broadcast服务消息处理</h2><p><code>Orderer</code>节点启动时已经在本地的<code>gRPC</code>服务器上注册了<code>Orderer</code>排序服务器，并创建了<code>Broadcast</code>服务处理句柄。当客户端调用<code>Broadcast()</code>服务接口发起服务请求时，<code>Orderer</code>排序服务器会调用<code>Broadcast()→s.bh.Handle()</code>方法处理请求，流程如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Broadcast(srv ab.AtomicBroadcast_BroadcastServer) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> s.bh.Handle(&amp;broadcastMsgTracer&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *handlerImpl)</span></span> Handle(srv ab.AtomicBroadcast_BroadcastServer) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是这个<code>Handle</code>的处理，分析如下：</p>
<p>①：等待接收处理消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg, err := srv.Recv()</span><br></pre></td></tr></table></figure>

<p>②：解析获取通道头部chdr、配置交易消息标志位isConfig、通道链支持对象（通道消息处理器）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br></pre></td></tr></table></figure>

<p>③：检查共识组件链对象是否准备好接收新的交易消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err = processor.WaitReady(); err != <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>④：分类处理消息</p>
<p><strong>处理普通消息</strong></p>
<p>4.1 解析获取通道的最新配置序号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">configSeq, err := processor.ProcessNormalMsg(msg)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/orderer/common/msgprocessor/standardchannel.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span></span> ProcessNormalMsg(env *cb.Envelope) (configSeq <span class="type">uint64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	configSeq = s.support.Sequence()</span><br><span class="line">	err = s.filters.Apply(env)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configSeq是最新配置序号，默认初始值为0，新建应用通道后该配置序号自增为1，通过比较该序号就能判断当前通道配置版本是否发生了更新，从而确定当前交易消息是否需要重新过滤与重新排序。</p>
<p>接着就是使用自带的默认通道消息过滤器过滤消息，有以下过滤条件：</p>
<ul>
<li>验证不能为空</li>
<li>拒绝过期的签名者身份证书</li>
<li>消息最大字节数过滤器（98MB）</li>
<li>消息签名验证过滤器</li>
</ul>
<p>4.2 构造新的普通交易消息并发送到共识组件链对象请求处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = processor.Order(msg, configSeq) </span><br></pre></td></tr></table></figure>

<p>这里我们只关注<code>kafka</code>的共识组件处理。</p>
<p>首先序列化消息，然后将该消息发送到<code>Kafka</code>集群的指定分区上请求排序，再转发给<code>Kafka</code>共识组件链对象请求打包出块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/orderer/consensus/kafka/chain.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> order(env *cb.Envelope, configSeq <span class="type">uint64</span>, originalOffset <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	marshaledEnv, err := utils.Marshal(env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot enqueue, unable to marshal envelope because = %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !chain.enqueue(newNormalMessage(marshaledEnv, configSeq, originalOffset)) &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot enqueue&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看enqueue方法是如何做的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span></span> enqueue(kafkaMsg *ab.KafkaMessage) <span class="type">bool</span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;[channel: %s] Enqueueing envelope...&quot;</span>, chain.ChainID())</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-chain.startChan: <span class="comment">// // 共识组件在启动阶段启动完成</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-chain.haltChan: <span class="comment">//  已经关闭chain.startChan通道</span></span><br><span class="line">		...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//// 创建Kafka生产者消息</span></span><br><span class="line">			message := newProducerMessage(chain.channel, payload)</span><br><span class="line">			<span class="comment">//// 发送消息到Kafka集群请求排序</span></span><br><span class="line">			<span class="keyword">if</span> _, _, err = chain.producer.SendMessage(message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理通道配置交易消息</strong></p>
<p>4.3  获取配置交易消息与通道的最新配置序号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config, configSeq, err := processor.ProcessConfigUpdateMsg(msg)</span><br></pre></td></tr></table></figure>

<p>代码位置：&#x2F;orderer&#x2F;common&#x2F;msgprocessor&#x2F;systemchannel.go&#x2F;ProcessConfigUpdateMsg,大概做了以下事情：</p>
<ul>
<li><em>获取消息中的通道ID</em></li>
<li><em>检查消息中的通道ID与当前通道ID是否一致,一致的话交由标准通道处理器处理</em></li>
<li><em>创建新应用通道的通道配置实体Bundle结构对象</em></li>
<li><em>构造新的通道配置更新交易消息（ConfigEnvelope类型），注意将该消息的通道配置序号更新为1</em></li>
<li><em>创建内层的通道配置交易消息（CONFIG类型）</em></li>
<li><em>创建外层的配置交易消息（ORDERER_TRANSACTION类型）</em></li>
<li><em>应用系统通道的消息过滤器</em></li>
<li><em>返回新的通道配置交易消息与当前系统通道的配置序号</em></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SystemChannel)</span></span> ProcessConfigUpdateMsg(envConfigUpdate *cb.Envelope) (config *cb.Envelope, configSeq <span class="type">uint64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	channelID, err := utils.ChannelID(envConfigUpdate) <span class="comment">// 获取消息中的通道ID</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//检查消息中的通道ID与当前通道ID是否一致</span></span><br><span class="line">	<span class="keyword">if</span> channelID == s.support.ChainID() &#123;</span><br><span class="line">		<span class="comment">//// 交由标准通道处理器处理</span></span><br><span class="line">		<span class="keyword">return</span> s.StandardChannel.ProcessConfigUpdateMsg(envConfigUpdate)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 创建新的应用通道，其通道配置序号默认初始化为0</span></span><br><span class="line">	<span class="comment">// 创建新应用通道的通道配置实体Bundle结构对象</span></span><br><span class="line">	bundle, err := s.templator.NewChannelConfig(envConfigUpdate)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//构造新的通道配置更新交易消息（ConfigEnvelope类型），注意将该消息的通道配置序号更新为1</span></span><br><span class="line">	newChannelConfigEnv, err := bundle.ConfigtxValidator().ProposeConfigUpdate(envConfigUpdate)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建内层的通道配置交易消息（CONFIG类型）</span></span><br><span class="line">	newChannelEnvConfig, err := utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, channelID, s.support.Signer(), newChannelConfigEnv, msgVersion, epoch)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//创建外层的配置交易消息（ORDERER_TRANSACTION类型）</span></span><br><span class="line">	wrappedOrdererTransaction, err := utils.CreateSignedEnvelope(cb.HeaderType_ORDERER_TRANSACTION, s.support.ChainID(), s.support.Signer(), newChannelEnvConfig, msgVersion, epoch)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 应用系统通道的消息过滤器</span></span><br><span class="line">	err = s.StandardChannel.filters.Apply(wrappedOrdererTransaction)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//返回新的通道配置交易消息与当前系统通道的配置序号</span></span><br><span class="line">	<span class="keyword">return</span> wrappedOrdererTransaction, s.support.Sequence(), <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>4.4 构造新的配置交易消息发送到共识组件链对象请求排序</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = processor.Configure(config, configSeq)</span><br></pre></td></tr></table></figure>

<p>这里我们依旧只是考虑<code>kafka</code>共识组件，<code>processor.Configure()</code>方法实际上是调用<code>chainImpl.configure()</code>方法，同样构造<code>Kafka</code>常规消息（<code>KafkaMessageRegular</code>类型）。其中，<code>Class</code>消息类别属于<code>KafkaMessageRegular_CONFIG</code>类型，包含了通道配置交易消息、 通道配置序号<code>configSeq</code>与初始消息偏移量<code>originalOffset（0）</code>。接着，调用<code>chain.enqueue()</code>方法，将其发送到<code>Kafka</code>集群上指定主题（<code>chainID</code>）和分区号（0）的分区上，同时，由<code>Kafka</code>共识组件链对象分区消费者<code>channelConsumer</code>获取该消息，再交由给<code>Kafka</code>共识组件链对象请求打包出块。</p>
<p>⑤：发送成功处理状态响应消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = srv.Send(&amp;ab.BroadcastResponse&#123;Status: cb.Status_SUCCESS&#125;)</span><br></pre></td></tr></table></figure>

<p>整个流程图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzs6ruy53j31860u0doq.jpg" alt="image-20210125112957202"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> (文章图片代码资料)</p>
<p>微信公众号：区块链技术栈</p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码|以太坊启动流程</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码|以太坊启动流程</p>
<p>文章以及资料（开源）：<a href="https://github.com/mindcarver/blockchain_guide">github地址</a>  </p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1go6tgnjvkhj20jg0c6mxi.jpg" alt="9ff239564d5d1129fa544f25d95c7468"></p>
<h1 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h1><p>以太坊是如何启动一个网络节点的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./geth --datadir &quot;../data0&quot; --nodekeyhex &quot;27aa615f5fa5430845e4e97229def5f23e9525a20640cc49304f40f3b43824dc&quot; --bootnodes $enodeid --mine --debug --metrics --syncmode=&quot;full&quot; --gcmode=archive  --gasprice 0 --port 30303 --rpc --rpcaddr &quot;0.0.0.0&quot; --rpcport 8545 --rpcapi &quot;db,eth,net,web3,personal&quot; --nat any --allow-insecure-unlock  2&gt;&gt;log 1&gt;&gt;log 0&gt;&gt;log &gt;&gt;log &amp;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>geth : 编译好的geth程序，可以起别名</li>
<li>datadir：数据库和keystore密钥的数据目录</li>
<li>nodekeyhex: 十六进制的P2P节点密钥</li>
<li>bootnodes:用于P2P发现引导的enode urls</li>
<li>mine：打开挖矿</li>
<li>debug:突出显示调用位置日志(文件名及行号)</li>
<li>metrics: 启用metrics收集和报告</li>
<li>syncmode:同步模式 (“fast”, “full”, or “light”)</li>
<li>gcmode:表示即时将内存中的数据写入到文件中，否则重启节点可能会导致区块高度归零而丢失数据</li>
<li>gasprice:挖矿接受交易的最低gas价格</li>
<li>port:网卡监听端口(默认值:30303)</li>
<li>rpc:启用HTTP-RPC服务器</li>
<li>rpcaddr:HTTP-RPC服务器接口地址(默认值:“localhost”)</li>
<li>rpcport:HTTP-RPC服务器监听端口(默认值:8545)</li>
<li>rpcapi:基于HTTP-RPC接口提供的API</li>
<li>nat: NAT端口映射机制 (any|none|upnp|pmp|extip:<IP>) (默认: “any”)</li>
<li>allow-insecure-unlock:用于解锁账户</li>
</ul>
<p>详细的以太坊启动参数可以参考我的以太坊理论系列，里面有对参数的详细解释。</p>
<hr>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><code>geth</code>位于<code>cmd/geth/main.go</code>文件中，入口如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmkul302pj31gu0mcnd2.jpg" alt="image-20201012152238541"></p>
<p>我们通过这张图可以看出来：main()并不是真正意义上的入口，在初始化完常量和变量以后，会先调用模块的init()函数，然后才是main()函数。所以初始化的工作是在init()函数里完成的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize the CLI app and start Geth</span></span><br><span class="line">	app.Action = geth</span><br><span class="line">	app.HideVersion = <span class="literal">true</span> <span class="comment">// we have a command to print the version</span></span><br><span class="line">	app.Copyright = <span class="string">&quot;Copyright 2013-2019 The go-ethereum Authors&quot;</span></span><br><span class="line">	app.Commands = []cli.Command&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从这我们找到了入口函数geth:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<ol>
<li>准备操作内存缓存配额并设置度量系统</li>
<li>加载配置和注册服务</li>
<li>启动节点</li>
<li>守护当前线程</li>
</ol>
<h2 id="加载配置和注册服务"><a href="#加载配置和注册服务" class="headerlink" title="加载配置和注册服务"></a>加载配置和注册服务</h2><p>makeFullNode</p>
<h3 id="1-加载配置"><a href="#1-加载配置" class="headerlink" title="1.加载配置"></a>1.加载配置</h3><p>makeConfigNode</p>
<p>首先加载默认配置(作为主网节点启动)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := gethConfig&#123;</span><br><span class="line">		Eth:  eth.DefaultConfig,</span><br><span class="line">		Shh:  whisper.DefaultConfig,</span><br><span class="line">		Node: defaultNodeConfig(),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>eth.DefaultConfig</strong> : 以太坊节点的主要参数配置。主要包括: 同步模式(fast)、chainid、交易池配置、gasprice、挖矿配置等；</li>
<li><strong>whisper.DefaultConfig</strong> : 主要用于配置网络间通讯；</li>
<li><strong>defaultNodeConfig()</strong> : 主要用于配置对外提供的RPC节点服务；</li>
<li><strong>dashboard.DefaultConfig</strong> : 主要用于对外提供看板数据访问服务。</li>
</ul>
<p>接着加载自定义配置（适用私有链）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> file := ctx.GlobalString(configFileFlag.Name); file != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := loadConfig(file, &amp;cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后加载命令窗口参数（开发阶段）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">utils.SetNodeConfig(ctx, &amp;cfg.Node) <span class="comment">// 本地节点配置</span></span><br><span class="line">utils.SetEthConfig(ctx, stack, &amp;cfg.Eth)<span class="comment">// 以太坊配置</span></span><br><span class="line">utils.SetShhConfig(ctx, stack, &amp;cfg.Shh)<span class="comment">// whisper配置</span></span><br></pre></td></tr></table></figure>

<h3 id="2-RegisterEthService"><a href="#2-RegisterEthService" class="headerlink" title="2.RegisterEthService"></a>2.RegisterEthService</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterEthService</span><span class="params">(stack *node.Node, cfg *eth.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> cfg.SyncMode == downloader.LightSync &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">			fullNode, err := eth.New(ctx, cfg)</span><br><span class="line">			<span class="keyword">if</span> fullNode != <span class="literal">nil</span> &amp;&amp; cfg.LightServ &gt; <span class="number">0</span> &#123;</span><br><span class="line">				ls, _ := les.NewLesServer(fullNode, cfg)</span><br><span class="line">				fullNode.AddLesServer(ls)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fullNode, err</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		Fatalf(<span class="string">&quot;Failed to register the Ethereum service: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了两个新类型：ServiceContext和Service。</p>
<p>先看一下ServiceContext的定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	config         *Config</span><br><span class="line">	services       <span class="keyword">map</span>[reflect.Type]Service <span class="comment">// Index of the already constructed services</span></span><br><span class="line">	EventMux       *event.TypeMux           <span class="comment">// Event multiplexer used for decoupled notifications</span></span><br><span class="line">	AccountManager *accounts.Manager        <span class="comment">// Account manager created by the node.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceContext主要是存储了一些从结点（或者叫协议栈）那里继承过来的、和具体Service无关的一些信息，比如结点config、account manager等。其中有一个services字段保存了当前正在运行的所有Service.</p>
<p>接下来看一下Service的定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Protocols retrieves the P2P protocols the service wishes to start.</span></span><br><span class="line">	<span class="comment">// 协议检索服务希望启动的P2P协议</span></span><br><span class="line">	Protocols() []p2p.Protocol</span><br><span class="line"></span><br><span class="line">	<span class="comment">// APIs retrieves the list of RPC descriptors the service provides</span></span><br><span class="line">	<span class="comment">// API检索服务提供的RPC描述符列表</span></span><br><span class="line">	APIs() []rpc.API</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start is called after all services have been constructed and the networking</span></span><br><span class="line">	<span class="comment">// layer was also initialized to spawn any goroutines required by the service.</span></span><br><span class="line">	<span class="comment">//在所有服务都已构建完毕并且网络层也已初始化以生成服务所需的所有goroutine之后，将调用start。</span></span><br><span class="line">	Start(server *p2p.Server) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Stop terminates all goroutines belonging to the service, blocking until they</span></span><br><span class="line">	<span class="comment">// are all terminated.</span></span><br><span class="line">	<span class="comment">//Stop终止属于该服务的所有goroutine，直到它们全部终止为止一直阻塞。</span></span><br><span class="line">	Stop() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务注册过程中，主要注册四个服务：EthService、DashboardService、ShhService、EthStatsService，这四种服务类均扩展自Service接口。其中，EthService根据同步模式的不同，分为两种实现：</p>
<ul>
<li>LightEthereum，支持LightSync模式</li>
<li>Ethereum，支持FullSync、FastSync模式</li>
</ul>
<p>LightEthereum作为轻客户端，与Ethereum区别在于，它只需要更新区块头。当需要查询区块体数据时，需要通过调用其他全节点的les服务进行查询；另外，轻客户端本身是不能进行挖矿的。</p>
<p>回到RegisterEthService代码，分两个来讲：</p>
<p>LightSync同步：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = stack.Register(<span class="function"><span class="keyword">func</span><span class="params">(ctx *node.ServiceContext)</span></span> (node.Service, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> les.New(ctx, cfg)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(ctx *node.ServiceContext, config *eth.Config)</span></span> (*LightEthereum, <span class="type">error</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="number">1.</span>ctx.OpenDatabase <span class="comment">// 创建leveldb数据库</span></span><br><span class="line">  <span class="number">2.</span>core.SetupGenesisBlockWithOverride<span class="comment">// 根据创世配置初始化链数据目录</span></span><br><span class="line">  <span class="number">3.</span>实例化本地链id、共识引擎、注册peer节点、帐户管理器以及布隆过滤器的初始化</span><br><span class="line">  <span class="number">4.</span>light.NewLightChain<span class="comment">// 使用数据库中可用的信息返回完全初始化的轻链。它初始化默认的以太坊头</span></span><br><span class="line">  <span class="number">5.</span>light.NewTxPool <span class="comment">// 实例化交易池NewTxPool</span></span><br><span class="line">  <span class="number">6.</span>leth.ApiBackend = &amp;LesApiBackend&#123;ctx.ExtRPCEnabled(), leth, <span class="literal">nil</span>&#125; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FullSync&#x2F;Fast同步：</p>
<ol>
<li><p>参数校验</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> config.SyncMode == downloader.LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> !config.SyncMode.IsValid() &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.Miner.GasPrice == <span class="literal">nil</span> || config.Miner.GasPrice.Cmp(common.Big0) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">if</span> config.NoPruning &amp;&amp; config.TrieDirtyCache &gt; <span class="number">0</span> &#123;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>打开数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx.OpenDatabaseWithFreezer</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据创世配置初始化链数据目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.SetupGenesisBlockWithOverride</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化Ethereum对象</p>
</li>
<li><p>创建BlockChain实例对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.NewBlockChain</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">core.NewTxPool</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化协议管理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">NewProtocolManager(...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化对外API服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;EthAPIBackend&#123;ctx.ExtRPCEnabled(), eth, <span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-RegisterShhService"><a href="#3-RegisterShhService" class="headerlink" title="3.RegisterShhService"></a>3.RegisterShhService</h3><p>注册Whisper服务，用于p2p网络间加密通信。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">whisper.New(cfg), <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RegisterEthStatsService"><a href="#4-RegisterEthStatsService" class="headerlink" title="4.RegisterEthStatsService"></a>4.RegisterEthStatsService</h3><p>注册状态推送服务,将当前以太坊网络状态推送至指定URL地址.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ethstats.New(url, ethServ, lesServ)</span><br></pre></td></tr></table></figure>

<h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><p>启动本地节点以及启动所有注册的服务。</p>
<h3 id="1-启动节点"><a href="#1-启动节点" class="headerlink" title="1.启动节点"></a>1.启动节点</h3><p>startNode</p>
<h4 id="1-1-stack-Start"><a href="#1-1-stack-Start" class="headerlink" title="1.1 stack.Start()"></a>1.1 stack.Start()</h4><ol>
<li><p>实例化p2p.Server对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为注册的服务创建上下文</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">  ctx := &amp;ServiceContext&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>收集协议并启动新组装的p2p server</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">  <span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后启动配置的RPC接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n.startRPC(services)</span><br></pre></td></tr></table></figure>

<ul>
<li>startInProc (启动进程内通讯服务)</li>
<li>startIPC （启动IPC RPC端点）</li>
<li>startHTTP（启动HTTP RPC端点）</li>
<li>startWS （启动websocket RPC端点）</li>
</ul>
</li>
</ol>
<h3 id="2-解锁账户"><a href="#2-解锁账户" class="headerlink" title="2.解锁账户"></a>2.解锁账户</h3><p>unlockAccounts</p>
<p>在datadir&#x2F;keystore目录主要用于记录在当前节点创建的帐户keystore文件。如果你的keystore文件不在本地是无法进行解锁的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解锁datadir/keystore目录中帐户</span></span><br><span class="line">ks := stack.AccountManager().Backends(keystore.KeyStoreType)[<span class="number">0</span>].(*keystore.KeyStore)</span><br><span class="line">	passwords := utils.MakePasswordList(ctx)</span><br><span class="line">	<span class="keyword">for</span> i, account := <span class="keyword">range</span> unlocks &#123;</span><br><span class="line">		unlockAccount(ks, account, i, passwords)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注册钱包事件"><a href="#3-注册钱包事件" class="headerlink" title="3.注册钱包事件"></a>3.注册钱包事件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> accounts.WalletEvent, <span class="number">16</span>)</span><br><span class="line">stack.AccountManager().Subscribe(events)</span><br></pre></td></tr></table></figure>

<h3 id="4-监听钱包事件"><a href="#4-监听钱包事件" class="headerlink" title="4.监听钱包事件"></a>4.监听钱包事件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		<span class="keyword">switch</span> event.Kind &#123;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletArrived:</span><br><span class="line">			<span class="keyword">if</span> err := event.Wallet.Open(<span class="string">&quot;&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Warn(<span class="string">&quot;New wallet appeared, failed to open&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> accounts.WalletOpened:</span><br><span class="line">			status, _ := event.Wallet.Status()</span><br><span class="line">			log.Info(<span class="string">&quot;New wallet appeared&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL(), <span class="string">&quot;status&quot;</span>, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> derivationPaths []accounts.DerivationPath</span><br><span class="line">			<span class="keyword">if</span> event.Wallet.URL().Scheme == <span class="string">&quot;ledger&quot;</span> &#123;</span><br><span class="line">				derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.LegacyLedgerBaseDerivationPath)</span><br><span class="line">			&#125;</span><br><span class="line">			derivationPaths = <span class="built_in">append</span>(derivationPaths, accounts.DefaultBaseDerivationPath)</span><br><span class="line"></span><br><span class="line">			event.Wallet.SelfDerive(derivationPaths, ethClient)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> accounts.WalletDropped:</span><br><span class="line">			log.Info(<span class="string">&quot;Old wallet dropped&quot;</span>, <span class="string">&quot;url&quot;</span>, event.Wallet.URL())</span><br><span class="line">			event.Wallet.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="5-启动挖矿"><a href="#5-启动挖矿" class="headerlink" title="5.启动挖矿"></a>5.启动挖矿</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ethereum.StartMining(threads)</span><br></pre></td></tr></table></figure>

<h2 id="启动守护线程"><a href="#启动守护线程" class="headerlink" title="启动守护线程"></a>启动守护线程</h2><p>stop通道阻塞当前线程，直到节点被停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">node.Wait()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以太坊启动主要就做了3件事，包括加载配置注册服务、启动节点相关服务以及启动守护线程。</p>
<hr>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM介绍</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E4%BB%8B%E7%BB%8D-18/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM介绍</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote>
<p>|-opcodes.go 具体指令集的含义</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM动态数据类型</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-21/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM动态数据类型</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm9mzi9m8j314y0u07wl.jpg" alt="image-20210113185500297"></p>
<p>Solidity提供了在其他编程语言常见的数据类型。除了简单的值类型比如数字和结构体，还有一些其他数据类型，随着数据的增加可以进行动态扩展的动态类型。动态类型的3大类：</p>
<ul>
<li>映射(Mappings)：<code>mapping(bytes32 =&gt; uint256)</code>， <code>mapping(address =&gt; string)</code>等等</li>
<li>数组(Arrays)：<code>[]uint256</code>，<code>[]byte</code>等等</li>
<li>字节数组(Byte arrays)：只有两种类型：<code>string</code>，<code>bytes</code></li>
</ul>
<p>在本系列的第二篇文章中我们看见了固定大小的简单类型在内存中的表示方式。</p>
<ul>
<li>基本数值：<code>uint256</code>，<code>byte</code>等等</li>
<li>定长数组：<code>[10]uint8</code>，<code>[32]byte</code>，<code>bytes32</code></li>
<li>组合了上面类型的结构体</li>
</ul>
<p>固定大小的存储变量都是尽可能的打包成32字节的块然后依次存放在存储器中的。（如果这看起来很陌生，请阅读本系列的第二篇文章： <a href="https://www.jianshu.com/p/9df8d15418ed">固定长度数据类型的表示方法</a></p>
<p>在本文中我们将会研究Solidity是如何支持更加复杂的数据结构的。在表面上看可能Solidity中的数组和映射比较熟悉，但是从它们的实现方式来看在本质上却有着不同的性能特征。</p>
<p>我们会从映射开始，这是三者当中最简单的。数组和字节数组其实就是拥有更加高级特征的映射。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>让我们存储一个数值在<code>uint256 =&gt; uint256</code>映射中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xC0FEFE</span>] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize c-mapping.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 不做任何事情，应该会被优化掉</span></span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  swap1</span><br><span class="line">  dup2</span><br><span class="line">  mstore</span><br><span class="line">  <span class="number">0x20</span></span><br><span class="line">  mstore</span><br><span class="line">  <span class="comment">// 将0x42 存储在地址0x798...187c上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line"> <span class="number">0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>我们可以将EVM想成一个键-值( key-value)数据库，不过每个key都限制为32字节。与其直接使用key<code>0xC0FEFE</code>，不如使用key的哈希值<code>0x798...187c</code>，并且<code>0x42</code>存储在这里。哈希函数使用的是<code>keccak256</code>(SHA256)函数。</p>
<p>在这个例子中我们没有看见<code>keccak256</code>指令本身，因为优化器已经提前计算了结果并內联到了字节码中。在没什么作用的<code>mstore</code>指令中，我们依然可以看到计算的痕迹。</p>
<h2 id="计算地址"><a href="#计算地址" class="headerlink" title="计算地址"></a>计算地址</h2><p>使用一些Python代码来把<code>0xC0FEFE</code>哈希成<code>0x798...187c</code>。如果你想要跟着做下去，你需要安装Python 3.6，或者安装<a href="https://link.jianshu.com/?t=https://pypi.python.org/pypi/pysha3">pysha3</a> 来获得<code>keccak_256</code>哈希函数。</p>
<p>定义两个协助函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> sha3</span><br><span class="line"><span class="comment">#将数值转换成32字节数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytes32</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">return</span> binascii.unhexlify(<span class="string">&#x27;%064x&#x27;</span> % i)</span><br><span class="line"><span class="comment"># 计算32字节数组的 keccak256 哈希值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keccak256</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sha3.keccak_256(x).hexdigest()</span><br></pre></td></tr></table></figure>

<p>将数值转换成32个字节：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01&#x27;</span></span><br><span class="line">&gt;&gt;&gt; bytes32(<span class="number">0xC0FEFE</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xfe\xfe&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>+</code>操作符，将两个字节数组连接起来：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes32(<span class="number">1</span>) + bytes32(<span class="number">2</span>)</span><br><span class="line">b<span class="string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02&#x27;</span></span><br></pre></td></tr></table></figure>

<p>计算一些字节的 keccak256 哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; keccak256(bytes(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以计算<code>0x798...187c</code>了。</p>
<p>存储变量<code>items</code>的位置是<code>0x0</code>（因为它是第一个存储变量）。连接key<code>0xc0fefe</code>和<code>items</code>的位置来获取地址：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xC0FEFE, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xC0FEFE</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为key计算存储地址的公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(bytes32(key) + bytes32(position))</span><br></pre></td></tr></table></figure>

<h2 id="两个映射"><a href="#两个映射" class="headerlink" title="两个映射"></a>两个映射</h2><p>我们先把公式放在这里，后面数值存储时需要计算会用到该公式。</p>
<p>假设我们的合约有两个映射：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsA;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) itemsB;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      itemsA[<span class="number">0xAAAA</span>] = <span class="number">0xAAAA</span>;</span><br><span class="line">      itemsB[<span class="number">0xBBBB</span>] = <span class="number">0xBBBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsA</code>的位置是<code>0</code>，key为<code>0xAAAA</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xAAAA, position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xAAAA</span>) + bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>itemsB</code>的位置为<code>1</code>，key为<code>0xBBBB</code>：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># key = 0xBBBB, position = 1</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0xBBBB</span>) + bytes32(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用编译器来验证一下这些计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping<span class="number">-2.</span>sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ... 忽略可能会被优化掉的内存操作</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="number">0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0xbbbb</span></span><br><span class="line">  <span class="number">0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>跟期望的结果一样。</p>
<h2 id="汇编代码中的KECCAK256"><a href="#汇编代码中的KECCAK256" class="headerlink" title="汇编代码中的KECCAK256"></a>汇编代码中的KECCAK256</h2><p>编译器可以提前计算key的地址是因为相关的值是常量。如果key使用的是变量，那么哈希就必须要在汇编代码中完成。现在我们无效化优化器，来看看在汇编代码中哈希是如何完成的。</p>
<p>事实证明很容易就能让优化器无效，只要引入一个间接的虚变量<code>i</code>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint256) items;</span><br><span class="line">    <span class="comment">//这个变量会造成常量的优化失败</span></span><br><span class="line">    uint256 i = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[i] = <span class="number">0x42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量<code>items</code>的位置依然是<code>0x0</code>，所以我们应该期待地址与之前是一样的。</p>
<p>加上优化选项进行编译，但是这次不会提前计算哈希值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">solc --bin --<span class="keyword">asm</span> --optimize  c-mapping--no-constant-folding.sol</span><br></pre></td></tr></table></figure>

<p>注释的汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 加载`i` 到栈中</span></span><br><span class="line">  sload(<span class="number">0x1</span>)</span><br><span class="line">    [<span class="meta">0xC0FEFE</span>]</span><br><span class="line">  <span class="comment">// 将key`0xC0FEFE`存放在内存中的0x0位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0xC0FEFE 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0xC0FEFE 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将位置 `0x0` 存储在内存中的 0x20 (32)位置上，为哈希做准备</span></span><br><span class="line">  <span class="number">0x20</span> <span class="comment">// 32</span></span><br><span class="line">    [<span class="meta">0x20 0x0</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x0 0x20 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x20 0x0 0x0</span>]</span><br><span class="line">  mstore</span><br><span class="line">    [<span class="meta">0x0</span>]</span><br><span class="line">    memory: &#123;</span><br><span class="line">      <span class="number">0x00</span> =&gt; <span class="number">0xC0FEFE</span></span><br><span class="line">      <span class="number">0x20</span> =&gt; <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从第0个字节开始，哈希在内存中接下来的0x40(64)个字节</span></span><br><span class="line">  <span class="number">0x40</span> <span class="comment">// 64</span></span><br><span class="line">    [<span class="meta">0x40 0x0</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x0 0x40</span>]</span><br><span class="line">  keccak256</span><br><span class="line">    [<span class="meta">0x798...187c</span>]</span><br><span class="line">  <span class="comment">// 将0x42 存储在计算的地址上</span></span><br><span class="line">  <span class="number">0x42</span></span><br><span class="line">    [<span class="meta">0x42 0x798...187c</span>]</span><br><span class="line">  swap1</span><br><span class="line">    [<span class="meta">0x798...187c 0x42</span>]</span><br><span class="line">  sstore</span><br><span class="line">    store: &#123;</span><br><span class="line">      <span class="number">0x798</span>..<span class="number">.187</span>c =&gt; <span class="number">0x42</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>mstore</code>指令写入32个字节到内存中。内存操作便宜很多，只需要3 gas就可以读取和写入。前半部分的汇编代码就是通过将key和位置加载到相邻的内存块中来进行“连接”的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">31</span>  <span class="number">32</span>                 <span class="number">63</span></span><br><span class="line"><span class="punctuation">[</span>    key (<span class="number">32</span> bytes)    <span class="punctuation">]</span><span class="punctuation">[</span> position (<span class="number">32</span> bytes) <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>然后<code>keccak256</code>指令哈希内存中的数据。成本取决于被哈希的数据有多少：</p>
<ul>
<li>每个SHA3操作需要支付 30 gas</li>
<li>每个32字节的字需要支付 6 gas</li>
</ul>
<p>对于一个<code>uint256</code>类型key，gas的成本是42：<code>30 + 6 * 2</code>。</p>
<h2 id="映射大数值"><a href="#映射大数值" class="headerlink" title="映射大数值"></a>映射大数值</h2><p>每个存储槽只能存储32字节。如果我们尝试存储一个更大一点的结构体会怎么样？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> <span class="title class_">Tuple</span>) tuples;</span><br><span class="line">    struct <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">a</span> = <span class="number">0x1A</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">b</span> = <span class="number">0x1B</span>;</span><br><span class="line">      tuples[<span class="number">0x1</span>].<span class="property">c</span> = <span class="number">0x1C</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，你会看见3个<code>sstore</code>指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">//忽略未优化的代码</span></span><br><span class="line">  <span class="number">0x1a</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1b</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e</span></span><br><span class="line">  sstore</span><br><span class="line">  <span class="number">0x1c</span></span><br><span class="line">  <span class="number">0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意计算的地址除了最后一个数字其他都是一样的。<code>Tulp</code>结构体成员是依次排列的(..7d, ..7e, ..7f)。</p>
<h2 id="映射不会打包"><a href="#映射不会打包" class="headerlink" title="映射不会打包"></a>映射不会打包</h2><p>考虑到映射的设计方式，每项需要的最小存储空间是32字节，即使你实际只需要存储1个字节：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="title function_">mapping</span>(<span class="function"><span class="params">uint256</span> =&gt;</span> uint8) items;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items[<span class="number">0xA</span>] = <span class="number">0xAA</span>;</span><br><span class="line">      items[<span class="number">0xB</span>] = <span class="number">0xBB</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个数值大于32字节，那么你需要的存储空间会以32字节依次增加。</p>
<h2 id="动态数组是映射的升级"><a href="#动态数组是映射的升级" class="headerlink" title="动态数组是映射的升级"></a>动态数组是映射的升级</h2><p>在典型语言中，数组只是连续存储在内存中一系列相同类型的元素。假设你有一个包含100个<code>uint8</code>类型的元素数组，那么这就会占用100个字节的内存。这种模式的话，将整个数组加载到CPU的缓存中然后循环遍历每个元素会便宜一点。</p>
<p>对于大多数语言而言，数组比映射都会便宜一些。不过在Solidity中，数组是更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br></pre></td></tr></table></figure>

<p>但是请记住，对于这些存储槽的每次访问实际上就像数据库中的key-value的查找一样。访问一个数组的元素跟访问一个映射的元素是没什么区别的。</p>
<p>思考一下<code>[]uint256</code>类型，它本质上与<code>mapping(uint256 =&gt; uint256)</code>是一样的，只不过后者多了一点特征，让它看起去就像数组一样。</p>
<ul>
<li><code>length</code>表示一共有多少个元素</li>
<li>边界检查。当读取或写入时索引值大于<code>length</code>就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小时，自动清除未使用的存储槽</li>
<li><code>bytes</code>和<code>string</code>的特殊优化让短数组(小于32字节)存储更加高效</li>
</ul>
<h2 id="简单数组"><a href="#简单数组" class="headerlink" title="简单数组"></a>简单数组</h2><p>看一下保存3个元素的数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-darray.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[] chunks;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">      chunks.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组访问的汇编代码难以追踪，使用<a href="https://link.jianshu.com/?t=https://remix.ethereum.org/">Remix</a>调试器来运行合约：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8388873-3f80ed93b21b374a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>模拟的最后，我们可以看到有4个存储槽被使用了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000bb</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x00000000000000000000000000000000000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p><code>chunks</code>变量的位置是<code>0x0</code>，用来存储数组的长度（<code>0x3</code>），哈希变量的位置来找到存储数组数据的地址：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个地址上数组的每个元素依次排列（<code>0x29..63</code>，<code>0x29..64</code>，<code>0x29..65</code>）。</p>
<h2 id="动态数据打包"><a href="#动态数据打包" class="headerlink" title="动态数据打包"></a>动态数据打包</h2><p>所有重要的打包行为是什么样的？数组与映射比较，数组的一个优势就是打包。拥有4个元素的<code>uint128[]</code>数组元素刚刚好需要2个存储槽（再加1个存储槽用来存储长度）。</p>
<p>思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint128[] s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">        s[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">        s[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">        s[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行这个代码，存储器的最后看起来像这样：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000bb000000000000000000000000000000aa</span></span><br><span class="line">key: <span class="number">0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0x000000000000000000000000000000dd000000000000000000000000000000cc</span></span><br></pre></td></tr></table></figure>

<p>只有三个存储槽被使用了，跟预料的一样。长度再次存储在存储变量的<code>0x0</code>位置上。4个元素被打包放入两个独立的存储槽中。该数组的开始地址是变量位置的哈希值：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># position = 0</span></span><br><span class="line">&gt;&gt;&gt; keccak256(bytes32(<span class="number">0</span>))</span><br><span class="line"><span class="string">&#x27;290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在的地址是每两个数组元素增加一次，看起来很好！</p>
<p>但是汇编代码本身优化的并不好。因为使用了两个存储槽，所以我们会希望优化器使用两个<code>sstore</code>指令来完成任务。不幸的是，由于边界检查(和一些其他因素)，所以没有办法将<code>sstore</code>指令优化掉。</p>
<p>使用4个<code>sstore</code>指令才能完成任务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:105:116  s[0] = 0xAA */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:126:137  s[1] = 0xBB */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:147:158  s[2] = 0xCC */</span><br><span class="line">sstore</span><br><span class="line">/* <span class="string">&quot;c-bytes--sstore-optimize-fail.sol&quot;</span>:168:179  s[3] = 0xDD */</span><br><span class="line">sstore</span><br></pre></td></tr></table></figure>

<h3 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h3><p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度小于31字节，只需要1个存储槽来存储整个数组。长一点的字节数组跟正常数组的表示方式差不多。</p>
<p>看看短一点的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xAA</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xBB</span>);</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="number">0xCC</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组只有3个字节（小于31字节），所以它只占用1个存储槽。在Remix中运行，存储看起来如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">key: <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">value</span>: <span class="number">0xaabbcc0000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<p>数据<code>0xaabbcc...</code>从左到右的进行存储。后面的0是空数据。最后的<code>0x06</code>字节是数组的编码长度。公式是<code>长度=编码长度/2</code>，在这个例子中实际长度是<code>6/2=3</code>。</p>
<p><code>string</code>与<code>bytes</code>的原理一模一样。</p>
<h2 id="长字节数组"><a href="#长字节数组" class="headerlink" title="长字节数组"></a>长字节数组</h2><p>如果数据的长度大于31字节，字节数组就跟<code>[]byte</code>一样。来看一下长度为128字节的字节数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c-bytes--long.sol</span></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    bytes s;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        s.<span class="property">length</span> = <span class="number">32</span> * <span class="number">4</span>;</span><br><span class="line">        s[<span class="number">31</span>] = <span class="number">0x1</span>;</span><br><span class="line">        s[<span class="number">63</span>] = <span class="number">0x2</span>;</span><br><span class="line">        s[<span class="number">95</span>] = <span class="number">0x3</span>;</span><br><span class="line">        s[<span class="number">127</span>] = <span class="number">0x4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Remix中运行，可以看见使用了4个存储槽：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>x0000...<span class="number">0000</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0101</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e563</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0001</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e564</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0002</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e565</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0003</span></span><br><span class="line"><span class="number">0</span>x290d..<span class="selector-class">.e566</span></span><br><span class="line"><span class="number">0</span>x0000...<span class="number">0004</span></span><br></pre></td></tr></table></figure>

<p><code>0x0</code>的存储槽不再用来存储数据，整个存储槽现在存储编码的数组长度。要获得实际长度，使用<code>长度=（编码长度-1）/2</code>公式。在这个例子中长度是<code>（0x101 - 1）/2=128</code>。实际的字节被保存在<code>0x290d...e563</code>，并且存储槽是连续的。</p>
<p>字节数组的汇编代码相当多。除了正常的边界检查和数组恢复大小等，它还需要对长度进行编码&#x2F;解码，以及注意长字节数组和短字节数组之间的转换。</p>
<blockquote>
<p>为什么要编码长度？因为编码之后，可以很容易的测试出来字节数组是长还是短。注意对于长数组而言编码长度总是奇数，而短数组的编码长度总是偶数。汇编代码只需要查看一下最后一位是否为0，为0就是偶数（短数组），非0就是奇数（长数组）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查看Solidity编译器的内部工作，可以看见熟悉的数据结构例如映射和数组与传统编程语言完全不同。</p>
<p>概括：</p>
<ul>
<li>数组跟映射一样，非高效</li>
<li>比映射的汇编代码更加复杂</li>
<li>小类型(<code>byte</code>，<code>uint8</code>，<code>string</code>)时存储比映射高效</li>
<li>汇编代码优化的不是很好。即使是打包，每个任务都会有一个<code>sstore</code>指令</li>
</ul>
<p>EVM的存储器就是一个键值数据库，跟git很像。如果你改变了任一东西，根节点的校验和也会改变。如果两个根节点拥有相同的校验和，存储的数据就能保证是一样的。</p>
<p>为了体会Solidity和EVM的奇特，可以想象一下在git仓库里数组里面的每个元素都是它自己的文件。当你改变数组里一个元素的值，实际上就相当于创建了一个提交。当你迭代一个数组时，你不能一次性的加载整个数组，你必须要到仓库中进行查找并分别找到每个文件。</p>
<p>不仅仅这样，每个文件都限制到32字节！因为我们需要将数据结构都分割成32字节的块，Solidity编译器的所有逻辑和优化都是很负责的，全部在汇编的时候完成。</p>
<p>不过32字节的限制是完全任意的。支持键值存储的可以使用key来存储任意类型的数值。也许未来我们添加新的EVM指令使用key来存储任意的字节数组。</p>
<p>不过现在，EVM存储器就是一个伪装成32字节数组的键值数据库。</p>
<blockquote>
<p>可以看看<a href="https://link.jianshu.com/?t=https://github.com/ethereum/solidity/blob/3b07c4d38e40c52ee8a4d16e56e2afa1a0f27905/libsolidity/codegen/ArrayUtils.cpp#L624">ArrayUtils::resizeDynamicArray</a> 来了解一下当恢复数组大小时编译器的动作。正常情况下数据结构都会作为语言的标准库来完成的，但是在Solidity中嵌入到了编译器里面。</p>
</blockquote>
<blockquote>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕hyperledger fabric源码|Committer记账节点</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95hyperledger%20fabric%E6%BA%90%E7%A0%81_Committer%E8%AE%B0%E8%B4%A6%E8%8A%82%E7%82%B9-8/</url>
    <content><![CDATA[<blockquote>
<p>死磕hyperledger fabric源码|Committer记账节点</p>
<p>文章及代码：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>分支：v1.1.0</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn3h9nzkclj31c00u0wt0.jpg" alt="facdd49577decf1dc62abc9fc97caf97"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Committer</code>记账节点功能模块的设计与实现的源代码主要分布在下表：</p>
<table>
<thead>
<tr>
<th align="center">源码目录</th>
<th align="center"></th>
<th align="center">文件</th>
<th align="center">功能阐述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">core</td>
<td align="center">committer</td>
<td align="center">Txvalidator</td>
<td align="center">交易验证器功能模块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">committer.go</td>
<td align="center">账本提交器接口定义</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">committer_impl.go</td>
<td align="center">账本提交器实现</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">ledger</td>
<td align="center">kvledge</td>
<td align="center">kvLedger账本功能模块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ledgerstorage</td>
<td align="center">账本数据存储对象模块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">pvtdatastorage</td>
<td align="center">隐私数据存储对象模块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">ledgermgmt</td>
<td align="center">账本管理模块</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">customtx</td>
<td align="center">配置交易处理器模块</td>
</tr>
<tr>
<td align="center">common</td>
<td align="center">ledger</td>
<td align="center">blockstorage</td>
<td align="center">区块存储模块</td>
</tr>
<tr>
<td align="center">protos</td>
<td align="center">Common</td>
<td align="center">ledger</td>
<td align="center">protobuf消息定义模块</td>
</tr>
</tbody></table>
<p>接下来将会围绕着这部分的内容进行分析。</p>
<h2 id="创建Committer功能模块"><a href="#创建Committer功能模块" class="headerlink" title="创建Committer功能模块"></a>创建Committer功能模块</h2><p>Peer节点通过请求调用<code>CSCC</code>系统链码加入应用通道，执行<code>joinChain()→peer.Create- ChainFromBlock()→createChain()</code>函数，基于应用通道创世区块创建通道的链结构对象，用于管理账本、通道配置等资源，以正常接收通道的账本区块。</p>
<p>接着，创建了交易验证器，并封装了<code>vsccValidatorImpl</code>结构对象用于支持调用VSCC链码。</p>
<p>然后，创建账本提交器，并定义回调函数<code>eventer</code>，用于提交账本后自动更新链结构上的最新配置区块对象。</p>
<p>现在进入到<code>createChain</code>里面分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createChain</span><span class="params">(cid <span class="type">string</span>, ledger ledger.PeerLedger, cb *common.Block)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">  vcs := <span class="keyword">struct</span> &#123; <span class="comment">// 构造新的验证链码支持对象</span></span><br><span class="line">		*chainSupport</span><br><span class="line">		*semaphore.Weighted</span><br><span class="line">		Support</span><br><span class="line">	&#125;&#123;cs, validationWorkersSemaphore, GetSupport()&#125;</span><br><span class="line">	validator := txvalidator.NewTxValidator(vcs) <span class="comment">// 创建交易验证器</span></span><br><span class="line">	<span class="comment">// 创建账本提交器</span></span><br><span class="line">	c := committer.NewLedgerCommitterReactive(ledger, <span class="function"><span class="keyword">func</span><span class="params">(block *common.Block)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		chainID, err := utils.GetChainIDFromBlock(block)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> SetCurrConfigBlock(block, chainID)</span><br><span class="line">	&#125;)</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// 创建transient隐私数据存储对象</span></span><br><span class="line">	store, err := transientStoreFactory.OpenStore(bundle.ConfigtxValidator().ChainID())</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 初始化指定通道上的Gossip消息模块。</span></span><br><span class="line">	<span class="comment">// 若是主节点，则从Orderer服务节点获取区块数据。否则，从组织内其他节点同步数据</span></span><br><span class="line">	service.GetGossipService().InitializeChannel(bundle.ConfigtxValidator().ChainID(), ordererAddresses, service.Support&#123;</span><br><span class="line">		Validator: validator,</span><br><span class="line">		Committer: c,</span><br><span class="line">		Store:     store,</span><br><span class="line">		Cs:        simpleCollectionStore,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	chains.Lock()</span><br><span class="line">	<span class="keyword">defer</span> chains.Unlock()</span><br><span class="line">	<span class="comment">// 构造新的链结构并插入Peer节点链结构</span></span><br><span class="line">	chains.list[cid] = &amp;chain&#123;</span><br><span class="line">		cs:        cs, <span class="comment">// 链支持对象</span></span><br><span class="line">		cb:        cb, <span class="comment">// 配置区块</span></span><br><span class="line">		committer: c,  <span class="comment">// 账本提交器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="验证交易数据的合法性"><a href="#验证交易数据的合法性" class="headerlink" title="验证交易数据的合法性"></a>验证交易数据的合法性</h2><p>验证交易入口：<code>core/committer/txvalidator/validator.go/validateTx()</code>,主要做了以下几件事</p>
<p>①：<em>解析获取交易数据的Envelope结构对象</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> env, err := utils.GetEnvelopeFromBlock(d); err != <span class="literal">nil</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>检查交易格式是否正确、签名是否合法、交易内容是否被篡改</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> payload, txResult = validation.ValidateTransaction(env, v.support.Capabilities()); txResult != peer.TxValidationCode_VALID &#123;</span><br><span class="line">			logger.Errorf(<span class="string">&quot;Invalid transaction with index %d&quot;</span>, tIdx)</span><br><span class="line">			results &lt;- &amp;blockValidationResult&#123;</span><br><span class="line">				tIdx:           tIdx,</span><br><span class="line">				validationCode: txResult,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：<em>解析获取通道头部</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader)</span><br></pre></td></tr></table></figure>

<p>④：<em>检查通道链结构是否存在</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">channel := chdr.ChannelId</span><br><span class="line"><span class="keyword">if</span> !v.chainExists(channel) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>⑤：<em>根据<code>Header</code>的类型来分别处理消息</em></p>
<p>5.1 <em>普通交易消息</em></p>
<p>先从账本获取指定交易的ID数据，检查是否存在，然后获取交易读写集，并检查写集的合法性，调用<code>VSCC</code>验证交易背书策略，接着获取交易链码实例，并设置调用链码实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">txID = chdr.TxId</span><br><span class="line"><span class="comment">// 从账本获取指定交易的ID数据，检查是否存在</span></span><br><span class="line"><span class="keyword">if</span> _, err := v.support.Ledger().GetTransactionByID(txID); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取交易读写集，并检查写集的合法性，调用VSCC验证交易背书策略</span></span><br><span class="line">err, cde := v.vscc.VSCCValidateTx(payload, d, env)</span><br><span class="line">i..</span><br><span class="line"><span class="comment">// 获取交易链码实例</span></span><br><span class="line">invokeCC, upgradeCC, err := v.getTxCCInstance(payload)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设置调用链码实例</span></span><br><span class="line">txsChaincodeName = invokeCC</span><br></pre></td></tr></table></figure>

<p>5.2 <em>通道配置交易消息</em></p>
<p>先解析获取配置交易对象，然后更新通道配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道配置交易消息，解析获取配置交易对象</span></span><br><span class="line">configEnvelope, err := configtx.UnmarshalConfigEnvelope(payload.Data)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 更新通道配置</span></span><br><span class="line"><span class="keyword">if</span> err := v.support.Apply(configEnvelope); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.3 如果是<em>Peer资源更新消息</em>，直接构造<code>blockValidationResult</code>返回</p>
<p>⑥：<em>序列化封装交易Envelope结构对象</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := proto.Marshal(env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">&quot;Cannot marshal transaction: %s&quot;</span>, err)</span><br><span class="line">			results &lt;- &amp;blockValidationResult&#123;</span><br><span class="line">				tIdx:           tIdx,</span><br><span class="line">				validationCode: peer.TxValidationCode_MARSHAL_TX_ERROR,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>⑦：<em>最后通过了交易，基于上述参数构造区块验证结果对象</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">results &lt;- &amp;blockValidationResult&#123;</span><br><span class="line">			tIdx:                 tIdx,</span><br><span class="line">			txsChaincodeName:     txsChaincodeName,</span><br><span class="line">			txsUpgradedChaincode: txsUpgradedChaincode,</span><br><span class="line">			validationCode:       peer.TxValidationCode_VALID,</span><br><span class="line">			txid:                 txID,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="账本提交器"><a href="#账本提交器" class="headerlink" title="账本提交器"></a>账本提交器</h2><p>账本提交器的<code>LedgerCommitter.CommitWithPvtData()</code>方法负责执行具体的账本提交工作。该方法首先调用<code>LedgerCommitter</code>对象的<code>lc.preCommit(blockAndPvtData.Block)</code>方法，预处理待提交的区块数据，对于配置区块执行自定义<code>lc.eventer(block)</code>回调函数，即从当前区块中解析出链ID，再调用<code>SetCurrConfigBlock</code>()函数，从本地链结构字典中获取关联的链结构<code>chains.list[cid]</code>并更新其最新的配置区块。接着，调用<code>lc.PeerLedger.CommitWithPvtData(blockAndPvtData)→kvLedger.CommitWithPvtData()</code>方法提交数据到账本中，这是账本提交器的核心工作方法。当成功提交账本后，调用<code>lc.postCommit(blockAndPvtData.Block)</code>方法，基于该区块创建区块事件与过滤区块事件，并执行<code>producer.Send()</code>方法将两个事件发送到事件服务器，通知订阅客户端有新区块到达。</p>
<p>进入到<code>CommitWithPvtData</code>()方法中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *kvLedger)</span></span> CommitWithPvtData(pvtdataAndBlock *ledger.BlockAndPvtData) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	block := pvtdataAndBlock.Block                 <span class="comment">// 获取区块对象</span></span><br><span class="line">	blockNo := pvtdataAndBlock.Block.Header.Number <span class="comment">// 获取区块号</span></span><br><span class="line">	<span class="comment">// 验证并准备区块和隐私数据对象</span></span><br><span class="line">	err = l.txtmgmt.ValidateAndPrepare(pvtdataAndBlock, <span class="literal">true</span>)</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//提交区块和隐私数据到账本中</span></span><br><span class="line">	<span class="keyword">if</span> err = l.blockStore.CommitWithPvtData(pvtdataAndBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	...	</span><br><span class="line">	<span class="keyword">if</span> err = l.txtmgmt.Commit(); err != <span class="literal">nil</span> &#123; <span class="comment">// 更新有效交易数据到状态数据库</span></span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">`Error during commit to txmgr:%s`</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ledgerconfig.IsHistoryDBEnabled() &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Channel [%s]: Committing block [%d] transactions to history database&quot;</span>, l.ledgerID, blockNo)</span><br><span class="line">		<span class="keyword">if</span> err := l.historyDB.Commit(block); err != <span class="literal">nil</span> &#123; <span class="comment">// 更新区块数据到历史数据库</span></span><br><span class="line">			<span class="built_in">panic</span>(fmt.Errorf(<span class="string">`Error during commit to history db:%s`</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数主要也就做了以下比较关键的事情：</p>
<ul>
<li><code>ValidateAndPrepare</code>:验证并准备区块和隐私数据对象</li>
<li><code>CommitWithPvtData</code>:提交区块和隐私数据到账本中</li>
<li><code>txtmgmt.Commit()</code>:更新有效交易数据到状态数据库</li>
<li><code>l.historyDB.Commit(block)</code>:更新区块数据到历史数据库</li>
</ul>
<p>接下来将分别介绍这些功能的细节。</p>
<h3 id="验证并准备区块和隐私数据对象"><a href="#验证并准备区块和隐私数据对象" class="headerlink" title="验证并准备区块和隐私数据对象"></a>验证并准备区块和隐私数据对象</h3><p>函数调用：</p>
<blockquote>
<p>err &#x3D; l.txtmgmt.ValidateAndPrepare(pvtdataAndBlock, true)</p>
<p>-&gt; batch, err :&#x3D; txmgr.validator.ValidateAndPrepareBatch(blockAndPvtdata, doMVCCValidation)</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateAndPreparePvtBatch</span><span class="params">(block *valinternal.Block, pvtdata <span class="keyword">map</span>[<span class="type">uint64</span>]*ledger.TxPvtData)</span></span> (*privacyenabledstate.PvtUpdateBatch, <span class="type">error</span>) &#123;</span><br><span class="line">	pvtUpdates := privacyenabledstate.NewPvtUpdateBatch()</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Txs &#123;</span><br><span class="line">		<span class="keyword">if</span> tx.ValidationCode != peer.TxValidationCode_VALID &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !tx.ContainsPvtWrites() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		txPvtdata := pvtdata[<span class="type">uint64</span>(tx.IndexInBlock)] <span class="comment">// 获取指定交易的隐私数据</span></span><br><span class="line">		<span class="keyword">if</span> txPvtdata == <span class="literal">nil</span> &#123;                         <span class="comment">// 跳过没有隐私数据的交易</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查是否需要验证隐私数据，默认都返回true</span></span><br><span class="line">		<span class="keyword">if</span> requiresPvtdataValidation(txPvtdata) &#123;</span><br><span class="line">			<span class="comment">// 验证隐私数据哈希值是否匹配</span></span><br><span class="line">			<span class="keyword">if</span> err := validatePvtdata(tx, txPvtdata); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> pvtRWSet *rwsetutil.TxPvtRwSet</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="comment">// 解析隐私数据写集合</span></span><br><span class="line">		<span class="keyword">if</span> pvtRWSet, err = rwsetutil.TxPvtRwSetFromProtoMsg(txPvtdata.WriteSet); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 添加到隐私数据更新批量操作</span></span><br><span class="line">		addPvtRWSetToPvtUpdateBatch(pvtRWSet, pvtUpdates, version.NewHeight(block.Num, <span class="type">uint64</span>(tx.IndexInBlock)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pvtUpdates, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先遍历当前内部区块的交易列表<code>block.Txs</code>，对于其中的每个交易对象tx，需要过滤掉如下三类交易。</p>
<ul>
<li>交易验证码不为<code>TxValidationCode_VALID</code>的无效交易</li>
<li>不存在隐私数据写数据哈希值的交易</li>
<li>无隐私数据的交易</li>
</ul>
<p>如果交易通过了上述检查，则对于合法有效的交易tx及其隐私数据txPvtdata（TxPvt-Data类型），调用<code>validatePvtdata(tx，txPvtdata)</code>方法，以验证隐私数据哈希值的正确性，因为隐私数据都是由<code>Endorser</code>背书节点生成的，需要检查传播后的数据是否被篡改过。大致的过程如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validatePvtdata</span><span class="params">(tx *valinternal.Transaction, pvtdata *ledger.TxPvtData)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> _, nsPvtdata := <span class="keyword">range</span> pvtdata.WriteSet.NsPvtRwset &#123;</span><br><span class="line">		<span class="keyword">for</span> _, collPvtdata := <span class="keyword">range</span> nsPvtdata.CollectionPvtRwset &#123;</span><br><span class="line">			<span class="comment">// 基于原始数据计算隐私数据哈希值</span></span><br><span class="line">			collPvtdataHash := util.ComputeHash(collPvtdata.Rwset)</span><br><span class="line">			<span class="comment">// 获取 交易中的数据哈希值</span></span><br><span class="line">			hashInPubdata := tx.RetrieveHash(nsPvtdata.Namespace, collPvtdata.CollectionName)</span><br><span class="line">			<span class="comment">// 比较隐私数据哈希值</span></span><br><span class="line">			<span class="keyword">if</span> !bytes.Equal(collPvtdataHash, hashInPubdata) &#123;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提交区块和隐私数据到账本中"><a href="#提交区块和隐私数据到账本中" class="headerlink" title="提交区块和隐私数据到账本中"></a>提交区块和隐私数据到账本中</h3><p>函数调用：<strong>l.blockStore.CommitWithPvtData(pvtdataAndBlock)</strong></p>
<blockquote>
<p>core&#x2F;ledger&#x2F;ledgerstorage&#x2F;store.go&#x2F;CommitWithPvtData</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span></span> CommitWithPvtData(blockAndPvtdata *ledger.BlockAndPvtData) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> blockAndPvtdata.BlockPvtData &#123;</span><br><span class="line">		<span class="comment">// 添加隐私数据到隐私数据列表pvtdata</span></span><br><span class="line">		pvtdata = <span class="built_in">append</span>(pvtdata, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 准备将隐私数据列表pvtdata提交到账本中，先提交再确认</span></span><br><span class="line">	<span class="keyword">if</span> err := s.pvtdataStore.Prepare(blockAndPvtdata.Block.Header.Number, pvtdata); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提交区块到账本中</span></span><br><span class="line">	<span class="keyword">if</span> err := s.AddBlock(blockAndPvtdata.Block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.pvtdataStore.Rollback()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确认提交隐私数据</span></span><br><span class="line">	<span class="keyword">return</span> s.pvtdataStore.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概就做了以下几件事：</p>
<ol>
<li>准备提交隐私数据：<code>Prepare</code></li>
<li>提交区块数据：<code>s.AddBlock</code></li>
<li>确认提交隐私数据：<code>s.pvtdataStore.Commit()</code></li>
</ol>
<p>①：准备提交隐私数据</p>
<p>通过隐私数据存储对象调用s.pvtdataStore.Prepare()→store.Prepare()方法，将pvtdata列表中的每个隐私数据对象重新编码并构成KV键值对，添加到账本上隐私数据库的更新批量操作中，并同步更新到数据库中。最后，等待区块数据提交操作确认后，根据提交结果状态确认提交或回滚恢复隐私数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Prepare(blockNum <span class="type">uint64</span>, pvtData []*ledger.TxPvtData) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 检查合法性，执行Prepare()时应该是false，因为Commit和Rollback操作会重置该标志位</span></span><br><span class="line">	<span class="keyword">if</span> s.batchPending &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;ErrIllegalCall&#123;<span class="string">`A pending batch exists as as result of last invoke to &quot;Prepare&quot; call.</span></span><br><span class="line"><span class="string">			 Invoke &quot;Commit&quot; or &quot;Rollback&quot; on the pending batch before invoking &quot;Prepare&quot; function`</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取下一个区块号</span></span><br><span class="line">	expectedBlockNum := s.nextBlockNum()</span><br><span class="line">	<span class="comment">// 检查区块号的合法性</span></span><br><span class="line">	<span class="keyword">if</span> expectedBlockNum != blockNum &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;ErrIllegalArgs&#123;fmt.Sprintf(<span class="string">&quot;Expected block number=%d, recived block number=%d&quot;</span>, expectedBlockNum, blockNum)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建数据库更新操作集合batch，记录所有需要删除或增加数据的key键</span></span><br><span class="line">	batch := leveldbhelper.NewUpdateBatch()</span><br><span class="line">	<span class="keyword">var</span> key, value []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="comment">// 遍历隐私数据列表，构造该隐私数据KV键值对</span></span><br><span class="line">	<span class="keyword">for</span> _, txPvtData := <span class="keyword">range</span> pvtData &#123;</span><br><span class="line">		<span class="comment">// 遍历隐私数据列表，构造该隐私数据KV键值对</span></span><br><span class="line">		key = encodePK(blockNum, txPvtData.SeqInBlock)</span><br><span class="line">		<span class="keyword">if</span> value, err = encodePvtRwSet(txPvtData.WriteSet); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 构造value值：隐私数据写集合</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Adding private data to LevelDB batch for block [%d], tran [%d]&quot;</span>, blockNum, txPvtData.SeqInBlock)</span><br><span class="line">		<span class="comment">// 添加隐私数据键值对的操作</span></span><br><span class="line">		batch.Put(key, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加pendingCommitKey键值对的操作</span></span><br><span class="line">	batch.Put(pendingCommitKey, emptyValue)</span><br><span class="line">	<span class="comment">// 同步执行数据库的更新操作集合</span></span><br><span class="line">	<span class="keyword">if</span> err := s.db.WriteBatch(batch, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新状态标志位</span></span><br><span class="line">	s.batchPending = <span class="literal">true</span></span><br><span class="line">	logger.Debugf(<span class="string">&quot;Saved %d private data write sets for block [%d]&quot;</span>, <span class="built_in">len</span>(pvtData), blockNum)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：提交区块数据</p>
<p>调用<code>s.AddBlock(blockAndPvtdata.Block)</code>方法，实际上是通过区块文件管理器，调用<code>blockfileMgr.addBlock()</code>方法，提交新区块<code>blockAndPvt-data.Block</code>到区块数据文件中，并保存新的区块检查点信息<code>newCPInfo</code>。接着，调用<code>indexBlock()</code>方法，建立当前区块的索引信息与索引检查点信息（当前区块号等），更新到区块索引数据库中。然后，调用<code>mgr.updateCheckpoint(newCPInfo)</code>方法，更新区块文件管理器上的区块检查点信息，再执行mgr.cpInfoCond.Broadcast()方法，广播唤醒所有等待该同步条件变量的程序，通知已有新区块提交到账本中。最后，调用<code>mgr.updateBlockchain-Info()</code>方法，更新区块链信息，如最新区块高度、最新区块头哈希值等。</p>
<p>③：确认提交隐私数据</p>
<p>调用 <code>s.pvtdataStore.Commit()</code>方法，执行隐私数据的提交确认操作。由于前面的<code>Prepare()</code>方法已经更新了所有的隐私数据键值对到数据库中，因此，该方法实际上是在隐私数据库上删除<code>pendingCommitKey</code>键值对，并添加<code>lastCommittedBlkkey</code>键值对，以保存最近提交成功的区块号<code>committingBlockNum</code>。最后，更新隐私数据相关标志位与变量，将等待提交确认标志位batchPending与标志位<code>isEmpty</code>设置为<code>false</code>，将<code>lastCommitted-Block</code>更新为提交账本的区块号<code>committingBlockNum</code>。 </p>
<p>如果提交区块数据失败，则<code>CommitWithPvtData()</code>将通过隐私数据存储对象调用s.pvt-dataStore.Rollback()方法执行回滚操作，将已提交的隐私数据恢复到提交数据库之前的状态。</p>
<h3 id="提交数据到状态数据库"><a href="#提交数据到状态数据库" class="headerlink" title="提交数据到状态数据库"></a>提交数据到状态数据库</h3><p>入口：<strong>core&#x2F;ledger&#x2F;kvledger&#x2F;txmgmt&#x2F;txmgr&#x2F;lockbasedtxmgr&#x2F;lockbased_txmgr.go&#x2F; Commit()</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txmgr *LockBasedTxMgr)</span></span> Commit() <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> err := txmgr.db.ApplyPrivacyAwareUpdates(txmgr.batch,</span><br><span class="line">		version.NewHeight(txmgr.currentBlock.Header.Number, <span class="type">uint64</span>(<span class="built_in">len</span>(txmgr.currentBlock.Data.Data)<span class="number">-1</span>)))</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CommonStorageDB)</span></span> ApplyPrivacyAwareUpdates(updates *UpdateBatch, height *version.Height) <span class="type">error</span> &#123;</span><br><span class="line">	addPvtUpdates(updates.PubUpdates, updates.PvtUpdates)</span><br><span class="line">	addHashedUpdates(updates.PubUpdates, updates.HashUpdates, !s.BytesKeySuppoted())</span><br><span class="line">	<span class="keyword">return</span> s.VersionedDB.ApplyUpdates(updates.PubUpdates.UpdateBatch, height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会进入到下面的函数中：</p>
<blockquote>
<p>core&#x2F;ledger&#x2F;kvledger&#x2F;txmgmt&#x2F;statedb&#x2F;stateleveldb&#x2F;stateleveldb.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vdb *versionedDB)</span></span> ApplyUpdates(batch *statedb.UpdateBatch, height *version.Height) <span class="type">error</span> &#123;</span><br><span class="line">	dbBatch := leveldbhelper.NewUpdateBatch()</span><br><span class="line">	namespaces := batch.GetUpdatedNamespaces()</span><br><span class="line">	<span class="keyword">for</span> _, ns := <span class="keyword">range</span> namespaces &#123;</span><br><span class="line">		updates := batch.GetUpdates(ns)</span><br><span class="line">		<span class="keyword">for</span> k, vv := <span class="keyword">range</span> updates &#123;</span><br><span class="line">			compositeKey := constructCompositeKey(ns, k)</span><br><span class="line">			logger.Debugf(<span class="string">&quot;Channel [%s]: Applying key(string)=[%s] key(bytes)=[%#v]&quot;</span>, vdb.dbName, <span class="type">string</span>(compositeKey), compositeKey)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> vv.Value == <span class="literal">nil</span> &#123;</span><br><span class="line">				dbBatch.Delete(compositeKey)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dbBatch.Put(compositeKey, statedb.EncodeValue(vv.Value, vv.Version))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dbBatch.Put(savePointKey, height.ToBytes())</span><br><span class="line">	<span class="comment">// Setting snyc to true as a precaution, false may be an ok optimization after further testing.</span></span><br><span class="line">	<span class="keyword">if</span> err := vdb.db.WriteBatch(dbBatch, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplyUpdates()</code>方法主要做了以下几件事：</p>
<ol>
<li>遍历更新批量操作，对于其包含的键值对（键k与值vv），调用<code>constructCompositeKey(ns，k)</code>方法重新构造组合键<code>compositeKey</code></li>
<li>检查该键值对操作的删除标识。如果vv.Value为nil，说明该键值对更新操作为删除操作，则继续调用<code>dbBatch.Delete(compositeKey)</code>方法，添加该删除操作到<code>dbBatch</code>对象中。否则，将vv.Version中的区块号与交易序号经过编码序列化成字节数组，并与<code>vv.Value</code>组合成编码值<code>encodedValue</code>，再将其写入操作添加到dbBatch对象中</li>
<li>调用<code>dbBatch.Put</code>方法，添加保存点标识的<code>KV</code>键值对。其中，键为<code>[]byte&#123;0x00&#125;</code>，值为版本<code>height</code>经过编码序列化后的字节数组</li>
<li>调用<code>vdb.db.WriteBatch</code>方法，以原子操作方式将<code>dbBatch</code>更新同步到状态数据库上。注意，在写入数据库时同样会重新构造KV键值对，在原来的键上添加数据库名称（链ID&#x2F;账本ID）前缀，即<code>[]byte(dbName)+[]byte&#123;0x00&#125;</code>，以隔离不同通道上的状态数据。</li>
</ol>
<h3 id="更新历史数据库"><a href="#更新历史数据库" class="headerlink" title="更新历史数据库"></a>更新历史数据库</h3><p>调用<code>l.historyDB.Commit(block)</code>方法，以更新区块<code>block</code>中经过<code>Endorser</code>背书的有效交易数据到历史数据库中，代码如下：</p>
<blockquote>
<p>core&#x2F;ledger&#x2F;kvledger&#x2F;history&#x2F;historydb&#x2F;historyleveldb&#x2F;historyleveldb.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(historyDB *historyDB)</span></span> Commit(block *common.Block) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	blockNo := block.Header.Number <span class="comment">// 获取区块号</span></span><br><span class="line">	<span class="comment">//Set the starting tranNo to 0</span></span><br><span class="line">	<span class="keyword">var</span> tranNo <span class="type">uint64</span></span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Get the invalidation byte array for the block</span></span><br><span class="line">	<span class="comment">// 获取交易验证码列表</span></span><br><span class="line">	txsFilter := util.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER])</span><br><span class="line">	<span class="comment">// Initialize txsFilter if it does not yet exist (e.g. during testing, for genesis block, etc)</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(txsFilter) == <span class="number">0</span> &#123;</span><br><span class="line">		txsFilter = util.NewTxValidationFlags(<span class="built_in">len</span>(block.Data.Data))</span><br><span class="line">		block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = txsFilter</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write each tran&#x27;s write set to history db</span></span><br><span class="line">	<span class="keyword">for</span> _, envBytes := <span class="keyword">range</span> block.Data.Data &#123; <span class="comment">// 遍历区块所有交易数据</span></span><br><span class="line">		<span class="keyword">if</span> txsFilter.IsInvalid(<span class="type">int</span>(tranNo)) &#123; <span class="comment">// 过滤掉无效交易</span></span><br><span class="line">			logger.Debugf(<span class="string">&quot;Channel [%s]: Skipping history write for invalid transaction number %d&quot;</span>,</span><br><span class="line">				historyDB.dbName, tranNo)</span><br><span class="line">			tranNo++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解析获取交易消息Envelope结构对象</span></span><br><span class="line">		env, err := putils.GetEnvelopeFromBlock(envBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">		<span class="comment">// 检查类型：经Endorser背书的普通交易消息</span></span><br><span class="line">		<span class="keyword">if</span> common.HeaderType(chdr.Type) == common.HeaderType_ENDORSER_TRANSACTION &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// extract actions from the envelope message</span></span><br><span class="line">			<span class="comment">// 从交易消息中解析提取链码动作</span></span><br><span class="line">			respPayload, err := putils.GetActionFromEnvelope(envBytes)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">...</span><br><span class="line">			<span class="comment">// 解析交易读写集到TxReadWriteSet结构对象中</span></span><br><span class="line">			<span class="keyword">if</span> err = txRWSet.FromProtoBytes(respPayload.Results); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 遍历所有读写集，重新构造KV键值对添加到历史数据库</span></span><br><span class="line">			<span class="keyword">for</span> _, nsRWSet := <span class="keyword">range</span> txRWSet.NsRwSets &#123;</span><br><span class="line">				ns := nsRWSet.NameSpace</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> _, kvWrite := <span class="keyword">range</span> nsRWSet.KvRwSet.Writes &#123;</span><br><span class="line">					writeKey := kvWrite.Key</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 构造组合键</span></span><br><span class="line">					compositeHistoryKey := historydb.ConstructCompositeHistoryKey(ns, writeKey, blockNo, tranNo)</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 写入空的字节数组[]byte&#123;&#125;</span></span><br><span class="line">					dbBatch.Put(compositeHistoryKey, emptyValue)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 跳过交易，因为该消息不是经过Endorser背书的普通交易消息</span></span><br><span class="line">			logger.Debugf(<span class="string">&quot;Skipping transaction [%d] since it is not an endorsement transaction\n&quot;</span>, tranNo)</span><br><span class="line">		&#125;</span><br><span class="line">		tranNo++</span><br><span class="line">	&#125;</span><br><span class="line">	height := version.NewHeight(blockNo, tranNo) <span class="comment">// 创建版本对象</span></span><br><span class="line">	dbBatch.Put(savePointKey, height.ToBytes())  <span class="comment">// 添加保存点用于恢复</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步更新批量操作dbBatch到历史数据库中</span></span><br><span class="line">	<span class="keyword">if</span> err := historyDB.db.WriteBatch(dbBatch, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止：账本提交功能分析结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM固定长度数据类型表示</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA-20/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM固定长度数据类型表示</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
<p>我们先看一个简单的<code>Solidity</code>合约的汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该合约归结于<code>sstore</code>指令的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0x0</span>, <span class="number">0x1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>EVM将<code>0x1</code>数值存储在<code>0x0</code>的位置上</li>
<li>每个存储槽可以存储正好<strong>32</strong>字节(或<strong>256</strong>位)</li>
</ul>
<p>在本文中我们将会开始研究<code>Solidity</code>如何使用<code>32</code>字节的块来表示更加复杂的数据类型如结构体和数组。我们也将会看到存储是如何被优化的，以及优化是如何失败的。</p>
<p>在典型编程语言中理解数据类型在底层是如何表示的没有太大的作用。但是在<code>Solidity</code>(或其他的EVM语言)中，这个知识点是非常重要的，因为存储的访问是非常昂贵的：</p>
<ul>
<li><code>sstore</code>指令成本是20000 gas，或比基本的算术指令要贵~5000x</li>
<li><code>sload</code>指令成本是 200 gas，或比基本的算术指令要贵~100x</li>
</ul>
<p>这里说的成本，就是真正的金钱，而不仅仅是毫秒级别的性能。运行和使用合约的成本基本上是由<code>sstore</code>指令和<code>sload</code>指令来主导的！</p>
<h2 id="Parsecs磁带上的Parsecs"><a href="#Parsecs磁带上的Parsecs" class="headerlink" title="Parsecs磁带上的Parsecs"></a>Parsecs磁带上的Parsecs</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmm7k9gjm5j31e80mqh7z.jpg" alt="image-20210113174357355"></p>
<p>构建一个通用计算机器需要两个基本要素：</p>
<ul>
<li>一种循环的方式，无论是跳转还是递归</li>
<li>无限量的内存</li>
</ul>
<p><code>EVM</code>的汇编代码有跳转，<code>EVM</code>的存储器提供无限的内存。这对于一切就已经足够了，包括模拟一个运行以太坊的世界，这个世界本身就是一个模拟运行以太坊的世界………</p>
<p>EVM的存储器对于合约来说就像一个无限的自动收报机磁带，磁带上的每个槽都能存储32个字节，就像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span><span class="selector-attr">[32 bytes]</span>...</span><br></pre></td></tr></table></figure>

<p>我们将会看到数据是如何在无限的磁带中生存的。</p>
<blockquote>
<p>磁带的长度是2²⁵⁶，或者每个合约~10⁷⁷存储槽。可观测的宇宙粒子数是10⁸⁰。大概1000个合约就可以容纳所有的质子、中子和电子。不要相信营销炒作，因为它比无穷大要短的多。</p>
</blockquote>
<h2 id="空磁带"><a href="#空磁带" class="headerlink" title="空磁带"></a>空磁带</h2><p>存储器初始的时候是空白的，默认是0。拥有无限的磁带不需要任何的成本。</p>
<p>以一个简单的合约来演示一下0值的行为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    uint256 c;</span><br><span class="line">    uint256 d;</span><br><span class="line">    uint256 e;</span><br><span class="line">    uint256 f;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      f = <span class="number">0xc0fefe</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局很简单。</p>
<ul>
<li>变量<code>a</code>在<code>0x0</code>的位置上</li>
<li>变量<code>b</code>在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>关键问题是：如果我们只使用<code>f</code>，我们需要为<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>支付多少成本？</p>
<p>编译一下再看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sstore(0x5, 0xc0fefe)</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>所以一个存储变量的声明不需要任何成本，因为没有初始化的必要。Solidity为存储变量保留了位置，但是只有当你存储数据进去的时候才需要进行付费。</p>
<p>这样的话，我们只需要为存储<code>0x5</code>进行付费。</p>
<p>如果我们手动编写汇编代码的话，我们可以选择任意的存储位置，而用不着”扩展”存储器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个任意的存储位置</span></span><br><span class="line"><span class="built_in">sstore</span>(<span class="number">0xc0fefe</span>, <span class="number">0x42</span>)</span><br></pre></td></tr></table></figure>

<h2 id="读取零"><a href="#读取零" class="headerlink" title="读取零"></a>读取零</h2><p>你不仅可以写在存储器的任意位置，你还可以立刻读取任意的位置。从一个未初始化的位置读取只会返回<code>0x0</code>。</p>
<p>让我们看看一个合约从一个未初始化的位置<code>a</code>读取数据：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-zero-value.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// sload(0x0) returning 0x0</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">  <span class="comment">// a + 1; where a == 0</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// sstore(0x0, a + 1)</span></span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>注意生成从一个未初始化的位置<code>sload</code>的代码是无效的。</p>
<p>然而，我们可以比Solidity编译器聪明。既然我们知道<code>tag_2</code>是构造器，而且<code>a</code>从未被写入过数据，那么我们可以用<code>0x0</code>替换掉<code>sload</code>，以此节省5000 gas。</p>
<h2 id="结构体的表示"><a href="#结构体的表示" class="headerlink" title="结构体的表示"></a>结构体的表示</h2><p>来看一下我们的第一个复杂数据类型，一个拥有 6 个域的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;</span><br><span class="line">      uint256 a;</span><br><span class="line">      uint256 b;</span><br><span class="line">      uint256 c;</span><br><span class="line">      uint256 d;</span><br><span class="line">      uint256 e;</span><br><span class="line">      uint256 f;</span><br><span class="line">    &#125;</span><br><span class="line">    Tuple t;</span><br><span class="line">    <span class="function">function <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      t.f = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储器中的布局和状态变量是一样的：</p>
<ul>
<li><code>t.a</code>域在<code>0x0</code>的位置上</li>
<li><code>t.b</code>域在<code>0x1</code>的位置上</li>
<li>以此类推………</li>
</ul>
<p>就像之前一样，我们可以直接写入<code>t.f</code>而不用为初始化付费。</p>
<p>编译一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="keyword">struct</span>-fields.sol</span><br></pre></td></tr></table></figure>

<p>然后我们看见一模一样的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h3 id="固定长度数组"><a href="#固定长度数组" class="headerlink" title="固定长度数组"></a>固定长度数组</h3><p>让我们来声明一个定长数组：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[<span class="number">6</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">5</span>] = <span class="number">0xC0FEFE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器知道这里到底有几个<code>uint256</code>(32字节)类型的数值，所以它可以很容易让数组里面的元素依次存储起来，就像它存储变量和结构体一样。</p>
<p>在这个合约中，我们再次存储到<code>0x5</code>的位置上。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">tag_4:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>这个稍微长一点，但是如果你仔细一点，你会看见它们其实是一样的。我们手动的来优化一下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">  <span class="comment">// 0+5. 替换为0x5</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  <span class="comment">// 压入栈中然后立刻出栈。没有作用，只是移除</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  pop</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>移除掉标记和伪指令之后，我们再次得到相同的字节码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  0xc0fefe</span><br><span class="line">  0x5</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<h2 id="数组边界检查"><a href="#数组边界检查" class="headerlink" title="数组边界检查"></a>数组边界检查</h2><p>我们看到了定长数组、结构体和状态变量在存储器中的布局是一样的，但是产生的汇编代码是不同的。这是因为<code>Solidity</code>为数组的访问产生了边界检查代码。</p>
<p>让我们再次编译数组合约，这次去掉优化的选项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> c-<span class="type">static</span>-array.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码在下面已经注释了，并且打印出每条指令的机器状态：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">  <span class="number">0xc0fefe</span></span><br><span class="line">    [<span class="meta">0xc0fefe</span>]</span><br><span class="line">  <span class="number">0x5</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  dup1</span><br><span class="line">  <span class="comment">/* 数组边界检查代码 */</span></span><br><span class="line">  <span class="comment">// 5 &lt; 6</span></span><br><span class="line">  <span class="number">0x6</span></span><br><span class="line">    [<span class="meta">0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  dup2</span><br><span class="line">    [<span class="meta">0x5 0x6 0x5 0xc0fefe</span>]</span><br><span class="line">  lt</span><br><span class="line">    [<span class="meta">0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  <span class="comment">// bound_check_ok = 1 (TRUE)</span></span><br><span class="line">  <span class="comment">// if(bound_check_ok) &#123; goto tag5 &#125; else &#123; invalid &#125;</span></span><br><span class="line">  tag_5</span><br><span class="line">    [<span class="meta">tag_5 0x1 0x5 0xc0fefe</span>]</span><br><span class="line">  jumpi</span><br><span class="line">    <span class="comment">// 测试条件为真，跳转到 tag_5.</span></span><br><span class="line">    <span class="comment">//  `jumpi` 从栈中消耗两项数据</span></span><br><span class="line">    [<span class="meta">0x5 0xc0fefe</span>]</span><br><span class="line">  invalid</span><br><span class="line"><span class="comment">// 数据访问有效，继续执行</span></span><br><span class="line"><span class="comment">// stack: [0x5 0xc0fefe]</span></span><br><span class="line">tag_5:</span><br><span class="line">  sstore</span><br><span class="line">    []</span><br><span class="line">    storage: &#123; <span class="number">0x5</span> =&gt; <span class="number">0xc0fefe</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在已经看见了边界检查代码。我们也看见了编译器可以对这类东西进行一些优化，但是不是非常完美。</p>
<p>在本文的后面我们将会看到数组的边界检查是如何干扰编译器优化的，比起存储变量和结构体，定长数组的效率更低。</p>
<h2 id="打包行为"><a href="#打包行为" class="headerlink" title="打包行为"></a>打包行为</h2><p>存储是非常昂贵的。一个关键的优化就是尽可能的将数据打包成一个32字节数值。</p>
<p>考虑一个有 4 个存储变量的合约，每个变量都是 64 位，全部加起来就是 256 位（32字节）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="type">uint64</span> a;</span><br><span class="line">    <span class="type">uint64</span> b;</span><br><span class="line">    <span class="type">uint64</span> c;</span><br><span class="line">    <span class="type">uint64</span> d;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望（希望）编译器使用一个<code>sstore</code>指令将这些数据存放到同一个存储槽中。</p>
<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing.sol</span><br></pre></td></tr></table></figure>

<p>汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tag_2:</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:122  a */</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  dup1</span><br><span class="line">  sload</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:125:131  0xaaaa */</span></span><br><span class="line">  <span class="number">0xaaaa</span></span><br><span class="line">  <span class="built_in">not</span>(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:121:131  a = 0xaaaa */</span></span><br><span class="line">  <span class="function">swap1</span></span><br><span class="line"><span class="function">  swap2</span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0x80</span>), exp(<span class="number">0x2</span>, <span class="number">0x40</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:139:149  b = 0xbbbb */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xbbbb0000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">not</span><span class="params">(sub(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), exp(<span class="number">0x2</span>, <span class="number">0x80</span>)))</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:157:167  c = 0xcccc */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xcccc00000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  <span class="title">sub</span><span class="params">(exp(<span class="number">0x2</span>, <span class="number">0xc0</span>), <span class="number">0x1</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/* &quot;c-many-variables--packing.sol&quot;:175:185  d = 0xdddd */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">and</span></span></span><br><span class="line"><span class="function">  0xdddd000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="function">  <span class="keyword">or</span></span></span><br><span class="line"><span class="function">  swap1</span></span><br><span class="line"><span class="function">  sstore</span></span><br></pre></td></tr></table></figure>

<p>这里还是有很多的位转移我没能弄明白，但是无所谓。最关键事情是这里只有一个<code>sstore</code>指令。</p>
<p>这样优化就成功！</p>
<h2 id="干扰优化器"><a href="#干扰优化器" class="headerlink" title="干扰优化器"></a>干扰优化器</h2><p>优化器并不能一直工作的这么好。让我们来干扰一下优化器。唯一的改变就是使用协助函数来设置存储变量：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64 a;</span><br><span class="line">    uint64 b;</span><br><span class="line">    uint64 c;</span><br><span class="line">    uint64 d;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">setAB</span>();</span><br><span class="line">      <span class="title function_">setCD</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setAB</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      a = <span class="number">0xaaaa</span>;</span><br><span class="line">      b = <span class="number">0xbbbb</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setCD</span>(<span class="params"></span>) internal &#123;</span><br><span class="line">      c = <span class="number">0xcccc</span>;</span><br><span class="line">      d = <span class="number">0xdddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ solc --bin --<span class="keyword">asm</span> --optimize c-many-variables--packing-helpers.sol</span><br></pre></td></tr></table></figure>

<p>输出的汇编代码太多了，我们忽略了大多数的细节，只关注结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 通过跳到tag_5来调用setAB()</span></span><br><span class="line">  jump</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//通过跳到tag_7来调用setCD() </span></span><br><span class="line">  jump</span><br><span class="line"><span class="comment">// setAB()函数</span></span><br><span class="line">tag_5:</span><br><span class="line">  <span class="comment">// 进行位转移和设置a，b</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_9:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setAB()的地方</span></span><br><span class="line"><span class="comment">//setCD()函数</span></span><br><span class="line">tag_7:</span><br><span class="line">  <span class="comment">// 进行位转移和设置c，d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sstore</span><br><span class="line">tag_10:</span><br><span class="line">  jump  <span class="comment">// 返回到调用setCD()的地方</span></span><br></pre></td></tr></table></figure>

<p>现在这里有两个<code>sstore</code>指令而不是一个。Solidity编译器可以优化一个标签内的东西，但是无法优化跨标签的。</p>
<p>调用函数会让你消耗更多的成本，不是因为函数调用昂贵（他们只是一个跳转指令），而是因为<code>sstore</code>指令的优化可能会失败。</p>
<p>为了解决这个问题，Solidity编译器应该学会如何內联函数，本质上就是不用调用函数也能得到相同的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">0xaaaa</span>;</span><br><span class="line">b <span class="operator">=</span> <span class="number">0xbbbb</span>;</span><br><span class="line">c <span class="operator">=</span> <span class="number">0xcccc</span>;</span><br><span class="line">d <span class="operator">=</span> <span class="number">0xdddd</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们仔细阅读输出的完整汇编代码，我们会看见<code>setAB()</code>和<code>setCD()</code>函数的汇编代码被包含了两次，不仅使代码变得臃肿了，并且还需要花费额外的gas来部署合约。在学习合约的生命周期时我们再来谈谈这个问题。</p>
</blockquote>
<h2 id="为什么优化器会被干扰？"><a href="#为什么优化器会被干扰？" class="headerlink" title="为什么优化器会被干扰？"></a>为什么优化器会被干扰？</h2><p>因为优化器不会跨标签进行优化。思考一下”1+1”，在同一个标签下，它会被优化成<code>0x2</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化成功！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>但是如果指令被标签分开的话就不会被优化了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化失败！</span></span><br><span class="line">tag_0:</span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">  <span class="number">0x1</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>在0.4.13版本中上面的行为都是真实的。也许未来会改变。</p>
<h2 id="再次干扰优化器"><a href="#再次干扰优化器" class="headerlink" title="再次干扰优化器"></a>再次干扰优化器</h2><p>让我们看看优化器失败的另一种方式，打包适用于定长数组吗？思考一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint64[<span class="number">4</span>] numbers;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">      numbers[<span class="number">0</span>] = <span class="number">0x0</span>;</span><br><span class="line">      numbers[<span class="number">1</span>] = <span class="number">0x1111</span>;</span><br><span class="line">      numbers[<span class="number">2</span>] = <span class="number">0x2222</span>;</span><br><span class="line">      numbers[<span class="number">3</span>] = <span class="number">0x3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再一次，这里有4个64位的数值我们希望能打包成一个32位的数值，只使用一个<code>sstore</code>指令。</p>
<p>编译的汇编代码太长了，我们就数数<code>sstore</code>和<code>sload</code>指令的条数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ solc --bin --asm --optimize c-<span class="built_in">static</span>-<span class="keyword">array</span>--packing.sol | grep -E <span class="string">&#x27;(sstore|sload)&#x27;</span></span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br><span class="line">  sload</span><br><span class="line">  sstore</span><br></pre></td></tr></table></figure>

<p>哦，不！即使定长数组与等效的结构体和存储变量的存储布局是一样的，优化也失败了。现在需要4对<code>sload</code>和<code>sstore</code>指令。</p>
<p>快速的看一下汇编代码，可以发现每个数组的访问都有一个边界检查代码，它们在不同的标签下被组织起来。优化无法跨标签，所以优化失败。</p>
<p>不过有个小安慰。其他额外的3个<code>sstore</code>指令比第一个要便宜：</p>
<ul>
<li><code>sstore</code>指令第一次写入一个新位置需要花费 20000 gas</li>
<li><code>sstore</code>指令后续写入一个已存在的位置需要花费 5000 gas</li>
</ul>
<p>所以这个特殊的优化失败会花费我们35000 gas而不是20000 gas，多了额外的75%。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果Solidity编译器能弄清楚存储变量的大小，它就会将这些变量依次的放入存储器中。如果可能的话，编译器会将数据紧密的打包成32字节的块。</p>
<p>总结一下目前我们见到的打包行为：</p>
<ul>
<li>存储变量：打包</li>
<li>结构体：打包</li>
<li>定长数组：不打包。在理论上应该是打包的</li>
</ul>
<p>因为存储器访问的成本较高，所以你应该将存储变量作为自己的数据库模式。当写一个合约时，做一个小实验是比较有用的，检测汇编代码看看编译器是否进行了正确的优化。</p>
<p>我们可以肯定Solidity编译器在未来肯定会改良。对于现在而言，很不幸，我们不能盲目的相信它的优化器。</p>
<p>它需要你真正的理解存储变量。</p>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8ABI%E7%BC%96%E7%A0%81%E7%9A%84%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95-22/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM如何调用ABI编码的外部方法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmma6b1e5zj312g0pmnpe.jpg" alt="image-20210113191423657"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>abi是什么？<br>前面我们认识到的是智能合约直接在EVM上的表示方式，但是，比如我想用java端程序去访问智能合约的某个方法，难道让java开发人员琢磨透汇编和二进制的表示，再去对接？<br>这明显是不可能的，为此abi产生了。这是一个通用可读的json格式的数据，任何别的客户端开发人员或者别的以太坊节点只要指定要调用的方法，通过abi将其解析为字节码并传递给evm，evm来计算处理该字节码并返回结果给前端。abi就起到这么一个作用，类似于传统的客户端和服务器端地址好交互规则，比如json格式的数据，然后进行交互。</p>
<p>在本系列的上一篇文章中我们看到了<code>Solidity</code>是如何在EVM存储器中表示复杂数据结构的。但是如果无法交互，数据就是没有意义的。智能合约就是数据和外界的中间体。</p>
<p>在这篇文章中我们将会看到<code>Solidity</code>和<code>EVM</code>可以让外部程序来调用合约的方法并改变它的状态。</p>
<p>“外部程序”不限于<code>DApp/JavaScript</code>。任何可以使用<code>HTTP RPC</code>与以太坊节点通信的程序，都可以通过创建一个交易与部署在区块链上的任何合约进行交互。</p>
<p>创建一个交易就像发送一个<code>HTTP</code>请求。<code>Web</code>的服务器会接收你的<code>HTTP</code>请求，然后改变数据库。交易会被网络接收，底层的区块链会扩展到包含改变的状态。</p>
<p>交易对于智能合约就像<code>HTTP</code>请求对于<code>Web</code>服务器。</p>
<h2 id="合约交易"><a href="#合约交易" class="headerlink" title="合约交易"></a>合约交易</h2><p>让我们来看一下将状态变量设置在<code>0x1</code>位置上的交易。我们想要交互的合约有一个对变量<code>a</code>的设置者和获取者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  function setA(uint256 _a) &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">  function getA() returns(uint256) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约部署在Rinkeby测试网上。可以随意使用Etherscan，并搜索地址 <a href="https://rinkeby.etherscan.io/address/0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2#code">0x62650ae5…</a>进行查看。</p>
<p>我创建了一个可以调用<code>setA(1)</code>的交易，可以在地址<a href="https://rinkeby.etherscan.io/tx/0x7db471e5792bbf38dc784a5b983ee6a7bbe3f1db85dd4daede9ee88ed88057a5">0x7db471e5…</a>上查看该交易。</p>
<p>交易的input data是：</p>
<blockquote>
<p>0xee919d500000000000000000000000000000000000000000000000000000000000000001</p>
</blockquote>
<p>对于EVM而言，这只是36字节的元数据。它对元数据不会进行处理，会直接将元数据作为<code>calldata</code>传递给智能合约。如果智能合约是个Solidity程序，那么它会将这些输入字节解释为方法调用，并为<code>setA(1)</code>执行适当的汇编代码。</p>
<p>输入数据可以分成两个子部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 方法选择器(<span class="number">4</span>字节)</span><br><span class="line"><span class="number">0xee919d5</span></span><br><span class="line">#第一个参数(<span class="number">32</span>字节)</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000001</span></span><br></pre></td></tr></table></figure>

<p>前面的4个字节是方法选择器，剩下的输入数据是方法的参数，32个字节的块。在这个例子中，只有一个参数，值是<code>0x1</code>。</p>
<p>方法选择器是方法签名的 kecccak256 哈希值。在这个例子中方法的签名是<code>setA(uint256)</code>，也就是方法名称和参数的类型。</p>
<p>让我们用Python来计算方法选择器。首先，哈希方法签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 安装pyethereum [https:<span class="comment">//github.com/ethereum/pyethereum/#installation](https://github.com/ethereum/pyethereum/#installation)&gt; from ethereum.utils import sha3&gt; sha3(&quot;setA(uint256)&quot;).hex()&#x27;ee919d50445cd9f463621849366a537968fe1ce096894b0d0c001528383d4769&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后获取哈希值的前4字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; sha3(<span class="string">&quot;setA(uint256)&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;ee919d50&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="应用二进制接口（ABI）"><a href="#应用二进制接口（ABI）" class="headerlink" title="应用二进制接口（ABI）"></a>应用二进制接口（ABI）</h2><p>对于EVM而言，交易的输入数据(<code>calldata</code>)只是一个字节序列。EVM内部不支持调用方法。</p>
<p>智能合约可以选择通过以结构化的方式处理输入数据来模拟方法调用，就像前面所说的那样。</p>
<p>如果EVM上的所有语言都同意相同的方式解释输入数据，那么它们就可以很容易进行交互。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#formal-specification-of-the-encoding">合约应用二进制接口</a>（ABI）指定了一个通用的编码模式。</p>
<p>我们已经看到了ABI是如何编码一个简单的方法调用，例如<code>SetA(1)</code>。在后面章节中我们将会看到方法调用和更复杂的参数是如何编码的。</p>
<h2 id="调用一个获取者"><a href="#调用一个获取者" class="headerlink" title="调用一个获取者"></a>调用一个获取者</h2><p>如果你调用的方法改变了状态，那么整个网络必须要同意。这就需要有交易，并消耗gas。</p>
<p>一个获取者如<code>getA()</code>不会改变任何东西。我们可以将方法调用发送到本地的以太坊节点，而不用请求整个网络来执行计算。一个<code>eth_call</code>RPC请求可以允许你在本地模拟交易。这对于只读方法或gas使用评估比较有帮助。</p>
<p>一个<code>eth_call</code>就像一个缓存的HTTP GET请求。</p>
<ul>
<li>它不改变全球的共识状态</li>
<li>本地区块链(“缓存”)可能会有点稍微过时</li>
</ul>
<p>制作一个<code>eth_call</code>来调用 <code>getA</code>方法，通过返回值来获取状态<code>a</code>。首先，计算方法选择器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sha3(<span class="string">&quot;getA()&quot;</span>)[<span class="number">0</span>:<span class="number">4</span>].hex()</span><br><span class="line"><span class="string">&#x27;d46300fd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于没有参数，输入数据就只有方法选择器了。我们可以发送一个<code>eth_call</code>请求给任意的以太坊节点。对于这个例子，我们依然将请求发送给 infura.io的公共以太坊节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ curl -X POST \-H <span class="string">&quot;Content-Type: application/json&quot;</span> \<span class="string">&quot;[https://rinkeby.infura.io/YOUR_INFURA_TOKEN](https://rinkeby.infura.io/YOUR_INFURA_TOKEN)&quot;</span> \--data <span class="string">&#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;id&quot;: 1,&quot;method&quot;: &quot;eth_call&quot;,&quot;params&quot;: [&#123;&quot;to&quot;: &quot;0x62650ae5c5777d1660cc17fcd4f48f6a66b9a4c2&quot;,&quot;data&quot;: &quot;0xd46300fd&quot;&#125;,&quot;latest&quot;]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据ABI，该字节应该会解释为<code>0x1</code>数值。</p>
<h2 id="外部方法调用的汇编"><a href="#外部方法调用的汇编" class="headerlink" title="外部方法调用的汇编"></a>外部方法调用的汇编</h2><p>现在来看看编译的合约是如何处理源输入数据的，并以此来制作一个方法调用。思考一个定义了<code>setA(uint256)</code>的合约：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">  uint256 a;</span><br><span class="line">  <span class="comment">// 注意: `payable` 让汇编简单一点点</span></span><br><span class="line">  function setA(uint256 _a) payable &#123;</span><br><span class="line">    a = _a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">solc --bin --asm --optimize call.sol</span><br></pre></td></tr></table></figure>

<p>调用方法的汇编代码在合约内部，在<code>sub_0</code>标签下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sub_0: assembly &#123;</span><br><span class="line">    mstore(<span class="number">0x40</span>, <span class="number">0x60</span>)</span><br><span class="line">    and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="number">0xee919d50</span></span><br><span class="line">    dup2</span><br><span class="line">    eq</span><br><span class="line">    tag_2</span><br><span class="line">    jumpi</span><br><span class="line">  tag_1:</span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">    dup1</span><br><span class="line">    revert</span><br><span class="line">  tag_2:</span><br><span class="line">    tag_3</span><br><span class="line">    calldataload(<span class="number">0x4</span>)</span><br><span class="line">    jump(tag_4)</span><br><span class="line">  tag_3:</span><br><span class="line">    stop</span><br><span class="line">  tag_4:</span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:96  a */</span></span><br><span class="line">    <span class="number">0x0</span></span><br><span class="line">      <span class="comment">/* &quot;call.sol&quot;:95:101  a = _a */</span></span><br><span class="line">    dup2</span><br><span class="line">    swap1</span><br><span class="line">    sstore</span><br><span class="line">  tag_5:</span><br><span class="line">    pop</span><br><span class="line">    jump <span class="comment">// 跳出</span></span><br><span class="line">auxdata: <span class="number">0xa165627a7a7230582016353b5ec133c89560dea787de20e25e96284d67a632e9df74dd981cc4db7a0a0029</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个样板代码与此讨论是无关的，但是仅供参考：</p>
<ul>
<li>最上面的<code>mstore(0x40, 0x60)</code>为sha3哈希保留了内存中的前64个字节。不管合约是否需要，这个都会存在的。</li>
<li>最下面的<code>auxdata</code>用来验证发布的源码与部署的字节码是否相同的。这个是可选择的，但是嵌入到了编译器中</li>
</ul>
<p>将剩下的汇编代码分成两个部分，这样容易分析一点：</p>
<ul>
<li>匹配选择器并跳掉方法处</li>
<li>加载参数、执行方法，并从方法返回</li>
</ul>
<p>首先，匹配选择器的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载前4个字节作为方法选择器</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">//  如果选择器匹配`0xee919d50`, 跳转到 setA</span></span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2</span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">tag_1:</span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line"><span class="comment">// setA函数</span></span><br><span class="line">tag_2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>除了开始从调用数据里面加载4字节时的位转移，其他的都是非常清晰明朗的。为了清晰可见，给出了汇编逻辑的低级伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// 跳转到setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 匹配失败，返回并还原</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<p>实际方法调用的注释汇编代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setA</span></span><br><span class="line">tag_2:</span><br><span class="line">  <span class="comment">// 方法调用之后跳转的地方</span></span><br><span class="line">  tag_3</span><br><span class="line">  <span class="comment">// 加载第一个参数(数值0x1).</span></span><br><span class="line">  calldataload(<span class="number">0x4</span>)</span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  jump(tag_4)</span><br><span class="line">tag_4:</span><br><span class="line">  <span class="comment">// sstore(0x0, 0x1)</span></span><br><span class="line">  <span class="number">0x0</span></span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">tag_5:</span><br><span class="line">  pop</span><br><span class="line">  <span class="comment">//程序的结尾，将会跳转到 tag_3并停止</span></span><br><span class="line">  jump</span><br><span class="line">tag_3:</span><br><span class="line">  <span class="comment">// 程序结尾</span></span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>在进入方法体之前，汇编代码做了两件事情：</p>
<ol>
<li>保存了一个位置，方法调用之后返回此位置</li>
<li>从调用数据里面加载参数到栈中</li>
</ol>
<p>低级的伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存位置，方法调用结束后返回此位置</span></span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA</span></span><br><span class="line">  <span class="comment">// 从调用数据里面加载参数到栈中</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">4</span>+<span class="number">32</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<p>将这两部分组合起来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2 <span class="comment">// goto setA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// 无匹配方法。失败</span></span><br><span class="line">  revert</span><br><span class="line">@returnTo = tag_3</span><br><span class="line">tag_2: <span class="comment">// setA(uint256 _a)</span></span><br><span class="line">  @arg1 = calldata[<span class="number">4</span>:<span class="number">36</span>]</span><br><span class="line">tag_4: <span class="comment">// a = _a</span></span><br><span class="line">  sstore(<span class="number">0x0</span>, @arg1)</span><br><span class="line">tag_5 <span class="comment">// 返回</span></span><br><span class="line">  jump(@returnTo)</span><br><span class="line">tag_3:</span><br><span class="line">  stop</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有趣的小细节：<code>revert</code>的操作码是<code>fd</code>。但是在黄皮书中你不会找到它的详细说明，或者在代码中找到它的实现。实际上，<code>fd</code>不是确实存在的！这是个无效的操作。当EVM遇到了一个无效的操作，它会放弃并且会有还原状态的副作用。</p>
</blockquote>
<h2 id="处理多个方法"><a href="#处理多个方法" class="headerlink" title="处理多个方法"></a>处理多个方法</h2><p>Solidity编译器是如何为有多个方法的合约产生汇编代码的？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256 a;</span><br><span class="line">    uint256 b;</span><br><span class="line">    function setA(uint256 _a) &#123;</span><br><span class="line">      a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    function setB(uint256 _b) &#123;</span><br><span class="line">      b = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单，只要一些<code>if-else</code>分支就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// methodSelector = calldata[0:4]</span></span><br><span class="line">and(div(calldataload(<span class="number">0x0</span>), <span class="number">0x100000000000000000000000000000000000000000000000000000000</span>), <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="comment">// if methodSelector == 0x9cdcf9b</span></span><br><span class="line"><span class="number">0x9cdcf9b</span></span><br><span class="line">dup2</span><br><span class="line">eq</span><br><span class="line">tag_2 <span class="comment">// SetB</span></span><br><span class="line">jumpi</span><br><span class="line"><span class="comment">// elsif methodSelector == 0xee919d50</span></span><br><span class="line">dup1</span><br><span class="line"><span class="number">0xee919d50</span></span><br><span class="line">eq</span><br><span class="line">tag_3 <span class="comment">// SetA</span></span><br><span class="line">jumpi</span><br></pre></td></tr></table></figure>

<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">methodSelector = calldata[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> methodSelector == <span class="string">&quot;0x9cdcf9b&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_2</span><br><span class="line">elsif methodSelector == <span class="string">&quot;0xee919d50&quot;</span>:</span><br><span class="line">  <span class="keyword">goto</span> tag_3</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="comment">// Cannot find a matching method. Fail.</span></span><br><span class="line">  revert</span><br></pre></td></tr></table></figure>

<h2 id="ABI为复杂方法调用进行编码"><a href="#ABI为复杂方法调用进行编码" class="headerlink" title="ABI为复杂方法调用进行编码"></a>ABI为复杂方法调用进行编码</h2><p>对于一个方法调用，交易输入数据的前4个字节总是方法选择器。跟在后面的32字节块就是方法参数。 <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">ABI编码规范</a>显示了更加复杂的参数类型是如何被编码的，但是阅读起来非常的痛苦。</p>
<p>另一个学习ABI编码的方式是使用 <a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py">pyethereum的ABI编码函数</a> 来研究不同数据类型是如何编码的。我们会从简单的例子开始，然后建立更复杂的类型。</p>
<p>首先，导出<code>encode_abi</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">from ethereum.abi <span class="keyword">import</span> encode_abi</span><br></pre></td></tr></table></figure>

<p>对于一个有3个<code>uint256</code>类型参数的方法（例如<code>foo(uint256 a, uint256 b, uint256 c)</code>），编码参数只是简单的依次对<code>uint256</code>数值进行编码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 第一个数组列出了参数的类型</span><br><span class="line"># 第二个数组列出了参数的值</span><br><span class="line">&gt; encode_abi([<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小于32字节的类型会被填充到32字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi([<span class="string">&quot;int8&quot;</span>, <span class="string">&quot;uint32&quot;</span>, <span class="string">&quot;uint64&quot;</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).hex()</span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br></pre></td></tr></table></figure>

<p>对于定长数组，元素还是32字节的块（如果必要的话会填充0），依次排列：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">   [<span class="string">&quot;int8[3]&quot;</span>, <span class="string">&quot;int256[3]&quot;</span>],</span><br><span class="line">   [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// int8[3]. Zero-padded to 32 bytes.</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000001</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000002</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="comment">// int256[3].</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000005</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000006</span></span><br></pre></td></tr></table></figure>

<h2 id="ABI为动态数组编码"><a href="#ABI为动态数组编码" class="headerlink" title="ABI为动态数组编码"></a>ABI为动态数组编码</h2><p>ABI介绍了一种间接的编码动态数组的方法，遵循一个叫做<a href="https://github.com/ethereum/pyethereum/blob/4e945e2a24554ec04eccb160cff689a82eed7e0d/ethereum/abi.py#L735-L741">头尾编码</a>的模式。</p>
<p>该模式其实就是动态数组的元素被打包到交易的调用数据尾部，参数(“头”)会被引用到调用数据里，这里就是数组元素。</p>
<p>如果我们调用的方法有3个动态数组，参数的编码就会像这样（添加注释和换行为了更加的清晰）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>],</span><br><span class="line">  [[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1: 数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：数组数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 参数3： 数组数据在0x160位置 </span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">/************* TAIL (128**3 bytes) *************/</span></span><br><span class="line"><span class="comment">//  0x60位置。参数1的数据</span></span><br><span class="line"><span class="comment">// 长度后跟这元素</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// 0xe0位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">//0x160位置。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<p><code>HEAD</code>部分有32字节参数，指出<code>TAIL</code>部分的位置，<code>TAIL</code>部分包含了3个动态数组的实际数据。</p>
<p>举个例子，第一个参数是<code>0x60</code>，指出调用数据的第96个(<code>0x60</code>)字节。如果你看一下第96个字节，它是数组的开始地方。前32字节是长度，后面跟着的是3个元素。</p>
<p>混合动态和静态参数是可能的。这里有个(<code>static</code>，<code>dynamic</code>，<code>static</code>)参数。静态参数按原样编码，而第二个动态数组的数据放到了尾部：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256&quot;</span>, <span class="string">&quot;uint256[]&quot;</span>, <span class="string">&quot;uint256&quot;</span>],</span><br><span class="line">  [<span class="number">0xaaaa</span>, [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], <span class="number">0xbbbb</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">/************* HEAD (32*3 bytes) *************/</span></span><br><span class="line"><span class="comment">// 参数1： 0xaaaa</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>aaaa</span><br><span class="line"><span class="comment">// 参数2：数组数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数3： 0xbbbb</span></span><br><span class="line"><span class="number">000000000000000000000000000000000000000000000000000000000000</span>bbbb</span><br><span class="line"><span class="comment">/************* TAIL (128 bytes) *************/</span></span><br><span class="line"><span class="comment">// 0x60位置。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br></pre></td></tr></table></figure>

<h2 id="编码字节数组"><a href="#编码字节数组" class="headerlink" title="编码字节数组"></a>编码字节数组</h2><p>字符串和字节数组同样是头尾编码。唯一的区别是字节数组会被紧密的打包成一个32字节的块，就像：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">// 参数1： 字符串数据在0x60位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="comment">// 参数2：字符串数据在0xa0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a0</span><br><span class="line"><span class="comment">// 参数3：字符串数据在0xe0位置</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="comment">// 0x60 (96)。 参数1的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6161616100000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xa0 (160)。参数2的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6262626200000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 0xe0 (224)。参数3的数据</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000004</span></span><br><span class="line"><span class="number">6363636300000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>对于每个字符串&#x2F;字节数组，前面的32字节是编码长度，后面跟着才是字符串&#x2F;字节数组的内容。</p>
<p>如果字符串大于32字节，那么多个32字节块就会被使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码字符串的48字节</span></span><br><span class="line">ethereum.abi.encode_abi(</span><br><span class="line">  [<span class="string">&quot;string&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;a&quot;</span> * (<span class="number">32</span>+<span class="number">16</span>)]</span><br><span class="line">).hex()</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">//字符串的长度为0x30 (48)</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000030</span></span><br><span class="line"><span class="number">6161616161616161616161616161616161616161616161616161616161616161</span></span><br><span class="line"><span class="number">6161616161616161616161616161616100000000000000000000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>嵌套数组中每个嵌套有一个间接寻址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; encode_abi(</span><br><span class="line">  [<span class="string">&quot;uint256[][]&quot;</span>],</span><br><span class="line">  [[[<span class="number">0xa1</span>, <span class="number">0xa2</span>, <span class="number">0xa3</span>], [<span class="number">0xb1</span>, <span class="number">0xb2</span>, <span class="number">0xb3</span>], [<span class="number">0xc1</span>, <span class="number">0xc2</span>, <span class="number">0xc3</span>]]]</span><br><span class="line">).hex()</span><br><span class="line"><span class="comment">//参数1：外层数组在0x20位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000020</span></span><br><span class="line"><span class="comment">// 0x20。每个元素都是里层数组的位置</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000060</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000e0</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000160</span></span><br><span class="line"><span class="comment">// array[0]在0x60位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>a3</span><br><span class="line"><span class="comment">// array[1] 在0xe0位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>b3</span><br><span class="line"><span class="comment">// array[2]在0x160位置上</span></span><br><span class="line"><span class="number">0000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c1</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c2</span><br><span class="line"><span class="number">00000000000000000000000000000000000000000000000000000000000000</span>c3</span><br></pre></td></tr></table></figure>

<h2 id="Gas成本和ABI编码设计"><a href="#Gas成本和ABI编码设计" class="headerlink" title="Gas成本和ABI编码设计"></a>Gas成本和ABI编码设计</h2><p>为什么ABI将方法选择器截断到4个字节？如果我们不使用sha256的整个32字节，会不会不幸的碰到不同方法发生冲突的情况？ 如果这个截断是为了节省成本，那么为什么在用更多的0来进行填充时，而仅仅只为了节省方法选择器中的28字节而截断呢？</p>
<p>这种设计看起来互相矛盾……直到我们考虑到一个交易的gas成本。</p>
<ul>
<li>每笔交易需要支付 21000 gas</li>
<li>每笔交易的0字节或代码需要支付 4 gas</li>
<li>每笔交易的非0字节或代码需要支付 68 gas</li>
</ul>
<p>啊哈！0要便宜17倍，0填充现在看起来没有那么不合理了。</p>
<p>方法选择器是一个加密哈希值，是个伪随机。一个随机的字符串倾向于拥有很多的非0字节，因为每个字节只有0.3%（1&#x2F;255）的概率是0。</p>
<ul>
<li><code>0x1</code>填充到32字节成本是192 gas<br>4*31 (0字节) + 68 (1个非0字节)</li>
<li>sha256可能有32个非0字节，成本大概2176 gas<br>32 * 68</li>
<li>sha256截断到4字节，成本大概272 gas<br>32*4</li>
</ul>
<p>ABI展示了另外一个底层设计的奇特例子，通过gas成本结构进行激励。</p>
<blockquote>
<h3 id="负整数…"><a href="#负整数…" class="headerlink" title="负整数…."></a>负整数….</h3></blockquote>
<p>一般使用叫做 <a href="https://en.wikipedia.org/wiki/Two's_complement">补码</a>的方式来表达负整数。<code>int8</code>类型<code>-1</code>的数值编码会都是1。<code>1111 1111</code>。</p>
<p>ABI用1来填充负整数，所以<code>-1</code>会被填充为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure>

<p>越大的负整数（<code>-1</code>大于<code>-2</code>）1越多，会花费相当多的gas。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与智能合约交互，你需要发送原始字节。它会进行一些计算，可能会改变自己的状态，然后会返回给你原始字节。方法调用实际上不存在，这是ABI创造的集体假象。</p>
<p>ABI被指定为一个低级格式，但是在功能上更像一个跨语言RPC框架的序列化格式。</p>
<p>我们可以在DApp和Web App的架构层面之间进行类比：</p>
<ul>
<li>区块链就是一个备份数据库</li>
<li>合约就像web服务器</li>
<li>交易就像请求</li>
<li>ABI是数据交换格式，就像<a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protocol Buffer</a>。</li>
</ul>
<blockquote>
<p>翻译自 <a href="https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7">https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EVM指令集</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEVM%E6%8C%87%E4%BB%A4%E9%9B%86-19/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EVM指令集</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
<p>以下指令集持续更新，最新文章请参考上面</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn1z0rqeqaj31c00u0k20.jpg" alt="f4a720afd869d70c3d1d2149980ba0e9"></p>
<h2 id="EVM-指令集概念"><a href="#EVM-指令集概念" class="headerlink" title="EVM 指令集概念"></a>EVM 指令集概念</h2><p><strong>EVM执行的是字节码</strong>。由于操作码被限制在一个字节以内，所以EVM指令集最多只能容纳<strong>256</strong>条指令。目前EVM已经定义了<code>100</code>多条指令，还有<strong>100</strong>多条指令可供以后扩展。<strong>这100多条指令包括算术运算指令，比较操作指令，按位运算指令，密码学计算指令，栈、memory、storage操作指令，跳转指令，区块、智能合约相关指令等</strong>。</p>
<h2 id="EVM指令集"><a href="#EVM指令集" class="headerlink" title="EVM指令集"></a>EVM指令集</h2><h3 id="算数运算指令集"><a href="#算数运算指令集" class="headerlink" title="算数运算指令集"></a>算数运算指令集</h3><blockquote>
<p><em>0x0</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOP:       &quot;STOP&quot;,</span><br><span class="line">ADD:        &quot;ADD&quot;, //加法运算</span><br><span class="line">MUL:        &quot;MUL&quot;, //乘法运算</span><br><span class="line">SUB:        &quot;SUB&quot;, //减法运算</span><br><span class="line">DIV:        &quot;DIV&quot;, //无符号整除运算</span><br><span class="line">SDIV:       &quot;SDIV&quot;, //有符号整除运算</span><br><span class="line">MOD:        &quot;MOD&quot;, //无符号取模运算</span><br><span class="line">SMOD:       &quot;SMOD&quot;, //有符号取模运算</span><br><span class="line">EXP:        &quot;EXP&quot;,  //指数运算</span><br><span class="line">NOT:        &quot;NOT&quot;,</span><br><span class="line"></span><br><span class="line">//从栈顶弹出两个元素，进行比较，</span><br><span class="line">//然后把结果（1表示true，0表示false）推入栈顶。</span><br><span class="line">//其中LT和GT把弹出的元素解释为无符号整数进行比较，</span><br><span class="line">//SLT和SGT把弹出的元素解释为有符号数进行比较，EQ不关心符号</span><br><span class="line">LT:         &quot;LT&quot;,  //无符号小于比较</span><br><span class="line">GT:         &quot;GT&quot;, //无符号大于比较</span><br><span class="line">SLT:        &quot;SLT&quot;, //有符号小于比较</span><br><span class="line">SGT:        &quot;SGT&quot;, //有符号大于比较</span><br><span class="line">EQ:         &quot;EQ&quot;,  // 等于比较</span><br><span class="line"></span><br><span class="line">//SZERO指令从栈顶弹出一个元素，判断它是否为0，如果是，则把1推入栈顶，否则把0推入栈顶</span><br><span class="line">ISZERO:     &quot;ISZERO&quot;, //布尔取反</span><br><span class="line"></span><br><span class="line">//SIGNEXTEND指令从栈顶依次弹出k和x，并</span><br><span class="line">//把x解释为k+1（0 &lt;= k &lt;= 31）字节有符号整数，然</span><br><span class="line">//后把x符号扩展至32字节。比如x是二进制10000000，k是0，</span><br><span class="line">//则符号扩展之后，结果为二进制1111…10000000（共249个1）</span><br><span class="line">SIGNEXTEND: &quot;SIGNEXTEND&quot; //符号位扩展</span><br></pre></td></tr></table></figure>



<h3 id="位运算指令集"><a href="#位运算指令集" class="headerlink" title="位运算指令集"></a>位运算指令集</h3><blockquote>
<p><em>0x10</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//AND、OR、XOR指令从栈顶弹出两个元素，进行按位运算，然后把结果推入栈顶</span><br><span class="line">AND:    &quot;AND&quot;,</span><br><span class="line">OR:     &quot;OR&quot;,</span><br><span class="line">XOR:    &quot;XOR&quot;,</span><br><span class="line"></span><br><span class="line">//BYTE指令先后从栈顶弹出n和x，取x的第n个字节并推入栈顶。</span><br><span class="line">//由于EVM的字长是32个字节，所以n在[0, 31]区间内才有意义，</span><br><span class="line">//否则BYTE的运算结果就是0。另外，字节是从左到右数的，因此第0个字节占据字的最高位8个比特</span><br><span class="line">BYTE:   &quot;BYTE&quot;, </span><br><span class="line"></span><br><span class="line">//这三条指令都是先后从栈顶弹出两个数n和x，</span><br><span class="line">//其中x是要进行位移操作顶数，n是位移比特数，然后把结果推入栈顶</span><br><span class="line">SHL:    &quot;SHL&quot;,</span><br><span class="line">//SHR和SAR的区别在于，前者执行逻辑右移（空缺补0），后者执行算术右移（空缺补符号位）</span><br><span class="line">SHR:    &quot;SHR&quot;,</span><br><span class="line">SAR:    &quot;SAR&quot;,</span><br><span class="line"></span><br><span class="line">ADDMOD: &quot;ADDMOD&quot;,</span><br><span class="line"></span><br><span class="line">//MULMOD指令依次从栈顶弹出x、y、z三个数，</span><br><span class="line">//先计算x和y的乘积（不受溢出限制），再计算乘积和z的模，最后把结果推入栈顶</span><br><span class="line">//假定乘积不会溢出，那么MULMOD(x, y, z)等价于x * y % z</span><br><span class="line">MULMOD: &quot;MULMOD&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="加密指令集"><a href="#加密指令集" class="headerlink" title="加密指令集"></a>加密指令集</h3><blockquote>
<p><em>0x20</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA3: &quot;SHA3&quot;</span><br></pre></td></tr></table></figure>



<h3 id="关闭状态指令集"><a href="#关闭状态指令集" class="headerlink" title="关闭状态指令集"></a>关闭状态指令集</h3><blockquote>
<p><em>0x30</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ADDRESS:        &quot;ADDRESS&quot;,</span><br><span class="line">BALANCE:        &quot;BALANCE&quot;,</span><br><span class="line">ORIGIN:         &quot;ORIGIN&quot;,</span><br><span class="line">CALLER:         &quot;CALLER&quot;,</span><br><span class="line">CALLVALUE:      &quot;CALLVALUE&quot;,</span><br><span class="line">CALLDATALOAD:   &quot;CALLDATALOAD&quot;,</span><br><span class="line">CALLDATASIZE:   &quot;CALLDATASIZE&quot;,</span><br><span class="line">CALLDATACOPY:   &quot;CALLDATACOPY&quot;,</span><br><span class="line">CODESIZE:       &quot;CODESIZE&quot;,</span><br><span class="line">CODECOPY:       &quot;CODECOPY&quot;,</span><br><span class="line">GASPRICE:       &quot;GASPRICE&quot;,</span><br><span class="line">EXTCODESIZE:    &quot;EXTCODESIZE&quot;,</span><br><span class="line">EXTCODECOPY:    &quot;EXTCODECOPY&quot;,</span><br><span class="line">RETURNDATASIZE: &quot;RETURNDATASIZE&quot;,</span><br><span class="line">RETURNDATACOPY: &quot;RETURNDATACOPY&quot;,</span><br><span class="line">EXTCODEHASH:    &quot;EXTCODEHASH&quot;,</span><br></pre></td></tr></table></figure>



<h3 id="块操作指令集"><a href="#块操作指令集" class="headerlink" title="块操作指令集"></a>块操作指令集</h3><blockquote>
<p><em>0x40</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BLOCKHASH:   &quot;BLOCKHASH&quot;,</span><br><span class="line">COINBASE:    &quot;COINBASE&quot;,</span><br><span class="line">TIMESTAMP:   &quot;TIMESTAMP&quot;,</span><br><span class="line">NUMBER:      &quot;NUMBER&quot;,</span><br><span class="line">DIFFICULTY:  &quot;DIFFICULTY&quot;,</span><br><span class="line">GASLIMIT:    &quot;GASLIMIT&quot;,</span><br><span class="line">CHAINID:     &quot;CHAINID&quot;,</span><br><span class="line">SELFBALANCE: &quot;SELFBALANCE&quot;</span><br></pre></td></tr></table></figure>



<h3 id="存储和执行指令集"><a href="#存储和执行指令集" class="headerlink" title="存储和执行指令集"></a>存储和执行指令集</h3><blockquote>
<p><em>0x50</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP: &quot;POP&quot;,  // 栈顶弹出元素</span><br><span class="line">MLOAD:    &quot;MLOAD&quot;,</span><br><span class="line">MSTORE:   &quot;MSTORE&quot;,</span><br><span class="line">MSTORE8:  &quot;MSTORE8&quot;,</span><br><span class="line">SLOAD:    &quot;SLOAD&quot;, //先取出栈顶元素x，然后在storage中取以x为键的值（storage[x]）存入栈顶</span><br><span class="line">SSTORE:   &quot;SSTORE&quot;, //存储storage是一个键值存储，可将256位字映射到256位字</span><br><span class="line">JUMP:     &quot;JUMP&quot;,</span><br><span class="line">JUMPI:    &quot;JUMPI&quot;,</span><br><span class="line">PC:       &quot;PC&quot;,</span><br><span class="line">MSIZE:    &quot;MSIZE&quot;,</span><br><span class="line">GAS:      &quot;GAS&quot;,</span><br><span class="line">JUMPDEST: &quot;JUMPDEST&quot;</span><br></pre></td></tr></table></figure>



<h3 id="Push指令集"><a href="#Push指令集" class="headerlink" title="Push指令集"></a>Push指令集</h3><blockquote>
<p><em>0x60</em></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// PUSH系列指令把紧跟在指令后面的N（1 ～ 32）字节元素推入栈顶</span><br><span class="line">PUSH1:  &quot;PUSH1&quot;,</span><br><span class="line">...</span><br><span class="line">PUSH32: &quot;PUSH32&quot;,</span><br><span class="line"></span><br><span class="line">   //DUP系列指令复制从栈顶开始数的第N（1 ～ 16）个元素，并把复制后的元素推入栈顶</span><br><span class="line">DUP1:  &quot;DUP1&quot;,</span><br><span class="line">DUP2:  &quot;DUP2&quot;,</span><br><span class="line">...</span><br><span class="line">DUP16: &quot;DUP16&quot;,</span><br><span class="line"></span><br><span class="line">//SWAP系列指令把栈顶元素和从栈顶开始数的第N（1 ～ 16）+ 1 个元素进行交换。</span><br><span class="line">SWAP1:  &quot;SWAP1&quot;,</span><br><span class="line">...</span><br><span class="line">SWAP16: &quot;SWAP16&quot;,</span><br><span class="line"></span><br><span class="line">LOG0:   &quot;LOG0&quot;,</span><br><span class="line">...</span><br><span class="line">LOG4:   &quot;LOG4&quot;,</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之EthDB</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthDB-17/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之EthDB</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-leveldb.go</span><br><span class="line">|-memorydb.go</span><br><span class="line">|-batch.go</span><br><span class="line">|-database.go</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://www.jianshu.com/nb/9496943">https://www.jianshu.com/nb/9496943</a> （levelDB源码）</p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Ethash共识算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEthash%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-9/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Ethash共识算法</p>
<p>代码分支：<a href="https://github.com/ethereum/go-ethereum/tree/v1.9.9">https://github.com/ethereum/go-ethereum/tree/v1.9.9</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>目前以太坊中有两个共识算法的实现：<code>clique</code>和<code>ethash</code>。而<code>ethash</code>是目前以太坊主网（<code>Homestead</code>版本）的<code>POW</code>共识算法。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><code>ethash</code>模块位于以太坊项目目录下的<code>consensus/ethash</code>目录下。</p>
<ul>
<li><strong>algorithm.go</strong><br>实现了<code>Dagger-Hashimoto</code>算法的所有功能，比如生成<code>cache</code>和<code>dataset</code>、根据<code>Header</code>和<code>Nonce</code>计算挖矿哈希等。</li>
<li><strong>api.go</strong><br>实现了供<code>RPC</code>使用的<code>api</code>方法。</li>
<li><strong>consensus.go</strong><br>实现了以太坊共识接口的部分方法，包括<code>Verify</code>系列方法（<code>VerifyHeader</code>、<code>VerifySeal</code>等）、<code>Prepare</code>和<code>Finalize</code>、<code>CalcDifficulty</code>、<code>Author</code>、<code>SealHash</code>。</li>
<li><strong>ethash.go</strong><br>实现了<code>cache</code>结构体和<code>dataset</code>结构体及它们各自的方法、<code>MakeCache</code>&#x2F;<code>MakeDataset</code>函数、<code>Ethash</code>对象的<code>New</code>函数，和<code>Ethash</code>的内部方法。</li>
<li><strong>sealer.go</strong><br>实现了共识接口的<code>Seal</code>方法，和<code>Ethash</code>的内部方法<code>mine</code>。这些方法实现了<code>ethash</code>的挖矿功能。</li>
</ul>
<h2 id="Ethash-设计原理"><a href="#Ethash-设计原理" class="headerlink" title="Ethash 设计原理"></a>Ethash 设计原理</h2><h3 id="Ethash设计目标"><a href="#Ethash设计目标" class="headerlink" title="Ethash设计目标"></a>Ethash设计目标</h3><p>以太坊设计共识算法时，期望达到三个目的：</p>
<ol>
<li>抗<code>ASIC</code>性：为算法创建专用硬件的优势应尽可能小，让普通计算机用户也能使用CPU进行开采。<ul>
<li>通过内存限制来抵制（<code>ASIC</code>使用矿机内存昂贵）</li>
<li>大量随机读取内存数据时计算速度就不仅仅受限于计算单元，更受限于内存的读出速度。</li>
</ul>
</li>
<li>轻客户端可验证性: 一个区块应能被轻客户端快速有效校验。</li>
<li>矿工应该要求存储完整的区块链状态。</li>
</ol>
<h3 id="哈希数据集"><a href="#哈希数据集" class="headerlink" title="哈希数据集"></a>哈希数据集</h3><p><code>ethash</code>要计算哈希，需要先有一块数据集。这块数据集较大，初始大小大约有<code>1G</code>，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。计算哈希的数据源就是从这块数据集中来的；而决定使用数据集中的哪些数据进行哈希计算的，才是<code>header</code>的数据和<code>Nonce</code>字段。这部分是由<code>Dagger</code>算法实现的。</p>
<h4 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h4><p><code>Dagger</code>算法是用来生成数据集<code>Dataset</code>的，核心的部分就是<code>Dataset</code>的生成方式和组织结构。</p>
<p>可以把<code>Dataset</code>想成多个<code>item</code>（<strong>dataItem</strong>）组成的数组，每个<code>item</code>是<code>64</code>字节的byte数组（一条哈希）。<code>dataset</code>的初始大小约为<code>1G</code>，每隔3万个区块（一个<code>epoch</code>区间）就会更新一次，且每次更新都会比之前变大<code>8M</code>左右。</p>
<p><code>Dataset</code>的每个<code>item</code>是由一个缓存块（<code>cache</code>）生成的，缓存块也可以看做多个<code>item</code>（<strong>cacheItem</strong>）组成，缓存块占用的内存要比<code>dataset</code>小得多，它的初始大小约为<code>16M</code>。同<code>dataset</code>类似，每隔 3 万个区块就会更新一次，且每次更新都会比之前变大<code>128K</code>左右。</p>
<p>生成一条<code>dataItem</code>的程是：从缓存块中“随机”（这里的“随机”不是真的随机数，而是指事前不能确定，但每次计算得到的都是一样的值）选择一个<code>cacheItem</code>进行计算，得的结果参与下次计算，这个过程会循环 256 次。</p>
<p>缓存块是由<code>seed</code>生成的，而<code>seed</code>的值与块的高度有关。所以生成<code>dataset</code>的过程如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm8arq9t7j30x80eytji.jpg" alt="image-20201213144908721"></p>
<p><code>Dagger</code>还有一个关键的地方，就是确定性。即同一个<code>epoch</code>内，每次计算出来的<code>seed</code>、缓存、<code>dataset</code>都是相同的。否则对于同一个区块，挖矿的人和验证的人使用不同的<code>dataset</code>，就没法进行验证了。</p>
<hr>
<h3 id="Hashimoto算法"><a href="#Hashimoto算法" class="headerlink" title="Hashimoto算法"></a>Hashimoto算法</h3><p>是<code>Thaddeus Dryja</code>创造的。旨在通过<code>IO</code>限制来抵制矿机。在挖矿过程中，使内存读取限制条件，由于内存设备本身会比计算设备更加便宜以及普遍，在内存升级优化方面，全世界的大公司也都投入巨大，以使内存能够适应各种用户场景，所以有了随机访问内存的概念<code>RAM</code>，因此,现有的内存可能会比较接近最优的评估算法。<code>Hashimoto</code>算法使用区块链作为源数据，满足了上面的 1 和 3 的要求。</p>
<p>它的作用就是使用区块Header的哈希和Nonce字段、利用dataset数据，生成一个最终的哈希值。</p>
<hr>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="生成哈希数据集"><a href="#生成哈希数据集" class="headerlink" title="生成哈希数据集"></a>生成哈希数据集</h3><p><code>generate</code>函数位于<code>ethash.go</code>文件中，主要是为了生成<code>dataset</code>,其中包扩以下内容。</p>
<h4 id="生成cache-size"><a href="#生成cache-size" class="headerlink" title="生成cache size"></a>生成cache size</h4><p><code>cache size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> *，   <code>epochLength</code> 为 30000，如果<code>epoch</code> 小于 2048，则从已知的<code>epoch</code>返回相应的<code>cache size</code>，否则重新计算<code>epoch</code> </p>
<p><code>cache</code>的大小是线性增长的，<code>size</code>的值等于(2^24^ + 2^17^ * epoch - 64)，用这个值除以 64 看结果是否是一个质数，如果不是，减去128 再重新计算，直到找到最大的质数为止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">csize := cacheSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> cacheSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcCacheSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCacheSize</span><span class="params">(epoch <span class="type">int</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	size := cacheInitBytes + cacheGrowthBytes*<span class="type">uint64</span>(epoch) - hashBytes</span><br><span class="line">	<span class="keyword">for</span> !<span class="built_in">new</span>(big.Int).SetUint64(size / hashBytes).ProbablyPrime(<span class="number">1</span>) &#123; <span class="comment">// Always accurate for n &lt; 2^64</span></span><br><span class="line">		size -= <span class="number">2</span> * hashBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成dataset-size"><a href="#生成dataset-size" class="headerlink" title="生成dataset size"></a>生成dataset size</h4><p><code>dataset Size</code> 主要<em>某个特定块编号的ethash验证缓存的大小</em> , 类似上面生成<code>cache size</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dsize := datasetSize(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">datasetSize</span><span class="params">(block <span class="type">uint64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">	epoch := <span class="type">int</span>(block / epochLength)</span><br><span class="line">	<span class="keyword">if</span> epoch &lt; maxEpoch &#123;</span><br><span class="line">		<span class="keyword">return</span> datasetSizes[epoch]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> calcDatasetSize(epoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-seed-种子"><a href="#生成-seed-种子" class="headerlink" title="生成 seed 种子"></a>生成 seed 种子</h4><p><em>seedHash是用于生成验证缓存和挖掘数据集的种子。</em>长度为 32。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seed := seedHash(d.epoch*epochLength + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">seedHash</span><span class="params">(block <span class="type">uint64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> block &lt; epochLength &#123;</span><br><span class="line">		<span class="keyword">return</span> seed</span><br><span class="line">	&#125;</span><br><span class="line">	keccak256 := makeHasher(sha3.NewLegacyKeccak256())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(block/epochLength); i++ &#123;</span><br><span class="line">		keccak256(seed, seed)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> seed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成cache"><a href="#生成cache" class="headerlink" title="生成cache"></a>生成cache</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">generateCache(cache, d.epoch, seed)</span><br></pre></td></tr></table></figure>

<p>接下来分析<code>generateCache</code>的关键代码：</p>
<p>先了解一下<strong>hashBytes</strong>，在下面的计算中都是以此为单位，它的值为 64 ，相当于一个<code>keccak512</code>哈希的长度,下文以<strong>item</strong>称呼<code>[hashBytes]byte</code>。</p>
<p>①：初始化<code>cache</code></p>
<p>此循环用来初始化<code>cache</code>：先将<code>seed</code>的哈希填入<code>cache</code>的第一个<code>item</code>,随后使用前一个<code>item</code>的哈希，填充后一个<code>item</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> offset := <span class="type">uint64</span>(hashBytes); offset &lt; size; offset += hashBytes &#123;</span><br><span class="line">		keccak512(cache[offset:], cache[offset-hashBytes:offset])</span><br><span class="line">		atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：对cache中数据按规则做异或</p>
<p>为对于每一个<code>item</code>（<code>srcOff</code>），“随机”选一个<code>item</code>（<code>xorOff</code>）与其进行异或运算；将运算结果的哈希写入<code>dstOff</code>中。这个运算逻辑将进行<code>cacheRounds</code>次。</p>
<p>两个需要注意的地方：</p>
<ul>
<li>一是<code>srcOff</code>是从尾部向头部变化的，而<code>dstOff</code>是从头部向尾部变化的。并且它俩是对应的，即当<code>srcOff</code>代表倒数第x个item时，<code>dstOff</code>则代表正数第x个item。</li>
<li>二是<code>xorOff</code>的选取。注意我们刚才的“随机”是打了引号的。<code>xorOff</code>的值看似随机，因为在给出<code>seed</code>之前，你无法知道xorOff的值是多少；但一旦<code>seed</code>的值确定了，那么每一次<code>xorOff</code>的值都是确定的。而seed的值是由区块的高度决定的。这也是同一个<code>epoch</code>内总是能得到相同<code>cache</code>数据的原因。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cacheRounds; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; rows; j++ &#123;</span><br><span class="line">			<span class="keyword">var</span> (</span><br><span class="line">				srcOff = ((j - <span class="number">1</span> + rows) % rows) * hashBytes</span><br><span class="line">				dstOff = j * hashBytes</span><br><span class="line">				xorOff = (binary.LittleEndian.Uint32(cache[dstOff:]) % <span class="type">uint32</span>(rows)) * hashBytes</span><br><span class="line">			)</span><br><span class="line">			bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBytes], cache[xorOff:xorOff+hashBytes])</span><br><span class="line">			keccak512(cache[dstOff:], temp)</span><br><span class="line"></span><br><span class="line">			atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="生成dataset"><a href="#生成dataset" class="headerlink" title="生成dataset"></a>生成dataset</h4><p><code>dataset</code>大小的计算和<code>cache</code>类似，量级不同：2^30^ + 2^23^ * epoch - 128，然后每次减256寻找最大质数。</p>
<p>生成数据是一个循环，每次生成64个字节，主要的函数是<code>generateDatasetItem</code>：</p>
<p><code>generateDatasetItem</code>的数据来源就是<code>cache</code>数据，而最终的dataset值会存储在mix变量中。整个过程也是由多个循环构成。 </p>
<p>①：初始化<code>mix</code>变量</p>
<p>根据cache值对<code>mix</code>变量进行初始化。其中<code>hashWords</code>代表的是一个<code>hash</code>里有多少个<code>word</code>值：一个<code>hash</code>的长度为<code>hashBytes</code>即64字节，一个<code>word</code>（uint32类型）的长度为 4 字节，因此<code>hashWords</code>值为 16。选取<code>cache</code>中的哪一项数据是由参数<code>index</code>和<code>i</code>变量决定的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">byte</span>, hashBytes)</span><br><span class="line">binary.LittleEndian.PutUint32(mix, cache[(index%rows)*hashWords]^index)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; hashWords; i++ &#123;</span><br><span class="line">	binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], cache[(index%rows)*hashWords+<span class="type">uint32</span>(i)])</span><br><span class="line">&#125;</span><br><span class="line">keccak512(mix, mix)</span><br></pre></td></tr></table></figure>

<p>②：将<code>mix</code>转换成<code>[]uint32</code>类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">intMix := <span class="built_in">make</span>([]<span class="type">uint32</span>, hashWords)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intMix); i++ &#123;</span><br><span class="line">		intMix[i] = binary.LittleEndian.Uint32(mix[i*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：将<code>cache</code>数据聚合进<code>intmix</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; datasetParents; i++ &#123;</span><br><span class="line">		parent := fnv(index^i, intMix[i%<span class="number">16</span>]) % rows</span><br><span class="line">		fnvHash(intMix, cache[parent*hashWords:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>FNV</code>哈希算法，是一种不需要使用密钥的哈希算法。</p>
<p>这个算法很简单：a乘以FNV质数0x01000193，然后再和b异或。</p>
<p>首先用这个算法算出一个索引值，利用这个索引从<code>cache</code>中选出一个值（<code>data</code>），然后对<code>mix</code>中的每个字节都计算一次<code>FNV</code>，得到最终的哈希值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnv</span><span class="params">(a, b <span class="type">uint32</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">0x01000193</span> ^ b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnvHash</span><span class="params">(mix []<span class="type">uint32</span>, data []<span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">        mix[i] = mix[i]*<span class="number">0x01000193</span> ^ data[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>④：将<code>intMix</code>又恢复成<code>mix</code>并计算<code>mix</code>的哈希返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> intMix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	keccak512(mix, mix)</span><br><span class="line">	<span class="keyword">return</span> mix</span><br></pre></td></tr></table></figure>

<p><code>generateCache</code>和<code>generateDataset</code>是实现<code>Dagger</code>算法的核心函数，到此整个生成哈希数据集的的过程结束。</p>
<hr>
<h3 id="共识引擎核心函数"><a href="#共识引擎核心函数" class="headerlink" title="共识引擎核心函数"></a>共识引擎核心函数</h3><p>代码位于<code>consensus.go</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glnee6vhalj31py0lkgq4.jpg" alt="image-20201214150532321"></p>
<p>①：<code>Author</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回coinbase, coinbase是打包第一笔交易的矿工的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Author(header *types.Header) (common.Address, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> header.Coinbase, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<code>VerifyHeader</code></p>
<p>主要有两步检查，第一步检查<strong>header是否已知</strong>或者<strong>是未知的祖先</strong>，第二步是<code>ethash</code>的检查：</p>
<p>2.1 header.Extra 不能超过32字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(<span class="built_in">len</span>(header.Extra)) &gt; params.MaximumExtraDataSize &#123;  <span class="comment">// 不超过32字节</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;extra-data too long: %d &gt; %d&quot;</span>, <span class="built_in">len</span>(header.Extra), params.MaximumExtraDataSize)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 时间戳不能超过15秒，15秒以后的就被认定为未来的块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !uncle &#123;</span><br><span class="line">		<span class="keyword">if</span> header.Time &gt; <span class="type">uint64</span>(time.Now().Add(allowedFutureBlockTime).Unix()) &#123;</span><br><span class="line">			<span class="keyword">return</span> consensus.ErrFutureBlock</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 当前header的时间戳小于父块的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.Time &lt;= parent.Time &#123; <span class="comment">// 当前header的时间小于等于父块的</span></span><br><span class="line">		<span class="keyword">return</span> errZeroBlockTime</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 根据时间戳和父块的难度来验证块的难度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">expected := ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.5验证<code>gas limit</code>小于2^63^ -1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cap</span> := <span class="type">uint64</span>(<span class="number">0x7fffffffffffffff</span>)</span><br><span class="line">	<span class="keyword">if</span> header.GasLimit &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasLimit: have %v, max %v&quot;</span>, header.GasLimit, <span class="built_in">cap</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 确认<code>gasUsed</code>为&lt;&#x3D; <code>gasLimit</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.GasUsed &gt; header.GasLimit &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gasUsed: have %d, gasLimit %d&quot;</span>, header.GasUsed, header.GasLimit)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 验证块号是父块加1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> diff := <span class="built_in">new</span>(big.Int).Sub(header.Number, parent.Number); diff.Cmp(big.NewInt(<span class="number">1</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrInvalidNumber</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.8检查给定的块是否满足pow难度要求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seal &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.VerifySeal(chain, header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：<code>VerifyUncles</code></p>
<p>3.1叔叔块最多两个 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(block.Uncles()) &gt; maxUncles &#123;</span><br><span class="line">		<span class="keyword">return</span> errTooManyUncles</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.2收集叔叔块和祖先块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">number, parent := block.NumberU64()<span class="number">-1</span>, block.ParentHash()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">7</span>; i++ &#123;</span><br><span class="line">		ancestor := chain.GetBlock(parent, number)</span><br><span class="line">		<span class="keyword">if</span> ancestor == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		ancestors[ancestor.Hash()] = ancestor.Header()</span><br><span class="line">		<span class="keyword">for</span> _, uncle := <span class="keyword">range</span> ancestor.Uncles() &#123;</span><br><span class="line">			uncles.Add(uncle.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		parent, number = ancestor.ParentHash(), number<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ancestors[block.Hash()] = block.Header()</span><br><span class="line">	uncles.Add(block.Hash())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.3 确保叔块只被奖励一次且叔块有个有效的祖先</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, uncle := <span class="keyword">range</span> block.Uncles() &#123;</span><br><span class="line">		<span class="comment">// Make sure every uncle is rewarded only once</span></span><br><span class="line">		hash := uncle.Hash()</span><br><span class="line">		<span class="keyword">if</span> uncles.Contains(hash) &#123;</span><br><span class="line">			<span class="keyword">return</span> errDuplicateUncle</span><br><span class="line">		&#125;</span><br><span class="line">		uncles.Add(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure the uncle has a valid ancestry</span></span><br><span class="line">		<span class="keyword">if</span> ancestors[hash] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errUncleIsAncestor</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ancestors[uncle.ParentHash] == <span class="literal">nil</span> || uncle.ParentHash == block.ParentHash() &#123;</span><br><span class="line">			<span class="keyword">return</span> errDanglingUncle</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := ethash.verifyHeader(chain, uncle, ancestors[uncle.ParentHash], <span class="literal">true</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：<code>Prepare</code></p>
<blockquote>
<p>初始化<code>header</code>的<code>Difficulty</code>字段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := chain.GetHeader(header.ParentHash, header.Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	header.Difficulty = ethash.CalcDifficulty(chain, header.Time, parent)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>⑤：<code>Finalize</code>会执行交易后的所有状态修改（例如，区块奖励），但<strong>不会组装</strong>该区块。</p>
<p>5.1累积任何块和叔块的奖励</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">accumulateRewards(chain.Config(), state, header, uncles)</span><br></pre></td></tr></table></figure>

<p>5.2计算状态树的根哈希并提交到<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br></pre></td></tr></table></figure>

<p>⑥：<code>FinalizeAndAssemble</code> 运行任何交易后状态修改（例如，块奖励），并组装最终块。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> FinalizeAndAssemble(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt) (*types.Block, <span class="type">error</span>) &#123;</span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, uncles, receipts), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显就是比<code>Finalize</code>多了 <code>types.NewBlock</code></p>
<p>⑦：<code>SealHash</code>返回在<code>seal</code>之前块的哈希（会跟<code>seal</code>之后的块哈希不同）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> SealHash(header *types.Header) (hash common.Hash) &#123;</span><br><span class="line">	hasher := sha3.NewLegacyKeccak256()</span><br><span class="line"></span><br><span class="line">	rlp.Encode(hasher, []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		header.ParentHash,</span><br><span class="line">		header.UncleHash,</span><br><span class="line">		header.Coinbase,</span><br><span class="line">		header.Root,</span><br><span class="line">		header.TxHash,</span><br><span class="line">		header.ReceiptHash,</span><br><span class="line">		header.Bloom,</span><br><span class="line">		header.Difficulty,</span><br><span class="line">		header.Number,</span><br><span class="line">		header.GasLimit,</span><br><span class="line">		header.GasUsed,</span><br><span class="line">		header.Time,</span><br><span class="line">		header.Extra,</span><br><span class="line">	&#125;)</span><br><span class="line">	hasher.Sum(hash[:<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑧：<code>Seal</code>给定的输入块生成一个新的密封请求（<strong>挖矿</strong>），并将结果推送到给定的通道中。</p>
<p>注意，该方法将立即返回并将异步发送结果。 根据共识算法，可能还会返回多个结果。这部分会在下面的挖矿中具体分析，这里跳过。</p>
<hr>
<h3 id="挖矿细节"><a href="#挖矿细节" class="headerlink" title="挖矿细节"></a>挖矿细节</h3><blockquote>
<p>大家在阅读本文时有任何疑问均可留言给我，我一定会及时回复。如果觉得写得不错可以关注最下方<strong>参考</strong>的 <code>github项目</code>，可以第一时间关注作者文章动态。</p>
</blockquote>
<p>挖矿的核心接口定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Seal(chain ChainReader, block *types.Block, results <span class="keyword">chan</span>&lt;- *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>进入到<code>seal</code>函数：</p>
<p>①：如果运行错误的<code>POW</code>，直接返回空的<code>nonce</code>和<code>MixDigest</code>，同时块也是空块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.config.PowMode == ModeFake || ethash.config.PowMode == ModeFullFake &#123;</span><br><span class="line">		header := block.Header()</span><br><span class="line">		header.Nonce, header.MixDigest = types.BlockNonce&#123;&#125;, common.Hash&#123;&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> results &lt;- block.WithSeal(header):</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;fake&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：共享<code>pow</code>的话，则转到它的共享对象执行<code>Seal</code>操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ethash.shared != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ethash.shared.Seal(chain, block, results, stop)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：获取种子源，并根据其生成<code>ethash</code>需要的种子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f ethash.rand == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 获得种子</span></span><br><span class="line">		seed, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ethash.lock.Unlock()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		ethash.rand = rand.New(rand.NewSource(seed.Int64())) <span class="comment">// 给rand赋值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：挖矿的核心工作交给<code>mine</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; threads; i++ &#123;</span><br><span class="line">		pend.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>, nonce <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> pend.Done()</span><br><span class="line">			ethash.mine(block, id, nonce, abort, locals) <span class="comment">// 真正执行挖矿的动作</span></span><br><span class="line">		&#125;(i, <span class="type">uint64</span>(ethash.rand.Int63()))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：处理挖矿的结果</p>
<ul>
<li>外部意外中止，停止所有挖矿线程</li>
<li>其中一个线程挖到正确块，中止其他所有线程</li>
<li>ethash对象发生改变，停止当前所有操作，重启当前方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> result *types.Block</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> result = &lt;-locals:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> results &lt;- result: <span class="comment">//其中一个线程挖到正确块，中止其他所有线程</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				ethash.config.Log.Warn(<span class="string">&quot;Sealing result is not read by miner&quot;</span>, <span class="string">&quot;mode&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="string">&quot;sealhash&quot;</span>, ethash.SealHash(block.Header()))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ethash.update:</span><br><span class="line">			<span class="built_in">close</span>(abort)</span><br><span class="line">			<span class="keyword">if</span> err := ethash.Seal(chain, block, results, stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				ethash.config.Log.Error(<span class="string">&quot;Failed to restart sealing after update&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>由上可以知道<code>seal</code>的核心工作是由<code>mine</code>函数完成的，重点介绍一下。</p>
<p><code>mine</code>函数其实也比较简单，它是<em>真正的<code>pow</code>矿工，用来搜索一个<code>nonce</code>值，<code>nonce</code>值开始于<code>seed</code>值，<code>seed</code>值是能最终产生正确的可匹配可验证的区块难度</em></p>
<p>①：从区块头中提取相关数据，放在全局变量域中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		header  = block.Header()</span><br><span class="line">		hash    = ethash.SealHash(header).Bytes()</span><br><span class="line">		target  = <span class="built_in">new</span>(big.Int).Div(two256, header.Difficulty) <span class="comment">// 这是用来验证的target</span></span><br><span class="line">		number  = header.Number.Uint64()</span><br><span class="line">		dataset = ethash.dataset(number, <span class="literal">false</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>②：开始产生随机<code>nonce</code>，直到我们中止或找到一个好的<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		attempts = <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">		nonce    = seed</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>③： 聚集完整的<code>dataset</code>数据，为特定的header和nonce产生最终哈希值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashimotoFull</span><span class="params">(dataset []<span class="type">uint32</span>, hash []<span class="type">byte</span>, nonce <span class="type">uint64</span>)</span></span> ([]<span class="type">byte</span>, []<span class="type">byte</span>) &#123;</span><br><span class="line">  <span class="comment">//定义一个lookup函数，用于在数据集中查找数据</span></span><br><span class="line">	lookup := <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">uint32</span>)</span></span> []<span class="type">uint32</span> &#123;</span><br><span class="line">		offset := index * hashWords <span class="comment">//hashWords是上面定义的常量值= 16</span></span><br><span class="line">		<span class="keyword">return</span> dataset[offset : offset+hashWords]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hashimoto(hash, nonce, <span class="type">uint64</span>(<span class="built_in">len</span>(dataset))*<span class="number">4</span>, lookup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现实际上<code>hashimotoFull</code>函数做的工作就是将原始数据集进行了读取分割，然后传给<code>hashimoto</code>函数。接下来重点分析<code>hashimoto</code>函数：</p>
<p>3.1根据seed获取区块头</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows := <span class="type">uint32</span>(size / mixBytes) ①</span><br><span class="line">seed := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">40</span>) ②</span><br><span class="line"><span class="built_in">copy</span>(seed, hash) ③</span><br><span class="line">binary.LittleEndian.PutUint64(seed[<span class="number">32</span>:], nonce)④</span><br><span class="line">seed = crypto.Keccak512(seed)⑤</span><br><span class="line">seedHead := binary.LittleEndian.Uint32(seed)⑥</span><br></pre></td></tr></table></figure>

<ol>
<li>计算数据集的行数</li>
<li>合并<code>header+nonce</code>到一个 40 字节的<code>seed</code></li>
<li>将区块头的<code>hash</code>拷贝到<code>seed</code>中</li>
<li>将<code>nonce</code>值填入<code>seed</code>的后（40-32&#x3D;8）字节中去，（nonce本身就是<code>uint64</code>类型，是 64 位，对应 8 字节大小），正好把<code>hash</code>和<code>nonce</code>完整的填满了 40 字节的 seed </li>
<li><code>Keccak512</code>加密<code>seed</code></li>
<li>从<code>seed</code>中获取区块头</li>
</ol>
<p>3.2 从复制的种子开始混合</p>
<ul>
<li><code>mixBytes</code>常量&#x3D; 128，<code>mix</code>的长度为 32，元素为<code>uint32</code>，是 32位，对应为 4 字节大小。所以<code>mix</code>总共大小为 4*32&#x3D;128 字节大小</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mix := <span class="built_in">make</span>([]<span class="type">uint32</span>, mixBytes/<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i++ &#123;</span><br><span class="line">		mix[i] = binary.LittleEndian.Uint32(seed[i%<span class="number">16</span>*<span class="number">4</span>:])</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 混合随机数据集节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">temp := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="built_in">len</span>(mix))<span class="comment">//与mix结构相同，长度相同</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; loopAccesses; i++ &#123;</span><br><span class="line">		parent := fnv(<span class="type">uint32</span>(i)^seedHead, mix[i%<span class="built_in">len</span>(mix)]) % rows</span><br><span class="line">		<span class="keyword">for</span> j := <span class="type">uint32</span>(<span class="number">0</span>); j &lt; mixBytes/hashBytes; j++ &#123;</span><br><span class="line">			<span class="built_in">copy</span>(temp[j*hashWords:], lookup(<span class="number">2</span>*parent+j))</span><br><span class="line">		&#125;</span><br><span class="line">		fnvHash(mix, temp)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 压缩混合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(mix); i += <span class="number">4</span> &#123;</span><br><span class="line">		mix[i/<span class="number">4</span>] = fnv(fnv(fnv(mix[i], mix[i+<span class="number">1</span>]), mix[i+<span class="number">2</span>]), mix[i+<span class="number">3</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	mix = mix[:<span class="built_in">len</span>(mix)/<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	digest := <span class="built_in">make</span>([]<span class="type">byte</span>, common.HashLength)</span><br><span class="line">	<span class="keyword">for</span> i, val := <span class="keyword">range</span> mix &#123;</span><br><span class="line">		binary.LittleEndian.PutUint32(digest[i*<span class="number">4</span>:], val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digest, crypto.Keccak256(<span class="built_in">append</span>(seed, digest...))</span><br></pre></td></tr></table></figure>

<p>最终返回的是<code>digest</code>和<code>digest</code>与<code>seed</code>的哈希；而<code>digest</code>其实就是<code>mix</code>的<code>[]byte</code>形式。在前面<code>Ethash.mine</code>的代码中我们已经看到使用第二个返回值与<code>target</code>变量进行比较，以确定这是否是一个有效的哈希值。</p>
<hr>
<h3 id="验证pow"><a href="#验证pow" class="headerlink" title="验证pow"></a>验证pow</h3><p>挖矿信息的验证有两部分：</p>
<ol>
<li>验证<code>Header.Difficulty</code>是否正确</li>
<li>验证<code>Header.MixDigest</code>和<code>Header.Nonce</code>是否正确</li>
</ol>
<p>①：验证<code>Header.Difficulty</code>的代码主要在<code>Ethash.verifyHeader</code>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeader(chain consensus.ChainReader, header, parent *types.Header, uncle <span class="type">bool</span>, seal <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  expected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> expected.Cmp(header.Difficulty) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid difficulty: have %v, want %v&quot;</span>, header.Difficulty, expected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过区块高度和时间差作为参数来计算<code>Difficulty</code>值，然后与待验证的区块的<code>Header.Difficulty</code>字段进行比较，如果相等则认为是正确的。</p>
<p>②：<code>MixDigest</code>和<code>Nonce</code>的验证主要是在<code>Header.verifySeal</code>中：</p>
<p>验证的方式:使用<code>Header.Nonce</code>和头部哈希通过<code>hashimoto</code>重新计算一遍<code>MixDigest</code>和<code>result</code>哈希值,并且验证的节点是不需要dataset数据的。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> </p>
<p>公众号：区块链技术栈  （推荐哦）</p>
<p><a href="https://eth.wiki/concepts/ethash/design-rationale">https://eth.wiki/concepts/ethash/design-rationale</a></p>
<p><a href="https://eth.wiki/concepts/ethash/dag">https://eth.wiki/concepts/ethash/dag</a></p>
<p><a href="https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/">https://www.vijaypradeep.com/blog/2017-04-28-ethereums-memory-hardness-explained/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Kademlia算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BKademlia%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Kademlia算法</p>
</blockquote>
<h2 id="KAD-算法概述"><a href="#KAD-算法概述" class="headerlink" title="KAD 算法概述"></a>KAD 算法概述</h2><p>Kademlia是一种点对点分布式哈希表（DHT），它在容易出错的环境中也具有可证明的一致性和性能。使用一种基于异或指标的拓扑结构来路由查询和定位节点，这简化了算法并有助于证明。该拓扑结构有一个特点：<strong>每次消息交换都能够传递或强化有效信息</strong>。系统利用这些信息进行并发的异步查询，可以容忍节点故障，并且故障不会导致用户超时。</p>
<h2 id="KAD算法要处理的问题"><a href="#KAD算法要处理的问题" class="headerlink" title="KAD算法要处理的问题"></a>KAD算法要处理的问题</h2><ol>
<li>如何分配存储内容到各个节点，新增&#x2F;删除内容如何处理</li>
<li>如何找到存储文件的节点&#x2F;地址&#x2F;路径</li>
</ol>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>节点的基本属性包括如下：</p>
<blockquote>
<ul>
<li>节点ID，Node ID</li>
<li>节点IP地址与端口号</li>
</ul>
</blockquote>
<p>在 Kad 网络中，所有节点都被当作一颗二叉树的叶子，并且每一个节点的位置都由其 ID 值的最短前缀唯一的确定。</p>
<p>对于任意一个节点，都可以把这颗二叉树分解为一系列连续的，不包含自己的子树。最高层的子树，由整颗树不包含自己的树的另一半组成；下一层子树由剩下部分不包含自己的一半组成；依此类推，直到分割完整颗树。图 1 就展示了节点0011如何进行子树的划分：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxt4yerlnj313e0ckgpk.jpg" alt="image-20201122115058412"></p>
<p>虚线包含的部分就是各子树，由上到下各层的前缀分别为0，01，000，0010。</p>
<p>Kad 协议确保每个节点知道其各子树的至少一个节点，只要这些子树非空。在这个前提下，每个节点都可以通过ID值来找到任何一个节点。这个路由的过程是通过所谓的 XOR（异或）距离得到的。</p>
<p>图 2 就演示了节点0011如何通过连续查询来找到节点1110的。节点0011通过在逐步底层的子树间不断学习并查询最佳节点，获得了越来越接近的节点，最终收敛到目标节点上。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxt81k4ltj314o0u0ti5.jpg" alt="image-20201122115359426"></p>
<p>需要说明的是:<strong>只有第一步查询的节点101，是节点0011已经知道的，后面各步查询的节点，都是由上一步查询返回的更接近目标的节点，这是一个递归操作的过程</strong>。</p>
<hr>
<h2 id="节点距离"><a href="#节点距离" class="headerlink" title="节点距离"></a>节点距离</h2><p>Kad 网络中每个节点都有一个 160 bit 的 ID 值作为标志符，Key 也是一个 160 bit 的标志符，每一个加入 Kad 网络的计算机都会在 160 bit 的 key 空间被分配一个节点 ID（node ID）值（可以认为 ID 是随机产生的）， <code>&lt;key,value&gt;</code> 对的数据就存放在 ID 值“最”接近 key 值的节点上。</p>
<p>判断两个节点 x,y 的距离远近是基于数学上的异或的二进制运算， d(x,y)&#x3D;x⊕y ，既对应位相同时结果为0，不同时结果为1。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    010101</span><br><span class="line">XOR 110001</span><br><span class="line">----------</span><br><span class="line">    100100</span><br></pre></td></tr></table></figure>

<p>则这两个节点的距离为 32+4&#x3D;36 。</p>
<p>显然，高位上数值的差异对结果的影响更大。</p>
<p>对于异或操作，有如下一些数学性质：</p>
<ul>
<li>两个节点间的距离是随机的</li>
<li>节点与自身的距离是0</li>
<li>对称性。A 到 B 的距离和 B 到 A 的距离相等</li>
<li>三角不等。distance(A,B)+distance(B,C) &lt;&#x3D; distance(A,C)</li>
</ul>
<p>对于任意给定的节点 x 和距离 Δ≥0 ，总会存在一个精确的节点 y ，使得 d(x,y)&#x3D;Δ 。另外，单向性也确保了对于同一个 key 值的所有查询都会逐步收敛到同一个路径上，而不管查询的起始节点位置如何。这样，只要沿着查询路径上的节点都缓存这个 <code>&lt;key,value&gt;</code> 对，就可以减轻存放热门 key 值节点的压力，同时也能够加快查询响应速度。</p>
<h2 id="K桶"><a href="#K桶" class="headerlink" title="K桶"></a>K桶</h2><h3 id="K-桶的概念"><a href="#K-桶的概念" class="headerlink" title="K 桶的概念"></a>K 桶的概念</h3><p>Kad 的路由表是通过一些称之为 K 桶的表格构造起来的。</p>
<p>对每一个 0≤i≤160 ，每个节点都保存有一些和自己距离范围在区间 [2^i^,2^i+1^) 内的一些节点信息，这些信息由一些 (IP address,UDP port,Node ID) 数据列表构成（Kad 网络是靠 UDP 协议交换信息的）。每一个这样的列表都称之为一个 K 桶，并且每个 K 桶内部信息存放位置是根据上次看到的时间顺序排列，最近（ least-recently）看到的放在头部，最后（most-recently）看到的放在尾部。每个桶都有不超过 k 个的数据项。</p>
<p>一个节点的全部 K 桶列表如下图 所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxxsik21cj30qs0eidhw.jpg" alt="image-20201122143202816"></p>
<p>当 i 值很小时，K 桶通常是空的（也就是说没有足够多的节点，比如当 i &#x3D; 0 时，就最多可能只有1项）；而当 i 值很大时，其对应 K 桶的项数又很可能会超过 k 个（当然，覆盖距离范围越广，存在较多节点的可能性也就越大），这里 k 是为平衡系统性能和网络负载而设置的一个常数，但必须是偶数，比如 k &#x3D; 20。在 BitTorrent 的实现中，取值为 k &#x3D; 8。</p>
<p>由于每个 K 桶覆盖距离的范围呈指数关系增长，这就形成了离自己近的节点的信息多，离自己远的节点的信息少，从而可以保证路由查询过程是收敛。因为是用指数方式划分区间，经过证明，对于一个有 N 个节点的 Kad 网络，最多只需要经过 logN 步查询，就可以准确定位到目标节点。</p>
<h3 id="K桶更新机制"><a href="#K桶更新机制" class="headerlink" title="K桶更新机制"></a>K桶更新机制</h3><p>当节点 x 收到一个 PRC 消息时，发送者 y 的 IP 地址就被用来更新对应的 K 桶，具体步骤如下：</p>
<ol>
<li>计算自己和发送者的距离： d(x,y)&#x3D;x⊕y ，注意：x 和 y 是 ID 值，不是 IP 地址</li>
<li>通过距离 d 选择对应的 K 桶进行更新操作</li>
<li>如果 y 的 IP 地址已经存在于这个 K 桶中，则把对应项移到该该 K 桶的尾部</li>
<li>如果 y 的 IP 地址没有记录在该 K 桶中<ol>
<li>如果该 K 桶的记录项小于 k 个，则直接把 y 的 (IP address, UDP port, Node ID) 信息插入队列尾部</li>
<li>如果该 K 桶的记录项大于 k 个，则选择头部的记录项（假如是节点 z）进行 RPC_PING 操作<ol>
<li>如果 z 没有响应，则从 K 桶中移除 z 的信息，并把 y 的信息插入队列尾部</li>
<li>如果 z 有响应，则把 z 的信息移到队列尾部，同时忽略 y 的信息</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>K 桶的更新机制非常高效的实现了一种把<strong>最近看到的节点更新</strong>的策略，除非在线节点一直未从 K 桶中移出过。也就是说在线时间长的节点具有较高的可能性继续保留在 K 桶列表中。</p>
<p>所以，通过把在线时间长的节点留在 K 桶里，Kad 就明显增加 K 桶中的节点在下一时间段仍然在线的概率，这<strong>对应 Kad 网络的稳定性和减少网络维护成本（不需要频繁构建节点的路由表）</strong>带来很大好处。</p>
<p>这种机制的另一个好处是能在<strong>一定程度上防御 DOS 攻击</strong>，因为只有当老节点失效后，Kad 才会更新 K 桶的信息，这就避免了通过新节点的加入来泛洪路由信息。</p>
<p>为了防止 K 桶老化，所有在一定时间之内无更新操作的 K 桶，都会分别从自己的 K 桶中随机选择一些节点执行 RPC_PING 操作。</p>
<p>上述这些 K 桶机制使 Kad 缓和了流量瓶颈（所有节点不会同时进行大量的更新操作），同时也能对节点的失效进行迅速响应。</p>
<hr>
<h2 id="协议消息"><a href="#协议消息" class="headerlink" title="协议消息"></a>协议消息</h2><p>Kademlia 协议包括四种远程 RPC 操作：PING、STORE、FIND_NODE、FIND_VALUE。</p>
<ol>
<li><p>PING 操作的作用是探测一个节点，用以判断其是否仍然在线。</p>
</li>
<li><p>STORE 操作的作用是通知一个节点存储一个 <code>&lt;key,value&gt;</code> 对，以便以后查询需要。</p>
</li>
<li><p>FIND_NODE 操作使用一个 160 bit 的 ID 作为参数。本操作的接受者返回它所知道的更接近目标 ID 的 K 个节点的 (IP address, UDP port, Node ID) 信息。</p>
<p>这些节点的信息可以是从一个单独的 K 桶获得，也可以从多个 K 桶获得（如果最接近目标 ID 的 K 桶未满）。不管是哪种情况，接受者都将返回 K 个节点的信息给操作发起者。但如果接受者所有 K 桶的节点信息加起来也没有 K 个，则它会返回全部节点的信息给发起者。</p>
</li>
<li><p>FIND_VALUE 操作和 FIND_NODE 操作类似，不同的是它只需要返回一个节点的 (IP address, UDP port, Node ID) 信息。如果本操作的接受者收到同一个 key 的 STORE 操作，则会直接返回存储的 value 值。</p>
<p>注：在 Kad 网络中，系统存储的数据以 <code>&lt;key,value&gt;</code> 对形式存放。根据笔者的分析，在 BitSpirit 的 DHT 实现中，其 key 值为 torrent 文件的 info_hash 串，其 value 值则和 torrent 文件有密切关系。</p>
</li>
</ol>
<p>为了防止伪造地址，在所有 RPC 操作中，接受者都需要响应一个随机的 160 bit 的 ID 值。另外，为了确信发送者的网络地址，PING 操作还可以附带在接受者的 RPC 回复信息中（<strong>在上述 4种操作中 接受者回复 发送者时，可以携带上 接受者对 发送者的 PING, 以此校验 发送者是否还健在</strong>）。</p>
<hr>
<h2 id="路由查找"><a href="#路由查找" class="headerlink" title="路由查找"></a>路由查找</h2><p>Kad 技术的最大特点之一就是能够提供快速的节点查找机制，并且还可以通过参数进行查找速度的调节。</p>
<p>假如节点 x 要查找 ID 值为 t 的节点，Kad 按照如下递归操作步骤进行路由查找：</p>
<ol>
<li>计算到 t 的距离： d(x,y)&#x3D;x⊕y</li>
<li>从 x 的第 [logd] 个 K 桶中取出 α 个节点的信息（“[”“]”是取整符号），同时进行 FIND_NODE 操作。如果这个 K 桶中的信息少于 α 个，则从附近多个桶中选择距离最接近 d 的总共 α 个节点。</li>
<li>对接受到查询操作的每个节点，如果发现自己就是 t，则回答自己是最接近 t 的；否则测量自己和 t 的距离，并从自己对应的 K 桶中选择 α 个节点的信息给 x。</li>
<li>X 对新接受到的每个节点都再次执行 FIND_NODE 操作，此过程不断重复执行，直到每一个分支都有节点响应自己是最接近 t 的。</li>
<li>通过上述查找操作，x 得到了 k 个最接近 t 的节点信息。</li>
</ol>
<p>注意：这里用“最接近”这个说法，是因为 ID 值为 t 的节点不一定存在网络中，也就是说 t 没有分配给任何一台电脑。</p>
<p>这里 α 也是为系统优化而设立的一个参数，就像 K 一样。在 BitTorrent 实现中，取值为 α&#x3D;3 。</p>
<p>当 α&#x3D;1 时，查询过程就类似于 Chord 的逐跳查询过程，如图 4。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxw58zgnyj30ym0u0ast.jpg" alt="image-20201122133505567"></p>
<p>整个路由查询过程是递归操作的，其过程可用数学公式表示为：</p>
<blockquote>
<p>N0&#x3D;x (即查询操作的发起者)</p>
<p>N1&#x3D;find ⎯noden0(t)</p>
<p>N2&#x3D;find ⎯noden1(t)</p>
<p>… …</p>
<p>Nl&#x3D;find ⎯nodenl−1(t)</p>
</blockquote>
<p>这个递归过程一直持续到 Nl&#x3D;t ，或者 Nl 的路由表中没有任何关于 t 的信息，即查询失败。</p>
<p>由于每次查询都能从更接近 t 的 K 桶中获取信息，这样的机制保证了每一次递归操作都能够至少获得距离减半（或距离减少 1 bit）的效果，从而保证整个查询过程的收敛速度为 O(logN) ，这里 N 为网络全部节点的数量。</p>
<p>当节点 x 要查询 <code>&lt;key,value&gt;</code> 对时，和查找节点的操作类似，x 选择 k 个 ID 值最接近 key 值的节点，执行 FIND_VALUE 操作，并对每一个返回的新节点重复执行 FIND_VALUE 操作，直到某个节点返回 value 值。</p>
<p>一旦 FIND_VALUE 操作成功执行，则 <code>&lt;key,value&gt;</code> 对数据会缓存在没有返回 value 值的最接近的节点上。这样下一次查询相同的 key 时就会更加快速的得到结果。通过这样的方式，热门 <code>&lt;key,value&gt;</code> 对数据的缓存范围就逐步扩大，使系统具有极佳的响应速度( <strong>cache 为存活24小时</strong>，但是目标节点上的内容时<strong>每1小时</strong>向其他最近节点重新发布&lt;key, value&gt;使得数据的超时时间得以刷新，而远离目标节点的节点的数据存活时间当然就可能不会被重新发布到，所以也就是数据缓存的超时时间和节点的距离成反比)</p>
<hr>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>存放 <code>&lt;key,value&gt;</code> 对数据的过程为：</p>
<ol>
<li>发起者首先定位 k 个 ID 值最接近 key 的节点</li>
<li>发起者对这 k 个节点发起 STORE 操作</li>
<li>执行 STORE 操作的 k 个节点每小时重发布自己所有的 <code>&lt;key,value&gt;</code> 对数据</li>
<li>为了限制失效信息，所有 <code>&lt;key,value&gt;</code> 对数据在初始发布24小时后过期</li>
</ol>
<p>另外，为了保证数据发布、搜寻的一致性，规定在任何时候，当节点 w 发现新节点 u 比 w 上的某些 <code>&lt;key,value&gt;</code> 对数据更接近，则 w 把这些 <code>&lt;key,value&gt;</code> 对数据复制到 u 上，但是并不会从 w 上删除。</p>
<hr>
<h2 id="节点的加入和离开"><a href="#节点的加入和离开" class="headerlink" title="节点的加入和离开"></a>节点的加入和离开</h2><p>如果节点 u 要想加入 Kad 网络，它必须要和一个已经在 Kad 网络的节点，比如 w，取得联系。</p>
<p>u 首先把 w 插入自己适当的 K 桶中，然后对自己的节点 ID 执行一次 FIND_NODE 操作 (向 w 发布 查找 u 的 FIND_NODE 请求)，然后根据接收到的信息更新自己的 K 桶内容。通过对自己邻近节点由近及远的逐步查询，u 完成了仍然是空的 K 桶信息的构建，同时也把自己的信息发布到其他节点的 K 桶中。</p>
<p>节点 u 为例，其路由表的生成过程为：</p>
<ol>
<li>最初，u 的路由表为一个单个的 K 桶，覆盖了整个 160 bit ID 空间，如图 6 最上面的路由表；</li>
<li>当学习到新的节点信息后，则 u 会尝试把新节点的信息，根据其前缀值插入到对应的 K 桶中：<ol>
<li>如果该 K 桶没有满，则新节点直接插入到这个 K 桶中；</li>
<li>如果该 K 桶已经满了，<ol>
<li>如果该 K 桶覆盖范围包含了节点 u 的 ID，则把该 K 桶分裂为两个大小相同的新 K 桶，并对原 K 桶内的节点信息按照新的 K 桶前缀值进行重新分配</li>
<li>如果该 K 桶覆盖范围没有包节点 u 的 ID，则直接丢弃该新节点信息</li>
</ol>
</li>
</ol>
</li>
<li>上述过程不断重复，最终会形成表 1 结构的路由表。达到距离近的节点的信息多，距离远的节点的信息少的结果，保证了路由查询过程能快速收敛。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxyh70im3j30vu0my40e.jpg" alt="image-20201122145547341"></p>
<p>在图 7 中，演示了当覆盖范围包含自己 ID 值的 K 桶是如何逐步分裂的。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkxyhl2k3bj30vk0pgq7o.jpg" alt="image-20201122145609681"></p>
<p>当 K 桶 010 满了之后，由于其覆盖范围包含了节点 0100 的 ID，故该 K 桶分裂为两个新的 K 桶：0101 和 0100，原 K 桶 010 的信息会根据其其前缀值重新分布到这两个新的 K 桶中。注意，这里并没有使用 160 bit 的 ID 值表示法，只是为了方便原理的演示，实际 Kad 网络中的 ID 值都是 160 bit 的。</p>
<p><strong>节点离开 Kad 网络不需要发布任何信息</strong>，Kademlia 协议的目标之一就是能够弹性工作在任意节点随时失效的情况下。为此，Kad 要求每个节点必须周期性 【一般是： 每小时】 的发布全部自己存放的 &lt;key,value&gt; 对数据，并把这些数据缓存在自己的 k 个最近邻居处，这样存放在失效节点的数据会很快被更新到其他新节点上。所以有节点离开了，那么就离开了，而且节点中的k-桶刷新机制也能保证会把已经不在线的节点信息从自己本地k-桶中移除</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>公众号：区块链技术栈</p>
<p>文章及所有资料：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之MPT树-上</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8A-13/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之MPT树-上</p>
</blockquote>
<h2 id="前缀树Trie"><a href="#前缀树Trie" class="headerlink" title="前缀树Trie"></a>前缀树Trie</h2><p>前缀树（又称字典树），通常来说，一个前缀树是用来<code>存储字符串</code>的。前缀树的每一个节点代表一个<code>字符串</code>（<code>前缀</code>）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>组成的。如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm73i6xursj31820qq789.jpg" alt="image-20201231160000592"></p>
<p>Trie的结点看上去是这样子的：</p>
<blockquote>
<p>[ [Ia, Ib, … I*], value]</p>
</blockquote>
<p>其中 <code>[Ia, Ib, ... I*]</code> 在本文中我们将其称为结点的 <em>索引数组</em> ，它以 key 中的下一个字符为索引，每个元素<code>I*</code>指向对应的子结点。 <code>value</code> 则代表从根节点到当前结点的路径组成的key所对应的值。如果不存在这样一个 key，则 value 的值为空。</p>
<p>前缀树的性质：</p>
<ol>
<li><p>每一层节点上面的值都不相同；</p>
</li>
<li><p>根节点不存储值；除根节点外每一个节点都<strong>只包含一个字符</strong>，代表的字符串是由节点本身的<code>原始字符串</code>，以及<code>通往该子节点路径上所有的字符</code>。</p>
</li>
<li><p>前缀树的查找效率是$O(m)$，$m$为所查找节点的长度，而哈希表的查找效率为$O(1)$。且一次查找会有 m 次 <code>IO</code>开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。</p>
</li>
<li><p>当存在一个节点，其内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。</p>
</li>
</ol>
<h2 id="压缩前缀树Patricia-Tree"><a href="#压缩前缀树Patricia-Tree" class="headerlink" title="压缩前缀树Patricia Tree"></a>压缩前缀树Patricia Tree</h2><p><strong>基数树</strong>（也叫<strong>基数特里树</strong>或<strong>压缩前缀树</strong>）是一种数据结构，是一种更节省空间的<strong>前缀树</strong>，其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数 <em>r</em> ，其中 <em>r</em> 为正整数， <em>x</em> 为 2 的幂， <em>x</em>≥1 ，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70dwcmgdj31780kkqae.jpg" alt="image-20201231133805927"></p>
<p>图中可以很容易看出数中所存储的键值对：</p>
<ul>
<li>6c0a5c71ec20bq3w &#x3D;&gt; 5</li>
<li>6c0a5c71ec20CX7j &#x3D;&gt; 27</li>
<li>6c0a5c71781a1FXq &#x3D;&gt; 18</li>
<li>6c0a5c71781a9Dog &#x3D;&gt; 64</li>
<li>6c0a8f743b95zUfe &#x3D;&gt; 30</li>
<li>6c0a8f743b95jx5R &#x3D;&gt; 2</li>
<li>6c0a8f740d16y03G &#x3D;&gt; 43</li>
<li>6c0a8f740d16vcc1 &#x3D;&gt; 48</li>
</ul>
<h2 id="默克尔树Merkle-Tree"><a href="#默克尔树Merkle-Tree" class="headerlink" title="默克尔树Merkle Tree"></a>默克尔树Merkle Tree</h2><p>Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm69qu5vh8j31ba0ragpn.jpg" alt="image-20201230225028932"></p>
<p>在构造<code>Merkle</code>树时，首先要计算数据块的哈希值，通常，选用<code>SHA-256</code>等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如<code>CRC</code>。然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希，再重复这个步骤，一直到计算出根哈希值。</p>
<p>所以我们可以简单总结出<strong>merkle Tree</strong> 有以下几个性质：</p>
<ul>
<li>校验整体数据的正确性</li>
<li>快速定位错误</li>
<li>快速校验部分数据是否在原始的数据中</li>
<li>存储空间开销大（<strong>大量中间哈希</strong>）</li>
</ul>
<h2 id="以太坊的改进方案"><a href="#以太坊的改进方案" class="headerlink" title="以太坊的改进方案"></a>以太坊的改进方案</h2><h3 id="使用-byte作为key类型"><a href="#使用-byte作为key类型" class="headerlink" title="使用[]byte作为key类型"></a>使用[]byte作为key类型</h3><p>在以太坊的Trie模块中，key和value都是[]byte类型。如果要使用其它类型，需要将其转换成[]byte类型（比如使用<strong>rlp</strong>进行转换）。</p>
<p><strong>Nibble</strong> ：是 key 的基本单元，是一个四元组（四个 bit 位的组合例如二进制表达的 0010 就是一个四元组）</p>
<p>在Trie模块对外提供的接口中，key类型是[]byte。但在内部实现里，将key中的每个字节按高4位和低4位拆分成了两个字节。比如你传入的key是：</p>
<blockquote>
<p>[0x1a, 0x2b, 0x3c, 0x4d]</p>
</blockquote>
<p>Trie内部将这个key拆分成：</p>
<blockquote>
<p>[0x1, 0xa, 0x2, 0xb, 0x3, 0xc, 0x4, 0xd]</p>
</blockquote>
<p>Trie内部的编码中将拆分后的<strong>每一个字节</strong>称为 <strong>nibble</strong></p>
<p>如果使用一个完整的 byte 作为 key 的最小单位，那么前文提到的索引数组的大小应该是 256（byte作为数组的索引，最大值为255，最小值为0）。而索引数组的每个元素都是一个 32 字节的哈希,这样每个结点要占用大量的空间。并且索引数组中的元素多数情况下是空的，不指向任何结点。因此这种实现方法占用大量空间而不使用。以太坊的改进方法，可以将索引数组的大小降为 16（4个bit的最大值为0xF，最小值为 0），因此大大减少空间的浪费。</p>
<h3 id="新增类型节点"><a href="#新增类型节点" class="headerlink" title="新增类型节点"></a>新增类型节点</h3><p>前缀树和<code>merkle</code>树存在明显的局限性，所以以太坊为<code>MPT</code>树新增了几种不同类型的树节点，通过针对不同节点不同操作来解决效率以及存储上的问题。</p>
<ol>
<li><strong>shortNode</strong>: 叶子节点或者扩展节点，当 <code>shortNode.Key</code>的末尾字节是终止符 <code>16</code> 时表示为叶子节点。当 <code>shortNode</code> 是叶子节点是，<code>Val</code> 是 valueNode。</li>
<li><strong>fullNode</strong>:  分支节点，<code>fullNode[16]</code>的类型是 <code>valueNode</code>。前 16 个元素对应键中可能存在的一个十六进制字符。如果键<code>[key,value]</code>在对应的分支处结束，则在列表末尾存储 <code>value</code> 。</li>
<li><strong>hashNode</strong>: 应该取名为 <code>collapsedNode</code> 折叠节点更合适些，但因为其值是一个哈希值当做指针使用，所以取名 <code>hashNode</code>。使用这个哈希值可以从数据库读取节点数据展开节点。</li>
<li><strong>valueNode</strong>: 数据节点，实际的业务数据值，严格来说他不属于树中的节点，它只存在于 <code>fullNode.Children</code> 或者 shortNode.Val 中。</li>
</ol>
<p>简单先看个例子，假设有3个键值对，看一下在以太坊中是怎么以MPT的形式存储的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg6d40u15j31hu0o0jzy.jpg" alt="image-20210108122909361"></p>
<h3 id="以太坊中使用到的MPT树结构"><a href="#以太坊中使用到的MPT树结构" class="headerlink" title="以太坊中使用到的MPT树结构"></a>以太坊中使用到的MPT树结构</h3><ul>
<li><code>State Trie</code> 区块头中的状态树<ul>
<li>key &#x3D;&gt; sha3(以太坊账户地址 address)</li>
<li>value &#x3D;&gt; rlp(账号内容信息 account)</li>
</ul>
</li>
<li>Transactions Trie 区块头中的交易树<ul>
<li>key &#x3D;&gt; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Receipts Trie</code> 区块头中的收据树<ul>
<li>key &#x3D; rlp(交易的偏移量 transaction index)</li>
<li>每个块都有各自的交易树，且不可更改</li>
</ul>
</li>
<li><code>Storage Trie</code> 存储树<ul>
<li>存储只能合约状态</li>
<li>每个账号有自己的 Storage Trie</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm70f77s2dj319g0lymyz.jpg" alt="image-20201231141329137"></p>
<p>这两个区块头中，<code>state root</code>、<code>tx root</code>、 <code>receipt root</code>分别存储了这三棵树的树根，第二个区块显示了当账号 17 5的数据变更(<strong>27 -&gt; 45</strong>)的时候，只需要存储跟这个账号相关的部分数据，而且老的区块中的数据还是可以正常访问。</p>
<h3 id="key编码规则"><a href="#key编码规则" class="headerlink" title="key编码规则"></a>key编码规则</h3><p>三种编码方式分别为：</p>
<ol>
<li><strong>Raw</strong>编码（原生的字符）；</li>
<li><strong>Hex</strong>编码（扩展的16进制编码）；</li>
<li><strong>Hex-Prefix</strong>编码（16进制前缀编码）；</li>
</ol>
<p><strong>Raw编码</strong></p>
<p><strong>Raw</strong>编码就是原生的<strong>key</strong>值，不做任何改变。这种编码方式的<strong>key</strong>，<em>是<strong>MPT</strong>对外提供接口的默认编码方式</em>。</p>
<blockquote>
<p>例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是[‘c’, ‘a’, ‘t’]，换成ASCII表示方式就是[63, 61, 74]</p>
</blockquote>
<p><strong>Hex编码</strong></p>
<p><em>Hex编码用于对内存中MPT树节点key进行编码</em>.</p>
<p>为了减少分支节点孩子的个数，将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p>
<blockquote>
<p>半字节，在计算机中，通常将8位二进制数称为字节，而把4位二进制数称为半字节。 高四位和低四位，这里的“位”是针对二进制来说的。比如数字 250 的二进制数为 11111010，则高四位是左边的 1111，低四位是右边的 1010。</p>
</blockquote>
<p>从<strong>Raw</strong>编码向<strong>Hex</strong>编码的转换规则是：</p>
<ul>
<li><strong>Raw</strong>编码输入的每个字符分解为高 4 位和低 4 位</li>
<li>如果是叶子节点，则在最后加上<strong>Hex</strong>值<code>0x10</code>表示结束</li>
<li>如果是分支节点不附加任何<strong>Hex</strong>值</li>
</ul>
<p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p>
<table>
<thead>
<tr>
<th align="left">i</th>
<th align="left">key[i]</th>
<th align="left">key[i]二进制</th>
<th align="left">nibbles[i*2]&#x3D;高四位</th>
<th align="left">nibbles[i*2+1]&#x3D;低四位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">114</td>
<td align="left">01110010</td>
<td align="left">0111&#x3D; 7</td>
<td align="left">0010&#x3D; 2</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">111</td>
<td align="left">01101111</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1111&#x3D;15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">109</td>
<td align="left">01101101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1101&#x3D;13</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">97</td>
<td align="left">01100001</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0001&#x3D;1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">110</td>
<td align="left">01101110</td>
<td align="left">0110&#x3D;6</td>
<td align="left">1110&#x3D;14</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">01100101</td>
<td align="left">0110&#x3D;6</td>
<td align="left">0101&#x3D;5</td>
</tr>
</tbody></table>
<p>最终得到 Hex(“romane”) &#x3D; <code>[7 2 6 15 6 13 6 1 6 14 6 5 16]</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="type">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span>   <span class="comment">// 高四位</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span> <span class="comment">// 低四位</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span> <span class="comment">// 最后一位存入标示符 代表是hex编码</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Hex-Prefix</strong>编码</p>
<p><strong>数学公式定义：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm75cvok4yj318s07iwfg.jpg" alt="image-20201231170415071"></p>
<p>Hex-Prefix 编码是一种任意量的半字节转换为数组的有效方式，还可以在存入一个标识符来区分不同节点类型。 因此 HP 编码是在由一个标识符前缀和半字节转换为数组的两部分组成。存入到数据库中存在节点 Key 的只有扩展节点和叶子节点，因此 HP 只用于区分扩展节点和叶子节点，不涉及无节点 key 的分支节点。其编码规则如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm74pxxc7yj31ju0cm41o.jpg" alt="image-20201231164209626"></p>
<p>前缀标识符由两部分组成：节点类型和奇偶标识，并存储在编码后字节的第一个半字节中。 0 表示扩展节点类型，1 表示叶子节点，偶为 0，奇为 1。最终可以得到唯一标识的前缀标识：</p>
<ul>
<li>0：偶长度的扩展节点</li>
<li>1：奇长度的扩展节点</li>
<li>2：偶长度的叶子节点</li>
<li>3：奇长度的叶子节点</li>
</ul>
<p>当偶长度时，第一个字节的低四位用<code>0</code>填充，当是奇长度时，则将 key[0] 存放在第一个字节的低四位中，这样 HP 编码结果始终是偶长度。 这里为什么要区分节点 key 长度的奇偶呢？这是因为，半字节 <code>1</code> 和 <code>01</code> 在转换为 bytes 格式时都成为<code>&lt;01&gt;</code>，无法区分两者。</p>
<p>例如，上图 “以太坊 MPT 树的哈希计算”中的控制节点1的key 为 <code>[ 7 2 6 f 6 d]</code>，因为是偶长度，则 HP[0]&#x3D; (00000000) &#x3D;0，H[1:]&#x3D; 解码半字节(key)。 而节点 3 的 key 为 <code>[1 6 e 6 5]</code>，为奇长度，则 HP[0]&#x3D; (0001 0001)&#x3D;17。</p>
<p><strong>HP</strong>编码的规则如下：</p>
<ul>
<li>key结尾为<strong>0x10</strong>，则去掉这个终止符</li>
<li>key之前补一个四元组这个Byte第0位区分奇偶信息，第 1 位区分节点类型</li>
<li>如果输入<strong>key</strong>的长度是偶数，则再添加一个四元组0x0在flag四元组后</li>
<li>将原来的key内容压缩，将分离的两个byte以高四位低四位进行合并</li>
</ul>
<blockquote>
<p>十六进制前缀编码相当于一个逆向的过程，比如输入的是[6 2 6 15 6 2 16]，</p>
<p>根据第一个规则去掉终止符16。根据第二个规则key前补一个四元组，从右往左第一位为1表示叶子节点，</p>
<p>从右往左第0位如果后面key的长度为偶数设置为0，奇数长度设置为1，那么四元组0010就是2。</p>
<p>根据第三个规则，添加一个全0的补在后面，那么就是20.根据第三个规则内容压缩合并，那么结果就是[0x20 0x62 0x6f 0x62]</p>
</blockquote>
<p> <strong>HP 编码源码实现:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	terminator := <span class="type">byte</span>(<span class="number">0</span>) <span class="comment">//初始化一个值为0的byte，它就是我们上面公式中提到的t</span></span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123;     <span class="comment">//验证hex有后缀编码，</span></span><br><span class="line">		terminator = <span class="number">1</span>         <span class="comment">//hex编码有后缀，则t=1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//此处只是去掉后缀部分的hex编码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////Compact开辟的空间长度为hex编码的一半再加1，这个1对应的空间是Compact的前缀</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">	<span class="comment">////这一阶段的buf[0]可以理解为公式中的16*f(t)</span></span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// the flag byte</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;     <span class="comment">//hex 长度为奇数，则逻辑上说明hex有前缀</span></span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">////这一阶段的buf[0]可以理解为公式中的16*（f(t)+1）</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// first nibble is contained in the first byte</span></span><br><span class="line">		hex = hex[<span class="number">1</span>:]    <span class="comment">//此时获取的hex编码无前缀无后缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:]) <span class="comment">//将hex编码映射到compact编码中</span></span><br><span class="line">	<span class="keyword">return</span> buf                  <span class="comment">//返回compact编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上三种编码方式的转换关系为：</p>
<ul>
<li>Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；</li>
<li>Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；</li>
<li>HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；</li>
</ul>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71rsyyekj319w05ygml.jpg" alt="image-20201231150011417"></p>
<p>以上介绍的MPT树，可以用来存储内容为任何长度的<code>key-value</code>数据项。倘若数据项的<code>key</code>长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：</p>
<ul>
<li>查询一个节点可能会需要许多次 IO 读取，效率低下；</li>
<li>系统易遭受 Dos 攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用<code>SLOAD</code>指令读取该树节点的内容，造成系统执行效率极度下降；</li>
<li>所有的 key 其实是一种明文的形式进行存储；</li>
</ul>
<p>为了解决以上问题，以太坊对<strong>MPT</strong>再进行了一次封装，对数据项的<strong>key</strong>进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是<code>(sha3(key), value)</code></p>
<p><strong>优势</strong>：</p>
<ul>
<li>传入MPT接口的 key 是固定长度的（32字节），可以避免出现树中出现长度很长的路径；</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>每次树操作需要增加一次哈希计算；</li>
<li>需要在数据库中存储额外的<code>sha3(key)</code>与<code>key</code>之间的对应关系；</li>
</ul>
<p>完整的编码流程如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm71x5i5djj31by07275g.jpg" alt="image-20201231150520220"></p>
<h2 id="MPT轻节点"><a href="#MPT轻节点" class="headerlink" title="MPT轻节点"></a>MPT轻节点</h2><p>上面的MPT树，有两个问题：</p>
<ul>
<li>每个节点都包含有大量信息，并且叶子节点中还包含有完整的数据信息。如果该MPT树并没有发生任何变化，并且没有被使用，则会白白占用一大片空间，想象一个以太坊，有多少个MPT树，都在内存中，那还了得。</li>
<li>并不是任何的客户端都对所有的MPT树都感兴趣，若每次都把完整的节点信息都下载下，下载时间长不说，并且会占用大量的磁盘空间。</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>为了解决上述问题，以太坊使用了一种缓存机制，可以称为是轻节点机制，大体如下：</p>
<ul>
<li>若某节点数据一直没有发生变化，则仅仅保留该节点的32位hash值，剩下的内容全部释放</li>
<li>若需要插入或者删除某节点，先通过该hash值db中查找对应的节点，并加载到内存，之后再进行删除插入操作</li>
</ul>
<h4 id="轻节点中添加数据"><a href="#轻节点中添加数据" class="headerlink" title="轻节点中添加数据"></a>轻节点中添加数据</h4><p>内存中只有这么一个轻节点，但是我要添加一个数据，也就是要给完整的MPT树中添加一个叶子节点，怎么添加？大体如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm8hgf9f3ij319a0pcgqh.jpg" alt="image-20210101204824090"></p>
<p>到此以太坊的MPT树的基础讲解结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> 文章及视频学习资料</p>
<p><a href="https://eth.wiki/en/fundamentals/patricia-tree">https://eth.wiki/en/fundamentals/patricia-tree</a></p>
<p><a href="https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D">https://ethereum.github.io/yellowpaper/paper.pdf#appendix.D</a></p>
<p><a href="https://ethfans.org/toya/articles/588">https://ethfans.org/toya/articles/588</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
<p><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/">https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/</a></p>
<p><a href="https://arxiv.org/pdf/1909.11590.pdf">https://arxiv.org/pdf/1909.11590.pdf</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/mpt.html">https://learnblockchain.cn/books/geth/part3/mpt.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Fetcher同步</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BFetcher%E5%90%8C%E6%AD%A5-6/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Fetcher同步</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> (文章资料在此，给个Star哦)</p>
</blockquote>
<h2 id="Fetcher-功能概述"><a href="#Fetcher-功能概述" class="headerlink" title="Fetcher 功能概述"></a>Fetcher 功能概述</h2><p>区块数据同步分为被动同步和主动同步:</p>
<ul>
<li><p>被动同步是指本地节点收到其他节点的一些<strong>广播</strong>的消息，然后请求区块信息。</p>
</li>
<li><p>主动同步是指节点主动向其他节点请求区块数据，比如geth刚启动时的syning，以及运行时定时和相邻节点同步</p>
</li>
</ul>
<p><code>Fetcher</code>负责被动同步，主要做以下事情：</p>
<ul>
<li>收到完整的block广播消息(NewBlockMsg)</li>
<li>收到blockhash广播消息(NewBlockHashesMsg)</li>
</ul>
<p>这两个消息又是分别由 <code>peer.AsyncSendNewBlockHash</code> 和 <code>peer.AsyncSendNewBlock</code> 两个方法发出的，这两个方法只有在矿工挖到新的区块时才会被调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅本地挖到新的区块的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> minedBroadcastLoop() &#123;</span><br><span class="line">    <span class="keyword">for</span> obj := <span class="keyword">range</span> pm.minedBlockSub.Chan() &#123;</span><br><span class="line">        <span class="keyword">if</span> ev, ok := obj.Data.(core.NewMinedBlockEvent); ok &#123;</span><br><span class="line">            pm.BroadcastBlock(ev.Block, <span class="literal">true</span>)  <span class="comment">// First propagate block to peers</span></span><br><span class="line">            pm.BroadcastBlock(ev.Block, <span class="literal">false</span>) <span class="comment">// Only then announce to the rest</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> BroadcastBlock(block *types.Block, propagate <span class="type">bool</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> propagate &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">            peer.AsyncSendNewBlock(block, td) <span class="comment">//发送区块数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pm.blockchain.HasBlock(hash, block.NumberU64()) &#123;</span><br><span class="line">        <span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">            peer.AsyncSendNewBlockHash(block) <span class="comment">//发送区块哈希</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当某个矿工产生了新的区块、并将这个新区块广播给其它节点，而<strong>其它远程节点</strong>收到广播的消息时，才会用到 <code>fetcher</code> 模块去同步这些区块。</p>
<hr>
<h2 id="fetcher的状态字段"><a href="#fetcher的状态字段" class="headerlink" title="fetcher的状态字段"></a>fetcher的状态字段</h2><p>在 <code>Fetcher</code> 内部对区块进行同步时，会被分成如下几个阶段，并且每个阶段都有一个状态字段与之对应，用来记录这个阶段的数据：</p>
<ul>
<li><code>Fetcher.announced</code>:此阶段代表节点宣称产生了新的区块（这个新产生的区块不一定是自己产生的，也可能是同步了其它节点新产生的区块），<code>Fetcher</code> 对象将相关信息放到 <code>Fetcher.announced</code> 中，等待下载。</li>
<li><code>Fetcher.fetching</code>：此阶段代表之前「announced」的区块正在被下载。</li>
<li><code>Fetcher.fetched</code>：代表区块的 <code>header</code> 已下载成功，现在等待下载 <code>body</code>。</li>
<li><code>Fetcher.completing</code>：代表 <code>body</code> 已经发起了下载，正在等待 <code>body</code> 下载成功。</li>
<li><code>Fetcher.queued</code>:代表 <code>body</code> 已经下载成功。因此一个区块的数据：<code>header</code> 和 body 都已下载完成，此区块正在等待写入本地数据库。</li>
</ul>
<h2 id="Fetcher-同步区块哈希"><a href="#Fetcher-同步区块哈希" class="headerlink" title="Fetcher 同步区块哈希"></a>Fetcher 同步区块哈希</h2><p>而新产生区块时，会使用消息 <code>NewBlockHashesMsg</code> 和 <code>NewBlockMsg</code> 对其进行传播。因此 <code>Fetcher</code> 对象也是从这两个消息处发现新的区块信息的。先来看同步区块哈希的过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == NewBlockHashesMsg:</span><br><span class="line">		<span class="keyword">var</span> announces newBlockHashesData</span><br><span class="line">		<span class="keyword">if</span> err := msg.Decode(&amp;announces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;%v: %v&quot;</span>, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Mark the hashes as present at the remote node</span></span><br><span class="line">		<span class="comment">// 将hash 标记存在于远程节点上</span></span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">			p.MarkBlock(block.Hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Schedule all the unknown hashes for retrieval 检索所有未知哈希</span></span><br><span class="line">		unknown := <span class="built_in">make</span>(newBlockHashesData, <span class="number">0</span>, <span class="built_in">len</span>(announces))</span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">			<span class="keyword">if</span> !pm.blockchain.HasBlock(block.Hash, block.Number) &#123;</span><br><span class="line">				unknown = <span class="built_in">append</span>(unknown, block) <span class="comment">// 本地不存在的话就扔到unkonwn里面</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, block := <span class="keyword">range</span> unknown &#123;</span><br><span class="line">			pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>先将接收的哈希标记在远程节点上，然后去本地检索是否有这个哈希，如果本地数据库不存在的话，就放到<code>unknown</code>里面，然后通知本地的<code>fetcher</code>模块再去远程节点上请求此区块的<code>header</code>和<code>body</code>。 接下来进入到<code>fetcher.Notify</code>方法中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span></span> Notify(peer <span class="type">string</span>, hash common.Hash, number <span class="type">uint64</span>, time time.Time,</span><br><span class="line">	headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) <span class="type">error</span> &#123;</span><br><span class="line">	block := &amp;announce&#123;</span><br><span class="line">		hash:        hash,</span><br><span class="line">		number:      number,</span><br><span class="line">		time:        time,</span><br><span class="line">		origin:      peer,</span><br><span class="line">		fetchHeader: headerFetcher,</span><br><span class="line">		fetchBodies: bodyFetcher,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.notify &lt;- block:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>它构造了一个 <code>announce</code> 结构，并将其发送给了 <code>Fetcher.notify</code> 这个 channel。注意 <code>announce</code> 这个结构里带着下载 header 和 body 的方法： <code>fetchHeader</code> 和 <code>fetchBodies</code> 。这两个方法在下面的过程中会讲到。 接下来我们进入到<code>fetcher.go</code>的loop函数中，找到<code>notify</code>，分以下几个内容：</p>
<p>①：校验防止Dos攻击(限制为256个)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := f.announces[notification.origin] + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> count &gt; hashLimit &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Peer exceeded outstanding announces&quot;</span>, <span class="string">&quot;peer&quot;</span>, notification.origin, <span class="string">&quot;limit&quot;</span>, hashLimit)</span><br><span class="line">				propAnnounceDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②：新来的块号必须满足 $chainHeight - blockno &lt; 7$ 或者 $blockno - chainHeight &lt; 32$ </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> notification.number &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> dist := <span class="type">int64</span>(notification.number) - <span class="type">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">			...			&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>③：准备下载<code>header</code>的<code>fetching</code>中存在此哈希则跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.fetching[notification.hash]; ok &#123; </span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>④：准备下载<code>body</code>的<code>completing</code>中存在此哈希也跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.completing[notification.hash]; ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：当确定<code>fetching</code>和<code>completing</code>不存在此区块哈希时，则把此区块哈希放入到<code>announced</code>中，准备拉取<code>header</code>和<code>body</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f.announced[notification.hash] = <span class="built_in">append</span>(f.announced[notification.hash], notification)</span><br></pre></td></tr></table></figure>

<p>⑥：如果 <code>Fetcher.announced</code> 中只有刚才新加入的这一个区块哈希，那么调用 <code>Fetcher.rescheduleFetch</code> 重新设置变量 <code>fetchTimer</code> 的周期</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f.announced) == <span class="number">1</span> &#123;</span><br><span class="line">				f.rescheduleFetch(fetchTimer)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拉取header"><a href="#拉取header" class="headerlink" title="拉取header"></a>拉取header</h3><p>接下来就是到<code>fetchTimer.C</code>函数中：进行拉取header的操作了,具体步骤如下：</p>
<p>①：选择要下载的区块，从 <code>announced</code> 转移到 <code>fetching</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.announced &#123;</span><br><span class="line">				<span class="keyword">if</span> time.Since(announces[<span class="number">0</span>].time) &gt; arriveTimeout-gatherSlack &#123;</span><br><span class="line">				<span class="comment">// 随机挑一个进行fetching</span></span><br><span class="line">					announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">					f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">					<span class="comment">// If the block still didn&#x27;t arrive, queue for fetching</span></span><br><span class="line">					<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">						f.fetching[hash] = announce <span class="comment">//</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②：发送下载 <code>header</code> 的请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送所有的header请求</span></span><br><span class="line">			<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Fetching scheduled headers&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;list&quot;</span>, hashes)</span><br><span class="line">				fetchHeader, hashes := f.fetching[hashes[<span class="number">0</span>]].fetchHeader, hashes</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="keyword">if</span> f.fetchingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">						f.fetchingHook(hashes)</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> _, hash := <span class="keyword">range</span> hashes &#123;</span><br><span class="line">						headerFetchMeter.Mark(<span class="number">1</span>)</span><br><span class="line">						fetchHeader(hash) </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;()</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们再回到<code>f.notify</code>函数中，找到<code>p.RequestOneHeader</code>，发送<code>GetBlockHeadersMsg</code>给远程节点，然后远程节点再通过<code>case msg.Code == GetBlockHeadersMsg</code>进行处理，本地区块链会返回headers，然后再发送回去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)</span><br><span class="line">...</span><br><span class="line">p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p>这时候我们请求的<code>headers</code>被远程节点给发送回来了，又是通过新的消息<code>BlockHeadersMsg</code>来传递的,当请求的 <code>header</code> 到来时，会通过两种方式来过滤header ：</p>
<ol>
<li><code>Fetcher.FilterHeaders</code> 通知 <code>Fetcher</code> 对象</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == BlockHeadersMsg:</span><br><span class="line">....</span><br><span class="line">filter := <span class="built_in">len</span>(headers) == <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> filter &#123;</span><br><span class="line">  headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<code>downloader.DeliverHeaders</code> 通知<code>downloader</code>对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">			err := pm.downloader.DeliverHeaders(p.id, headers)</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><code>downloader</code>相关的放在接下的文章探讨。继续看<code>FilterHeaders</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *headerFilterTask)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.headerFilter &lt;- filter: ①</span><br><span class="line">....</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;peer: peer, headers: headers, time: time&#125;: ②</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter: ③</span><br><span class="line">		<span class="keyword">return</span> task.headers</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要分为3个步骤：</p>
<ol>
<li>先发一个通信用的 <code>channel</code> 给 <code>headerFilter</code></li>
<li>将要过滤的 <code>headerFilterTask</code> 发送给 <code>filter</code></li>
<li>检索过滤后剩余的标题</li>
</ol>
<p>主要的处理步骤还是在<code>loop</code>函数中的<code>filter := &lt;-f.headerFilter</code>，在探讨处理前，先了解三个参数的含义：</p>
<ul>
<li><code>unknown：</code>未知的header</li>
<li><code>incomplete：</code><strong>header</strong>拉取完成，但是<strong>body</strong>还没有拉取</li>
<li><code>complete：</code><strong>header</strong>和<strong>body</strong>都拉取完成，一个完整的块，可导入到数据库</li>
</ul>
<p>接下来正式进入到<code>for _, header := range task.headers &#123;&#125;</code>循环中: <strong>这是第一段重要的循环</strong></p>
<p>①：判断是否是在<code>fetching</code>中的header，并且不是其他同步算法的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> announce := f.fetching[hash]; announce != <span class="literal">nil</span> &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == <span class="literal">nil</span> &amp;&amp; f.completing[hash] == <span class="literal">nil</span> &amp;&amp; f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果传递的<code>header</code>与承诺的<code>number</code>不匹配，删除<code>peer</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> header.Number.Uint64() != announce.number &#123;</span><br><span class="line">  f.dropPeer(announce.origin)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：判断此区块在本地是否已存在,如果不存在且只有<code>header</code>（空块），直接放入<code>complete</code>以及<code>f.completing</code>中，否则就放入到<code>incomplete</code>中等待同步<code>body</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						announce.header = header</span><br><span class="line">						announce.time = task.time</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> header.TxHash == types.DeriveSha(types.Transactions&#123;&#125;) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header&#123;&#125;) &#123;</span><br><span class="line">				...</span><br><span class="line">							block := types.NewBlockWithHeader(header)</span><br><span class="line">							block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">							complete = <span class="built_in">append</span>(complete, block)</span><br><span class="line">							f.completing[hash] = announce</span><br><span class="line">							<span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">						incomplete = <span class="built_in">append</span>(incomplete, announce) <span class="comment">// 否则添加到需要完成拉取body的列表中</span></span><br></pre></td></tr></table></figure>

<p>④：如果<code>f.fetching</code>中不存在此哈希，就放入到<code>unkown</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// Fetcher doesn&#x27;t know about it, add to the return list |fetcher 不认识的放到unkown中</span></span><br><span class="line">					unknown = <span class="built_in">append</span>(unknown, header)</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：之后再把<code>Unknown</code>的<code>header</code>再通知fetcher继续过滤</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;headers: unknown, time: task.time&#125;:</span><br><span class="line">			<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是<strong>进入到第二个循环</strong>，要准备拿出incomplete里的哈希，进行同步body的同步</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, announce := <span class="keyword">range</span> incomplete &#123;</span><br><span class="line">				hash := announce.header.Hash()</span><br><span class="line">				<span class="keyword">if</span> _, ok := f.completing[hash]; ok &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				f.fetched[hash] = <span class="built_in">append</span>(f.fetched[hash], announce)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(f.fetched) == <span class="number">1</span> &#123;</span><br><span class="line">					f.rescheduleComplete(completeTimer)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>f.completing</code>中存在，就表明已经在开始同步<code>body</code>了，直接跳过，否则把这个哈希放入到<code>f.fetched</code>，表示<code>header</code>同步完毕，准备<code>body</code>同步，由<code>f.rescheduleComplete(completeTimer)</code>完成。最后是安排只有<code>header</code>的区块进行导入操作.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> complete &#123;</span><br><span class="line">				<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.enqueue(announce.origin, block)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析<code>completeTimer.C</code>，同步<code>body</code>的操作，这步完成就是要准备区块导入到数据库流程了。</p>
<h3 id="拉取body"><a href="#拉取body" class="headerlink" title="拉取body"></a>拉取body</h3><p>进入<code>completeTimer.C</code>，从f.fetched获取哈希，如果本地区块链查不到的话就把这个哈希放入到<code>f.completing</code>中，再循环进行<code>fetchBodies</code>，整个流程就结束了，代码大致如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-completeTimer.C:</span><br><span class="line">...</span><br><span class="line">			<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.fetched &#123;</span><br><span class="line">		....</span><br><span class="line">				<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">					request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">					f.completing[hash] = announce</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">        ...</span><br><span class="line">				<span class="keyword">go</span> f.completing[hashes[<span class="number">0</span>]].fetchBodies(hashes)</span><br><span class="line">			&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>关键的拉取<code>body</code>函数： <code>p.RequestBodies</code>，发送<code>GetBlockBodiesMsg</code>消息同步<code>body</code>。回到<code>handler</code>里面去查看对应的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == GetBlockBodiesMsg:</span><br><span class="line">		<span class="comment">// Decode the retrieval message</span></span><br><span class="line">		msgStream := rlp.NewStream(msg.Payload, <span class="type">uint64</span>(msg.Size))</span><br><span class="line">		<span class="keyword">if</span> _, err := msgStream.List(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			hash   common.Hash</span><br><span class="line">			bytes  <span class="type">int</span></span><br><span class="line">			bodies []rlp.RawValue</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">for</span> bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(bodies) &lt; downloader.MaxBlockFetch &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> data := pm.blockchain.GetBodyRLP(hash); <span class="built_in">len</span>(data) != <span class="number">0</span> &#123;</span><br><span class="line">				bodies = <span class="built_in">append</span>(bodies, data)</span><br><span class="line">				bytes += <span class="built_in">len</span>(data)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p.SendBlockBodiesRLP(bodies)</span><br></pre></td></tr></table></figure>

<p><code>softResponseLimit</code>返回的<code>body</code>大小最大为$2 * 1024 * 1024$,<code>MaxBlockFetch</code>表示每个请求最多128个<code>body</code>。</p>
<p>之后直接通过<code>GetBodyRLP</code>返回数据通过<code>SendBlockBodiesRLP</code>发回给节点。</p>
<p>节点将会接收到新消息：<code>BlockBodiesMsg</code>，进入查看：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤掉filter请求的body 同步，其他的都交给downloader</span></span><br><span class="line">		filter := <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> filter &#123;</span><br><span class="line">			transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">			err := pm.downloader.DeliverBodies(p.id, transactions, uncles)</span><br><span class="line">...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>过滤掉<code>filter</code>请求的<code>body</code> 同步，其他的都交给<code>downloader</code>，<code>downloader</code>部分之后的篇章讲。进入到<code>FilterBodies</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *bodyFilterTask)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.bodyFilter &lt;- filter:  ①</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the body list</span></span><br><span class="line">	<span class="comment">// 请求过滤body 列表</span></span><br><span class="line">	<span class="keyword">select</span> &#123; ②</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;bodyFilterTask&#123;peer: peer, transactions: transactions, uncles: uncles, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the bodies remaining after filtering</span></span><br><span class="line">	<span class="keyword">select</span> &#123; ③：</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.transactions, task.uncles</span><br></pre></td></tr></table></figure>

<p>主要分为3个步骤：</p>
<ol>
<li>先发一个通信用的 <code>channel</code> 给 <code>bodyFilter</code></li>
<li>将要过滤的 <code>bodyFilterTask</code> 发送给 <code>filter</code></li>
<li>检索过滤后剩余的<code>body</code></li>
</ol>
<p>现在进入到<code>case filter := &lt;-f.bodyFilter</code>里面，大致做了以下几件事：</p>
<p>①：首先从f.completing中获取要同步body的哈希</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(task.transactions) &amp;&amp; i &lt; <span class="built_in">len</span>(task.uncles); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.completing &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>②：然后从f.queued去查这个哈希是不是已经获取了body，如果没有并满足条件就创建一个完整block </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">						txnHash := types.DeriveSha(types.Transactions(task.transactions[i]))</span><br><span class="line">						uncleHash := types.CalcUncleHash(task.uncles[i])</span><br><span class="line">  <span class="keyword">if</span> txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer &#123;</span><br><span class="line">							matched = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">								block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i])</span><br><span class="line">								block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">                blocks = <span class="built_in">append</span>(blocks, block)</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>③：最后对完整的块进行导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">				<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.enqueue(announce.origin, block)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>最后用一张粗略的图来大概的描述一下整个同步区块哈希的流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glae3zccpdj30wm0t6q67.jpg" alt="image-20201203090304059"></p>
<hr>
<p>同步区块哈希的最终会走到<code>f.enqueue</code>里面，这个也是<strong>同步区块</strong>最重要的要做的一件事，下文就会讲到。</p>
<h2 id="Fetcher-同步区块"><a href="#Fetcher-同步区块" class="headerlink" title="Fetcher 同步区块"></a>Fetcher 同步区块</h2><p>分析完上面比较复杂的同步区块哈希过程，接下来就要分析比较简单的同步区块过程。从<code>NewBlockMsg</code>开始：</p>
<p>主要做两件事：</p>
<p>①：<code>fetcher</code>模块导入远程节点发过来的区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.fetcher.Enqueue(p.id, request.Block)</span><br></pre></td></tr></table></figure>

<p>②：<strong>主动同步</strong>远程节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, td := p.Head(); trueTD.Cmp(td) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			p.SetHead(trueHead, trueTD)</span><br><span class="line">			currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">			<span class="keyword">if</span> trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> pm.synchronise(p)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>主动同步由<code>Downloader</code>去处理，我们这篇只讨论<code>fetcher</code>相关。</p>
<h3 id="区块入队列"><a href="#区块入队列" class="headerlink" title="区块入队列"></a>区块入队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.fetcher.Enqueue(p.id, request.Block)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> op := &lt;-f.inject:</span><br><span class="line">			propBroadcastInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			f.enqueue(op.origin, op.block)</span><br></pre></td></tr></table></figure>

<p>正式进入将区块送进<code>queue</code>中，主要做了以下几件事：</p>
<p>①： 确保新加<code>peer</code>没有导致<code>DOS</code>攻击</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := f.queues[peer] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; blockLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Discarded propagated block, exceeded allowance&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;limit&quot;</span>, blockLimit)</span><br><span class="line">		propBroadcastDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：丢弃掉过去的和比较老的区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dist := <span class="type">int64</span>(block.NumberU64()) - <span class="type">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">  f.forgetHash(hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：安排区块导入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := f.queued[hash]; !ok &#123;</span><br><span class="line">	op := &amp;inject&#123;</span><br><span class="line">		origin: peer,</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	f.queues[peer] = count</span><br><span class="line">	f.queued[hash] = op</span><br><span class="line">	f.queue.Push(op, -<span class="type">int64</span>(block.NumberU64()))</span><br><span class="line">	<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">		f.queueChangeHook(op.block.Hash(), <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Debug(<span class="string">&quot;Queued propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;queued&quot;</span>, f.queue.Size())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，已经将区块送入到<code>queue</code>中，接下来就是要回到<code>loop</code>函数中去处理<code>queue</code>中的区块。</p>
<h3 id="区块入库"><a href="#区块入库" class="headerlink" title="区块入库"></a>区块入库</h3><p>loop函数在处理队列中的区块主要做了以下事情：</p>
<ol>
<li>判断队列是否为空</li>
<li>取出区块哈希，并且和本地链进行比较，如果太高的话，就暂时不导入</li>
<li>最后通过f.insert将区块插入到数据库。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">height := f.chainHeight()</span><br><span class="line">		<span class="keyword">for</span> !f.queue.Empty() &#123;</span><br><span class="line">			op := f.queue.PopItem().(*inject)</span><br><span class="line">			hash := op.block.Hash()</span><br><span class="line">		...</span><br><span class="line">			number := op.block.NumberU64()</span><br><span class="line">			<span class="keyword">if</span> number &gt; height+<span class="number">1</span> &#123;</span><br><span class="line">				f.queue.Push(op, -<span class="type">int64</span>(number))</span><br><span class="line">	...</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> number+maxUncleDist &lt; height || f.getBlock(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.forgetBlock(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			f.insert(op.origin, op.block) <span class="comment">//导入块</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>f.insert</code>中，主要做了以下几件事：</p>
<p>①：判断区块的父块是否存在，不存在则中断插入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := f.getBlock(block.ParentHash())</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Debug(<span class="string">&quot;Unknown parent of propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;parent&quot;</span>, block.ParentHash())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②： 快速验证header，<strong>并在传递时广播该块</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := f.verifyHeader(block.Header()); err &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			propBroadcastOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">			<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>③：运行真正的插入逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Propagated block import failed&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：导入成功广播此块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>真正做区块入库的是f.insertChain，这里会调用blockchain模块去操作，具体细节会后续文章讲述，到此为止Fether模块的同步就到此结束了，下面是同步区块的流程图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glae40anr7j30ps0mkn0t.jpg" alt="image-20201203090327173"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a> </p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之MPT树-下</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMPT%E6%A0%91-%E4%B8%8B-14/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之MPT树-下</p>
<p>文章以及资料请查看：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<p><a href="https://github.com/blockchainGuide/">上篇</a>主要介绍了以太坊中的MPT树的原理，这篇主要会对MPT树涉及的源码进行拆解分析。<code>trie</code>模块主要有以下几个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">|-encoding.<span class="keyword">go</span> 主要讲编码之间的转换</span><br><span class="line">|-hasher.<span class="keyword">go</span> 实现了从某个结点开始计算子树的哈希的功能</span><br><span class="line">|-node.<span class="keyword">go</span> 定义了一个Trie树中所有结点的类型和解析的代码</span><br><span class="line">|-sync.<span class="keyword">go</span> 实现了SyncTrie对象的定义和所有方法</span><br><span class="line">|-iterator.<span class="keyword">go</span> 定义了所有枚举相关接口和实现</span><br><span class="line">|-secure_trie.<span class="keyword">go</span> 实现了SecureTrie对象</span><br><span class="line">|-proof.<span class="keyword">go</span> 为key构造一个merkle证明</span><br><span class="line">|-trie.<span class="keyword">go</span> Trie树的增删改查</span><br><span class="line">|-database.<span class="keyword">go</span> 对内存中的trie树节点进行引用计数</span><br></pre></td></tr></table></figure>



<h2 id="实现概览"><a href="#实现概览" class="headerlink" title="实现概览"></a>实现概览</h2><h3 id="encoding-go"><a href="#encoding-go" class="headerlink" title="encoding.go"></a>encoding.go</h3><p>这个主要是讲三种编码（<code>KEYBYTES encoding</code>、<code>HEX encoding</code>、<code>COMPACT encoding</code>）的实现与转换，<code>trie</code>中全程都需要用到这些，该文件中主要实现了如下功能：</p>
<ol>
<li>hex编码转换为Compact编码：<code>hexToCompact()</code></li>
<li>Compact编码转换为hex编码：<code>compactToHex()</code></li>
<li>keybytes编码转换为Hex编码：<code>keybytesToHex()</code></li>
<li>hex编码转换为keybytes编码：<code>hexToKeybytes()</code></li>
<li>获取两个字节数组的公共前缀的长度：<code>prefixLen()</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    terminator := <span class="type">byte</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123; <span class="comment">//检查是否有结尾为0x10 =&gt; 16</span></span><br><span class="line">        terminator = <span class="number">1</span> <span class="comment">//有结束标记16说明是叶子节点</span></span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>] <span class="comment">//去除尾部标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>) <span class="comment">// 字节数组</span></span><br><span class="line">    </span><br><span class="line">    buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// 标志byte为00000000或者00100000</span></span><br><span class="line">    <span class="comment">//如果长度为奇数，添加奇数位标志1，并把第一个nibble字节放入buf[0]的低四位</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">        buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">// 奇数标志 00110000</span></span><br><span class="line">        buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// 第一个nibble包含在第一个字节中 0011xxxx</span></span><br><span class="line">        hex = hex[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将两个nibble字节合并成一个字节</span></span><br><span class="line">    decodeNibbles(hex, buf[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compact编码转化为Hex编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compactToHex</span><span class="params">(compact []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    base := keybytesToHex(compact)</span><br><span class="line">    base = base[:<span class="built_in">len</span>(base)<span class="number">-1</span>]</span><br><span class="line">     <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="comment">// base[0]包括四种情况</span></span><br><span class="line">    <span class="comment">// 00000000 扩展节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000001 扩展节点奇数位</span></span><br><span class="line">    <span class="comment">// 00000010 叶子节点偶数位</span></span><br><span class="line">    <span class="comment">// 00000011 叶子节点奇数位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply terminator flag</span></span><br><span class="line">    <span class="keyword">if</span> base[<span class="number">0</span>] &gt;= <span class="number">2</span> &#123;</span><br><span class="line">       <span class="comment">//如果是叶子节点，末尾添加Hex标志位16</span></span><br><span class="line">        base = <span class="built_in">append</span>(base, <span class="number">16</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply odd flag</span></span><br><span class="line">    <span class="comment">//如果是偶数位，chop等于2，否则等于1</span></span><br><span class="line">    chop := <span class="number">2</span> - base[<span class="number">0</span>]&amp;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> base[chop:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将十六进制的bibbles转成key bytes，这只能用于偶数长度的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToKeybytes</span><span class="params">(hex []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> hasTerm(hex) &#123;</span><br><span class="line">        hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can&#x27;t convert hex key of odd length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    key := <span class="built_in">make</span>([]<span class="type">byte</span>, (<span class="built_in">len</span>(hex)+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    decodeNibbles(hex, key)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回a和b的公共前缀的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixLen</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, length = <span class="number">0</span>, <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; length &#123;</span><br><span class="line">        length = <span class="built_in">len</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; length; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i] != b[i] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="node-go"><a href="#node-go" class="headerlink" title="node.go"></a>node.go</h3><h4 id="四种节点"><a href="#四种节点" class="headerlink" title="四种节点"></a>四种节点</h4><p>node 接口分四种实现: fullNode，shortNode，valueNode，hashNode，其中只有 fullNode 和 shortNode 可以带有子节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123;</span><br><span class="line">		Children [<span class="number">17</span>]node <span class="comment">// 分支节点</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123; <span class="comment">//扩展节点</span></span><br><span class="line">		Key   []<span class="type">byte</span></span><br><span class="line">		Val   node <span class="comment">//可能指向叶子节点，也可能指向分支节点。</span></span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="type">byte</span></span><br><span class="line">	valueNode []<span class="type">byte</span> <span class="comment">// 叶子节点值，但是该叶子节点最终还是会包装在shortNode中</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="trie-go"><a href="#trie-go" class="headerlink" title="trie.go"></a>trie.go</h3><p>Trie对象实现了MPT树的所有功能，包括(key, value)对的增删改查、计算默克尔哈希，以及将整个树写入数据库中。</p>
<h3 id="iterator-go"><a href="#iterator-go" class="headerlink" title="iterator.go"></a>iterator.go</h3><p><code>nodeIterator</code>提供了遍历树内部所有结点的功能。其结构如下：此结构体是在<code>trie.go</code>定义的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	trie.NodeIterator</span><br><span class="line">	t   *odrTrie</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面包含了一个接口<code>NodeIterator</code>，它的实现则是由<code>iterator.go</code>来提供的，其方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Next(descend <span class="type">bool</span>) <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Hash() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Parent() common.Hash </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Leaf() <span class="type">bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafKey() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafBlob() []<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> LeafProof() [][]<span class="type">byte</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> Path() []<span class="type">byte</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> seek(prefix []<span class="type">byte</span>) <span class="type">error</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> peek(descend <span class="type">bool</span>) (*nodeIteratorState, *<span class="type">int</span>, []<span class="type">byte</span>, <span class="type">error</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> nextChild(parent *nodeIteratorState, ancestor common.Hash) (*nodeIteratorState, []<span class="type">byte</span>, <span class="type">bool</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> push(state *nodeIteratorState, parentIndex *<span class="type">int</span>, path []<span class="type">byte</span>) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *nodeIterator)</span></span> pop() </span><br></pre></td></tr></table></figure>

<p><code>NodeIterator</code>的核心是<code>Next</code>方法，每调用一次这个方法，NodeIterator对象代表的当前节点就会更新至下一个节点，当所有结点遍历结束，<code>Next</code>方法返回<code>false</code>。</p>
<p>生成NodeIterator结口的方法有以下3种：</p>
<p><strong>①：Trie.NodeIterator(start []byte)</strong></p>
<p>通过<code>start</code>参数指定从哪个路径开始遍历，如果为<code>nil</code>则从头到尾按顺序遍历。</p>
<p><strong>②：NewDifferenceIterator(a, b NodeIterator)</strong></p>
<p>当调用<code>NewDifferenceIterator(a, b NodeIterator)</code>后，生成的<code>NodeIterator</code>只遍历存在于 b 但不存在于 a 中的结点。</p>
<p><strong>③：NewUnionIterator(iters []NodeIterator)</strong></p>
<p>当调用<code>NewUnionIterator(its []NodeIterator)</code>后，生成的<code>NodeIterator</code>遍历的结点是所有传入的结点的合集。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><p><code>Database</code>是<code>trie</code>模块对真正数据库的缓存层，其目的是对缓存的节点进行引用计数，从而实现区块的修剪功能。主要方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(diskdb ethdb.KeyValueStore)</span></span> *Database</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabaseWithCache</span><span class="params">(diskdb ethdb.KeyValueStore, cache <span class="type">int</span>)</span></span> *Database </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> DiskDB() ethdb.KeyValueReader</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> InsertBlob(hash common.Hash, blob []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insert(hash common.Hash, blob []<span class="type">byte</span>, node node)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> insertPreimage(hash common.Hash, preimage []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> node(hash common.Hash) node</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Node(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> preimage(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> secureKey(key []<span class="type">byte</span>) []<span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Nodes() []common.Hash</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Reference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Dereference(root common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> dereference(child common.Hash, parent common.Hash)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Cap(limit common.StorageSize) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span></span> Commit(node common.Hash, report <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h3 id="security-trie-go"><a href="#security-trie-go" class="headerlink" title="security_trie.go"></a>security_trie.go</h3><p>可以理解为加密了的<code>trie</code>的实现，<code>ecurity_trie</code>包装了一下<code>trie</code>树， 所有的<code>key</code>都转换成<code>keccak256</code>算法计算的<code>hash</code>值。同时在数据库里面存储<code>hash</code>值对应的原始的<code>key</code>。<br>但是官方在代码里也注释了，这个代码不稳定，除了测试用例，别的地方并没有使用该代码。</p>
<h3 id="proof-go"><a href="#proof-go" class="headerlink" title="proof.go"></a>proof.go</h3><ul>
<li>Prove()：根据给定的<code>key</code>，在<code>trie</code>中，将满足<code>key</code>中最大长度前缀的路径上的节点都加入到<code>proofDb</code>（队列中每个元素满足：未编码的hash以及对应<code>rlp</code>编码后的节点）</li>
<li>VerifyProof()：验证<code>proffDb</code>中是否存在满足输入的<code>hash</code>，和对应key的节点，如果满足，则返回<code>rlp</code>解码后的该节点。</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="Trie对象的增删改查"><a href="#Trie对象的增删改查" class="headerlink" title="Trie对象的增删改查"></a>Trie对象的增删改查</h3><p>①：<strong>Trie树的初始化</strong></p>
<p>如果<code>root</code>不为空，就通过<code>resolveHash</code>来加载整个<code>Trie</code>树，如果为空，就新建一个<code>Trie</code>树。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span></span> (*Trie, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db: db,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root != (common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：<strong>Trie树的插入</strong></p>
<p>首先Trie树的插入是个递归调用的过程，它会从根开始找，一直找到合适的位置插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>n: 当前要插入的节点</li>
<li>prefix: 当前已经处理完的<strong>key</strong>(节点共有的前缀)</li>
<li>key: 未处理完的部分<strong>key</strong>，完整的<code>key = prefix + key</code></li>
<li>value：需要插入的值</li>
</ul>
<p>返回值说明：</p>
<ul>
<li>bool : 操作是否改变了<strong>Trie</strong>树(<strong>dirty</strong>)</li>
<li>Node :插入完成后的子树的根节点</li>
</ul>
<p>接下来就是分别对<code>shortNode</code>、<code>fullNode</code>、<code>hashNode</code>、<code>nil</code> 几种情况进行说明。</p>
<p><strong>2.1：节点为nil</strong></p>
<p>空树直接返回<code>shortNode</code>， 此时整颗树的根就含有了一个<code>shortNode</code>节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key, value, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2 ：节点为shortNode</strong></p>
<ul>
<li><p>首先计算公共前缀，如果公共前缀就等于<code>key</code>，那么说明这两个<code>key</code>是一样的，如果<code>value</code>也一样的(<code>dirty == false</code>)，那么返回错误。</p>
</li>
<li><p>如果没有错误就更新<code>shortNode</code>的值然后返回</p>
</li>
<li><p>如果公共前缀不完全匹配，那么就需要把公共前缀提取出来形成一个独立的节点(扩展节点),扩展节点后面连接一个<code>branch</code>节点，<code>branch</code>节点后面看情况连接两个<code>short</code>节点。</p>
</li>
<li><p>首先构建一个branch节点(branch :&#x3D; &amp;fullNode{flags: t.newFlag()}),然后再branch节点的Children位置调用t.insert插入剩下的两个short节点</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">matchlen := prefixLen(key, n.Key)</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">			dirty, nn, err := t.insert(n.Val, <span class="built_in">append</span>(prefix, key[:matchlen]...), key[matchlen:], value)</span><br><span class="line">			<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		branch := &amp;fullNode&#123;flags: t.newFlag()&#125;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		_, branch.Children[n.Key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, n.Key[:matchlen+<span class="number">1</span>]...), n.Key[matchlen+<span class="number">1</span>:], n.Val)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		_, branch.Children[key[matchlen]], err = t.insert(<span class="literal">nil</span>, <span class="built_in">append</span>(prefix, key[:matchlen+<span class="number">1</span>]...), key[matchlen+<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> matchlen == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, branch, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;key[:matchlen], branch, t.newFlag()&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.3: 节点为fullNode</strong></p>
<p>节点是<code>fullNode</code>(也就是分支节点)，那么直接往对应的孩子节点调用<code>insert</code>方法,然后把对应的孩子节点指向新生成的节点。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dirty, nn, err := t.insert(n.Children[key[<span class="number">0</span>]], <span class="built_in">append</span>(prefix, key[<span class="number">0</span>]), key[<span class="number">1</span>:], value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, n, err</span><br><span class="line">		&#125;</span><br><span class="line">		n = n.<span class="built_in">copy</span>()</span><br><span class="line">		n.flags = t.newFlag()</span><br><span class="line">		n.Children[key[<span class="number">0</span>]] = nn</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, n, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.4: 节点为hashnode</strong></p>
<p>暂时还在数据库中的节点，先调用 <code>t.resolveHash(n, prefix)</code>来加载到内存，然后调用<code>insert</code>方法来插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rn, err := t.resolveHash(n, prefix)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		dirty, nn, err := t.insert(rn, prefix, key, value)</span><br><span class="line">		<span class="keyword">if</span> !dirty || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, rn, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nn, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<strong>Trie树查询值</strong></p>
<p>其实就是根据输入的<code>hash</code>，找到对应的叶子节点的数据。主要看<code>TryGet</code>方法。</p>
<p>参数：</p>
<ul>
<li><code>origNode</code>：当前查找的起始<strong>node</strong>位置</li>
<li><code>key</code>：输入要查找的数据的<strong>hash</strong></li>
<li><code>pos</code>：当前<strong>hash</strong>匹配到第几位</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> tryGet(origNode node, key []<span class="type">byte</span>, pos <span class="type">int</span>) (value []<span class="type">byte</span>, newnode node, didResolve <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := (origNode).(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//表示当前trie是空树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> valueNode: <span class="comment">////这就是我们要查找的叶子节点对应的数据</span></span><br><span class="line">		<span class="keyword">return</span> n, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> *shortNode: <span class="comment">////在叶子节点或者扩展节点匹配</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(key)-pos &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[pos:pos+<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Val, key, pos+<span class="built_in">len</span>(n.Key))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Val = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> *fullNode:<span class="comment">//在分支节点匹配</span></span><br><span class="line">		value, newnode, didResolve, err = t.tryGet(n.Children[key[pos]], key, pos+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; didResolve &#123;</span><br><span class="line">			n = n.<span class="built_in">copy</span>()</span><br><span class="line">			n.Children[key[pos]] = newnode</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value, n, didResolve, err</span><br><span class="line">	<span class="keyword">case</span> hashNode: <span class="comment">//说明当前节点是轻节点，需要从db中获取</span></span><br><span class="line">		child, err := t.resolveHash(n, key[:pos])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, n, <span class="literal">true</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		value, newnode, _, err := t.tryGet(child, key, pos)</span><br><span class="line">		<span class="keyword">return</span> value, newnode, <span class="literal">true</span>, err</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>didResolve</code>用于判断<code>trie</code>树是否会发生变化，<code>tryGet()</code>只是用来获取数据的，当<code>hashNode</code>去<code>db</code>中获取该<code>node</code>值后需要更新现有的trie，<code>didResolve</code>就会发生变化。其他就是基本的递归查找树操作。</p>
<p>④：<strong>Trie树更新值</strong></p>
<p>更新值，其实就是调用insert方法进行操作。</p>
<p>到此Trie树的增删改查就讲解的差不多了。</p>
<h3 id="将节点写入到Trie的内存数据库"><a href="#将节点写入到Trie的内存数据库" class="headerlink" title="将节点写入到Trie的内存数据库"></a>将节点写入到Trie的内存数据库</h3><p>如果要把节点写入到内存数据库，需要序列化，可以先去了解下以太坊的Rlp编码。这部分工作由<code>trie.Commit()</code>完成，当<code>trie.Commit(nil)</code>，会执行序列化和缓存等操作，序列化之后是使用的<code>Compact Encoding</code>进行编码，从而达到节省空间的目的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;commit called on trie with nil database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	hash, cached, err := t.hashRoot(t.db, onleaf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.root = cached</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(hash.(hashNode)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大概讲了这些：</p>
<ul>
<li>每次执行<code>Commit()</code>，该trie的<code>cachegen</code>就会加 1</li>
<li><code>Commit()</code>方法返回的是<code>trie.root</code>所指向的<code>node</code>的<code>hash</code>（未编码）</li>
<li>其中的<code>hashRoot()</code>方法目的是<code>返回trie.root所指向的node的hash</code>以及<code>每个节点都带有各自hash的trie树的root</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为每个node生成一个hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> hashRoot(db *Database, onleaf LeafCallback) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hashNode(emptyRoot.Bytes()), <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	h := newHasher(onleaf)</span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(h)</span><br><span class="line">	<span class="keyword">return</span> h.hash(t.root, db, <span class="literal">true</span>) <span class="comment">//为每个节点生成一个未编码的hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>hashRoot</code>的核心方法就是 <code>h.hash</code>，它返回了头节点的<code>hash</code>以及每个子节点都带有<code>hash</code>的头节点（Trie.root指向它），大致做了以下几件事：</p>
<p>①：<em>如果我们不存储节点，而只是哈希，则从缓存中获取数据</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hash, dirty := n.cache(); hash != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !dirty &#123;</span><br><span class="line">			<span class="keyword">switch</span> n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *fullNode, *shortNode:</span><br><span class="line">				<span class="keyword">return</span> hash, hash, <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> hash, n, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>递归调用<code>h.hashChildren</code>，求出所有的子节点的<code>hash</code>值，再把原有的子节点替换成现在子节点的<code>hash</code>值</em></p>
<p><strong>2.1:如果节点是<code>shortNode</code></strong></p>
<p>首先把<code>collapsed.Key从Hex Encoding</code> 替换成 <code>Compact Encoding</code>, 然后递归调用<code>hash</code>方法计算子节点的<code>hash</code>和<code>cache</code>，从而把子节点替换成了子节点的<code>hash</code>值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line">		collapsed.Key = hexToCompact(n.Key)</span><br><span class="line">		cached.Key = common.CopyBytes(n.Key)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := n.Val.(valueNode); !ok &#123;</span><br><span class="line">			collapsed.Val, cached.Val, err = h.hash(n.Val, db, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> original, original, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>2.2:节点是fullNode</strong></p>
<p> 遍历每个子节点，把子节点替换成子节点的<code>Hash</code>值，否则的化这个节点没有<code>children</code>。直接返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">collapsed, cached := n.<span class="built_in">copy</span>(), n.<span class="built_in">copy</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> n.Children[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">		collapsed.Children[i], cached.Children[i], err = h.hash(n.Children[i], db, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> original, original, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cached.Children[<span class="number">16</span>] = n.Children[<span class="number">16</span>]</span><br><span class="line"><span class="keyword">return</span> collapsed, cached, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>③：<em>存储节点n的哈希值，如果我们指定了存储层，它会写对应的键&#x2F;值对</em></p>
<p>store()方法主要就做了两件事：</p>
<ul>
<li><code>rlp</code>序列化<code>collapsed</code>节点并将其插入db磁盘中</li>
<li>生成当前节点的<code>hash</code></li>
<li>将节点哈希插入<code>db</code></li>
</ul>
<p><strong>3.1：空数据或者hashNode，则不处理</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, isHash := n.(hashNode); n == <span class="literal">nil</span> || isHash &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2:生成节点的RLP编码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.tmp.Reset()                                 <span class="comment">// 缓存初始化</span></span><br><span class="line">	<span class="keyword">if</span> err := rlp.Encode(&amp;h.tmp, n); err != <span class="literal">nil</span> &#123; <span class="comment">//将当前node序列化</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;encode error: &quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h.tmp) &lt; <span class="number">32</span> &amp;&amp; !force &#123;</span><br><span class="line">		<span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">// Nodes smaller than 32 bytes are stored inside their parent 编码后的node长度小于32，若force为true，则可确保所有节点都被编码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//长度过大的，则都将被新计算出来的hash取代</span></span><br><span class="line">	hash, _ := n.cache() <span class="comment">//取出当前节点的hash</span></span><br><span class="line">	<span class="keyword">if</span> hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		hash = h.makeHashNode(h.tmp) <span class="comment">//生成哈希node</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3:将Trie节点合并到中间内存缓存中</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := common.BytesToHash(hash)</span><br><span class="line">		db.lock.Lock()</span><br><span class="line">		db.insert(hash, h.tmp, n)</span><br><span class="line">		db.lock.Unlock()</span><br><span class="line">		<span class="comment">// Track external references from account-&gt;storage trie</span></span><br><span class="line">		<span class="comment">//跟踪帐户-&gt;存储Trie中的外部引用</span></span><br><span class="line">		<span class="keyword">if</span> h.onleaf != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> n := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *shortNode:</span><br><span class="line">				<span class="keyword">if</span> child, ok := n.Val.(valueNode); ok &#123;  <span class="comment">//指向的是分支节点</span></span><br><span class="line">					h.onleaf(child, hash) <span class="comment">//用于统计当前节点的信息，比如当前节点有几个子节点，当前有效的节点数</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> *fullNode:</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> child, ok := n.Children[i].(valueNode); ok &#123;</span><br><span class="line">						h.onleaf(child, hash)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止将节点写入到<code>Trie</code>的内存数据库就已经完成了。</p>
<p><em>如果觉得文章不错可以关注公众号：<strong>区块链技术栈</strong>，详细的所有以太坊源码分析文章内容以及代码资料都在其中。</em></p>
<h3 id="Trie树缓存机制"><a href="#Trie树缓存机制" class="headerlink" title="Trie树缓存机制"></a>Trie树缓存机制</h3><p><code>Trie</code>树的结构里面有两个参数， 一个是<code>cachegen</code>,一个是<code>cachelimit</code>。这两个参数就是<code>cache</code>控制的参数。 <code>Trie</code>树每一次调用<code>Commit</code>方法，会导致当前的<code>cachegen</code>增加1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">    t.cachegen++</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>Trie</code>树插入的时候，会把当前的<code>cachegen</code>存放到节点中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> insert(n node, prefix, key []<span class="type">byte</span>, value node) (<span class="type">bool</span>, node, <span class="type">error</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, &amp;shortNode&#123;n.Key, nn, t.newFlag()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> newFlag() nodeFlag &#123;</span><br><span class="line">    <span class="keyword">return</span> nodeFlag&#123;dirty: <span class="literal">true</span>, gen: t.cachegen&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>trie.cachegen - node.cachegen &gt; cachelimit</code>，就可以把节点从内存里面拿掉。 也就是说节点经过几次<code>Commit</code>，都没有修改，那么就把节点从内存里面干掉。 只要<code>trie</code>路径上新增或者删除一个节点，整个路径的节点都需要重新实例化，也就是节点中的<code>nodeFlag</code>被初始化了。都需要重新更新到<code>db</code>磁盘。</p>
<p>拿掉节点过程在 <code>hasher.hash</code>方法中， 这个方法是在<code>commit</code>的时候调用。如果方法的<code>canUnload</code>方法调用返回真，那么就拿掉节点，如果只返回了<code>hash</code>节点，而没有返回<code>node</code>节点，这样节点就没有引用，不久就会被gc清除掉。 节点被拿掉之后，会用一个<code>hashNode</code>节点来表示这个节点以及其子节点。 如果后续需要使用，可以通过方法把这个节点加载到内存里面来。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hasher)</span></span> hash(n node, db *Database, force <span class="type">bool</span>) (node, node, <span class="type">error</span>) &#123;</span><br><span class="line">   	....</span><br><span class="line">       <span class="comment">// 从缓存中卸载节点。它的所有子节点将具有较低或相等的缓存世代号码。</span></span><br><span class="line">       cacheUnloadCounter.Inc(<span class="number">1</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考-总结"><a href="#参考-总结" class="headerlink" title="参考&amp;总结"></a>参考&amp;总结</h2><p>这部分重要的内容也就上面讲述的，主要集中在<code>Trie</code>上面，如果有不对的地方，可以及时指正哦。</p>
<blockquote>
<p><a href="https://mindcarver.cn/about/">https://mindcarver.cn/about/</a></p>
<p><a href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之blockChain分析</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BblockChain%E5%88%86%E6%9E%90-11/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之blockChain分析</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="blockchain关键元素"><a href="#blockchain关键元素" class="headerlink" title="blockchain关键元素"></a>blockchain关键元素</h2><ul>
<li><code>db</code>：持久化到底层数据储存，即<code>leveldb</code>；</li>
<li><code>genesisBlock</code>：创始区块</li>
<li><code>currentBlock</code>：当前区块，<code>blockchain</code>中并不是储存链所有的<code>block</code>，而是通过<code>currentBlock</code>向前回溯直到<code>genesisBlock</code>，这样就构成了区块链</li>
<li><code>bodyCache</code>、<code>bodyRLPCache</code>、<code>blockCache</code>、<code>futureBlocks</code>：区块链中的缓存结构，用于加快区块链的读取和构建；</li>
<li><code>hc</code>：<code>headerchain</code>区块头链，由<code>blockchain</code>额外维护的另一条链，由于<code>Header</code>和<code>Block</code>的储存空间是有很大差别的，但同时<code>Block</code>的<code>Hash</code>值就是<code>Header</code>（RLP）的<code>Hash</code>值，所以维护一个<code>headerchain</code>可以用于快速延长链，验证通过后再下载<code>blockchain</code>，或者可以与<code>blockchain</code>进行相互验证；</li>
<li><code>processor</code>：执行区块链交易的接口，收到一个新的区块时，要对区块中的所有交易执行一遍，一方面是验证，一方面是更新世界状态；</li>
<li><code>validator</code>：验证数据有效性的接口</li>
<li><code>futureBlocks</code>：收到的区块时间大于当前头区块时间15s而小于30s的区块，可作为当前节点待处理的区块。</li>
</ul>
<hr>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BadBlocks 处理客户端从网络上获取的最近的bad block列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> BadBlocks() []*types.Block &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addBadBlock 把bad block放入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> addBadBlock(block *types.Block) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CurrentBlock取回主链的当前头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentBlock() *types.Block &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentHeader检索规范链的当前头区块header。从HeaderChain的内部缓存中检索标头。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentHeader() *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CurrentFastBlock取回主链的当前fast-sync头区块，这个区块是从blockchian的内部缓存中取得</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> CurrentFastBlock() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将活动链或其子集写入给定的编写器.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Export(w io.Writer) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ExportN(w io.Writer, first <span class="type">uint64</span>, last <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FastSyncCommitHead快速同步，将当前头块设置为特定hash的区块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FastSyncCommitHead(hash common.Hash) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GasLimit返回当前头区块的gas limit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GasLimit() <span class="type">uint64</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Genesis 取回genesis区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Genesis() *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过hash从数据库或缓存中取到一个区块体(transactions and uncles)或RLP数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBody(hash common.Hash) *types.Body &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBodyRLP(hash common.Hash) rlp.RawValue &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetBlock 通过hash和number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlock(hash common.Hash, number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByHash 通过hash取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByHash(hash common.Hash) *types.Block &#123;&#125;</span><br><span class="line"><span class="comment">// GetBlockByNumber 通过number取到区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockByNumber(number <span class="type">uint64</span>) *types.Block &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash和number区块的header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeader(hash common.Hash, number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定hash的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByHash(hash common.Hash) *types.Header&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取给定number的区块header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetHeaderByNumber(number <span class="type">uint64</span>) *types.Header&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HasBlock检验hash对应的区块是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlock(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检查给定hash和number的区块的区块头是否存在数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasHeader(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasState检验state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasState(hash common.Hash) <span class="type">bool</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// HasBlockAndState检验hash对应的block和state trie是否完全存在数据库中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> HasBlockAndState(hash common.Hash, number <span class="type">uint64</span>) <span class="type">bool</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取给定hash的区块的总难度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetTd(hash common.Hash, number <span class="type">uint64</span>) *big.Int&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取从给定hash的区块到genesis区块的所有hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlockHashesFromHash(hash common.Hash, max <span class="type">uint64</span>) []common.Hash&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetReceiptsByHash 在特定的区块中取到所有交易的收据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetReceiptsByHash(hash common.Hash) types.Receipts &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetBlocksFromHash 取到特定hash的区块及其n-1个父区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetBlocksFromHash(hash common.Hash, n <span class="type">int</span>) (blocks []*types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// GetUnclesInChain 取回从给定区块到向前回溯特定距离到区块上的所有叔区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> GetUnclesInChain(block *types.Block, length <span class="type">int</span>) []*types.Header &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert 将新的头块注入当前块链。 该方法假设该块确实是真正的头。</span></span><br><span class="line"><span class="comment">// 如果它们较旧或者它们位于不同的侧链上，它还会将头部标题和头部快速同步块重置为同一个块。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insert(block *types.Block) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertChain尝试将给定批量的block插入到规范链中，否则，创建一个分叉。 如果返回错误，它将返回失败块的索引号以及描述错误的错误。</span></span><br><span class="line"><span class="comment">//插入完成后，将触发所有累积的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertChain(chain types.Blocks) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// insertChain将执行实际的链插入和事件聚合。 </span></span><br><span class="line"><span class="comment">// 此方法作为单独方法存在的唯一原因是使用延迟语句使锁定更清晰。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks) (<span class="type">int</span>, []<span class="keyword">interface</span>&#123;&#125;, []*types.Log, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertHeaderChain尝试将给定的headerchain插入到本地链中，可能会创建一个重组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertHeaderChain(chain []*types.Header, checkFreq <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InsertReceiptChain 使用交易和收据数据来完成已经存在的headerchain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> InsertReceiptChain(blockChain types.Blocks, receiptChain []types.Receipts) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//loadLastState从数据库加载最后一个已知的链状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> loadLastState() <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Processor 返回当前current processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Processor() Processor &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reset重置清除整个区块链，将其恢复到genesis state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Reset() <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ResetWithGenesisBlock 清除整个区块链, 用特定的genesis state重塑，被Reset所引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> ResetWithGenesisBlock(genesis *types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// repair尝试通过回滚当前块来修复当前的区块链，直到找到具有关联状态的块。</span></span><br><span class="line"><span class="comment">// 用于修复由崩溃/断电或简单的非提交尝试导致的不完整的数据库写入。</span></span><br><span class="line"><span class="comment">//此方法仅回滚当前块。 当前标头和当前快速块保持不变。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> repair(head **types.Block) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reorgs需要两个块、一个旧链以及一个新链，并将重新构建块并将它们插入到新的规范链中，并累积潜在的缺失事务并发布有关它们的事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> reorg(oldBlock, newBlock *types.Block) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Rollback 旨在从数据库中删除不确定有效的链片段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Rollback(chain []common.Hash) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SetReceiptsData 计算收据的所有非共识字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetReceiptsData</span><span class="params">(config *params.ChainConfig, block *types.Block, receipts types.Receipts)</span></span> <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetHead将本地链回滚到指定的头部。</span></span><br><span class="line"><span class="comment">// 通常可用于处理分叉时重选主链。对于Header，新Header上方的所有内容都将被删除，新的头部将被设置。</span></span><br><span class="line"><span class="comment">// 但如果块体丢失，则会进一步回退（快速同步后的非归档节点）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetHead(head <span class="type">uint64</span>) <span class="type">error</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetProcessor设置状态修改所需要的processor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetProcessor(processor Processor) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetValidator 设置用于验证未来区块的validator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> SetValidator(validator Validator) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// State 根据当前头区块返回一个可修改的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> State() (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// StateAt 根据特定时间点返回新的可变状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> StateAt(root common.Hash) (*state.StateDB, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Stop 停止区块链服务，如果有正在import的进程，它会使用procInterrupt来取消。</span></span><br><span class="line"><span class="comment">// it will abort them using the procInterrupt.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Stop() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TrieNode从memory缓存或storage中检索与trie节点hash相关联的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> TrieNode(hash common.Hash) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Validator返回当前validator.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> Validator() Validator &#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteBlockWithoutState仅将块及其元数据写入数据库，但不写入任何状态。 这用于构建竞争方叉，直到超过规范总难度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithoutState(block *types.Block, td *big.Int) (err <span class="type">error</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// WriteBlockWithState将块和所有关联状态写入数据库。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> WriteBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// writeHeader将标头写入本地链，因为它的父节点已知。 如果新插入的报头的总难度变得大于当前已知的TD，则重新路由规范链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> writeHeader(header *types.Header) <span class="type">error</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理未来区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="blockchain初始化"><a href="#blockchain初始化" class="headerlink" title="blockchain初始化"></a>blockchain初始化</h2><p>主要步骤：</p>
<p>①：创建一个新的headerChain结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.getProcInterrupt)</span><br></pre></td></tr></table></figure>

<ol>
<li>根据number（0）获取genesisHeader</li>
<li>从rawdb中读取HeadBlock并存储在currentHeader中</li>
</ol>
<p>②：获取genesisBlock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.genesisBlock = bc.GetBlockByNumber(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>③：如果链不为空，则用老的链数据初始化链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> bc.empty() &#123;</span><br><span class="line">		rawdb.InitDatabaseFromFreezer(bc.db)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：加载最新的状态数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bc.loadLastState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：检查区块哈希的当前状态，并确保链中没有任何坏块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> hash := <span class="keyword">range</span> BadHashes &#123;</span><br><span class="line">		<span class="keyword">if</span> header := bc.GetHeaderByHash(hash); header != <span class="literal">nil</span> &#123;</span><br><span class="line">			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())</span><br><span class="line">			<span class="keyword">if</span> headerByNumber != <span class="literal">nil</span> &amp;&amp; headerByNumber.Hash() == header.Hash() &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Found bad hash, rewinding chain&quot;</span>, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.ParentHash)</span><br><span class="line">				bc.SetHead(header.Number.Uint64() - <span class="number">1</span>)</span><br><span class="line">				log.Error(<span class="string">&quot;Chain rewind was successful, resuming normal operation&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：定时处理future block</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br><span class="line">	-&gt;procFutureBlocks</span><br><span class="line">		-&gt;InsertChain</span><br></pre></td></tr></table></figure>

<p>总的来说做了以下几件事：</p>
<ol>
<li>配置<code>cacheConfig</code>，创建各种lru缓存</li>
<li>初始化<code>triegc</code></li>
<li>初始化<code>stateDb</code>：<strong>state.NewDatabase(db)</strong></li>
<li>初始化区块和状态验证：<strong>NewBlockValidator()</strong></li>
<li>初始化状态处理器：<strong>NewStateProcessor()</strong></li>
<li>初始化区块头部链：<strong>NewHeaderChain()</strong></li>
<li>查找创世区块：<strong>bc.genesisBlock &#x3D; bc.GetBlockByNumber(0)</strong></li>
<li>加载最新的状态数据：<strong>bc.loadLastState()</strong></li>
<li>检查区块哈希的当前状态，并确保链中没有任何坏块</li>
<li><code>go bc.update()</code> 定时处理<code>future block</code></li>
</ol>
<h2 id="加载区块链状态"><a href="#加载区块链状态" class="headerlink" title="加载区块链状态"></a>加载区块链状态</h2><p>①：从数据库中恢复headblock，如果空的话，触发reset chain</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">head := rawdb.ReadHeadBlockHash(bc.db)</span><br><span class="line">	<span class="keyword">if</span> head == (common.Hash&#123;&#125;) &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Empty database, resetting chain&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：确保整个head block是可以获取的，若为空，则触发reset chain</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">currentBlock := bc.GetBlockByHash(head)</span><br><span class="line">	<span class="keyword">if</span> currentBlock == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Corrupt or empty database, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head block missing, resetting chain&quot;</span>, <span class="string">&quot;hash&quot;</span>, head)</span><br><span class="line">		<span class="keyword">return</span> bc.Reset()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：从stateDb中打开最新区块的状态trie，如果打开失败调用bc.repair(&amp;currentBlock)方法进行修复。修复方法就是从当前区块一个个的往前面找，直到找到好的区块，然后赋值给currentBlock。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := state.New(currentBlock.Root(), bc.stateCache); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Dangling block without a state associated, init from scratch</span></span><br><span class="line">		log.Warn(<span class="string">&quot;Head state missing, repairing chain&quot;</span>, <span class="string">&quot;number&quot;</span>, currentBlock.Number(), <span class="string">&quot;hash&quot;</span>, currentBlock.Hash())</span><br><span class="line">		<span class="keyword">if</span> err := bc.repair(&amp;currentBlock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		rawdb.WriteHeadBlockHash(bc.db, currentBlock.Hash())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：存储当前的headblock和设置当前的headHeader以及头部快速块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.currentBlock.Store(currentBlock)</span><br><span class="line">....</span><br><span class="line">bc.hc.SetCurrentHeader(currentHeader)</span><br><span class="line">...</span><br><span class="line">bc.currentFastBlock.Store(currentBlock)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之downloader同步</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5-7/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之downloader同步</p>
<p><strong>需要配合注释代码看</strong>：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> 给个star哦</p>
<p><em>这篇文章篇幅较长，能看下去的是条汉子，建议收藏</em></p>
<p>希望读者在阅读过程中，指出问题，给个关注，一起探讨。</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>downloader</code> 模块的代码位于 <code>eth/downloader</code> 目录下。主要的功能代码分别是：</p>
<ul>
<li><p><code>downloader.go</code> ：实现了区块同步逻辑</p>
</li>
<li><p><code>peer.go</code> ：对区块各个阶段的组装，下面的各个<code>FetchXXX</code> 就是很依赖这个模块。</p>
</li>
<li><p><code>queue.go</code> ：对<code>eth/peer.go</code>的封装</p>
</li>
<li><p><code>statesync.go</code> ：同步<code>state</code>对象</p>
</li>
</ul>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="full-sync"><a href="#full-sync" class="headerlink" title="full  sync"></a>full  sync</h3><p>full 模式会在数据库中保存所有区块数据，同步时从远程节点同步 header 和 body 数据，而state 和 receipt 数据则是在本地计算出来的。</p>
<p>在 full 模式下，downloader 会同步区块的 header 和 body 数据组成一个区块，然后通过 blockchain 模块的 <code>BlockChain.InsertChain</code> 向数据库中插入区块。在 <code>BlockChain.InsertChain</code> 中，会逐个计算和验证每个块的 <code>state</code> 和 <code>recepit</code> 等数据，如果一切正常就将区块数据以及自己计算得到的 <code>state</code>、<code>recepit</code> 数据一起写入到数据库中。</p>
<h3 id="fast-sync"><a href="#fast-sync" class="headerlink" title="fast sync"></a>fast sync</h3><p> <code>fast</code> 模式下，<code>recepit</code> 不再由本地计算，而是和区块数据一样，直接由 <code>downloader</code> 从其它节点中同步；<code>state</code> 数据并不会全部计算和下载，而是选一个较新的区块（称之为 <code>pivot</code>）的 <code>state</code> 进行下载，以这个区块为分界，之前的区块是没有 <code>state</code> 数据的，之后的区块会像 <code>full</code> 模式下一样在本地计算 <code>state</code>。因此在 <code>fast</code> 模式下，同步的数据除了 <code>header</code> 和 body，还有 <code>receipt</code>，以及 <code>pivot</code> 区块的 <code>state</code>。</p>
<p>因此 <code>fast</code> 模式忽略了大部分 <code>state</code> 数据，并且使用网络直接同步 <code>receipt</code> 数据的方式替换了 full 模式下的本地计算，所以比较快。</p>
<h3 id="light-sync"><a href="#light-sync" class="headerlink" title="light sync"></a>light sync</h3><p>light 模式也叫做轻模式，它只对区块头进行同步，而不同步其它的数据。</p>
<p>SyncMode:</p>
<ul>
<li>FullSync:从完整区块同步整个区块链历史</li>
<li>FastSync:快速下载标题，仅在链头处完全同步</li>
<li>LightSync:仅下载标题，然后终止</li>
</ul>
<h2 id="区块下载流程"><a href="#区块下载流程" class="headerlink" title="区块下载流程"></a>区块下载流程</h2><blockquote>
<p>图片只是大概的描述一下，实际还是要结合代码，<strong>所有区块链相关文章合集</strong>，<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>同时希望结识更多区块链圈子的人，可以star上面项目，持续更新</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glwzmv4zyej30zh0u0dps.jpg" alt="image-20201222221031797"></p>
<p>首先根据<code>Synchronise</code>开始区块同步，通过<code>findAncestor</code>找到指定节点的共同祖先，并在此高度进行同步，同时开启多个<code>goroutine</code>同步不同的数据：<code>header</code>、<code>receipt</code>、<code>body</code>。假如同步高度为 100 的区块，必须先<code>header</code>同步成功同步完成才可以唤醒<code>body</code>和<code>receipts</code>的同步。</p>
<p>而每个部分的同步大致都是由<code>FetchParts</code>来完成的，里面包含了各个<code>Chan</code>的配合，也会涉及不少的回调函数，总而言之多读几遍每次都会有不同的理解。接下来就逐步分析这些关键内容。</p>
<hr>
<h2 id="synchronise"><a href="#synchronise" class="headerlink" title="synchronise"></a>synchronise</h2><p>①：确保对方的TD高于我们自己的TD</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">	td := pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())</span><br><span class="line">	pHead, pTd := peer.Head()</span><br><span class="line">	<span class="keyword">if</span> pTd.Cmp(td) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启<code>downloader</code>的同步</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pm.downloader.Synchronise(peer.id, pHead, pTd, mode)</span><br></pre></td></tr></table></figure>

<p>进入函数：主要做了以下几件事：</p>
<ol>
<li><code>d.synchronise(id, head, td, mode)</code> ：同步过程</li>
<li>错误日志输出， 并删除此<code>peer</code>。</li>
</ol>
<p>进入到<code>d.synchronise</code>，走到最后一步<code>d.syncWithPeer(p, hash, td)</code>真正开启同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> synchronise(id <span class="type">string</span>, hash common.Hash, td *big.Int, mode SyncMode) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> d.syncWithPeer(p, hash, td)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syncWithPeer大概做了以下几件事：</p>
<ol>
<li>查找祖先<code>findAncestor</code></li>
<li>开启单独<code>goroutine</code>分别运行以下几个函数：<ul>
<li>fetchHeaders</li>
<li>processHeaders</li>
<li>fetchbodies</li>
<li>fetchReceipts</li>
<li>processFastSyncContent</li>
<li>processFullSyncContent</li>
</ul>
</li>
</ol>
<p>接下来的文章，以及整个<code>Downloader</code>模块主要内容就是围绕这几个部分进行展开。</p>
<hr>
<h2 id="findAncestor"><a href="#findAncestor" class="headerlink" title="findAncestor"></a>findAncestor</h2><p>同步首要的是<strong>确定同步区块的区间</strong>：顶部为远程节点的最高区块，底部为两个节点都拥有的相同区块的最高高度（祖先区块）。<code>findAncestor</code>就是用来找祖先区块。函数分析如下：</p>
<p>①：确定本地高度和远程节点的最高高度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		floor        = <span class="type">int64</span>(<span class="number">-1</span>) <span class="comment">// 底部</span></span><br><span class="line">		localHeight  <span class="type">uint64</span>  <span class="comment">// 本地最高高度</span></span><br><span class="line">		remoteHeight = remoteHeader.Number.Uint64() <span class="comment">// 远程节点最高高度</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">switch</span> d.mode &#123;</span><br><span class="line">	<span class="keyword">case</span> FullSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentBlock().NumberU64()</span><br><span class="line">	<span class="keyword">case</span> FastSync:</span><br><span class="line">		localHeight = d.blockchain.CurrentFastBlock().NumberU64()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		localHeight = d.lightchain.CurrentHeader().Number.Uint64()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：计算同步的高度区间和间隔</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">from, count, skip, max := calculateRequestSpan(remoteHeight, localHeight) </span><br></pre></td></tr></table></figure>

<ul>
<li><code>from</code>:：表示从哪个高度开始获取区块</li>
<li><code>count</code>：表示从远程节点获取多少个区块</li>
<li><code>skip</code>：表示间隔，比如<code>skip</code> 为 2 ，获取第一个高度为 5，则第二个就是 8</li>
<li><code>max</code>：表示最大高度</li>
</ul>
<p>③：发送获取<code>header</code>的请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> p.peer.RequestHeadersByNumber(<span class="type">uint64</span>(from), count, skip, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>④：处理上面请求接收到的<code>header</code>  :<code>case packet := &lt;-d.headerCh</code></p>
<ol>
<li>丢弃掉不是来自我们请求节的内容</li>
<li>确保返回的<code>header</code>数量不为空</li>
<li>验证返回的<code>headers</code>的高度是我们所请求的</li>
<li>检查是否找到共同祖先</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----①</span></span><br><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received headers from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----②</span></span><br><span class="line">headers := packet.(*headerPack).headers</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">				p.log.Warn(<span class="string">&quot;Empty head header set&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//-----③</span></span><br><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">				expectNumber := from + <span class="type">int64</span>(i)*<span class="type">int64</span>(skip+<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span> number := header.Number.Int64(); number != expectNumber &#123; <span class="comment">// 验证这些返回的header是否是我们上面请求的headers</span></span><br><span class="line">					p.log.Warn(<span class="string">&quot;Head headers broke chain ordering&quot;</span>, <span class="string">&quot;index&quot;</span>, i, <span class="string">&quot;requested&quot;</span>, expectNumber, <span class="string">&quot;received&quot;</span>, number)</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>, errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//-----④</span></span><br><span class="line"><span class="comment">// 检查是否找到共同祖先</span></span><br><span class="line">			finished = <span class="literal">true</span></span><br><span class="line">			<span class="comment">//注意这里是从headers最后一个元素开始查找，也就是高度最高的区块。</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="built_in">len</span>(headers) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">				<span class="comment">// 跳过不在我们请求的高度区间内的区块</span></span><br><span class="line">				<span class="keyword">if</span> headers[i].Number.Int64() &lt; from || headers[i].Number.Uint64() &gt; max &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// //检查我们本地是否已经有某个区块了，如果有就算是找到了共同祖先，</span></span><br><span class="line">				<span class="comment">//并将共同祖先的哈希和高度设置在number和hash变量中。</span></span><br><span class="line">				h := headers[i].Hash()</span><br><span class="line">				n := headers[i].Number.Uint64()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>⑤：如果通过固定间隔法找到了共同祖先则返回祖先，会对其高度与 <code>floor</code> 变量进行验证, <code>floor</code> 变量代表的是共同祖先的高度的最小值,如果找到共同祖先的高度比这个值还小，就认为是两个节点之间分叉太大了，不再允许进行同步。如果一切正常，就返回找到的共同祖先的高度 <code>number</code> 变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hash != (common.Hash&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">int64</span>(number) &lt;= floor &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, errInvalidAncestor</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>⑥：如果固定间隔法没有找到祖先则通过二分法来查找祖先，这部分可以思想跟二分法算法类似，有兴趣的可以细看。</p>
<hr>
<h2 id="queue详解"><a href="#queue详解" class="headerlink" title="queue详解"></a>queue详解</h2><p><code>queue</code>对象和<code>Downloader</code>对象是相互作用的，<code>Downloader</code>的很多功能离不开他，接下来我们介绍一下这部分内容，但是本节，<strong>可以先行跳过</strong>，等到了阅读下面的关于<code>Queue</code>调用的一些函数部分再回过来阅读这部分讲解。</p>
<h3 id="queue结构体"><a href="#queue结构体" class="headerlink" title="queue结构体"></a>queue结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> queue <span class="keyword">struct</span> &#123;</span><br><span class="line">  mode SyncMode <span class="comment">// 同步模式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// header处理相关</span></span><br><span class="line">  headerHead      common.Hash   <span class="comment">//最后一个排队的标头的哈希值以验证顺序</span></span><br><span class="line">  headerTaskPool  <span class="keyword">map</span>[<span class="type">uint64</span>]*types.Header  <span class="comment">//待处理的标头检索任务，将起始索引映射到框架标头</span></span><br><span class="line">  headerTaskQueue *prque.Prque  <span class="comment">//骨架索引的优先级队列，以获取用于的填充标头</span></span><br><span class="line">  headerPeerMiss <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已知不可用的对等头批处理集</span></span><br><span class="line">  headerPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前挂起的头检索操作</span></span><br><span class="line">  headerResults []*types.Header <span class="comment">//结果缓存累积完成的头</span></span><br><span class="line">  headerProced <span class="type">int</span> <span class="comment">//从结果中拿出来已经处理的header</span></span><br><span class="line">  headerContCh <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">//header下载完成时通知的频道</span></span><br><span class="line">  </span><br><span class="line">  blockTaskPool  <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的块（body）检索任务，将哈希映射到header</span></span><br><span class="line">  blockTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取块（bodies）</span></span><br><span class="line">  blockPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的块（body)检索操作</span></span><br><span class="line">  blockDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的块（body)</span></span><br><span class="line">  </span><br><span class="line">	receiptTaskPool <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">//待处理的收据检索任务，将哈希映射到header</span></span><br><span class="line">	receiptTaskQueue *prque.Prque <span class="comment">//标头的优先级队列,以用于获取收据</span></span><br><span class="line">	receiptPendPool <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest <span class="comment">//当前的正在处理的收据检索操作</span></span><br><span class="line">	receiptDonePool <span class="keyword">map</span>[common.Hash]<span class="keyword">struct</span>&#123;&#125; <span class="comment">//已经完成的收据</span></span><br><span class="line">	</span><br><span class="line">	resultCache []*fetchResult <span class="comment">//下载但尚未交付获取结果</span></span><br><span class="line">	resultOffset <span class="type">uint64</span> <span class="comment">//区块链中第一个缓存的获取结果的偏移量</span></span><br><span class="line">	resultSize common.StorageSize <span class="comment">// 块的近似大小</span></span><br><span class="line"></span><br><span class="line">	lock   *sync.Mutex</span><br><span class="line">	active *sync.Cond</span><br><span class="line">	closed <span class="type">bool</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要细分功能"><a href="#主要细分功能" class="headerlink" title="主要细分功能"></a>主要细分功能</h3><h4 id="数据下载开始安排任务"><a href="#数据下载开始安排任务" class="headerlink" title="数据下载开始安排任务"></a>数据下载开始安排任务</h4><ul>
<li><code>ScheduleSkeleton</code>:<em>将一批<code>header</code>检索任务添加到队列中，以填充已检索的<code>header skeleton</code></em></li>
<li><code>Schedule</code>:<em>用来准备对一些 <code>body</code> 和 <code>receipt</code> 数据的下载</em></li>
</ul>
<h4 id="数据下载中的各类状态"><a href="#数据下载中的各类状态" class="headerlink" title="数据下载中的各类状态"></a>数据下载中的各类状态</h4><ul>
<li><p><code>pending</code></p>
<p><code>pending</code>表示待检索的XXX请求的数量，包括了：<code>PendingHeaders</code>、<code>PendingBlocks</code>、<code>PendingReceipts</code>，分别都是对应取<code>XXXTaskQueue</code>的长度。</p>
</li>
<li><p><code>InFlight</code></p>
<p><code>InFlight</code>表示是否有正在获取XXX的请求，包括：<code>InFlightHeaders</code>、<code>InFlightBlocks</code>、<code>InFlightReceipts</code>，都是通过判断<code>len(q.receiptPendPool) &gt; 0</code> 来确认。</p>
</li>
<li><p><code>ShouldThrottle</code></p>
<p><code>ShouldThrottle</code>表示检查是否应该限制下载XXX，包括:<code>ShouldThrottleBlocks</code>、<code>ShouldThrottleReceipts</code>，主要是为了防止下载过程中本地内存占用过大。</p>
</li>
<li><p><code>Reserve</code></p>
<p><code>Reserve</code>通过构造一个 <code>fetchRequest</code> 结构并返回，向调用者提供指定数量的待下载的数据的信息（<code>queue</code> 内部会将这些数据标记为「正在下载」）。调用者使用返回的 <code>fetchRequest</code> 数据向远程节点发起新的获取数据的请求。包括：<code>ReserveHeaders</code>、<code>ReserveBodies</code>、<code>ReserveReceipts</code>。</p>
</li>
<li><p><code>Cancel</code></p>
<p><code>Cance</code>用来撤消对 <code>fetchRequest</code> 结构中的数据的下载（<code>queue</code> 内部会将这些数据重新从「正在下载」的状态更改为「等待下载」）。包括：<code>CancelHeaders</code>、<code>CancelBodies</code>、<code>CancelReceipts</code>。</p>
</li>
<li><p><code>expire</code></p>
<p><code>expire</code>检查正在执行中的请求是否超过了超时限制，包括：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>。</p>
</li>
<li><p><code>Deliver</code></p>
<p>当有数据下载成功时，调用者会使用 <code>deliver</code> 功能用来通知 <code>queue</code> 对象。包括：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。</p>
</li>
</ul>
<h4 id="数据下载完成获取区块数据"><a href="#数据下载完成获取区块数据" class="headerlink" title="数据下载完成获取区块数据"></a>数据下载完成获取区块数据</h4><ul>
<li><code>RetrieveHeaders</code><br>在填充 <code>skeleton</code> 完成后，<code>queue.RetrieveHeaders</code> 用来获取整个 <code>skeleton</code> 中的所有 <code>header</code>。</li>
<li><code>Results</code><br><code>queue.Results</code> 用来获取当前的 <code>header</code>、<code>body</code> 和 <code>receipt</code>（只在 <code>fast</code> 模式下） 都已下载成功的区块（并将这些区块从 <code>queue</code> 内部移除）</li>
</ul>
<hr>
<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><h4 id="ScheduleSkeleton"><a href="#ScheduleSkeleton" class="headerlink" title="ScheduleSkeleton"></a>ScheduleSkeleton</h4><p>queue.ScheduleSkeleton主要是为了填充skeleton，它的参数是要下载区块的起始高度和所有 <code>skeleton</code> 区块头，最核心的内容则是下面这段循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ScheduleSkeleton(from <span class="type">uint64</span>, skeleton []*types.Header) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> i, header := <span class="keyword">range</span> skeleton &#123;</span><br><span class="line">        index := from + <span class="type">uint64</span>(i*y)</span><br><span class="line">        q.headerTaskPool[index] = header</span><br><span class="line">        q.headerTaskQueue.Push(index, -<span class="type">int64</span>(index))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设已确定需要下载的区块高度区间是从 10 到 46，<code>MaxHeaderFetch</code> 的值为 10，那么这个高度区块就会被分成 3 组：10 - 19，20 - 29，30 - 39，而 skeleton 则分别由高度为 19、29、39 的区块头组成。循环中的 <code>index</code> 变量实际上是每一组区块中的第一个区块的高度（比如 10、20、30），<code>queue.headerTaskPool</code> 实际上是一个<strong>每一组区块中第一个区块的高度到最后一个区块的 header 的映射</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">headerTaskPool = &#123;</span><br><span class="line">  <span class="number">10</span>: headerOf_19,</span><br><span class="line">	<span class="number">20</span>: headerOf_20,</span><br><span class="line">	<span class="number">30</span>: headerOf_39,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ReserveHeaders"><a href="#ReserveHeaders" class="headerlink" title="ReserveHeaders"></a>ReserveHeaders</h4><p><code>reserve</code> 用来获取可下载的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reserve  = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, count <span class="type">int</span>)</span></span> (*fetchRequest, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> d.queue.ReserveHeaders(p, count), <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> ReserveHeaders(p *peerConnection, count <span class="type">int</span>) *fetchRequest &#123;</span><br><span class="line">  <span class="keyword">if</span> _, ok := q.headerPendPool[p.id]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="comment">//①</span></span><br><span class="line">  ...</span><br><span class="line">  send, skip := <span class="type">uint64</span>(<span class="number">0</span>), []<span class="type">uint64</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> send == <span class="number">0</span> &amp;&amp; !q.headerTaskQueue.Empty() &#123;</span><br><span class="line">		from, _ := q.headerTaskQueue.Pop()</span><br><span class="line">		<span class="keyword">if</span> q.headerPeerMiss[p.id] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := q.headerPeerMiss[p.id][from.(<span class="type">uint64</span>)]; ok &#123;</span><br><span class="line">				skip = <span class="built_in">append</span>(skip, from.(<span class="type">uint64</span>))</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		send = from.(<span class="type">uint64</span>) <span class="comment">// ②</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">for</span> _, from := <span class="keyword">range</span> skip &#123;</span><br><span class="line">		q.headerTaskQueue.Push(from, -<span class="type">int64</span>(from))</span><br><span class="line">	&#125; <span class="comment">// ③</span></span><br><span class="line">  ...</span><br><span class="line">  request := &amp;fetchRequest&#123;</span><br><span class="line">		Peer: p,</span><br><span class="line">		From: send,</span><br><span class="line">		Time: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	q.headerPendPool[p.id] = request <span class="comment">// ④</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①：根据<code>headerPendPool</code>来判断远程节点是否正在下载数据信息。</p>
<p>②：从<code>headerTaskQueue</code>取出值作为本次请求的起始高度，赋值给<code>send</code>变量，在这个过程中会排除headerPeerMiss所记录的节点下载数据失败的信息。</p>
<p>③：将失败的任务再重新写回<code>task queue</code></p>
<p>④：利用<code>send</code>变量构造<code>fetchRequest</code>结构，此结构是用来作为<code>FetchHeaders</code>来使用的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fetch = <span class="function"><span class="keyword">func</span><span class="params">(p *peerConnection, req *fetchRequest)</span></span> <span class="type">error</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> p.FetchHeaders(req.From, MaxHeaderFetch) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>ReserveHeaders</code>会从任务队列里选择最小的起始高度并构造<code>fetchRequest</code>传递给<code>fetch</code>获取数据。</p>
<hr>
<h4 id="DeliverHeaders"><a href="#DeliverHeaders" class="headerlink" title="DeliverHeaders"></a>DeliverHeaders</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">deliver = <span class="function"><span class="keyword">func</span><span class="params">(packet dataPack)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">			pack := packet.(*headerPack)</span><br><span class="line">			<span class="keyword">return</span> d.queue.DeliverHeaders(pack.peerID, pack.headers, d.headerProcCh)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>①：如果发现下载数据的节点没有在 <code>queue.headerPendPool</code> 中，就直接返回错误；否则就继续处理，并将节点记录从 <code>queue.headerPendPool</code> 中删除。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">request := q.headerPendPool[id]</span><br><span class="line">	<span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errNoFetchesPending</span><br><span class="line">	&#125;</span><br><span class="line">	headerReqTimer.UpdateSince(request.Time)</span><br><span class="line">	<span class="built_in">delete</span>(q.headerPendPool, id)</span><br></pre></td></tr></table></figure>

<p>②：验证<code>headers</code> </p>
<p>包括三方面验证：</p>
<ol>
<li>检查起始区块的高度和哈希</li>
<li>检查高度的连接性</li>
<li>检查哈希的连接性</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="comment">//检查起始区块的高度和哈希</span></span><br><span class="line">		<span class="keyword">if</span> headers[<span class="number">0</span>].Number.Uint64() != request.From &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>].Hash() != target &#123;</span><br><span class="line">			...</span><br><span class="line">			accepted = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> accepted &#123;</span><br><span class="line">		<span class="keyword">for</span> i, header := <span class="keyword">range</span> headers[<span class="number">1</span>:] &#123;</span><br><span class="line">			hash := header.Hash() <span class="comment">// 检查高度的连接性</span></span><br><span class="line">			<span class="keyword">if</span> want := request.From + <span class="number">1</span> + <span class="type">uint64</span>(i); header.Number.Uint64() != want &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> headers[i].Hash() != header.ParentHash &#123; <span class="comment">// 检查哈希的连接性</span></span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③： 将无效数据存入<code>headerPeerMiss</code>，并将这组区块起始高度重新放入<code>headerTaskQueue</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !accepted &#123;</span><br><span class="line">	...</span><br><span class="line">		miss := q.headerPeerMiss[id]</span><br><span class="line">		<span class="keyword">if</span> miss == <span class="literal">nil</span> &#123;</span><br><span class="line">			q.headerPeerMiss[id] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			miss = q.headerPeerMiss[id]</span><br><span class="line">		&#125;</span><br><span class="line">		miss[request.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		q.headerTaskQueue.Push(request.From, -<span class="type">int64</span>(request.From))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;delivery not accepted&quot;</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：保存数据，并通知<code>headerProcCh</code>处理新的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ready &gt; <span class="number">0</span> &#123;</span><br><span class="line">		process := <span class="built_in">make</span>([]*types.Header, ready)</span><br><span class="line">		<span class="built_in">copy</span>(process, q.headerResults[q.headerProced:q.headerProced+ready])</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> headerProcCh &lt;- process:</span><br><span class="line">			q.headerProced += <span class="built_in">len</span>(process)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：发送消息给.<code>headerContCh</code>，通知<code>skeleton</code> 都被下载完了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">		q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>DeliverHeaders</code> 会对数据进行检验和保存，并发送 channel 消息给 <code>Downloader.processHeaders</code> 和 <code>Downloader.fetchParts</code>的 <code>wakeCh</code> 参数。</p>
<hr>
<h4 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h4><p><code>processHeaders</code>在处理<code>header</code>数据的时候，会调用<code>queue.Schedule</code> 为下载 <code>body</code> 和 <code>receipt</code> 作准备。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inserts := d.queue.Schedule(chunk, origin)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> Schedule(headers []*types.Header, from <span class="type">uint64</span>) []*types.Header &#123;</span><br><span class="line">	inserts := <span class="built_in">make</span>([]*types.Header, <span class="number">0</span>, <span class="built_in">len</span>(headers))</span><br><span class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    ...</span><br><span class="line">		q.blockTaskPool[hash] = header</span><br><span class="line">		q.blockTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">			q.receiptTaskPool[hash] = header</span><br><span class="line">			q.receiptTaskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">		inserts = <span class="built_in">append</span>(inserts, header)</span><br><span class="line">		q.headerHead = hash</span><br><span class="line">		from++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inserts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要就是将信息写入到body和receipt队列，等待调度。</p>
<hr>
<h4 id="ReserveBody-Receipt"><a href="#ReserveBody-Receipt" class="headerlink" title="ReserveBody&amp;Receipt"></a>ReserveBody&amp;Receipt</h4><p>在 <code>queue</code> 中准备好了 <strong>body</strong> 和 <strong>receipt</strong> 相关的数据， <code>processHeaders</code>最后一段，是唤醒下载Bodyies和Receipts的关键代码，会通知 <code>fetchBodies</code> 和 <code>fetchReceipts</code> 可以对各自的数据进行下载了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>fetchXXX</code> 会调用<code>fetchParts</code>，逻辑类似上面的的，<code>reserve</code>最终则会调用<code>reserveHeaders</code>，<code>deliver</code> 最终调用的是 <code>queue.deliver</code>.</p>
<p>先来分析<code>reserveHeaders</code>：</p>
<p>①：如果没有可处理的任务，直接返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> taskQueue.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②：如果参数给定的节点正在下载数据，返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := pendPool[p.id]; ok &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>③：计算 queue 对象中的缓存空间还可以容纳多少条数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">space := q.resultSlots(pendPool, donePool)</span><br></pre></td></tr></table></figure>

<p>④：从 「task queue」 中依次取出任务进行处理</p>
<p>主要实现以下功能：</p>
<ul>
<li>计算当前 header 在 <code>queue.resultCache</code> 中的位置，然后填充 <code>queue.resultCache</code> 中相应位置的元素</li>
<li>处理空区块的情况，若为空不下载。</li>
<li>处理远程节点缺少这个当前区块数据的情况，如果发现这个节点曾经下载当前数据失败过，就不再让它下载了。</li>
</ul>
<p>注意：<code>resultCache</code> 字段用来记录所有正在被处理的数据的处理结果，它的元素类型是 <code>fetchResult</code> 。它的 <code>Pending</code> 字段代表当前区块还有几类数据需要下载。这里需要下载的数据最多有两类：body 和 receipt，<code>full</code> 模式下只需要下载 <code>body</code> 数据，而 <code>fast</code> 模式要多下载一个 <code>receipt</code> 数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> proc := <span class="number">0</span>; proc &lt; space &amp;&amp; <span class="built_in">len</span>(send) &lt; count &amp;&amp; !taskQueue.Empty(); proc++ &#123;</span><br><span class="line">		header := taskQueue.PopItem().(*types.Header)</span><br><span class="line">		hash := header.Hash()</span><br><span class="line">		index := <span class="type">int</span>(header.Number.Int64() - <span class="type">int64</span>(q.resultOffset))</span><br><span class="line">		<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(q.resultCache) || index &lt; <span class="number">0</span> &#123;</span><br><span class="line">			....</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> q.resultCache[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">			components := <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> q.mode == FastSync &#123;</span><br><span class="line">				components = <span class="number">2</span></span><br><span class="line">			&#125;</span><br><span class="line">			q.resultCache[index] = &amp;fetchResult&#123;</span><br><span class="line">				Pending: components,</span><br><span class="line">				Hash:    hash,</span><br><span class="line">				Header:  header,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> isNoop(header) &#123;</span><br><span class="line">			donePool[hash] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="built_in">delete</span>(taskPool, hash)</span><br><span class="line"></span><br><span class="line">			space, proc = space<span class="number">-1</span>, proc<span class="number">-1</span></span><br><span class="line">			q.resultCache[index].Pending--</span><br><span class="line">			progress = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.Lacks(hash) &#123;</span><br><span class="line">			skip = <span class="built_in">append</span>(skip, header)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			send = <span class="built_in">append</span>(send, header)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是构造 <code>fetchRequest</code> 结构并返回。</p>
<hr>
<h4 id="DeliverBodies-Receipts"><a href="#DeliverBodies-Receipts" class="headerlink" title="DeliverBodies&amp;Receipts"></a>DeliverBodies&amp;Receipts</h4><p><code>body</code> 或 <code>receipt</code> 数据都已经通过 <code>reserve</code> 操作构造了 <code>fetchRequest</code> 结构并传给 <code>fetch</code>，接下来就是等待数据的到达,数据下载成功后，会调用 <code>queue</code> 对象的 <code>deliver</code> 方法进行传递，包括 <code>queue.DeliverBodies</code> 和 <code>queue.DeliverReceipts</code>。这两个方法都以不同的参数调用了 <code>queue.deliver</code> 方法:</p>
<p>①：如果下载的数据数量为 0，则把所有此节点此次下载的数据标记为「缺失」</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> results == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">			request.Peer.MarkLacking(header.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：循环处理数据，通过调用<code>reconstruct</code> 填充 <code>resultCache[index]</code> 中的相应的字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err := reconstruct(header, i, q.resultCache[index]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			failure = err</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：验证<code>resultCache</code> 中的数据，其对应的 <code>request.Headers</code> 中的 <code>header</code> 都应为 nil，若不是则说明验证未通过，需要假如到task queue重新下载</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, header := <span class="keyword">range</span> request.Headers &#123;</span><br><span class="line">		<span class="keyword">if</span> header != <span class="literal">nil</span> &#123;</span><br><span class="line">			taskQueue.Push(header, -<span class="type">int64</span>(header.Number.Uint64()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果有数据被验证通过且写入 <code>queue.resultCache</code> 中了（<code>accepted</code> &gt; 0），发送 <code>queue.active</code> 消息。<code>Results</code> 会等待这这个信号。</p>
<hr>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h4><p>当(header、body、receipt)都下载完，就要将区块写入到数据库了，<code>queue.Results</code> 就是用来返回所有目前已经下载完成的数据，它在 <code>Downloader.processFullSyncContent</code> 和 <code>Downloader.processFastSyncContent</code> 中被调用。代码比较简单就不多说了。</p>
<p>到此为止<code>queue</code>对象就分析的差不多了。</p>
<hr>
<h2 id="同步headers"><a href="#同步headers" class="headerlink" title="同步headers"></a>同步headers</h2><p>继续回到<code>syncWithPeer</code>函数中，来讲下面比较关键的几个点。</p>
<h3 id="fetchHeaders"><a href="#fetchHeaders" class="headerlink" title="fetchHeaders"></a>fetchHeaders</h3><p>同步<code>headers</code> 是是由函数<code>fetchHeaders</code>来完成的。</p>
<p><code>fetchHeaders</code>的大致思想：</p>
<p> 同步<code>header</code>的数据会被填充到<code>skeleton</code>，每次从远程节点获取区块数据最大为<code>MaxHeaderFetch</code>（192），所以要获取的区块数据如果大于192 ，会被分成组，每组<code>MaxHeaderFetch</code>，剩余的不足192个的不会填充进<code>skeleton</code>，具体步骤如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glszpqzeuwj313u0msq73.jpg" alt="image-20201219111103965"></p>
<p>此种方式可以<strong>避免从同一节点下载过多错误数据</strong>，如果我们连接到了一个恶意节点，它可以创造一个链条很长且<code>TD</code>值也非常高的区块链数据。如果我们的区块从 0 开始全部从它那同步，也就下载了一些根本不被别人承认的数据。如果我只从它那同步 <code>MaxHeaderFetch</code> 个区块，然后发现这些区块无法正确填充我之前的 <code>skeleton</code>（可能是 <code>skeleton</code> 的数据错了，或者用来填充 <code>skeleton</code> 的数据错了），就会丢掉这些数据。</p>
<p>接下来查看下代码如何实现：</p>
<p>①：发起获取<code>header</code>的请求</p>
<p>如果是下载<code>skeleton</code>，则会从高度 <code>from+MaxHeaderFetch-1</code> 开始（包括），每隔 <code>MaxHeaderFetch-1</code> 的高度请求一个 <code>header</code>，最多请求 <code>MaxSkeletonSize</code> 个。如果不是的话，则要获取完整的<code>headers</code> 。</p>
<p>②：等待并处理<code>headerCh</code>中的<code>header</code>数据</p>
<p>2.1 确保远程节点正在返回我们需要填充<code>skeleton</code>所需的<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Received skeleton from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果<code>skeleton</code>已经下载完毕，则需要继续填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &amp;&amp; skeleton &#123;</span><br><span class="line">				skeleton = <span class="literal">false</span></span><br><span class="line">				getHeaders(from)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 整个<code>skeleton</code>填充完成，并且没有要获取的<code>header</code>了，要通知<code>headerProcCh</code>全部完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> packet.Items() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//下载pivot时不要中止标头的提取</span></span><br><span class="line">				<span class="keyword">if</span> atomic.LoadInt32(&amp;d.committed) == <span class="number">0</span> &amp;&amp; pivot &lt;= from &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;No headers, waiting for pivot commit&quot;</span>)</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">						getHeaders(from)</span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">						<span class="keyword">return</span> errCanceled</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//完成Pivot操作（或不进行快速同步），并且没有头文件，终止该过程</span></span><br><span class="line">				p.log.Debug(<span class="string">&quot;No more headers available&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- <span class="literal">nil</span>:</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 当<code>header</code>有数据并且是在获取<code>skeleton</code>的时候，调用<code>fillHeaderSkeleton</code>填充<code>skeleton</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> skeleton &#123;</span><br><span class="line">				filled, proced, err := d.fillHeaderSkeleton(from, headers)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					p.log.Debug(<span class="string">&quot;Skeleton chain invalid&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> errInvalidChain</span><br><span class="line">				&#125;</span><br><span class="line">				headers = filled[proced:]</span><br><span class="line">				from += <span class="type">uint64</span>(proced)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.5 如果当前处理的不是 <code>skeleton</code>，表明区块同步得差不多了，处理尾部的一些区块</p>
<p>判断本地的主链高度与新收到的 header 的最高高度的高度差是否在 <code>reorgProtThreshold</code> 以内，如果不是，就将高度最高的 <code>reorgProtHeaderDelay</code> 个 header 丢掉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> head+<span class="type">uint64</span>(reorgProtThreshold) &lt; headers[n<span class="number">-1</span>].Number.Uint64() &#123;</span><br><span class="line">						delay := reorgProtHeaderDelay</span><br><span class="line">						<span class="keyword">if</span> delay &gt; n &#123;</span><br><span class="line">							delay = n</span><br><span class="line">						&#125;</span><br><span class="line">						headers = headers[:n-delay]</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

<p>2.6 如果还有 <code>header</code> 未处理，发给 <code>headerProcCh</code> 进行处理，<code>Downloader.processHeaders</code> 会等待这个 channel 的消息并进行处理；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> d.headerProcCh &lt;- headers:</span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br><span class="line">				from += <span class="type">uint64</span>(<span class="built_in">len</span>(headers))</span><br><span class="line">  getHeaders(from)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.7 如果没有发送标头，或者所有标头等待 <code>fsHeaderContCheck</code> 秒，再次调用 <code>getHeaders</code> 请求区块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.log.Trace(<span class="string">&quot;All headers delayed, waiting&quot;</span>)</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(fsHeaderContCheck):</span><br><span class="line">					getHeaders(from)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					<span class="keyword">return</span> errCanceled</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码后来才加上的，其 commit 的记录在<a href="https://github.com/ethereum/go-ethereum/commit/6ee3b26f447459d3f3a316dbb572e461a273e193#diff-c2fa15e758e986688c646459d8970a50">这里</a>，而 「pull request」 在<a href="https://github.com/ethereum/go-ethereum/pull/17839">这里</a>。从 「pull request」 中作者的解释我们可以了解这段代码的逻辑和功能：这个修改主要是为了解决经常出现的 「invalid hash chain」 错误，出现这个错误的原因是因为在我们上一次从远程节点获取到一些区块并将它们加入到本地的主链的过程中，远程节点发生了 reorg 操作（参见<a href="https://yangzhe.me/2019/03/24/ethereum-blockchain/">这篇文章</a>里关于「主链与侧链」的介绍 ）；当我们再次根据高度请求新的区块时，对方返回给我们的是它的新的主链上的区块，而我们没有这个链上的历史区块，因此在本地写入区块时就会返回 「invalid hash chain」 错误。</p>
<p>要想发生 「reorg」 操作，就需要有新区块加入。在以太坊主网上，新产生一个区块的间隔是 10 秒到 20 秒左右。一般情况下，如果仅仅是区块数据，它的同步速度还是很快的，每次下载也有最大数量的限制。所以在新产生一个区块的这段时间里，足够同步完成一组区块数据而对方节点不会发生 「reorg」 操作。但是注意刚才说的「仅仅是区块数据」的同步较快，<strong>state 数据的同步就非常慢了</strong>。简单来说在完成同步之前可能会有多个 「pivot」 区块，这些区块的 state 数据会从网络上下载，这就大大拖慢了整个区块的同步速度，使得本地在同步一组区块的同时对方发生 「reorg」 操作的机率大大增加。</p>
<p>作者认为这种情况下发生的 「reorg」 操作是由新产生的区块的竞争引起的，所以最新的几个区块是「不稳定的」，如果本次同步的区块数量较多（也就是我们同步时消耗的时间比较长）（在这里「本次同步的区数数量较多」的表现是新收到的区块的最高高度与本地数据库中的最高高度的差距大于 <code>reorgProtThreshold</code>），那么在同步时可以先避免同步最新区块，这就是 <code>reorgProtThreshold</code> 和 <code>reorgProtHeaderDelay</code> 这个变量的由来。</p>
<p>至此，<code>Downloader.fetchHeaders</code> 方法就结束了，所有的区块头也就同步完成了。在上面我们提到填充<code>skeleton</code>的时候，是由<code>fillHeaderSkeleton</code>函数来完成，接下来就要细讲填充<code>skeleton</code>的细节。</p>
<hr>
<h3 id="fillHeaderSkeleton"><a href="#fillHeaderSkeleton" class="headerlink" title="fillHeaderSkeleton"></a>fillHeaderSkeleton</h3><p>首先我们知道以太坊在同步区块时，先确定要下载的区块的高度区间，然后将这个区间按 <code>MaxHeaderFetch</code> 切分成很多组，每一组的最后一个区块组成了 「skeleton」（最后一组不满 <code>MaxHeaderFetch</code> 个区块不算作一组）。不清楚的可以查看上面的图。</p>
<p>①：将一批<code>header</code>检索任务添加到队列中，以填充<code>skeleton</code>。</p>
<p>这个函数参照上面<strong>queue详解</strong>的分析</p>
<blockquote>
<p>func (q *queue) ScheduleSkeleton(from uint64, skeleton []*types.Header) {}</p>
</blockquote>
<p>②：调用<code>fetchParts</code> 获取<code>headers</code>数据</p>
<p><code>fetchParts</code>是很核心的函数，下面的<code>Fetchbodies</code>和<code>FetchReceipts</code>都会调用。先来大致看一下<code>fetchParts</code>的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> fetchParts(...) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">		<span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">		<span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">		<span class="keyword">case</span> &lt;-update:</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化下来就是这 5 个<code>channel</code>在处理，前面 4 个<code>channel</code>负责循环等待消息，<code>update</code>用来等待其他 4 个<code>channel</code>的通知来处理逻辑，先分开分析一个个的<code>channel</code>。</p>
<p>2.1 deliveryCh 传递下载的数据</p>
<p><code>deliveryCh</code> 作用就是传递下载的数据，当有数据被真正下载下来时，就会给这个 <code>channel</code> 发消息将数据传递过来。这个 channel 对应的分别是：<code>d.headerCh</code>、<code>d.bodyCh</code>、<code>d.receiptCh</code>，而这三个 <code>channel</code> 分别在以下三个方法中被写入数据：<code>DeliverHeaders</code>、<code>DeliverBodies</code>、<code>DeliverReceipts</code>。 看下<code>deliveryCh</code>如何处理数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> packet := &lt;-deliveryCh:</span><br><span class="line">			<span class="keyword">if</span> peer := d.peers.Peer(packet.PeerId()); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">				accepted, err := deliver(packet)<span class="comment">//传递接收到的数据块并检查链有效性</span></span><br><span class="line">				<span class="keyword">if</span> err == errInvalidChain &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> err != errStaleDelivery &#123;</span><br><span class="line">					setIdle(peer, accepted)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span> &amp;&amp; packet.Items() == <span class="number">0</span>:</span><br><span class="line">					...</span><br><span class="line">				<span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>收到下载数据后判断节点是否有效，如果节点没有被移除，则会通过<code>deliver</code>传递接收到的下载数据。如果没有任何错误，则通知<code>update</code>处理。</p>
<p>要注意<code>deliver</code>是一个回调函数，它调用了 queue 对象的 Deliver 方法：<code>queue.DeliverHeaders</code>、<code>queue.DeliverBodies</code>、<code>queue.DeliverReceipts</code>，在收到下载数据就会调用此回调函数（<strong>queue相关函数分析参照queue详解部分</strong>）。</p>
<p>在上面处理错误部分，有一个<code>setIdle</code>函数，它也是回调函数，其实现都是调用了 <code>peerConnection</code> 对象的相关方法：<code>SetHeadersIdle</code>、<code>SetBodiesIdle</code>、<code>SetReceiptsIdle</code>。它这个函数是指某些节点针对某类数据是空闲的，比如<code>header</code>、<code>bodies</code>、<code>receipts</code>，如果需要下载这几类数据，就可以从空闲的节点下载这些数据。</p>
<p>2.2 <code>wakeCh</code> 唤醒<code>fetchParts</code> ，下载新数据或下载已完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> cont := &lt;-wakeCh:</span><br><span class="line">			<span class="keyword">if</span> !cont &#123;</span><br><span class="line">				finished = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们通过调用fetchParts传递的参数知道，<code>wakeCh</code> 的值其实是 <code>queue.headerContCh</code>。在 <code>queue.DeliverHeaders</code> 中发现所有需要下戴的 header 都下载完成了时，才会发送 false 给这个 channel。<code>fetchParts</code> 在收到这个消息时，就知道没有 header 需要下载了。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span> DeliverHeaders(......) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(q.headerTaskPool) == <span class="number">0</span> &#123;</span><br><span class="line">        q.headerContCh &lt;- <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样如此，<code>body</code>和<code>receipt</code>则是<code>bodyWakeCh</code>和<code>receiptWakeCh</code>，在 <code>processHeaders</code> 中，如果所有 <code>header</code> 已经下载完成了，那么发送 <code>false</code> 给这两个 <code>channel</code>，通知它们没有新的 <code>header</code> 了。 <code>body</code> 和 <code>receipt</code> 的下载依赖于 <code>header</code>,需要 <code>header</code> 先下载完成才能下载，所以对于下戴 <code>body</code> 或 <code>receipt</code> 的 <code>fetchParts</code> 来说，收到这个 <code>wakeCh</code> 就代表不会再有通知让自己下载数据了.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processHeaders(origin <span class="type">uint64</span>, pivot <span class="type">uint64</span>, td *big.Int) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> headers := &lt;-d.headerProcCh:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                    <span class="keyword">select</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">                    <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">						...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.3 ticker 负责周期性的激活 <code>update</code>进行消息处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4 <code>update</code> （处理此前几个<code>channel</code>的数据）(<strong>重要</strong>)</p>
<p>2.4.1 判断是否有效节点，并获取超时数据的信息</p>
<p>获取超时数据的节点ID和数据数量，如果大于两个的话，就将这个节点设置为空闲状态(<code>setIdle</code>)，小于两个的话直接断开节点连接。</p>
<p><code>expire</code> 是一个回调函数，会返回当前所有的超时数据信息。这个函数的实际实现都是调用了 <code>queue</code> 对象的 <code>Expire</code> 方法：<code>ExpireHeaders</code>、<code>ExpireBodies</code>、<code>ExpireReceipts</code>,此函数会统计当前正在下载的数据中，起始时间与当前时间的差距超过给定阈值（<code>downloader.requestTTL</code> 方法的返回值）的数据，并将其返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.peers.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errNoPeers</span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> pid, fails := <span class="keyword">range</span> expire() &#123;</span><br><span class="line">  <span class="keyword">if</span> peer := d.peers.Peer(pid); peer != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fails &gt; <span class="number">2</span> &#123;</span><br><span class="line">						...</span><br><span class="line">						setIdle(peer, <span class="number">0</span>)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					...</span><br><span class="line">						<span class="keyword">if</span> d.dropPeer == <span class="literal">nil</span> &#123;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							d.dropPeer(pid)</span><br><span class="line">							....</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.4.2 处理完超时数据，判断是否还有下载的数据</p>
<p>如果没有其他可下载的内容，请等待或终止，这里<code>pending()</code>和<code>inFlight()</code>都是回调函数，<code>pending</code>分别对应了<code>queue.PendingHeaders</code>、<code>queue.PendingBlocks</code>、<code>queue.PendingReceipts</code>,用来返回各自要下载的任务数量。<code>inFlight()</code>分别对应了<code>queue.InFlightHeaders</code>、<code>queue.InFlightBlocks</code>、<code>queue.InFlightReceipts</code>,用来返回正在下载的数据数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !inFlight() &amp;&amp; finished &#123;</span><br><span class="line">				...</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>2.4.3 使用空闲节点，调用<code>fetch</code>函数发送数据请求</p>
<p><code>Idle()</code>回调函数在上面已经提过了，<code>throttle()</code>回调函数则分别对<code>queue.ShouldThrottleBlocks</code>、<code>queue.ShouldThrottleReceipts</code>,用来表示是否应该下载<code>bodies</code>或者<code>receipts</code>。</p>
<p><code>reserve</code>函数分别对应<code>queue.ReserveHeaders</code>、<code>queue.ReserveBodies</code>、<code>queue.ReserveReceipts</code>,用来从从下载任务中选取一些可以下载的任务，并构造一个 <code>fetchRequest</code> 结构。它还返回一个 <code>process</code> 变量，标记着是否有空的数据正在被处理。比如有可能某区块中未包含任何一条交易，因此它的 <code>body</code> 和 <code>receipt</code> 都是空的，这种数据其实是不需要下载的。在 <code>queue</code> 对象的 <code>Reserve</code> 方法中，会对这种情况进行识别。如果遇到空的数据，这些数据会被直接标记为下载成功。在方法返回时，就将是否发生过「直接标记为下载成功」的情况返回。</p>
<p><code>capacity</code>回调函数分别对应<code>peerConnection.HeaderCapacity</code>、<code>peerConnection.BlockCapacity</code>、<code>peerConnection.ReceiptCapacity</code>,用来决定下载需要请求数据的个数。</p>
<p><code>fetch</code>回调函数分别对应<code>peer.FetchHeaders</code>、<code>peer.Fetchbodies</code>、<code>peer.FetchReceipts</code>,用来发送获取各类数据的请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">progressed, throttled, running := <span class="literal">false</span>, <span class="literal">false</span>, inFlight()</span><br><span class="line">			idles, total := idle()</span><br><span class="line">			<span class="keyword">for</span> _, peer := <span class="keyword">range</span> idles &#123;</span><br><span class="line">				<span class="keyword">if</span> throttle() &#123;</span><br><span class="line">					...</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="keyword">if</span> pending() == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				request, progress, err := reserve(peer, capacity(peer))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> progress &#123;</span><br><span class="line">					progressed = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">        <span class="keyword">if</span> request == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> request.From &gt; <span class="number">0</span> &#123;</span><br><span class="line">				...</span><br><span class="line">				&#125;</span><br><span class="line">				...</span><br><span class="line">				<span class="keyword">if</span> err := fetch(peer, request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !progressed &amp;&amp; !throttled &amp;&amp; !running &amp;&amp; <span class="built_in">len</span>(idles) == total &amp;&amp; pending() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errPeersUnavailable</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>简单来概括这段代码就是：使用空闲节点下载数据，判断是否需要暂停，或者数据是否已经下载完成；之后选取数据进行下载；最后，如果没有遇到空块需要下载、且没有暂停下载和所有有效节点都空闲和确实有数据需要下载，但下载没有运行起来，就返回 <code>errPeersUnavailable</code> 错误。</p>
<p>到此为止<code>fetchParts</code>函数就分析的差不多了。里面涉及的跟<code>queue.go</code>相关的一些函数都在<strong>queue详解</strong>小节里介绍了。</p>
<hr>
<h3 id="processHeaders"><a href="#processHeaders" class="headerlink" title="processHeaders"></a>processHeaders</h3><p>通过<code>headerProcCh</code>接收<code>header</code>数据，并处理的过程是在<code>processHeaders</code>函数中完成的。整个处理过程集中在：<code>case headers := &lt;-d.headerProcCh中</code>:</p>
<p>①：如果<code>headers</code>的长度为0 ，则会有以下操作：</p>
<p>1.1 通知所有人<code>header</code>已经处理完毕</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">					<span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 若没有检索到任何<code>header</code>，说明他们的<code>TD</code>小于我们的，或者已经通过我们的<code>fetcher</code>模块进行了同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode != LightSync &#123;</span><br><span class="line">					head := d.blockchain.CurrentBlock()</span><br><span class="line">					<span class="keyword">if</span> !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>1.3 如果是<code>fast</code>或者<code>light</code> 同步，确保传递了<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">					head := d.lightchain.CurrentHeader()</span><br><span class="line">					<span class="keyword">if</span> td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> errStallingPeer</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果<code>headers</code>的长度大于 0</p>
<p>2.1 如果是fast或者light 同步，调用**ightchain.InsertHeaderChain()**写入<code>header</code>到<code>leveldb</code>数据库；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FastSync || d.mode == LightSync &#123;</span><br><span class="line">  ....</span><br><span class="line">  d.lightchain.InsertHeaderChain(chunk, frequency);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2 如果是<code>fast</code>或者<code>full sync</code>模式，则调用 d.queue.Schedule进行内容(body和receipt)检索。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.mode == FullSync || d.mode == FastSync &#123;</span><br><span class="line">  ...</span><br><span class="line">  inserts := d.queue.Schedule(chunk, origin)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：如果找到更新的块号，则要发信号通知新任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> d.syncStatsChainHeight &lt; origin &#123;</span><br><span class="line">				d.syncStatsChainHeight = origin - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此处理<code>Headers</code>的分析就完成了。</p>
<hr>
<h2 id="同步bodies"><a href="#同步bodies" class="headerlink" title="同步bodies"></a>同步bodies</h2><p>同步<code>bodies</code> 则是由<code>fetchBodies</code>函数完成的。</p>
<h3 id="fetchBodies"><a href="#fetchBodies" class="headerlink" title="fetchBodies"></a>fetchBodies</h3><p>同步bodies的过程跟同步header类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code></li>
<li><code>ReserveBodies</code>()从<code>bodyTaskPool</code>中取出要同步的<code>body</code>；</li>
<li>调用<code>fetch</code>，也就是调用这里的<code>FetchBodies</code>从节点获取<code>body</code>，发送<code>GetBlockBodiesMsg</code>消息；</li>
<li>收到<code>bodyCh</code>的数据后，调用<code>deliver</code>函数，将Transactions和<code>Uncles</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步Receipts"><a href="#同步Receipts" class="headerlink" title="同步Receipts"></a>同步Receipts</h2><h3 id="fetchReceipts"><a href="#fetchReceipts" class="headerlink" title="fetchReceipts"></a>fetchReceipts</h3><p>同步<code>receipts</code>的过程跟同步<code>header</code>类似，大致讲下步骤：</p>
<ol>
<li>调用<code>fetchParts</code>()</li>
<li><code>ReserveBodies</code>()从<code>ReceiptTaskPool</code>中取出要同步的<code>Receipt</code></li>
<li>调用这里的<code>FetchReceipts</code>从节点获取<code>receipts</code>，发送<code>GetReceiptsMsg</code>消息；</li>
<li>收到<code>receiptCh</code>的数据后，调用<code>deliver</code>函数，将<code>Receipts</code>写入<code>resultCache</code>。</li>
</ol>
<hr>
<h2 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h2><p>这里我们讲两种模式下的状态同步：</p>
<ul>
<li><strong>fullSync</strong>: <code>processFullSyncContent</code>，<code>full</code>模式下<code>Receipts</code>没有缓存到<code>resultCache</code>中，直接先从缓存中取出<code>body</code>数据，然后执行交易生成状态，最后写入区块链。</li>
<li><strong>fastSync</strong>:<code>processFastSyncContent</code>：fast模式的Receipts、Transaction、Uncles都在resultCache中，所以还需要下载”state”，进行校验，再写入区块链。</li>
</ul>
<p>接下来大致的讨论下这两种方式。</p>
<h3 id="processFullSyncContent"><a href="#processFullSyncContent" class="headerlink" title="processFullSyncContent"></a>processFullSyncContent</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processFullSyncContent() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		results := d.queue.Results(<span class="literal">true</span>)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> err := d.importBlockResults(results); err != <span class="literal">nil</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">...</span><br><span class="line">	blocks := <span class="built_in">make</span>([]*types.Block, <span class="built_in">len</span>(results))</span><br><span class="line">	<span class="keyword">for</span> i, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		blocks[i] = types.NewBlockWithHeader(result.Header).WithBody(result.Transactions, result.Uncles)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接从<code>result</code>中获取数据并生成<code>block</code>，直接插入区块链中，就结束了。</p>
<hr>
<h3 id="processFastSyncContent"><a href="#processFastSyncContent" class="headerlink" title="processFastSyncContent"></a>processFastSyncContent</h3><p>fast模式同步状态内容比较多，大致也就如下几部分，我们开始简单分析以下。</p>
<p>①：下载最新的区块状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sync := d.syncState(latest.Root)</span><br></pre></td></tr></table></figure>

<p>我们直接用一张图来表示整个大致流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glxk6y6zhjj31180jstcl.jpg" alt="image-20201223100153241"></p>
<p>具体的代码读者自己翻阅，大致就是这么个简单过程。</p>
<p>②：计算出pivot块</p>
<p><code>pivot</code>为<code>latestHeight - 64</code>，调用<code>splitAroundPivot</code>()方法以pivot为中心，将<code>results</code>分为三个部分：<code>beforeP</code>，<code>P</code>，<code>afterP</code>；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pivot := <span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> height := latest.Number.Uint64(); height &gt; <span class="type">uint64</span>(fsMinFullBlocks) &#123;</span><br><span class="line">		pivot = height - <span class="type">uint64</span>(fsMinFullBlocks)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">P, beforeP, afterP := splitAroundPivot(pivot, results)</span><br></pre></td></tr></table></figure>

<p>③： 对<code>beforeP</code>的部分调用<code>commitFastSyncData</code>，将<code>body</code>和<code>receipt</code>都写入区块链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">d.commitFastSyncData(beforeP, sync); </span><br></pre></td></tr></table></figure>

<p>④：对<strong>P</strong>的部分更新状态信息为<code>P block</code>的状态，把<strong>P</strong>对应的<strong>result</strong>（包含<strong>body</strong>和<strong>receipt</strong>）调用<strong>commitPivotBlock</strong>插入本地区块链中，并调用<strong>FastSyncCommitHead</strong>记录这个<strong>pivot</strong>的<strong>hash</strong>值，存在<strong>downloader</strong>中，标记为快速同步的最后一个区块<strong>hash</strong>值；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.commitPivotBlock(P); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：对<code>afterP</code>调用<code>d.importBlockResults</code>，将<code>body</code>插入区块链，而不插入<code>receipt</code>。因为是最后 64 个区块，所以此时数据库中只有<code>header</code>和<code>body</code>，没有<code>receipt</code>和状态，要通过<code>fullSync</code>模式进行最后的同步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := d.importBlockResults(afterP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个Downloader同步完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/ethereum/go-ethereum/pull/1889">https://github.com/ethereum/go-ethereum/pull/1889</a></p>
<p><a href="https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts">https://yangzhe.me/2019/05/09/ethereum-downloader/#fetchparts</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之p2p节点发现</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0-3/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之p2p节点发现</p>
</blockquote>
<p>在阅读节点发现源码之前必须要理解kadmilia算法，<a href="https://github.com/blockchainGuide/">可以参考：KAD算法详解</a>。</p>
<h2 id="节点发现概述"><a href="#节点发现概述" class="headerlink" title="节点发现概述"></a>节点发现概述</h2><p>节点发现，使本地节点得知其他节点的信息，进而加入到p2p网络中。</p>
<p>以太坊的节点发现基于类似的kademlia算法，源码中有两个版本，v4和v5。v4适用于全节点，通过<code>discover.ListenUDP</code>使用，v5适用于轻节点通过<code>discv5.ListenUDP</code>使用，本文介绍的是v4版本。</p>
<p>节点发现功能主要涉及 <strong>Server</strong> <strong>Table</strong> <strong>udp</strong> 这几个数据结构，它们有独自的事件响应循环，节点发现功能便是它们互相协作完成的。其中，每个以太坊客户端启动后都会在本地运行一个<strong>Server</strong>，并将网络拓扑中相邻的节点视为<strong>Node</strong>，而<strong>Table</strong>是<strong>Node</strong>的容器，<strong>udp</strong>则是负责维持底层的连接。这些结构的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzetbpzowj30z00egtbh.jpg" alt="image-20201123210628944"></p>
<h2 id="p2p服务开启节点发现"><a href="#p2p服务开启节点发现" class="headerlink" title="p2p服务开启节点发现"></a>p2p服务开启节点发现</h2><p>在P2p的server.go 的start方法中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := srv.setupDiscovery(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>setupDiscovery</code>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovery V4</span></span><br><span class="line">	<span class="keyword">var</span> unhandled <span class="keyword">chan</span> discover.ReadPacket</span><br><span class="line">	<span class="keyword">var</span> sconn *sharedUDPConn</span><br><span class="line">	<span class="keyword">if</span> !srv.NoDiscovery &#123;</span><br><span class="line">		...</span><br><span class="line">		ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover.ListenUDP</code>方法即开启了节点发现的功能.</p>
<p>首先解析出监听地址的UDP端口，根据端口返回与之相连的UDP连接，之后返回连接的本地网络地址，接着设置最后一个UDP-on-IPv4端口。到此为止节点发现的一些准备工作做好，接下下来开始UDP的监听：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<p>然后进行UDP 的监听，下面是监听的过程：</p>
<h3 id="监听UDP"><a href="#监听UDP" class="headerlink" title="监听UDP"></a>监听UDP</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听给定的socket 上的发现的包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenUDP</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> ListenV4(c, ln, cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenV4</span><span class="params">(c UDPConn, ln *enode.LocalNode, cfg Config)</span></span> (*UDPv4, <span class="type">error</span>) &#123;</span><br><span class="line">	closeCtx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	t := &amp;UDPv4&#123;</span><br><span class="line">		conn:            c,</span><br><span class="line">		priv:            cfg.PrivateKey,</span><br><span class="line">		netrestrict:     cfg.NetRestrict,</span><br><span class="line">		localNode:       ln,</span><br><span class="line">		db:              ln.Database(),</span><br><span class="line">		gotreply:        <span class="built_in">make</span>(<span class="keyword">chan</span> reply),</span><br><span class="line">		addReplyMatcher: <span class="built_in">make</span>(<span class="keyword">chan</span> *replyMatcher),</span><br><span class="line">		closeCtx:        closeCtx,</span><br><span class="line">		cancelCloseCtx:  cancel,</span><br><span class="line">		log:             cfg.Log,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.log == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.log = log.Root()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	t.tab = tab</span><br><span class="line">	<span class="keyword">go</span> tab.loop() <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	t.wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> t.loop() <span class="comment">//</span></span><br><span class="line">	<span class="keyword">go</span> t.readLoop(cfg.Unhandled) <span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<h4 id="1-新建路由表"><a href="#1-新建路由表" class="headerlink" title="1.新建路由表"></a>1.新建路由表</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab, err := newTable(t, ln.Database(), cfg.Bootnodes, t.log) </span><br></pre></td></tr></table></figure>

<p>新建路由表做了以下几件事：</p>
<ul>
<li>初始化table对象</li>
<li>设置bootnode（setFallbackNodes）<ul>
<li>节点第一次启动的时候，节点会与硬编码在以太坊源码中的<code>bootnode</code>进行连接，所有的节点加入几乎都先连接了它。连接上<code>bootnode</code>后，获取<code>bootnode</code>部分的邻居节点，然后进行节点发现，获取更多的活跃的邻居节点</li>
<li>nursery 是在 Table 为空并且数据库中没有存储节点时的初始连接节点（上文中的 6 个节点），通过 bootnode 可以发现新的邻居</li>
</ul>
</li>
<li>tab.seedRand：使用提供的种子值将生成器初始化为确定性状态</li>
<li>loadSeedNodes：加载种子节点；从保留已知节点的数据库中随机的抽取30个节点，再加上引导节点列表中的节点，放置入k桶中，如果K桶没有空间，则假如到替换列表中。</li>
</ul>
<h4 id="2-测试邻居节点连通性"><a href="#2-测试邻居节点连通性" class="headerlink" title="2.测试邻居节点连通性"></a>2.测试邻居节点连通性</h4><p>首先知道UDP协议是没有连接的概念的，所以需要不断的ping 来测试对端节点是否正常，在新建路由表之后，就来到下面的循环，不断的去做上面的事。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tab.loop()</span><br></pre></td></tr></table></figure>

<p>定时运行<code>doRefresh</code>、<code>doRevalidate</code>、<code>copyLiveNodes</code>进行刷新K桶。</p>
<p>以太坊的k桶设置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	alpha           = <span class="number">3</span>  <span class="comment">// Kademlia并发参数, 是系统内一个优化参数,控制每次从K桶最多取出节点个数,ethereum取值3</span></span><br><span class="line">  </span><br><span class="line">	bucketSize      = <span class="number">16</span> <span class="comment">// K桶大小(可容纳节点数)</span></span><br><span class="line">  </span><br><span class="line">	maxReplacements = <span class="number">10</span> <span class="comment">// 每桶更换列表的大小</span></span><br><span class="line">	hashBits          = <span class="built_in">len</span>(common.Hash&#123;&#125;) * <span class="number">8</span> <span class="comment">//每个节点ID长度,32*8=256, 32位16进制</span></span><br><span class="line">	nBuckets          = hashBits / <span class="number">15</span>       <span class="comment">//  K桶个数</span></span><br><span class="line">  ）</span><br></pre></td></tr></table></figure>

<p>首先搞清楚这三个定时器运行的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">refreshInterval    = <span class="number">30</span> * time.Minute</span><br><span class="line">revalidateInterval = <span class="number">10</span> * time.Second</span><br><span class="line">copyNodesInterval  = <span class="number">30</span> * time.Second</span><br></pre></td></tr></table></figure>

<h5 id="doRefresh"><a href="#doRefresh" class="headerlink" title="doRefresh"></a><code>doRefresh</code></h5><p>doRefresh对随机目标执行查找以保持K桶已满。如果表为空（初始引导程序或丢弃的有故障），则插入种子节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>从数据库加载随机节点和引导节点。这应该会产生一些以前见过的节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.loadSeedNodes()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地节点ID作为目标节点进行查找最近的邻居节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.net.lookupSelf()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> lookupSelf() []*enode.Node &#123;</span><br><span class="line">	<span class="keyword">return</span> t.newLookup(t.closeCtx, encodePubkey(&amp;t.priv.PublicKey)).run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *UDPv4)</span></span> newLookup(ctx context.Context, targetKey encPubkey) *lookup &#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">return</span> t.findnode(n.ID(), n.addr(), targetKey)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向这些节点发起<code>findnode</code>操作查询离target节点最近的节点列表,将查询得到的节点进行<code>ping-pong</code>测试,将测试通过的节点落库保存</p>
<p>经过这个流程后,节点的K桶就能够比较均匀地将不同网络节点更新到本地K桶中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unc (t *UDPv4) findnode(toid enode.ID, toaddr *net.UDPAddr, target encPubkey) ([]*node, <span class="type">error</span>) &#123;</span><br><span class="line">	t.ensureBond(toid, toaddr)</span><br><span class="line">	nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>, bucketSize)</span><br><span class="line">	nreceived := <span class="number">0</span></span><br><span class="line">  <span class="comment">// 设置回应回调函数，等待类型为neighborsPacket的邻近节点包，如果类型对，就执行回调请求</span></span><br><span class="line">	rm := t.pending(toid, toaddr.IP, p_neighborsV4, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;)</span></span> (matched <span class="type">bool</span>, requestDone <span class="type">bool</span>) &#123;</span><br><span class="line">		reply := r.(*neighborsV4)</span><br><span class="line">		<span class="keyword">for</span> _, rn := <span class="keyword">range</span> reply.Nodes &#123;</span><br><span class="line">			nreceived++</span><br><span class="line">      <span class="comment">// 得到一个简单的node结构</span></span><br><span class="line">			n, err := t.nodeFromRPC(toaddr, rn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				t.log.Trace(<span class="string">&quot;Invalid neighbor node received&quot;</span>, <span class="string">&quot;ip&quot;</span>, rn.IP, <span class="string">&quot;addr&quot;</span>, toaddr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, nreceived &gt;= bucketSize</span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="comment">//上面了一个管道事件，下面开始发送真正的findnode报文，然后进行等待了</span></span><br><span class="line">	t.send(toaddr, toid, &amp;findnodeV4&#123;</span><br><span class="line">		Target:     target,</span><br><span class="line">		Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix()),</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> nodes, &lt;-rm.errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>查找3个随机的目标节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		tab.net.lookupRandom()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="doRevalidate"><a href="#doRevalidate" class="headerlink" title="doRevalidate"></a><code>doRevalidate</code></h5><p>doRevalidate检查随机存储桶中的最后一个节点是否仍然存在，如果不是，则替换或删除该节点。</p>
<p>主要以下几步：</p>
<ol>
<li><p>返回随机的非空K桶中的最后一个节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">last, bi := tab.nodeToRevalidate()</span><br></pre></td></tr></table></figure>
</li>
<li><p>对最后的节点执行Ping操作，然后等待Pong</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remoteSeq, err := tab.net.ping(unwrapNode(last))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果节点ping通了的话，将节点移动到最前面</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.bumpInBucket(b, last)</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有收到回复，选择一个替换节点，或者如果没有任何替换节点，则删除该节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tab.replace(b, last)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="copyLiveNodes"><a href="#copyLiveNodes" class="headerlink" title="copyLiveNodes"></a><code>copyLiveNodes</code></h5><p>copyLiveNodes将表中的节点添加到数据库,如果节点在表中的时间超过了5分钟。</p>
<p>这部分代码比较简单，就伸展阐述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n.livenessChecks &gt; <span class="number">0</span> &amp;&amp; now.Sub(n.addedAt) &gt;= seedMinTableTime &#123;</span><br><span class="line">				tab.db.UpdateNode(unwrapNode(n))</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-检测各类信息"><a href="#3-检测各类信息" class="headerlink" title="3.检测各类信息"></a>3.检测各类信息</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> t.loop()</span><br></pre></td></tr></table></figure>

<p>loop循环主要监听以下几类消息：</p>
<ul>
<li>case &lt;-t.closeCtx.Done()：检测是否停止</li>
<li>p :&#x3D; &lt;-t.addReplyMatcher：检测是否有添加新的待处理消息</li>
<li>r :&#x3D; &lt;-t.gotreply：检测是否接收到其他节点的回复消息</li>
</ul>
<h4 id="4-处理UDP数据包"><a href="#4-处理UDP数据包" class="headerlink" title="4. 处理UDP数据包"></a>4. 处理UDP数据包</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> t.readLoop(cfg.Unhandled)</span><br></pre></td></tr></table></figure>

<p>主要有以下两件事：</p>
<ol>
<li><p>循环接收其他节点发来的udp消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nbytes, from, err := t.conn.ReadFromUDP(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理接收到的UDP消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.handlePacket(from, buf[:nbytes])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来对这两个函数进行进一步的解析。</p>
<h5 id="接收UDP消息"><a href="#接收UDP消息" class="headerlink" title="接收UDP消息"></a>接收UDP消息</h5><p>接收UDP消息比较的简单，就是不断的从连接中读取Packet数据，它有以下几种消息：</p>
<ul>
<li><p><code>ping</code>：用于判断远程节点是否在线。</p>
</li>
<li><p><code>pong</code>：用于回复<code>ping</code>消息的响应。</p>
</li>
<li><p><code>findnode</code>：查找与给定的目标节点相近的节点。</p>
</li>
<li><p><code>neighbors</code>：用于回复<code>findnode</code>的响应，与给定的目标节点相近的节点列表</p>
</li>
</ul>
<hr>
<h5 id="处理UDP消息"><a href="#处理UDP消息" class="headerlink" title="处理UDP消息"></a>处理UDP消息</h5><p>主要做了以下几件事：</p>
<ol>
<li><p>数据包解码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet, fromKey, hash, err := decodeV4(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查数据包是否有效，是否可以处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet.preverify(t, from, fromID, fromKey)</span><br></pre></td></tr></table></figure>

<p>在校验这一块，涉及不同的消息类型不同的校验，我们来分别对各种消息进行分析。</p>
<p>①：<code>ping</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验公钥是否有效</li>
</ul>
<p>②：<code>pong</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验回复是否正确</li>
</ul>
<p>③：<code>findNodes</code></p>
<ul>
<li>校验消息是否过期</li>
<li>校验节点是否是最近的节点</li>
</ul>
<p>④：<code>neighbors</code></p>
<ul>
<li>校验消息是否过期</li>
<li>用于回复<code>findnode</code>的响应，校验回复是否正确</li>
</ul>
</li>
<li><p>处理packet数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">packet.handle(t, from, fromID, hash)</span><br></pre></td></tr></table></figure>

<p>相同的，也会有4种消息，但是我们这边重点讲处理findNodes的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里就稍微介绍下如何处理<code>findnode</code>的消息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(req *findnodeV4)</span></span> handle(t *UDPv4, from *net.UDPAddr, fromID enode.ID, mac []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// 确定最近的节点</span></span><br><span class="line">	target := enode.ID(crypto.Keccak256Hash(req.Target[:]))</span><br><span class="line">	t.tab.mutex.Lock()</span><br><span class="line">	<span class="comment">//最接近的返回表中最接近给定id的n个节点</span></span><br><span class="line">	closest := t.tab.closest(target, bucketSize, <span class="literal">true</span>).entries</span><br><span class="line">	t.tab.mutex.Unlock()</span><br><span class="line">	<span class="comment">// 以每个数据包最多maxNeighbors的块的形式发送邻居，以保持在数据包大小限制以下。</span></span><br><span class="line">	p := neighborsV4&#123;Expiration: <span class="type">uint64</span>(time.Now().Add(expiration).Unix())&#125;</span><br><span class="line">	<span class="keyword">var</span> sent <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> closest &#123; <span class="comment">//扫描这些最近的节点列表，然后一个包一个包的发送给对方</span></span><br><span class="line">		<span class="keyword">if</span> netutil.CheckRelayIP(from.IP, n.IP()) == <span class="literal">nil</span> &#123;</span><br><span class="line">			p.Nodes = <span class="built_in">append</span>(p.Nodes, nodeToRPC(n))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) == maxNeighbors &#123;</span><br><span class="line">			t.send(from, fromID, &amp;p)<span class="comment">//给对方发送 neighborsPacket 包，里面包含节点列表</span></span><br><span class="line">			p.Nodes = p.Nodes[:<span class="number">0</span>]</span><br><span class="line">			sent = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.Nodes) &gt; <span class="number">0</span> || !sent &#123;</span><br><span class="line">		t.send(from, fromID, &amp;p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先先确定最近的节点，再一个包一个包的发给对方，并校验节点的IP，最后把有效的节点发送给请求方。</p>
</li>
</ol>
<hr>
<h2 id="涉及的结构体："><a href="#涉及的结构体：" class="headerlink" title="涉及的结构体："></a>涉及的结构体：</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>conn ：接口，包括了从UDP中读取和写入，关闭UDP连接以及获取本地地址。</li>
<li>netrestrict：IP网络列表</li>
<li>localNode：本地节点</li>
<li>tab：路由表</li>
</ul>
<hr>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><ul>
<li><p>buckets：所有节点都加到这个里面，按照距离</p>
</li>
<li><p>nursery：启动节点</p>
</li>
<li><p>rand：随机来源</p>
</li>
<li><p>ips：跟踪IP，确保IP中最多N个属于同一网络范围</p>
</li>
<li><p>net: UDP 传输的接口</p>
<ul>
<li>返回本地节点</li>
<li>将enrRequest发送到给定的节点并等待响应</li>
<li>findnode向给定节点发送一个findnode请求，并等待该节点最多发送了k个邻居</li>
<li>返回查找最近的节点</li>
<li>将ping消息发送到给定的节点，然后等待答复</li>
</ul>
</li>
</ul>
<p>以下是table的结构图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkm6yzncc3j30t00ggdim.jpg" alt="image-20201112104254003"></p>
<hr>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/blockchainguide/tree/main/%E4%B8%BB%E6%B5%81%E5%8C%BA%E5%9D%97%E9%93%BE/ethereum/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/p2p">思维导图获取地址</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzexhy1kqj31d80mqafh.jpg" alt="image-20201123211034861"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="http://mindcarver.cn/">http://mindcarver.cn/</a>     ⭐️⭐️⭐️⭐️</p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a> ⭐️⭐️⭐️⭐️</p>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">https://www.cnblogs.com/xiaolincoding/p/12571184.html</a> </p>
<p><a href="http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/">http://qjpcpu.github.io/blog/2018/01/29/shen-ru-ethereumyuan-ma-p2pmo-kuai-ji-chu-jie-gou/</a></p>
<p><a href="https://www.jianshu.com/p/b232c870dcd2">https://www.jianshu.com/p/b232c870dcd2</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/113684">https://bbs.huaweicloud.com/blogs/113684</a></p>
<p><a href="https://www.jianshu.com/p/94d02a41a146">https://www.jianshu.com/p/94d02a41a146</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之p2p网络启动</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%90%AF%E5%8A%A8-1/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之p2p网络启动</p>
<p>资料代码及文章:<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>持续输出区块链相关技术文章，喜欢作者可以持续关注，文章有问题，可以随时指出。</p>
</blockquote>
<h2 id="p2p源码目录"><a href="#p2p源码目录" class="headerlink" title="p2p源码目录"></a>p2p源码目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discover/          基于UDP的节点发现V4协议</span><br><span class="line">  discv5/            节点发现V5协议</span><br><span class="line">  enode/             节点信息</span><br><span class="line">  enr/               以太坊节点记录（ethereum node records)</span><br><span class="line">  nat/               网络地址转换，用于内网穿透</span><br><span class="line">  netutil/</span><br><span class="line">  protocol/</span><br><span class="line">  simulations/       本地p2p网络的模拟器</span><br><span class="line">  dial.go            建立连接请求，以任务的形式 </span><br><span class="line">  message.go         定义了读写的接口</span><br><span class="line">  metrics.go         计时器和计量器工具</span><br><span class="line">  peer.go            节点</span><br><span class="line">  protocol.go        子协议</span><br><span class="line">  rlpx.go            加密传输协议 </span><br><span class="line">  server.go          底层p2p网络的函数入口 </span><br></pre></td></tr></table></figure>



<h2 id="启动p2p网络"><a href="#启动p2p网络" class="headerlink" title="启动p2p网络"></a>启动p2p网络</h2><p>启动p2p网络主要会做以下几件事：</p>
<ol>
<li>发现远程节点，建立相邻节点列表</li>
<li>监听远程节点发过来的建立TCP请求</li>
<li>向远程节点发送建立TCP连接请求</li>
</ol>
<p>首先找到p2p网络启动的入口：</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p><code>start</code>函数主要做了以下6件事：</p>
<ol>
<li>初始化server的字段</li>
<li>设置本地节点setupLocalNode</li>
<li>设置监听TCP连接请求setupListening</li>
<li>设置节点发现（setupDiscovery）V4版本</li>
<li>设置最大可以主动发起的连接为50&#x2F;3</li>
<li>srv.run(dialer) 发起建立TCP连接请求</li>
</ol>
<p>其中setupLocalNode、setupListening、setupDiscovery、newDialState、srv.run(dialer)是我们要重点分析的函数。</p>
<h4 id="设置本地节点"><a href="#设置本地节点" class="headerlink" title="设置本地节点"></a>设置本地节点</h4><p>进入到setupLocalNode中：</p>
<p>①：创建devp2p握手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pubkey := crypto.FromECDSAPub(&amp;srv.PrivateKey.PublicKey)</span><br><span class="line">	srv.ourHandshake = &amp;protoHandshake&#123;Version: baseProtocolVersion, Name: srv.Name, ID: pubkey[<span class="number">1</span>:]&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		srv.ourHandshake.Caps = <span class="built_in">append</span>(srv.ourHandshake.Caps, p.<span class="built_in">cap</span>())</span><br><span class="line">	&#125;</span><br><span class="line">sort.Sort(capsByNameAndVersion(srv.ourHandshake.Caps))</span><br></pre></td></tr></table></figure>

<p>握手协议包括协议版本号，节点名称和节点的公钥，存入到Caps中要根据名称和协议排序。</p>
<p>②：创建本地节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, err := enode.OpenDB(srv.Config.NodeDatabase)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	srv.nodedb = db</span><br><span class="line">	srv.localnode = enode.NewLocalNode(db, srv.PrivateKey)</span><br><span class="line">	srv.localnode.SetFallbackIP(net.IP&#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;)</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> check conflicts</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">for</span> _, e := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">			srv.localnode.Set(e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先从节点数据库中去获取节点信息，如果不存在则新建本地节点并设置默认IP，同时将节点记录的协议特定信息存入到本地节点中。</p>
<hr>
<h4 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h4><p>进入到<code>setupListening</code>:</p>
<p>①：启动监听器</p>
<p>②：如果配置了NAT，则更新本地节点记录并映射TCP监听端口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> tcp, ok := listener.Addr().(*net.TCPAddr); ok &#123;</span><br><span class="line">		srv.localnode.Set(enr.TCP(tcp.Port))</span><br><span class="line">		<span class="keyword">if</span> !tcp.IP.IsLoopback() &amp;&amp; srv.NAT != <span class="literal">nil</span> &#123;</span><br><span class="line">			srv.loopWG.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				nat.Map(srv.NAT, srv.quit, <span class="string">&quot;tcp&quot;</span>, tcp.Port, tcp.Port, <span class="string">&quot;ethereum p2p&quot;</span>)</span><br><span class="line">				srv.loopWG.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：开启P2P监听，接收<code>inbound</code>连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv.listenLoop()</span><br></pre></td></tr></table></figure>

<p>这个函数需要进一步分析：</p>
<p>主要有以下逻辑：</p>
<ul>
<li><p>首先<code>defaultMaxPendingPeers</code>这个字段指的是<code>inbound</code> 和<code>outbound</code>连接，默认最大值为50</p>
</li>
<li><p>将监听的连接返回给<code>listener</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fd, err = srv.listener.Accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取监听的连接的地址并检查这个连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remoteIP := netutil.AddrIP(fd.RemoteAddr())</span><br><span class="line"><span class="keyword">if</span> err := srv.checkInboundConn(fd, remoteIP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkInboundConn</code>主要是做了以下的判断：</p>
<ul>
<li>拒绝不符合NetRestrict的连接（NetRestrict是指已经限定了某些连接，除此之外会拒绝）</li>
<li>拒绝尝试过多的节点</li>
</ul>
</li>
<li><p>最后真正建立连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			srv.SetupConn(fd, inboundConn, <span class="literal">nil</span>)<span class="comment">// 连接建立过程（将连接添加为peer）</span></span><br><span class="line">			slots &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;()</span><br></pre></td></tr></table></figure>

<p>要注意setupConn的第三个字段传入的是nil，表示还没有拨号，如果正在拨号的话需要节点公钥。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dialPubkey *ecdsa.PublicKey</span><br><span class="line">	<span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		dialPubkey = <span class="built_in">new</span>(ecdsa.PublicKey)</span><br><span class="line">		<span class="keyword">if</span> err := dialDest.Load((*enode.Secp256k1)(dialPubkey)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;dial destination doesn&#x27;t have a secp256k1 public key&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是进行RLPX（RLPX会单独讲）握手</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">remotePubkey, err := c.doEncHandshake(srv.PrivateKey, dialPubkey)</span><br></pre></td></tr></table></figure>

<p>如果dialDest 不为nil，检查公钥是否匹配，如果为nil,就从连接中返回一个node出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> dialDest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// For dialed connections, check that the remote public key matches.</span></span><br><span class="line">		<span class="comment">//对于拨号连接，请检查远程公钥是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> dialPubkey.X.Cmp(remotePubkey.X) != <span class="number">0</span> || dialPubkey.Y.Cmp(remotePubkey.Y) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> DiscUnexpectedIdentity</span><br><span class="line">		&#125;</span><br><span class="line">		c.node = dialDest</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.node = nodeFromConn(remotePubkey, c.fd)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正执行握手了 ,这部分也属于RLPX，跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">phs, err := c.doProtoHandshake(srv.ourHandshake)</span><br></pre></td></tr></table></figure>

<p>之后要进行检查，如果成功了的话，连接就会作为节点被添加，并且启动了runPeer.</p>
<p>到此为止，整个listenLoop 就完成了。</p>
<hr>
</li>
</ul>
<h4 id="设置节点发现"><a href="#设置节点发现" class="headerlink" title="设置节点发现"></a>设置节点发现</h4><p>进入到<code>srv.setupDiscovery()</code></p>
<p>①：添加特定于协议的发现源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">added := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, proto := <span class="keyword">range</span> srv.Protocols &#123;</span><br><span class="line">		<span class="keyword">if</span> proto.DialCandidates != <span class="literal">nil</span> &amp;&amp; !added[proto.Name] &#123;</span><br><span class="line">			srv.discmix.AddSource(proto.DialCandidates)</span><br><span class="line">			added[proto.Name] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果DHT禁用的话，就不要在UDP上监听</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> srv.NoDiscovery &amp;&amp; !srv.DiscoveryV5 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：监听给定的socket 上的发现的包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ntab, err := discover.ListenUDP(conn, srv.localnode, cfg)</span><br></pre></td></tr></table></figure>

<h4 id="创建DialState"><a href="#创建DialState" class="headerlink" title="创建DialState"></a>创建DialState</h4><p>dialstate负责拨号和查找发现。</p>
<p>①：初始化dialstate</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &amp;dialstate&#123;</span><br><span class="line">   maxDynDials: maxdyn,</span><br><span class="line">   self:        self,</span><br><span class="line">   netrestrict: cfg.NetRestrict,</span><br><span class="line">   log:         cfg.Logger,</span><br><span class="line">   static:      <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]*dialTask),</span><br><span class="line">   dialing:     <span class="built_in">make</span>(<span class="keyword">map</span>[enode.ID]connFlag),</span><br><span class="line">   bootnodes:   <span class="built_in">make</span>([]*enode.Node, <span class="built_in">len</span>(cfg.BootstrapNodes)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：加入初始引导节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s.bootnodes, cfg.BootstrapNodes)</span><br><span class="line"><span class="keyword">if</span> s.log == <span class="literal">nil</span> &#123;</span><br><span class="line">	s.log = log.Root()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③： 加入静态节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> cfg.StaticNodes &#123;</span><br><span class="line">		s.addStatic(n)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>bootnodes</code>是初始引导节点，在节点没有接收到任何节点的连接请求，也没有节点可以给我们邻居节点的时候，就去连接<code>bootnodes</code>，它硬编码在了以太坊的源码中。</p>
<p><code>static</code>是静态节点，如果我们想和某些节点保持长期的连接，就把它们加入到静态节点的列表中</p>
<p>接下来就是到了运行p2p网络的时候了，主要的函数是：<code>go srv.run(dialer)</code></p>
<hr>
<h2 id="运行p2p网络"><a href="#运行p2p网络" class="headerlink" title="运行p2p网络"></a>运行p2p网络</h2><h3 id="srv-run-dialer"><a href="#srv-run-dialer" class="headerlink" title="srv.run(dialer)"></a>srv.run(dialer)</h3><p>在p2p网络启动时候，我们会监听远程节点发送过来的TCP请求，到了运行p2p网络的时候，我们则会向远程节点发起TCP的连接请求。首先我们要知道我们所说的发起TCP连接请求可以形容成拨号，每个拨号都是以任务的形式存在，进入到<code>srv.run(dialer)</code>分析</p>
<p>整个函数就是一个循环，介绍下它的主要功能：</p>
<h4 id="发起TCP连接任务"><a href="#发起TCP连接任务" class="headerlink" title="发起TCP连接任务"></a>发起TCP连接任务</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scheduleTasks()</span><br></pre></td></tr></table></figure>

<p><code>scheduleTasks</code>主要是从queued task 中去获取任务，通过查询dialer以查找新任务并立即启动尽可能多的任务，我们这里要注意个变量<code>maxActiveDialTasks</code>,它的默认值为16 ，而安排任务的核心方法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nt := dialstate.newTasks(<span class="built_in">len</span>(runningTasks)+<span class="built_in">len</span>(queuedTasks), peers, time.Now())</span><br></pre></td></tr></table></figure>

<p>主要做了以下几件事：</p>
<p>①：为没有连接的静态节点创建拨号任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> id, t := <span class="keyword">range</span> s.static &#123;</span><br><span class="line">		err := s.checkDial(t.dest, peers)</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> errNotWhitelisted, errSelf:</span><br><span class="line">			s.log.Warn(<span class="string">&quot;Removing static dial candidate&quot;</span>, <span class="string">&quot;id&quot;</span>, t.dest.ID, <span class="string">&quot;addr&quot;</span>, &amp;net.TCPAddr&#123;IP: t.dest.IP(), Port: t.dest.TCP()&#125;, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="built_in">delete</span>(s.static, t.dest.ID())</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			s.dialing[id] = t.flags</span><br><span class="line">			newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先对拨号节点进行校验：正在连接，已经连接，是本身，不在白名单中，最近连接过的都会报错，并且不是在白名单中的和自身的节点会直接从静态节点列表中删除，校验通过的创建任务。</p>
<p>②：计算所需的动态拨号数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">needDynDials := s.maxDynDials</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		<span class="keyword">if</span> p.rw.is(dynDialedConn) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, flag := <span class="keyword">range</span> s.dialing &#123;</span><br><span class="line">		<span class="keyword">if</span> flag&amp;dynDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们主动发起的TCP连接请求是由节点最大连接数除以拨号比率得出的，即<code>maxPeers/radio</code>，同时我们会判断节点中是否已经有建立了连接的节点和正在拨号的节点，有的话会needDynDials会减去。</p>
<p>③：如果找不到任何的peers,就去随机找bootnode，发起连接</p>
<p>不过这个一般适用在<strong>测试网或者私链</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(peers) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(s.bootnodes) &gt; <span class="number">0</span> &amp;&amp; needDynDials &gt; <span class="number">0</span> &amp;&amp; now.Sub(s.start) &gt; fallbackInterval &#123;</span><br><span class="line">		bootnode := s.bootnodes[<span class="number">0</span>]</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes[:<span class="number">0</span>], s.bootnodes[<span class="number">1</span>:]...)</span><br><span class="line">		s.bootnodes = <span class="built_in">append</span>(s.bootnodes, bootnode)</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, bootnode) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：从节点发现结果中创建动态拨号任务</p>
<p>如果不满足最大任务数量的话，就去<code>s.lookupBuf</code>中寻找，<code>lookupBuf</code>通过KAD算法获取的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(s.lookupBuf) &amp;&amp; needDynDials &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> addDial(dynDialedConn, s.lookupBuf[i]) &#123;</span><br><span class="line">			needDynDials--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.lookupBuf = s.lookupBuf[:<span class="built_in">copy</span>(s.lookupBuf, s.lookupBuf[i:])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.lookupBuf) &lt; needDynDials &amp;&amp; !s.lookupRunning &#123;</span><br><span class="line">		s.lookupRunning = <span class="literal">true</span></span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, &amp;discoverTask&#123;want: needDynDials - <span class="built_in">len</span>(s.lookupBuf)&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：没有需要执行的任务，保持拨号逻辑继续运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nRunning == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(newtasks) == <span class="number">0</span> &amp;&amp; s.hist.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t := &amp;waitExpireTask&#123;s.hist.nextExpiry().Sub(now)&#125;</span><br><span class="line">		newtasks = <span class="built_in">append</span>(newtasks, t)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此创建新任务结束，返回<code>newTasks</code></p>
<hr>
<h4 id="执行TCP连接任务"><a href="#执行TCP连接任务" class="headerlink" title="执行TCP连接任务"></a>执行TCP连接任务</h4><p>直到满足最大活动任务数才开始任务执行，具体的执行过程在以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">startTasks := <span class="function"><span class="keyword">func</span><span class="params">(ts []task)</span></span> (rest []task) &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> ; <span class="built_in">len</span>(runningTasks) &lt; maxActiveDialTasks &amp;&amp; i &lt; <span class="built_in">len</span>(ts); i++ &#123;</span><br><span class="line">			t := ts[i]</span><br><span class="line">			srv.log.Trace(<span class="string">&quot;New dial task&quot;</span>, <span class="string">&quot;task&quot;</span>, t)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.Do(srv); taskdone &lt;- t &#125;()</span><br><span class="line">			runningTasks = <span class="built_in">append</span>(runningTasks, t)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ts[i:]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Do(srv);</span><br></pre></td></tr></table></figure>

<p>执行的主要任务包括下面几种：</p>
<ol>
<li>dialTask</li>
<li>discoverTask</li>
<li>waitExpireTask</li>
</ol>
<p>最关键的就是<code>dialTask</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> Do(srv *Server) &#123;</span><br><span class="line">	<span class="keyword">if</span> t.dest.Incomplete() &#123;</span><br><span class="line">		<span class="keyword">if</span> !t.resolve(srv) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err := t.dial(srv, t.dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		srv.log.Trace(<span class="string">&quot;Dial error&quot;</span>, <span class="string">&quot;task&quot;</span>, t, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="comment">// Try resolving the ID of static nodes if dialing failed.</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(*dialError); ok &amp;&amp; t.flags&amp;staticDialedConn != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> t.resolve(srv) &#123;</span><br><span class="line">				t.dial(srv, t.dest)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的连接是在<code>t.dail</code>中做的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际的网络连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *dialTask)</span></span> dial(srv *Server, dest *enode.Node) <span class="type">error</span> &#123;</span><br><span class="line">	fd, err := srv.Dialer.Dial(dest)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;dialError&#123;err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mfd := newMeteredConn(fd, <span class="literal">false</span>, &amp;net.TCPAddr&#123;IP: dest.IP(), Port: dest.TCP()&#125;)</span><br><span class="line">	<span class="keyword">return</span> srv.SetupConn(mfd, t.flags, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下面就没必要深究了，实际的网络连接操作到此为止了。</p>
<hr>
<h4 id="管理TCP连接任务"><a href="#管理TCP连接任务" class="headerlink" title="管理TCP连接任务"></a>管理TCP连接任务</h4><p>在TCP连接任务完成后，会对连接有各种处理，如下：</p>
<p>①：停止p2p服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-srv.quit:</span><br><span class="line"><span class="keyword">break</span> running</span><br></pre></td></tr></table></figure>

<p>②：添加静态节点到peer列表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addstatic:</span><br><span class="line">srv.log.Trace(<span class="string">&quot;Adding static node&quot;</span>, <span class="string">&quot;node&quot;</span>, n)</span><br><span class="line">dialstate.addStatic(n)</span><br></pre></td></tr></table></figure>

<p>③：发送断开连接请求，并断开连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removestatic:</span><br><span class="line">dialstate.removeStatic(n)</span><br><span class="line">			<span class="keyword">if</span> p, ok := peers[n.ID()]; ok &#123;</span><br><span class="line">				p.Disconnect(DiscRequested)</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>断开连接会立即返回，并且不会等连接关闭。</p>
<p>④：标记可信节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.addtrusted:</span><br><span class="line">trusted[n.ID()] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>⑤：从信任节点中删除一个节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> n := &lt;-srv.removetrusted:</span><br><span class="line"><span class="built_in">delete</span>(trusted, n.ID())</span><br></pre></td></tr></table></figure>

<p>⑥：拨号任务完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-taskdone:newTasks</span><br><span class="line">dialstate.taskDone(t, time.Now())</span><br><span class="line">delTask(t)</span><br></pre></td></tr></table></figure>

<p>⑦：连接已通过加密握手,远程身份是已知的（但尚未经过验证）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> c := &lt;-srv.checkpointPostHandshake:</span><br><span class="line">c.cont &lt;- srv.postHandshakeChecks(peers, inboundCount, c)</span><br></pre></td></tr></table></figure>

<p>⑧：连接已通过协议握手，已知其功能并验证了远程身份</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := srv.addPeerChecks(peers, inboundCount, c)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 握手完成，所有检查完毕</span></span><br><span class="line">				p := newPeer(srv.log, c, srv.Protocols)</span><br><span class="line">			<span class="comment">//启用了消息事件就把peerfeed传给peer</span></span><br><span class="line">				<span class="keyword">if</span> srv.EnableMsgEvents &#123;</span><br><span class="line">					p.events = &amp;srv.peerFeed</span><br><span class="line">				&#125;</span><br><span class="line">				name := truncateName(c.name)</span><br><span class="line">	p.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)+<span class="number">1</span>, <span class="string">&quot;name&quot;</span>, name)</span><br><span class="line">				<span class="keyword">go</span> srv.runPeer(p) <span class="comment">// 重点</span></span><br><span class="line">				peers[c.node.ID()] = p</span><br><span class="line">				<span class="keyword">if</span> p.Inbound() &#123;</span><br><span class="line">					inboundCount++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> conn, ok := c.fd.(*meteredConn); ok &#123;</span><br><span class="line">					conn.handshakeDone(p)<span class="comment">// </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p><code>addPeerChecks</code>会删除没有匹配协议的连接，并且会重复握手后检查，因为自执行这些检查后可能已更改。连接通过握手后，将调用<code>handshakeDone</code></p>
<p>⑨：Peer断开连接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> pd := &lt;-srv.delpeer:</span><br><span class="line">d := common.PrettyDuration(mclock.Now() - pd.created)</span><br><span class="line">			pd.log.Debug(<span class="string">&quot;Removing p2p peer&quot;</span>, <span class="string">&quot;addr&quot;</span>, pd.RemoteAddr(), <span class="string">&quot;peers&quot;</span>, <span class="built_in">len</span>(peers)<span class="number">-1</span>, <span class="string">&quot;duration&quot;</span>, d, <span class="string">&quot;req&quot;</span>, pd.requested, <span class="string">&quot;err&quot;</span>, pd.err)</span><br><span class="line">			<span class="built_in">delete</span>(peers, pd.ID())</span><br><span class="line">			<span class="keyword">if</span> pd.Inbound() &#123;</span><br><span class="line">				inboundCount--</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止整个主要的处理TCP连接的循环讲解结束。</p>
<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><ol>
<li>开启p2p网络主要包括：设置本地节点，监听TCP连接以及设置节点发现</li>
<li>运行P2P网络之后主要包括：发起TCP连接并执行连接，以及相关的连接处理。</li>
</ol>
<blockquote>
<p>公众号：区块链技术栈     </p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之state</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstate-16/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之state</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">｜-database.go 底层的存储设计</span><br><span class="line">｜-dump.go  用来dumpstateDB数据</span><br><span class="line">｜-iterator.go，用来遍历Trie</span><br><span class="line">｜-journal.go，用来记录状态的改变</span><br><span class="line">｜-state_object.go 通过state object操作账户值，并将修改后的storage trie写入数据库</span><br><span class="line">｜-statedb.go，以太坊整个的状态</span><br><span class="line">｜-sync.go，用来和downloader结合起来同步state</span><br></pre></td></tr></table></figure>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>以太坊的本质就是一个**基于交易的状态机(transaction-based state machine)**。在计算机科学中，一个 <em>状态机</em> 是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。</p>
<p>我们从**创世纪状态(genesis state)**开始，在网络中还没有任何交易的时候产生状态。当第一个区块执行第一个交易时候开始产生状态，直到执行完N个交易，第一个区块的最终状态产生，第二个区块的第一笔交易执行后将会改变第一个区块链的最终状态，以此类推，从而产生最终的区块状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkmt3uuo1j31g20hatb4.jpg" alt="image-20210112090020770"></p>
<h3 id="以太坊状态数据库"><a href="#以太坊状态数据库" class="headerlink" title="以太坊状态数据库"></a>以太坊状态数据库</h3><p>区块的状态数据并非保存在链上，而是将这些状态维护在默克尔压缩前缀树中，在区块链上仅记录对应的<code>Trie Root</code> 值。使用<code>LevelDB</code>维护树的持久化内容，而这个用来维护映射的数据库叫做 <code>StateDB</code>。</p>
<p>首先我们用一张图来大致了解一下<code>StateDB</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml0k9uv54j31c60g840z.jpg" alt="image-20210112165612767"></p>
<p>可以看到图中一共有两种状态，一个是世界状态<code>Trie</code>,一个是<code>storage Trie</code>,两者都是MPT树，世界状态包含了一个个的账户状态，账户状态通过以账户地址为键，维护在表示世界状态的树中，而每个账户状态中存储这账户存储树的<code>Root</code>。账户状态存储一下信息：</p>
<ol>
<li><strong>nonce</strong>: 表示此账户发出的交易数量</li>
<li><strong>balance</strong>: 账户余额 </li>
<li><strong>storageRoot</strong>:  账户存储树的Root根，用来存储合约信息</li>
<li><strong>codeHash</strong>: 账户的 EVM 代码哈希值，当这个地址接收到一个消息调用时，这些代码会被执行; 它和其它字段不同，创建后不可更改。如果 codeHash 为空，则说明该账户是一个简单的外部账户，只存在 <code>nonce</code> 和 <code>balance</code>。</li>
</ol>
<p>接下来将会分析State相关的一些类，着重关注<code>statedb.go、state_object.go、database.go</code>,其中涉及的Trie相关的代码可以参照：<a href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a></p>
<h3 id="关键的数据结构"><a href="#关键的数据结构" class="headerlink" title="关键的数据结构"></a>关键的数据结构</h3><p><strong>Account</strong></p>
<p>Account存储的是账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span>      <span class="comment">//账户发出的交易数量</span></span><br><span class="line">	Balance  *big.Int    <span class="comment">// 账户的余额</span></span><br><span class="line">	Root     common.Hash <span class="comment">//账户存储树的Root根，用来存储合约信息</span></span><br><span class="line">	CodeHash []<span class="type">byte</span>      <span class="comment">// 账户的 EVM 代码哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StateObject</strong></p>
<p>表示一个状态对象，可以从中获取到账户状态信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	address  common.Address</span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">	dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存的第一个错误</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Write caches.</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	originStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	pendingStorage Storage </span><br><span class="line"></span><br><span class="line">	<span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">	dirtyStorage Storage </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>StateDB</strong></p>
<p>用来存储状态对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">  db   Database</span><br><span class="line">	trie Trie <span class="comment">// 当前所有账户组成的MPT树</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这几个相关账户状态修改</span></span><br><span class="line">	stateObjects        <span class="keyword">map</span>[common.Address]*stateObject <span class="comment">// 存储缓存的账户状态信息</span></span><br><span class="line">	stateObjectsPending <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 状态对象已经完成但是还没有写入到Trie中</span></span><br><span class="line">	stateObjectsDirty   <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 在当前执行中修改的状态对象 ，用于后续commit </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三者之间的关系：</p>
<p>StateDB-&gt;Trie-&gt;Account-&gt;stateObject</p>
<p><strong>从StateDB中取出Trie根，根据地址从Trie树中获取账户的rlp编码数据，再进行解码成Account，然后根据Account生成stateObject</strong></p>
</blockquote>
<h2 id="StateDB存储状态"><a href="#StateDB存储状态" class="headerlink" title="StateDB存储状态"></a>StateDB存储状态</h2><p>StateDB读写状态主要关心以下几个文件：</p>
<ul>
<li>database.go</li>
<li>state_object.go</li>
<li>statedb.go</li>
</ul>
<p>接下来分别介绍这么几个文件，相当关键。</p>
<h3 id="database-go"><a href="#database-go" class="headerlink" title="database.go"></a>database.go</h3><h4 id="根据世界状态root打开世界状态树"><a href="#根据世界状态root打开世界状态树" class="headerlink" title="根据世界状态root打开世界状态树"></a>根据世界状态root打开世界状态树</h4><p>从<code>StateDB</code>中打开一个<code>Trie</code>大致经历以下过程：</p>
<blockquote>
<p>OpenTrie(root common.Hash)-&gt;NewSecure-&gt;New</p>
</blockquote>
<h4 id="根据账户地址和-stoage-root打开状态存储树"><a href="#根据账户地址和-stoage-root打开状态存储树" class="headerlink" title="根据账户地址和 stoage root打开状态存储树"></a>根据账户地址和 stoage root打开状态存储树</h4><p>创建一个账户的存储Trie过程如下：</p>
<blockquote>
<p>OpenStorageTrie(addrHash, root common.Hash)-&gt;NewSecure-New</p>
</blockquote>
<h4 id="Account和StateObject"><a href="#Account和StateObject" class="headerlink" title="Account和StateObject"></a>Account和StateObject</h4><p>以太坊的账户分为普通账户和合约账户,以<code>Account</code>表示，<code>Account</code>是账户的数据，不包含账户地址，账户需要使用地址来表示，地址在<code>stateObject</code>中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="type">uint64</span></span><br><span class="line">	Balance  *big.Int</span><br><span class="line">	Root     common.Hash <span class="comment">// 存储树的merkle树根 账户状态</span></span><br><span class="line">	CodeHash []<span class="type">byte</span> <span class="comment">//合约账户专属，合约代码编译后的Hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">  address  common.Address <span class="comment">// 账户地址</span></span><br><span class="line">	addrHash common.Hash <span class="comment">// 账户地址哈希</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB <span class="comment">// 所属的StateDB</span></span><br><span class="line">  dbErr <span class="type">error</span> <span class="comment">//VM不处理db层的错误，先记录下来，最后返回，只能保存1个错误，保存存的第一个错误</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, 使用trie组织stateObj的数据</span></span><br><span class="line">	code Code <span class="comment">// 合约字节码，在加载代码时设置</span></span><br><span class="line">	originStorage Storage <span class="comment">//将原始条目的存储高速缓存存储到dedup重写中，为每个事务重置</span></span><br><span class="line">	pendingStorage Storage <span class="comment">//在整个块的末尾需要刷新到磁盘的存储条目</span></span><br><span class="line">	dirtyStorage Storage <span class="comment">//在当前事务执行中已修改的存储条目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建StateObject"><a href="#创建StateObject" class="headerlink" title="创建StateObject"></a>创建StateObject</h4><p>创建状态对象会在两个地方进行调用：</p>
<ol>
<li>检索或者创建状态对象</li>
<li>创建账户</li>
</ol>
<p>最终都会去调用<code>createObject</code>创建一个新的状态对象。如果有一个现有的帐户给定的地址，老的将被覆盖并作为第二个返回值返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr)<span class="comment">// 如果存在老的，获取用来以后删除掉</span></span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="state-object-go"><a href="#state-object-go" class="headerlink" title="state_object.go"></a>state_object.go</h3><p><code>state_object.go</code>是很重要的文件，我们直接通过比较重要的函数来了解它。</p>
<h4 id="增加账户余额"><a href="#增加账户余额" class="headerlink" title="增加账户余额"></a>增加账户余额</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AddBalance-&gt;SetBalance</span><br></pre></td></tr></table></figure>

<h4 id="将对象的存储树保存到db"><a href="#将对象的存储树保存到db" class="headerlink" title="将对象的存储树保存到db"></a>将对象的存储树保存到db</h4><p>主要就做了两件事：</p>
<ol>
<li><em>updateTrie将缓存的存储修改写入对象的存储Trie。</em> </li>
<li><em>将所有节点写入到trie的内存数据库中</em></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> CommitTrie(db Database) <span class="type">error</span> &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	...</span><br><span class="line">	root, err := s.trie.Commit(<span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一件事会在下面继续讲，第二件事可以参照我之前关于 <a href="https://github.com/blockchainGuide/">死磕以太坊源码分析之MPT树-下</a>的讲解。</p>
<p>①：<strong>将缓存的存储修改写入对象的存储Trie</strong></p>
<blockquote>
<p>主要流程： 最终还是调用了trie.go的insert方法</p>
<p>updateTrie-&gt;TryUpdate-&gt;insert</p>
</blockquote>
<ol>
<li><code>s.finalise()</code> 将<code>dirtyStorage</code>中的所有数据移动到<code>pendingStorage</code>中</li>
<li>根据账户哈希和账户<code>root</code>打开账户存储树</li>
<li>将<code>key</code>与<code>trie</code>中的<code>value</code>关联，更新数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateTrie(db Database) Trie &#123;</span><br><span class="line">	s.finalise() ①</span><br><span class="line">...</span><br><span class="line">	</span><br><span class="line">	tr := s.getTrie(db) ②</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> s.pendingStorage &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (value == common.Hash&#123;&#125;) &#123;</span><br><span class="line">			s.setError(tr.TryDelete(key[:]))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		s.setError(tr.TryUpdate(key[:], v)) ③</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个核心也就是<code>updateTrie</code>，调用了<code>trie</code>的<code>insert</code>方法进行处理。</p>
<p>②：<strong>将所有节点写入到trie的内存数据库，其key以sha3哈希形式存储</strong></p>
<blockquote>
<p>流程：</p>
<p>trie.Commit-&gt;t.trie.Commit-&gt;t.hashRoot</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SecureTrie)</span></span> Commit(onleaf LeafCallback) (root common.Hash, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.getSecKeyCache()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t.trie.db.lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> hk, key := <span class="keyword">range</span> t.secKeyCache &#123;</span><br><span class="line">			t.trie.db.insertPreimage(common.BytesToHash([]<span class="type">byte</span>(hk)), key)</span><br><span class="line">		&#125;</span><br><span class="line">		t.trie.db.lock.Unlock()</span><br><span class="line"></span><br><span class="line">		t.secKeyCache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.trie.Commit(onleaf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>KeyCache</code>中已经有了，直接插入到磁盘数据库，否则的话插入到<code>Trie</code>的内存数据库。</p>
<h4 id="将trie根设置为的当前根哈希"><a href="#将trie根设置为的当前根哈希" class="headerlink" title="将trie根设置为的当前根哈希"></a>将trie根设置为的当前根哈希</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span></span> updateRoot(db Database) &#123;</span><br><span class="line">	s.updateTrie(db)</span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.db.StorageHashes += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	s.data.Root = s.trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法也比较简单，底层调用<code>UpdateTrie</code>然后再更新<code>root</code>.</p>
<p><code>State_object.go</code>的核心方法也就这么些内容。</p>
<h3 id="statedb-go"><a href="#statedb-go" class="headerlink" title="statedb.go"></a>statedb.go</h3><h4 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h4><p>创建账户的核心就是创建状态对象，然后再初始化值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> CreateAccount(addr common.Address) &#123;</span><br><span class="line">	newObj, prev := s.createObject(addr)</span><br><span class="line">	<span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">		newObj.setBalance(prev.data.Balance)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> createObject(addr common.Address) (newobj, prev *stateObject) &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr) </span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) </span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除、更新、获取状态对象"><a href="#删除、更新、获取状态对象" class="headerlink" title="删除、更新、获取状态对象"></a>删除、更新、获取状态对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> deleteStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> updateStateObject(obj *stateObject) </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getStateObject(obj *stateObject) &#123;</span><br></pre></td></tr></table></figure>

<p>这三个方法底层分别都是调用<code>Trie.TryDelete、Trie.TryUpdate、Trie.TryGet</code>方法来分别获取。</p>
<p>这里大致的讲一下<code>getStateObject</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> getDeletedStateObject(addr common.Address) *stateObject &#123;</span><br><span class="line">	<span class="comment">// Prefer live objects if any is available</span></span><br><span class="line">	<span class="keyword">if</span> obj := s.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> obj</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on loading the object from the database</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.AccountReads += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Load the object from the database</span></span><br><span class="line">	enc, err := s.trie.TryGet(addr[:])</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">		s.setError(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> data Account</span><br><span class="line">	<span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Insert into the live set</span></span><br><span class="line">	obj := newObject(s, addr, data)</span><br><span class="line">	s.setStateObject(obj)</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致就做了以下几件事：</p>
<ol>
<li>先从<code>StateDB</code>中获取<code>stateObjects</code>,有的话就返回。</li>
<li>如果没有的话就从<code>stateDB</code>的<code>trie</code>中获取账户状态数据，获取到<code>rlp</code>编码的数据之后，将其解码。</li>
<li>根据状态数据<code>Account</code> 构造<code>stateObject</code></li>
</ol>
<h4 id="余额操作"><a href="#余额操作" class="headerlink" title="余额操作"></a>余额操作</h4><p>余额的操作大致有添加、减少、和设定。我们就拿添加来分析：</p>
<p>根据地址获取<code>stateObject</code>，然后<code>addBalance</code>.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> AddBalance(addr common.Address, amount *big.Int) &#123;</span><br><span class="line">	stateObject := s.GetOrNewStateObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.AddBalance(amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="储存快照和回退快照"><a href="#储存快照和回退快照" class="headerlink" title="储存快照和回退快照"></a>储存快照和回退快照</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Snapshot() <span class="type">int</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> RevertToSnapshot(revid <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>储存快照和回退快照，我们可以在提交交易的流程中找到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, <span class="type">error</span>) &#123;</span><br><span class="line">	snap := w.current.state.Snapshot()</span><br><span class="line"></span><br><span class="line">	receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	w.current.txs = <span class="built_in">append</span>(w.current.txs, tx)</span><br><span class="line">	w.current.receipts = <span class="built_in">append</span>(w.current.receipts, receipt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> receipt.Logs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们会对当前状态进行快照，然后执行<code>ApplyTransaction</code>，如果在预执行交易的阶段出错了，那么会回退到备份的快照位置。之前的修改全部会回退。</p>
<h4 id="计算状态Trie的当前根哈希"><a href="#计算状态Trie的当前根哈希" class="headerlink" title="计算状态Trie的当前根哈希"></a>计算状态Trie的当前根哈希</h4><p>计算状态Trie的当前根哈希是由<code>IntermediateRoot</code>来完成的。</p>
<p>①：<strong>确定所有的脏存储状态（简单理解就是当前执行修改的所有对象）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span></span> Finalise(deleteEmptyObjects <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;</span><br><span class="line">		obj, exist := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> !exist &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> obj.suicided || (deleteEmptyObjects &amp;&amp; obj.empty()) &#123;</span><br><span class="line">			obj.deleted = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.finalise()</span><br><span class="line">		&#125;</span><br><span class="line">		s.stateObjectsPending[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.clearJournalAndRefund()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个跟<code>state_object</code>的<code>finalise</code>方法是一个方式，底层就是调用了<code>obj.finalise</code>将<code>dirty</code>状态的所有数据全部推入到<code>pending</code>中去，等待处理。</p>
<p>②：<strong>处理stateObjectsPending中的数据</strong></p>
<p>先更新账户的<code>Root</code>根，然后再将将给定的对象写入<code>trie</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsPending &#123;</span><br><span class="line">		obj := s.stateObjects[addr]</span><br><span class="line">		<span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line">			s.deleteStateObject(obj)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			obj.updateRoot(s.db)</span><br><span class="line">			s.updateStateObject(obj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将状态写入底层内存Trie数据库"><a href="#将状态写入底层内存Trie数据库" class="headerlink" title="将状态写入底层内存Trie数据库"></a>将状态写入底层内存Trie数据库</h4><p>这部分功能由commit方法完成。</p>
<ol>
<li>计算状态Trie的当前根哈希</li>
<li>将状态对象中的所有更改写入到存储树</li>
</ol>
<p>第一步在上面已经讲过了，第二步的内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsDirty &#123;</span><br><span class="line">		<span class="keyword">if</span> obj := s.stateObjects[addr]; !obj.deleted &#123;</span><br><span class="line">			....</span><br><span class="line">			<span class="keyword">if</span> err := obj.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是<code>objectCommitTrie</code>,这也是上面<code>state_object</code>的内容。</p>
<p>总结流程如下：</p>
<blockquote>
<p>1.IntermediateRoot</p>
<p>2.CommitTrie-&gt;updateTrie-&gt;trie.Commit-&gt;trie.db.insertPreimage(已经有了直接持久化到硬盘数据库)</p>
<p>​														  -&gt;t.trie.Commit（没有就提交到存储树中）</p>
</blockquote>
<p>最后看一下以太坊数据库的读写过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmlw6izetsj31ha0oogom.jpg" alt="image-20210113111013494"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://www.jianshu.com/p/20d7f7c37b03">https://www.jianshu.com/p/20d7f7c37b03</a></p>
<p><a href="https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033">https://hackernoon.com/getting-deep-into-ethereum-how-data-is-stored-in-ethereum-e3f669d96033</a></p>
<p><a href="https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf">https://web.xidian.edu.cn/qqpei/files/Blockchain/4_Data.pdf</a></p>
<p><a href="http://www.ltk100.com/article-112-1.html">http://www.ltk100.com/article-112-1.html</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之rlpx协议</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Brlpx%E5%8D%8F%E8%AE%AE-4/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之rlpx协议</p>
</blockquote>
<p>本文主要参考自eth官方文档：<a href="https://github.com/blockchainGuide">rlpx协议</a></p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><ul>
<li><code>X || Y</code>：表示X和Y的串联</li>
<li><code>X ^ Y</code>： X和Y按位异或</li>
<li><code>X[:N]</code>：X的前N个字节</li>
<li><code>[X, Y, Z, ...]</code>：[X, Y, Z, …]的RLP递归编码</li>
<li><code>keccak256(MESSAGE)</code>：以太坊使用的keccak256哈希算法</li>
<li><code>ecies.encrypt(PUBKEY, MESSAGE, AUTHDATA)</code>：RLPx使用的非对称身份验证加密函数     AUTHDATA是身份认证的数据，并非密文的一部分     但是AUTHDATA会在生成消息tag前，写入HMAC-256哈希函数</li>
<li><code>ecdh.agree(PRIVKEY, PUBKEY)</code>：是PRIVKEY和PUBKEY之间的椭圆曲线Diffie-Hellman协商函数</li>
</ul>
<hr>
<h2 id="ECIES加密"><a href="#ECIES加密" class="headerlink" title="ECIES加密"></a>ECIES加密</h2><p>ECIES (Elliptic Curve Integrated Encryption Scheme) 非对称加密用于RLPx握手。RLPx使用的加密系统：</p>
<ul>
<li>椭圆曲线secp256k1基点<code>G</code></li>
<li><code>KDF(k, len)</code>：密钥推导函数 NIST SP 800-56 Concatenation</li>
<li><code>MAC(k, m)</code>：HMAC函数，使用了SHA-256哈希</li>
<li><code>AES(k, iv, m)</code>：AES-128对称加密函数，CTR模式</li>
</ul>
<p>假设Alice想发送加密消息给Bob，并且希望Bob可以用他的静态私钥<code>kB</code>解密。Alice知道Bob的静态公钥<code>KB</code>。</p>
<p>Alice为了对消息<code>m</code>进行加密：</p>
<ol>
<li>生成一个随机数<code>r</code>并生成对应的椭圆曲线公钥<code>R = r * G</code></li>
<li>计算共享密码<code>S = Px</code>，其中 <code>(Px, Py) = r * KB</code></li>
<li>推导加密及认证所需的密钥<code>kE || kM = KDF(S, 32)</code>以及随机向量<code>iv</code></li>
<li>使用AES加密 <code>c = AES(kE, iv, m)</code></li>
<li>计算MAC校验 <code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>发送完整密文<code>R || iv || c || d</code>给Bob</li>
</ol>
<p>Bob对密文<code>R || iv || c || d</code>进行解密：</p>
<ol>
<li>推导共享密码<code>S = Px</code>, 其中<code>(Px, Py) = r * KB = kB * R</code></li>
<li>推导加密认证用的密钥<code>kE || kM = KDF(S, 32)</code></li>
<li>验证MAC<code>d = MAC(keccak256(kM), iv || c)</code></li>
<li>获得明文<code>m = AES(kE, iv || c)</code></li>
</ol>
<hr>
<h2 id="节点身份"><a href="#节点身份" class="headerlink" title="节点身份"></a>节点身份</h2><p>所有的加密操作都基于<strong>secp256k1</strong>椭圆曲线。每个节点维护一个静态的<strong>secp256k1</strong>私钥。建议该私钥只能进行手动重置（例如删除文件或数据库条目）。</p>
<hr>
<h2 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h2><p>RLPx连接基于TCP通信，并且每次通信都会生成随机的临时密钥用于加密和验证。生成临时密钥的过程被称作“握手” (handshake)，握手在发起端（initiator, 发起TCP连接请求的节点）和接收端（recipient, 接受连接的节点）之间进行。</p>
<ol>
<li>发起端向接收端发起TCP连接，发送<code>auth</code>消息</li>
<li>接收端接受连接，解密、验证<code>auth</code>消息（检查recovery of signature &#x3D;&#x3D; <code>keccak256(ephemeral-pubk)</code>）</li>
<li>接收端通过<code>remote-ephemeral-pubk</code> 和 <code>nonce</code>生成<code>auth-ack</code>消息</li>
<li>接收端推导密钥，发送首个包含<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息的数据帧 (frame)</li>
<li>发起端接收到<code>auth-ack</code>消息，导出密钥</li>
<li>发起端发送首个加密后的数据帧，包含发起端<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息</li>
<li>接收端接收并验证首个加密后的数据帧</li>
<li>发起端接收并验证首个加密后的数据帧</li>
<li>如果两边的首个加密数据帧的MAC都验证通过，则加密握手完成</li>
</ol>
<p>如果首个数据帧的验证失败，则任意一方都可以断开连接。</p>
<h3 id="握手消息"><a href="#握手消息" class="headerlink" title="握手消息"></a>握手消息</h3><p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">auth = auth-size || enc-auth-body</span><br><span class="line">auth-size = size of enc-auth-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">auth-vsn = <span class="number">4</span></span><br><span class="line">auth-body = [sig, initiator-pubk, initiator-nonce, auth-vsn, ...]</span><br><span class="line">enc-auth-body = ecies.encrypt(recipient-pubk, auth-body || auth-padding, auth-size)</span><br><span class="line">auth-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ack = ack-size || enc-ack-body</span><br><span class="line">ack-size = size of enc-ack-body, encoded as a big-endian <span class="number">16</span>-bit integer</span><br><span class="line">ack-vsn = <span class="number">4</span></span><br><span class="line">ack-body = [recipient-ephemeral-pubk, recipient-nonce, ack-vsn, ...]</span><br><span class="line">enc-ack-body = ecies.encrypt(initiator-pubk, ack-body || ack-padding, ack-size)</span><br><span class="line">ack-padding = arbitrary data</span><br></pre></td></tr></table></figure>

<p>实现必须忽略<code>auth-vsn</code> 和 <code>ack-vsn</code>中的所有不匹配。</p>
<p>实现必须忽略<code>auth-body</code> 和 <code>ack-body</code>中的所有额外列表元素。</p>
<p>握手消息互换后，密钥生成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">static-shared-secret = ecdh.agree(privkey, remote-pubk)</span><br><span class="line">ephemeral-key = ecdh.agree(ephemeral-privkey, remote-ephemeral-pubk)</span><br><span class="line">shared-secret = keccak256(ephemeral-key || keccak256(nonce || initiator-nonce))</span><br><span class="line">aes-secret = keccak256(ephemeral-key || shared-secret)</span><br><span class="line">mac-secret = keccak256(ephemeral-key || aes-secret)</span><br></pre></td></tr></table></figure>

<h2 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h2><p>握手后所有的消息都按帧 (frame) 传输。一帧数据携带属于某一功能的一条加密消息。</p>
<p>分帧传输的主要目的是在单一连接上实现可靠的支持多路复用协议。其次，因数据包分帧，为消息认证码产生了适当的分界点，使得加密流变得简单了。通过握手生成的密钥对数据帧进行加密和验证。</p>
<p>帧头提供关于消息大小和消息源功能的信息。填充字节用于防止缓存区不足，使得帧组件按指定区块字节大小对齐。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">frame = header-ciphertext || header-mac || frame-ciphertext || frame-mac</span><br><span class="line">header-ciphertext = aes(aes-secret, header)</span><br><span class="line">header = frame-size || header-data || header-padding</span><br><span class="line">header-data = [capability-id, context-id]</span><br><span class="line">capability-id = integer, always zero</span><br><span class="line">context-id = integer, always zero</span><br><span class="line">header-padding = zero-fill header to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br><span class="line">frame-ciphertext = aes(aes-secret, frame-data || frame-padding)</span><br><span class="line">frame-padding = zero-fill frame-data to <span class="number">16</span>-<span class="type">byte</span> boundary</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>RLPx中的消息认证 (Message authentication) 使用了两个keccak256状态，分别用于两个传输方向。<code>egress-mac</code>和<code>ingress-mac</code>分别代表发送和接收状态，每次发送或者接收密文，其状态都会更新。初始握手后，MAC状态初始化如下:</p>
<p><strong>发送端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br></pre></td></tr></table></figure>

<p><strong>接收端：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.init((mac-secret ^ initiator-nonce) || ack)</span><br><span class="line">ingress-mac = keccak256.init((mac-secret ^ recipient-nonce) || auth)</span><br></pre></td></tr></table></figure>

<p>当发送一帧数据时，通过即将发送的数据更新<code>egress-mac</code>状态，然后计算相应的MAC值。通过将帧头与其对应MAC值的加密输出异或来进行更新。这样做是为了确保对明文MAC和密文执行统一操作。所有的MAC值都以明文发送。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ header-ciphertext</span><br><span class="line">egress-mac = keccak256.update(egress-mac, header-mac-seed)</span><br><span class="line">header-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p><strong>计算 <code>frame-mac</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">egress-mac = keccak256.update(egress-mac, frame-ciphertext)</span><br><span class="line">frame-mac-seed = aes(mac-secret, keccak256.digest(egress-mac)[:16]) ^ keccak256.digest(egress-mac)[:16]</span><br><span class="line">egress-mac = keccak256.update(egress-mac, frame-mac-seed)</span><br><span class="line">frame-mac = keccak256.digest(egress-mac)[:16]</span><br></pre></td></tr></table></figure>

<p>只要发送者和接受者按相同方式更新<code>egress-mac</code>和<code>ingress-mac</code>，并且在ingress帧中比对<code>header-mac</code> 和 <code>frame-mac</code>的值，就能对ingress帧中的MAC值进行校验。这一步应当在解密<code>header-ciphertext</code> 和 <code>frame-ciphertext</code>之前完成。</p>
<hr>
<h2 id="功能消息"><a href="#功能消息" class="headerlink" title="功能消息"></a>功能消息</h2><p>初始握手后的所有消息均与“功能”相关。单个RLPx连接上就可以同时使用任何数量的功能。</p>
<p>功能由简短的ASCII名称和版本号标识。连接两端都支持的功能在隶属于“ p2p”功能的<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息中进行交换，p2p功能需要在所有连接中都可用。</p>
<h3 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h3><p>初始Hello消息编码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame-data = msg-id || msg-data</span><br><span class="line">frame-size = length of frame-data, encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<p>其中，<code>msg-id</code>是标识消息的由RLP编码的整数，<code>msg-data</code>是包含消息数据的RLP列表。</p>
<p>Hello之后的所有消息均使用Snappy算法压缩。请注意，压缩消息的<code>frame-size</code>指<code>msg-data</code>压缩前的大小。消息的压缩编码为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame-data = msg-id || snappyCompress(msg-data)</span><br><span class="line">frame-size = length of (msg-id || msg-data) encoded as a 24bit big-endian integer</span><br></pre></td></tr></table></figure>

<h2 id="基于msg-id的复用"><a href="#基于msg-id的复用" class="headerlink" title="基于msg-id的复用"></a>基于<code>msg-id</code>的复用</h2><p>frame中虽然支持<code>capability-id</code>，但是在本RLPx版本中并没有将该字段用于不同功能之间的复用（当前版本仅使用msg-id来实现复用）。</p>
<p>每种功能都会根据需要分配尽可能多的msg-id空间。所有这些功能所需的msg-id空间都必须通过静态指定。在连接和接收<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>消息时，两端都具有共享功能（包括版本）的对等信息，并且能够就msg-id空间达成共识。</p>
<p>msg-id应当大于0x11(0x00-0x10保留用于“ p2p”功能）。</p>
<hr>
<h2 id="p2p功能"><a href="#p2p功能" class="headerlink" title="p2p功能"></a>p2p功能</h2><p>所有连接都具有“p2p”功能。初始握手后，连接的两端都必须发送<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00">Hello</a>或<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。在接收到Hello消息后，会话就进入激活状态，并且可以开始发送其他消息。由于前向兼容性，实现必须忽略协议版本中的所有差异。与处于较低版本的节点通信时，实现应尝试靠近该版本。</p>
<p>任何时候都可能会收到<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#disconnect-0x01">Disconnect</a>消息。</p>
<h3 id="Hello-0x00"><a href="#Hello-0x00" class="headerlink" title="Hello (0x00)"></a>Hello (0x00)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[protocolVersion: P, clientId: B, capabilities, listenPort: P, nodeKey: B_64, ...]</span><br></pre></td></tr></table></figure>

<p>握手完成后，双方发送的第一包数据。在收到Hello消息前，不能发送任何其他消息。实现必须忽略Hello消息中所有其他列表元素，因为可能会在未来版本中用到。</p>
<ul>
<li><code>protocolVersion</code>当前p2p功能版本为第5版</li>
<li><code>clientId</code>表示客户端软件身份，人类可读字符串, 比如”Ethereum(++)&#x2F;1.0.0“</li>
<li><code>capabilities</code>支持的子协议列表，名称及其版本：<code>[[cap1, capVersion1], [cap2, capVersion2], ...]</code></li>
<li><code>listenPort</code>节点的收听端口 (位于当前连接路径的接口)，0表示没有收听</li>
<li><code>nodeId</code>secp256k1的公钥，对应节点私钥</li>
</ul>
<h3 id="Disconnect-0x01"><a href="#Disconnect-0x01" class="headerlink" title="Disconnect (0x01)"></a>Disconnect (0x01)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[reason: P]</span><br></pre></td></tr></table></figure>

<p>通知节点断开连接。收到该消息后，节点应当立即断开连接。如果是发送，正常的主机会给节点2秒钟读取时间，使其主动断开连接。</p>
<p><code>reason</code> 一个可选整数，表示断开连接的原因：</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x00</code></td>
<td>Disconnect requested</td>
</tr>
<tr>
<td><code>0x01</code></td>
<td>TCP sub-system error</td>
</tr>
<tr>
<td><code>0x02</code></td>
<td>Breach of protocol, e.g. a malformed message, bad RLP, …</td>
</tr>
<tr>
<td><code>0x03</code></td>
<td>Useless peer</td>
</tr>
<tr>
<td><code>0x04</code></td>
<td>Too many peers</td>
</tr>
<tr>
<td><code>0x05</code></td>
<td>Already connected</td>
</tr>
<tr>
<td><code>0x06</code></td>
<td>Incompatible P2P protocol version</td>
</tr>
<tr>
<td><code>0x07</code></td>
<td>Null node identity received - this is automatically invalid</td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>Client quitting</td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>Unexpected identity in handshake</td>
</tr>
<tr>
<td><code>0x0a</code></td>
<td>Identity is the same as this node (i.e. connected to itself)</td>
</tr>
<tr>
<td><code>0x0b</code></td>
<td>Ping timeout</td>
</tr>
<tr>
<td><code>0x10</code></td>
<td>Some other reason specific to a subprotocol</td>
</tr>
</tbody></table>
<h3 id="Ping-0x02"><a href="#Ping-0x02" class="headerlink" title="Ping (0x02)"></a>Ping (0x02)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>要求节点立即进行<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#pong-0x03">Pong</a>回复。</p>
<h3 id="Pong-0x03"><a href="#Pong-0x03" class="headerlink" title="Pong (0x03)"></a>Pong (0x03)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>回复节点的<a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md#ping-0x02">Ping</a>包。</p>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="返回传输对象"><a href="#返回传输对象" class="headerlink" title="返回传输对象"></a>返回传输对象</h4><blockquote>
<p>返回一个transport对象,连接持续5秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handshakeTimeout 5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRLPX</span><span class="params">(fd net.Conn)</span></span> transport &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h4><blockquote>
<p>返回Msg对象,调用读写器的ReadMsg,连接持续30秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> ReadMsg() (Msg, <span class="type">error</span>) &#123;</span><br><span class="line">  ..</span><br><span class="line">	t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入消息"><a href="#写入消息" class="headerlink" title="写入消息"></a>写入消息</h4><blockquote>
<p>调用读写器的WriteMsg写信息,连接持续20秒</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> WriteMsg(msg Msg) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议版本握手"><a href="#协议版本握手" class="headerlink" title="协议版本握手"></a>协议版本握手</h4><blockquote>
<p>协议握手,输入输出均是protoHandshake对象,包含了版本号、名称、容量、端口号、ID和一个扩展属性,握手时会对这些信息进行验证</p>
</blockquote>
<h4 id="加密握手"><a href="#加密握手" class="headerlink" title="加密握手"></a>加密握手</h4><blockquote>
<p>握手时主动发起者叫<strong>initiator</strong></p>
<p>接收方叫<strong>receiver</strong></p>
<p>分别对应两种处理方式<strong>initiatorEncHandshake</strong>和receiverEncHandshake</p>
<p>两种处理方式成功以后都会得到一个<strong>secrets</strong>对象,保存了共享密钥信息,它会跟原有的<strong>net.Conn</strong>对象一起生成一个帧处理器:<strong>rlpxFrameRW</strong></p>
<p>握手双方使用到的信息有:各自的公私钥地址对**(iPrv,iPub,rPrv,rPub)<strong>、各自生成的随机公私钥对</strong>(iRandPrv,iRandPub,rRandPrv,rRandPub)<strong>、各自生成的临时随机数</strong>(initNonce,respNonce).**<br> 其中i开头的表示发起方**(initiator)<strong>信息,r开头的表示接收方</strong>(receiver)**信息.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rlpx)</span></span> doEncHandshake(prv *ecdsa.PrivateKey, dial *ecdsa.PublicKey) (*ecdsa.PublicKey, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		sec secrets</span><br><span class="line">		err <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> dial == <span class="literal">nil</span> &#123;</span><br><span class="line">		sec, err = receiverEncHandshake(t.fd, prv) <span class="comment">// 接收者</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sec, err = initiatorEncHandshake(t.fd, prv, dial) <span class="comment">//主动发起者</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	t.rw = newRLPXFrameRW(t.fd, sec)</span><br><span class="line">	t.wmu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> sec.Remote.ExportECDSA(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就讲解一下主动握手部分源码<code>initiatorEncHandshake</code>：</p>
<p>①：初始化握手对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h := &amp;encHandshake&#123;initiator: <span class="literal">true</span>, remote: ecies.ImportECDSAPublic(remote)&#125;</span><br></pre></td></tr></table></figure>

<p>②：生成验证信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authMsg, err := h.makeAuthMsg(prv) </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *encHandshake)</span></span> makeAuthMsg(prv *ecdsa.PrivateKey) (*authMsgV4, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 生成己方随机数initNonce</span></span><br><span class="line">	h.initNonce = <span class="built_in">make</span>([]<span class="type">byte</span>, shaLen)</span><br><span class="line">	_, err := rand.Read(h.initNonce)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 生成随机的一组公私钥对</span></span><br><span class="line">	h.randomPrivKey, err = ecies.GenerateKey(rand.Reader, crypto.S256(), <span class="literal">nil</span>)</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成静态共享秘密token(用己方私钥和对方公钥进行有限域乘法)</span></span><br><span class="line">	token, err := h.staticSharedSecret(prv)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//  和己方随机数异或后用随机生成的私钥签名</span></span><br><span class="line">	signed := xor(token, h.initNonce)</span><br><span class="line">	signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：封包,将验证信息和握手进行rlp编码并拼接前缀信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authPacket, err := sealEIP8(authMsg, h)</span><br></pre></td></tr></table></figure>

<p>④：通过conn发送消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.Write(authPacket)</span><br></pre></td></tr></table></figure>

<p>⑤：处理接收的信息,得到响应包</p>
<blockquote>
<p><code>readHandshakeMsg</code>比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 </p>
<p>结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">authRespMsg := <span class="built_in">new</span>(authRespV4)</span><br><span class="line">authRespPacket, err := readHandshakeMsg(authRespMsg, encAuthRespLen, prv, conn)</span><br></pre></td></tr></table></figure>

<p>⑥：填充响应的respNonce(对方随机数,生成共享私钥用)和remoteRandomPub(对方的随机公钥)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.handleAuthResp(authRespMsg)</span><br></pre></td></tr></table></figure>

<p>⑦：将请求包和响应包封装成共享秘密(secrets)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.secrets(authPacket, authRespPacket)</span><br></pre></td></tr></table></figure>

<p>到此RLPX 相关的比较重要的内容就解读差不多了。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/blockchainGuide/blockchainguide">https://github.com/blockchainGuide/blockchainguide</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a>  ☆ ☆ ☆ ☆ ☆</p>
<p><a href="https://github.com/ethereum/devp2p/blob/master/rlpx.md">https://github.com/ethereum/devp2p/blob/master/rlpx.md</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之txpool</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btxpool-12/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之txpool</p>
<p>请结合以下代码阅读:<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文章不易，也希望大家多多指出问题</p>
</blockquote>
<h2 id="交易池概念原理"><a href="#交易池概念原理" class="headerlink" title="交易池概念原理"></a>交易池概念原理</h2><p>交易池工作概况：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzwre4v4ej31120tcgpa.jpg" alt="image-20201225104748102"></p>
<ol>
<li>交易池的数据来源主要来自：<ul>
<li>本地提交，也就是第三方应用通过调用本地以太坊节点的<code>RPC</code>服务所提交的交易；</li>
<li>远程同步，是指通过广播同步的形式，将其他以太坊节点的交易数据同步至本地节点;</li>
</ul>
</li>
<li>交易池中交易去向：被Miner模块获取并验证，用于挖矿；挖矿成功后写进区块并被广播</li>
<li><code>Miner</code>取走交易是复制，交易池中的交易并不减少。直到交易被写进规范链后才从交易池删除；</li>
<li>交易如果被写进分叉，交易池中的交易也不减少，等待重新打包。</li>
</ol>
<h2 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h2><h3 id="TxPoolConfig"><a href="#TxPoolConfig" class="headerlink" title="TxPoolConfig"></a>TxPoolConfig</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Locals    []common.Address <span class="comment">// 本地账户地址存放</span></span><br><span class="line">	NoLocals  <span class="type">bool</span>             <span class="comment">// 是否开启本地交易机制</span></span><br><span class="line">	Journal   <span class="type">string</span>           <span class="comment">// 本地交易存放路径</span></span><br><span class="line">	Rejournal time.Duration    <span class="comment">// 持久化本地交易的间隔</span></span><br><span class="line">	PriceLimit <span class="type">uint64</span>         <span class="comment">// 价格超出比例，若想覆盖一笔交易的时候，若价格上涨比例达不到要求，那么不能覆盖</span></span><br><span class="line">	PriceBump  <span class="type">uint64</span> <span class="comment">// 替换现有交易的最低价格涨幅百分比（一次）</span></span><br><span class="line">	AccountSlots <span class="type">uint64</span> <span class="comment">// 每个账户的可执行交易限制</span></span><br><span class="line">	GlobalSlots  <span class="type">uint64</span> <span class="comment">// 全部账户最大可执行交易</span></span><br><span class="line">	AccountQueue <span class="type">uint64</span> <span class="comment">// 单个账户不可执行的交易限制</span></span><br><span class="line">	GlobalQueue  <span class="type">uint64</span> <span class="comment">// 全部账户最大非执行交易限制</span></span><br><span class="line">	Lifetime time.Duration <span class="comment">// 一个账户在queue中的交易可以存活的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认配置：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="TxPool"><a href="#TxPool" class="headerlink" title="TxPool"></a>TxPool</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      TxPoolConfig <span class="comment">// 交易池配置</span></span><br><span class="line">	chainconfig *params.ChainConfig <span class="comment">// 区块链配置</span></span><br><span class="line">	chain       blockChain <span class="comment">// 定义blockchain接口</span></span><br><span class="line">	gasPrice    *big.Int</span><br><span class="line">	txFeed      event.Feed <span class="comment">//时间流</span></span><br><span class="line">	scope       event.SubscriptionScope <span class="comment">// 订阅范围</span></span><br><span class="line">	signer      types.Signer <span class="comment">//签名</span></span><br><span class="line">	mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">	istanbul <span class="type">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">	currentState  *state.StateDB <span class="comment">// 当前头区块对应的状态</span></span><br><span class="line">	pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">	currentMaxGas <span class="type">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">	locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">	journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">	pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">	queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">	beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">	all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">	priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">	chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">	chainHeadSub    event.Subscription</span><br><span class="line">	reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">	reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">	queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">	reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">	wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="txpool初始化"><a href="#txpool初始化" class="headerlink" title="txpool初始化"></a>txpool初始化</h2><p><code>Txpool</code>初始化主要做了以下几件事：</p>
<p>①：检查配置  配置有问题则用默认值填充</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config = (&amp;config).sanitize()</span><br></pre></td></tr></table></figure>

<p>   对于这部分的检查查看<code>TxPoolConfig</code>的字段。</p>
<p>②：初始化本地账户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.locals = newAccountSet(pool.signer)</span><br></pre></td></tr></table></figure>

<p>③：将配置的本地账户地址加到交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.locals.add(addr)</span><br></pre></td></tr></table></figure>

<p>   我们在安装以太坊客户端可以指定一个数据存储目录，此目录便会存储着所有我们导入的或者通过本地客户端创建的帐户<code>keystore</code>文件。而这个加载过程便是从该目录加载帐户数据</p>
<p>④：更新交易池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.reset(<span class="literal">nil</span>, chain.CurrentBlock().Header())</span><br></pre></td></tr></table></figure>

<p>⑤：创建所有交易存储的列表，所有交易的价格用最小堆存放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.priced = newTxPricedList(pool.all)</span><br></pre></td></tr></table></figure>

<p>   通过排序，优先处理<code>gasprice</code>越高的交易。</p>
<p>⑥：如果本地交易开启 那么从本地磁盘加载本地交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>⑦：订阅链上事件消息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>

<p>⑧：开启主循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> pool.loop()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：local交易比remote交易具有更高的权限，一是不轻易被替换；二是持久化，即通过一个本地的journal文件保存尚未打包的local交易。所以在节点启动的时候，优先从本地加载local交易。</p>
<p>本地地址会被加入白名单，凡由此地址发送的交易均被认为是local交易，不论是从本地递交还是从远端发送来的。</p>
</blockquote>
<p>到此为止交易池加载过程结束。</p>
<h2 id="添加交易到txpool"><a href="#添加交易到txpool" class="headerlink" title="添加交易到txpool"></a>添加交易到txpool</h2><p>之前我们说过交易池中交易的来源一方面是其他节点广播过来的，一方面是本地提交的，追根到源代码一个是<code>AddLocal</code>，一个是<code>AddRemote</code>,不管哪个都会调用<code>addTxs</code>。我们对添加交易的讨论就会从这个函数开始，它主要做了以下几件事,先用一张简图说明一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxhi23euj31ak0u0h34.jpg" alt="image-20201225104721173"></p>
<ol>
<li><p>过滤池中已经存在的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(tx.Hash()) != <span class="literal">nil</span> &#123;</span><br><span class="line">  errs[i] = fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, tx.Hash())</span><br><span class="line">			knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将交易添加到队列中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newErrs, dirtyAddrs := pool.addTxsLocked(news, local)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">进入到addTxsLocked函数中：</span><br><span class="line">replaced, err := pool.add(tx, local)</span><br></pre></td></tr></table></figure>

<p>进入到 <code>pool.add</code>函数中，这个<code>add</code>函数相当重要，它是将交易添加到<code>queue</code>中，等待后面的promote，到<code>pending</code>中去。如果在<code>queue</code>或者<code>pending</code>中已经存在，并且它的gas price更高时，将覆盖之前的交易。下面来拆开的分析一下add 这个函数。</p>
<p>①：看交易是否收到过，如果已经收到过就丢弃</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.all.Get(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding already known transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;known transaction: %x&quot;</span>, hash)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：如果交易没通过验证也要丢弃，这里的重点是验证函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">validateTx: 主要做了以下几件事</span><br><span class="line">- 交易大小不能超过<span class="number">32</span>kb</span><br><span class="line">- 交易金额不能为负</span><br><span class="line">- 交易gas值不能超出当前交易池设定的gaslimit</span><br><span class="line">- 交易签名必须正确</span><br><span class="line">- 如果交易为远程交易，则需验证其gasprice是否小于交易池gasprice最小值，如果是本地，优先打包，不管gasprice</span><br><span class="line">- 判断当前交易nonce值是否过低</span><br><span class="line">- 交易所需花费的转帐手续费是否大于帐户余额  cost == V + GP * GL</span><br><span class="line">- 判断交易花费gas是否小于其预估花费gas</span><br></pre></td></tr></table></figure>

<p>③：如果交易池已满，丢弃价格过低的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">uint64</span>(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</span><br><span class="line">		<span class="keyword">if</span> !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		drop := pool.priced.Discard(pool.all.Count()-<span class="type">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue<span class="number">-1</span>), pool.locals)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</span><br><span class="line">			...</span><br><span class="line">			pool.removeTx(tx.Hash(), <span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>注意这边的<code>GlobalSlots</code>和<code>GlobalQueue</code> ，就是我们说的<code>pending</code>和<code>queue</code>的最大容量，如果交易池的交易数超过两者之和，就要丢弃价格过低的交易。</p>
</li>
</ol>
<p>④：判断当前交易在pending队列中是否存在<code>nonce</code>值相同的交易。存在则判断当前交易所设置的<code>gasprice</code>是否超过设置的<code>PriceBump</code>百分比，超过则替换覆盖已存在的交易，否则报错返回<code>替换交易gasprice过低</code>，并且把它扔到<code>queue</code>队列中<code>(enqueueTx)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</span><br><span class="line"><span class="comment">// Nonce already pending, check if required price bump is met</span></span><br><span class="line"> 		inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line"><span class="keyword">if</span> !inserted &#123;</span><br><span class="line"> 			pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 			<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="comment">// New transaction is better, replace old one</span></span><br><span class="line"> 		<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line"> 			pool.all.Remove(old.Hash())</span><br><span class="line"> 			pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"> 			pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		pool.all.Add(tx)</span><br><span class="line"> 		pool.priced.Put(tx)</span><br><span class="line"> 		pool.journalTx(from, tx)</span><br><span class="line"> 		pool.queueTxEvent(tx)</span><br><span class="line"> 		log.Trace(<span class="string">&quot;Pooled new executable transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;from&quot;</span>, from, <span class="string">&quot;to&quot;</span>, tx.To())</span><br><span class="line"> 		<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// New transaction isn&#x27;t replacing a pending one, push into queue</span></span><br><span class="line"> 	replaced, err = pool.enqueueTx(hash, tx)</span><br></pre></td></tr></table></figure>

<p>   添加交易的流程就到此为止了。接下来就是如何把<code>queue</code>（暂时不可执行）中添加的交易扔到<code>pending</code>（可执行交易）中，速成<code>promote</code>。</p>
<ol start="3">
<li><p>提升交易</p>
<p>提升交易主要把交易从<code>queue</code>扔到<code>pending</code>中，我们在接下来的里面重点讲</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := pool.requestPromoteExecutables(dirtyAddrs)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="交易升级"><a href="#交易升级" class="headerlink" title="交易升级"></a>交易升级</h2><p><code>promoteExecutables</code>将<code>future queue</code>中的交易移动到<code>pending</code>中，同时也会删除很多无效交易比如<code>nonce</code>低或者余额低等等，主要分以下步骤：先看张图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glzxix54vaj313m0si4d2.jpg" alt="image-20201225104612253"></p>
<p>①：将所有<code>queue</code>中<code>nonce</code>低于账户当前<code>nonce</code>的交易从<code>all</code>里面删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">forwards := list.Forward(pool.currentState.GetNonce(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> forwards &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>②：将所有<code>queue</code>中花费大于账户余额 或者<code>gas</code>大于限制的交易从all里面删除</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：将所有可执行的交易从<code>queue</code>里面移到<code>pending</code>里面（<code>proteTx</code>）</p>
<p>注：可执行交易：将<code>pending</code>里面<code>nonce</code>值大于等于账户当前状态<code>nonce</code>的，且<code>nonce</code>连续的几笔交易作为准备好的交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">readies := list.Ready(pool.pendingNonces.get(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> readies &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			<span class="keyword">if</span> pool.promoteTx(addr, hash, tx) &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Promoting queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				promoted = <span class="built_in">append</span>(promoted, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>重点就是 <strong>promoteTx</strong>的处理，这个方法与add的不同之处在于，<code>addTx</code>是获得到的<strong>新交易插入pending</strong>，而<code>promoteTx</code>是将<strong>queue列表中的Txs放入pending</strong>接下来我们先看看里面是如何来处理的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">	<span class="keyword">if</span> !inserted &#123;</span><br><span class="line">		<span class="comment">// An older transaction was better, discard this</span></span><br><span class="line">		<span class="comment">// 老的交易更好，删除这个交易</span></span><br><span class="line">		pool.all.Remove(hash)</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Otherwise discard any previous transaction and mark this</span></span><br><span class="line">	<span class="comment">// 现在这个交易更好，删除旧的交易</span></span><br><span class="line">	<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要就做了这几件事：</p>
<ol>
<li>将交易插入<code>pending</code>中，如果待插入的交易<code>nonce</code>在<code>pending</code>列表中存在，那么待插入的交易<code>gas price</code>大于或等于原交易价值的<code>110%（</code>跟<code>pricebump</code>设定有关）时，替换原交易</li>
<li>如果新交易替换了某个交易，从<code>all</code>列表中删除老交易</li>
<li>最后更新一下<code>all</code>列表</li>
</ol>
<p>经过<code>proteTx</code>之后，要扔到<code>pending</code>的交易都放在了<code>promoted []*types.Transaction</code>中，再回到<code>promoteExecutables</code>中，继续下面步骤：</p>
<p>④：如果非本地账户<code>queue</code>大于限制（<code>AccountQueue</code>），从最后取出<code>nonce</code>较大的交易进行<code>remove</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !pool.locals.contains(addr) &#123;</span><br><span class="line">			caps = list.Cap(<span class="type">int</span>(pool.config.AccountQueue))</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> caps &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				pool.all.Remove(hash)</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：最后如果队列中此账户的交易为空则删除此账户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.queue, addr)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>到此我们的升级交易要做的事情就完毕了。</p>
<hr>
<h2 id="交易降级"><a href="#交易降级" class="headerlink" title="交易降级"></a>交易降级</h2><p>交易降级的几个场景：</p>
<ol>
<li>出现了新的区块，将会从<code>pending</code>中移除出现在区块中的交易到<code>queue</code>中</li>
<li>或者是另外一笔交易（<code>gas price</code> 更高）,则会从<code>pending</code>中移除到<code>queue</code>中</li>
</ol>
<p>关键函数：demoteUnexecutables，主要做的事情如下：</p>
<p>①：遍历<code>pending</code>中所有地址对应的交易列表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure>

<p>②：删除所有认为过旧的交易（<code>low nonce</code>）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">olds := list.Forward(nonce)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>③：删除所有费用过高的交易（余额低或用尽），并将所有无效者送到<code>queue</code>中以备后用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops))</span><br><span class="line">		pendingNofundsMeter.Mark(<span class="type">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Demoting pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.enqueueTx(hash, tx)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>④：如果交易前面有间隙，将后面的交易移到<code>queue</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> list.Len() &gt; <span class="number">0</span> &amp;&amp; list.txs.Get(nonce) == <span class="literal">nil</span> &#123;</span><br><span class="line">			gapped := list.Cap(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(<span class="string">&quot;Demoting invalidated transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				pool.enqueueTx(hash, tx)</span><br><span class="line">			&#125;</span><br><span class="line">			pendingGauge.Dec(<span class="type">int64</span>(<span class="built_in">len</span>(gapped)))</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>注：间隙的出现通常是因为交易余额问题导致的。假如原规范链 A 上交易m花费10，分叉后该账户又在分叉链B发出一个交易m花费20，这就导致该账户余额本来可以支付A链上的某笔交易，但在B链上可能就不够了。这个余额不足的交易在B如果是n+3，那么在A链上n+2，n+4号交易之间就出现了空隙，这就导致从n+3开始往后所有的交易都要降级；</p>
<p>到此为止交易降级结束。</p>
<hr>
<h2 id="重置交易池"><a href="#重置交易池" class="headerlink" title="重置交易池"></a>重置交易池</h2><hr>
<p><strong>重置交易池</strong>将检索区块链的当前状态（主要由于更新导致链状态变化），并确保交易池的内容对于链状态而言是有效的。</p>
<p><code>reset</code>的调用时机如下：</p>
<ol>
<li><code>TxPool</code>初始化的过程：<code>NewTxPool</code>；</li>
<li><code>TxPool</code>事件监听<code>go</code>程收到规范链更新事件</li>
</ol>
<p>流程图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjq7vc6bz8j31260sodlq.jpg" alt="image-20201015185551752"></p>
<p>根据上面流程图，主要功能是由于规范链的更新，重新整理交易池：</p>
<p>①：<em>如果老区块头不为空 且老区块头不是新区块的父区块，说明新老区块不在一条链上</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> oldHead != <span class="literal">nil</span> &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：<em>如果新头区块和旧头区块相差大于64，则所有交易不必回退到交易池</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> depth := <span class="type">uint64</span>(math.Abs(<span class="type">float64</span>(oldNum) - <span class="type">float64</span>(newNum))); depth &gt; <span class="number">64</span> &#123;</span><br><span class="line">  log.Debug(<span class="string">&quot;Skipping deep transaction reorg&quot;</span>, <span class="string">&quot;depth&quot;</span>, depth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：<em>如果旧链的头区块大于新链的头区块高度，旧链向后退并回收所有回退的交易</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>④：<em>如果新链的头区块大于旧链的头区块，新链后退并回收交易</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：<em>当新旧链到达同一高度的时候同时回退，知道找到共同的父节点</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> rem.Hash() != add.Hash() &#123;</span><br><span class="line">				discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">				<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br></pre></td></tr></table></figure>

<p>⑥：<em>给交易池设置最新的世界状态</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Failed to reset txpool state&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pool.currentState = statedb</span><br><span class="line">	pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">	pool.currentMaxGas = newHead.GasLimit</span><br></pre></td></tr></table></figure>

<p>⑦：<em>把旧链回退的交易放入交易池</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">senderCacher.<span class="built_in">recover</span>(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>到此整个<code>reset</code>的流程就结束了。</p>
<hr>
<blockquote>
<p>参考：</p>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn/</a></p>
<p><a href="https://github.com/mindcarver/blockchain_guide">https://github.com/mindcarver/blockchain_guide</a> </p>
<p><a href="https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0">https://learnblockchain.cn/2019/06/03/eth-txpool/#%E6%B8%85%E7%90%86%E4%BA%A4%E6%98%93%E6%B1%A0</a></p>
<p><a href="https://blog.csdn.net/lj900911/article/details/84825739">https://blog.csdn.net/lj900911/article/details/84825739</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之Trie树</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Btrie-15/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之Trie树</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>希望读者在阅读过程中发现问题可以及时评论哦，大家一起进步。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之挖矿流程</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8C%96%E7%9F%BF%E6%B5%81%E7%A8%8B-8/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之挖矿流程</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> (文章资料在此，给个Star哦)</p>
</blockquote>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>以太坊挖矿的主要流程是由<code>miner</code>包负责的，下面是基本的一个架构：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glkzcyd6xhj31am0u0qe0.jpg" alt="image-20201212125409326"></p>
<p>首先外部是通过<code>miner</code>对象进行了操作，<code>miner</code>里面则是实用<code>worker</code>对象来实现挖矿的整体功能。miner决定着是否停止挖矿或者是否可以开始挖矿，同时还可以设置矿工的地址来获取奖励。</p>
<p>真正调度处理挖矿相关细节的则是在worker.go里面，我们先来看一张总体的图。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllc2fgu1gj31cw0rwdlc.jpg" alt="image-20201212201358073"></p>
<p>上图我们看到有四个循环，分别通过几个<code>channel</code>负责不同的事：</p>
<h3 id="newWorkLoop"><a href="#newWorkLoop" class="headerlink" title="newWorkLoop"></a>newWorkLoop</h3><ol>
<li><code>startCh</code>：接收<code>startCh</code>信号，开始挖矿</li>
<li><code>chainHeadCh</code>：表示接收到新区块，需要终止当前的挖矿工作，开始新的挖矿。</li>
<li><code>timer.C</code>：默认每三秒检查一次是否有新交易需要处理。如果有则需要重新开始挖矿。以便将加高的交易优先打包到区块中。</li>
</ol>
<p>在 <code>newWorkLoop</code> 中还有一个辅助信号，<code>resubmitAdjustCh</code> 和 <code>resubmitIntervalCh</code>。运行外部修改timer计时器的时钟。<code>resubmitAdjustCh</code>是根据历史情况重新计算一个合理的间隔时间。而<code>resubmitIntervalCh</code>则允许外部，实时通过 <code>Miner</code> 实例方法 <code>SetRecommitInterval</code> 修改间隔时间。</p>
<h3 id="mainLoop"><a href="#mainLoop" class="headerlink" title="mainLoop"></a>mainLoop</h3><ol>
<li><code>newWorkCh</code>:接收生成新的挖矿任务信号</li>
<li><code>chainSideCh</code>:接收区块链中加入了一个新区块作为当前链头的旁支的信号</li>
<li><code>txsCh</code>:接收交易池的Pending中新加入了交易事件的信号</li>
</ol>
<p><code>TaskLoop</code>则是提交新的挖矿任务，而<code>resultLoop</code>则是成功出块之后做的一些处理。</p>
<hr>
<h2 id="启动挖矿"><a href="#启动挖矿" class="headerlink" title="启动挖矿"></a>启动挖矿</h2><h3 id="挖矿的参数设置"><a href="#挖矿的参数设置" class="headerlink" title="挖矿的参数设置"></a>挖矿的参数设置</h3><p><code>geth</code>挖矿的参数设置定义在 <code>cmd/utils/flags.go</code> 文件中</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–mine</td>
<td align="left">false</td>
<td align="center">是否开启自动挖矿</td>
</tr>
<tr>
<td align="left">–miner.threads</td>
<td align="left">0</td>
<td align="center">挖矿时可用并行PoW计算的协程（轻量级线程）数。 兼容过时参数 —minerthreads。</td>
</tr>
<tr>
<td align="left">–miner.notify</td>
<td align="left">空</td>
<td align="center">挖出新块时用于通知远程服务的任意数量的远程服务地址。 是用 <code>,</code>分割的多个远程服务器地址。 如：”<a href="http://api.miner.com,http//api2.miner.com%E2%80%9C">http://api.miner.com,http://api2.miner.com“</a></td>
</tr>
<tr>
<td align="left">–miner.noverify</td>
<td align="left">false</td>
<td align="center">是否禁用区块的PoW工作量校验。</td>
</tr>
<tr>
<td align="left">–miner.gasprice</td>
<td align="left">1000000000 wei</td>
<td align="center">矿工可接受的交易Gas价格， 低于此GasPrice的交易将被拒绝写入交易池和不会被矿工打包到区块。</td>
</tr>
<tr>
<td align="left">–miner.gastarget</td>
<td align="left">8000000 gas</td>
<td align="center">动态计算新区块燃料上限（gaslimit）的下限值。 兼容过时参数 —targetgaslimit。</td>
</tr>
<tr>
<td align="left">–miner.gaslimit</td>
<td align="left">8000000 gas</td>
<td align="center">动态技术新区块燃料上限的上限值。</td>
</tr>
<tr>
<td align="left">–miner.etherbase</td>
<td align="left">第一个账户</td>
<td align="center">用于接收挖矿奖励的账户地址， 默认是本地钱包中的第一个账户地址。</td>
</tr>
<tr>
<td align="left">–miner.extradata</td>
<td align="left">geth版本号</td>
<td align="center">允许矿工自定义写入区块头的额外数据。</td>
</tr>
<tr>
<td align="left">–miner.recommit</td>
<td align="left">3s</td>
<td align="center">重新开始挖掘新区块的时间间隔。 将自动放弃进行中的挖矿后，重新开始一次新区块挖矿。</td>
</tr>
</tbody></table>
<h3 id="常见的启动挖矿的方式"><a href="#常见的启动挖矿的方式" class="headerlink" title="常见的启动挖矿的方式"></a>常见的启动挖矿的方式</h3><h4 id="参数设置挖矿"><a href="#参数设置挖矿" class="headerlink" title="参数设置挖矿"></a>参数设置挖矿</h4><blockquote>
<p>dgeth –dev –mine</p>
</blockquote>
<h4 id="控制台启动挖矿"><a href="#控制台启动挖矿" class="headerlink" title="控制台启动挖矿"></a>控制台启动挖矿</h4><blockquote>
<p>miner.start(1)</p>
</blockquote>
<h4 id="rpc-启动挖矿"><a href="#rpc-启动挖矿" class="headerlink" title="rpc 启动挖矿"></a>rpc 启动挖矿</h4><p>这是部署节点使用的方式，一般设置如下：</p>
<blockquote>
<p>&#x2F;geth –datadir “&#x2F;data0” –nodekeyhex “27aa615f5fa5430845e4e99229def5f23e9525a20640cc49304f40f3b43824dc” –bootnodes $enodeid –mine –debug –metrics –syncmode&#x3D;”full” –gcmode&#x3D;archive –istanbul.blockperiod 5 –gasprice 0 –port 30303 –rpc –rpcaddr “0.0.0.0” –rpcport 8545 –rpcapi “db,eth,net,web3,personal” –nat any –allow-insecure-unlock </p>
</blockquote>
<hr>
<p>开始源码分析，进入到<code>miner.go</code>的<code>New</code>函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(eth Backend, config *Config, chainConfig *params.ChainConfig, mux *event.TypeMux, engine consensus.Engine, isLocalBlock <span class="keyword">func</span>(block *types.Block)</span></span> <span class="type">bool</span>) *Miner &#123;</span><br><span class="line">	miner := &amp;Miner&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> miner.update()</span><br><span class="line">	<span class="keyword">return</span> miner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> update() &#123;</span><br><span class="line">  <span class="keyword">switch</span> ev.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> downloader.StartEvent:</span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> miner.Mining() &#123;</span><br><span class="line">					miner.Stop()</span><br><span class="line">					atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">1</span>)</span><br><span class="line">					log.Info(<span class="string">&quot;Mining aborted due to sync&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> downloader.DoneEvent, downloader.FailedEvent:</span><br><span class="line">				shouldStart := atomic.LoadInt32(&amp;miner.shouldStart) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">				atomic.StoreInt32(&amp;miner.canStart, <span class="number">1</span>)</span><br><span class="line">				atomic.StoreInt32(&amp;miner.shouldStart, <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">if</span> shouldStart &#123;</span><br><span class="line">					miner.Start(miner.coinbase)</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们初始化的<code>canStart=1</code> ， 如果<code>Downloader</code>模块正在同步，则<code>canStart=0</code>,并且停止挖矿，如果<code>Downloader</code>模块<code>Done</code>或者<code>Failed</code>，则<code>canStart=1</code>,且同时<code>shouldStart=0</code>,miner将启动。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">miner.Start(miner.coinbase)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(miner *Miner)</span></span> Start(coinbase common.Address) &#123;</span><br><span class="line">...</span><br><span class="line">	miner.worker.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *worker)</span></span> start() &#123;</span><br><span class="line">...</span><br><span class="line">	w.startCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将会进入到<code>mainLoop</code>中去处理<code>startCh</code>：</p>
<p>①：清除过旧的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">clearPending(w.chain.CurrentBlock().NumberU64())</span><br></pre></td></tr></table></figure>

<p>②：提交新的挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commit := <span class="function"><span class="keyword">func</span><span class="params">(noempty <span class="type">bool</span>, s <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">		w.newWorkCh &lt;- &amp;newWorkReq&#123;interrupt: interrupt, noempty: noempty, timestamp: timestamp&#125;</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成新的挖矿任务"><a href="#生成新的挖矿任务" class="headerlink" title="生成新的挖矿任务"></a>生成新的挖矿任务</h2><p>根据<code>newWorkCh</code>生成新的挖矿任务，进入到<code>CommitNewWork</code>中：</p>
<p>①：组装<code>header</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">header := &amp;types.Header&#123; <span class="comment">//组装header</span></span><br><span class="line">		ParentHash: parent.Hash(),</span><br><span class="line">		Number:     num.Add(num, common.Big1), <span class="comment">//num+1</span></span><br><span class="line">		GasLimit:   core.CalcGasLimit(parent, w.config.GasFloor, w.config.GasCeil),</span><br><span class="line">		Extra:      w.extra,</span><br><span class="line">		Time:       <span class="type">uint64</span>(timestamp),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：根据共识引擎吃初始化header的共识字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.engine.Prepare(w.chain, header); </span><br></pre></td></tr></table></figure>

<p>③：为当前挖矿新任务创建环境</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.makeCurrent(parent, header)</span><br></pre></td></tr></table></figure>

<p>④：添加叔块</p>
<p>叔块集分本地矿工打包区块和其他挖矿打包的区块。优先选择自己挖出的区块。选择时，将先删除太旧的区块，只从最近的7(staleThreshold)个高度中选择，最多<strong>选择两个叔块</strong>放入新区块中.在真正添加叔块的同时会进行校验，包括如下：</p>
<ul>
<li>叔块存在报错</li>
<li>添加的uncle是父块的兄弟报错</li>
<li>叔块的父块未知报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">commitUncles(w.localUncles)</span><br><span class="line">commitUncles(w.remoteUncles)</span><br></pre></td></tr></table></figure>

<p>⑤：如果noempty为false，则提交空块，不填充交易进入到区块中,表示提前挖矿</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !noempty &#123;</span><br><span class="line">  w.commit(uncles, <span class="literal">nil</span>, <span class="literal">false</span>, tstart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥：填充交易到新区块中</p>
<p>6.1 从交易池中获取交易，并把交易分为本地交易和远程交易，本地交易优先，先将本地交易提交，再将外部交易提交。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">localTxs, remoteTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions), pending</span><br><span class="line">	<span class="keyword">for</span> _, account := <span class="keyword">range</span> w.eth.TxPool().Locals() &#123;</span><br><span class="line">		<span class="keyword">if</span> txs := remoteTxs[account]; <span class="built_in">len</span>(txs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(remoteTxs, account)</span><br><span class="line">			localTxs[account] = txs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(localTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   txs := types.NewTransactionsByPriceAndNonce(w.current.signer, localTxs)</span><br><span class="line">   <span class="keyword">if</span> w.commitTransactions(txs, w.coinbase, interrupt) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(remoteTxs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.2提交交易 </p>
<ul>
<li>首先校验有没有可用的<code>Gas</code></li>
<li>如果碰到以下情况要进行交易执行的中断<ul>
<li>新的头块事件到达，中断信号为 1     (整个任务会被丢弃)</li>
<li><code>worker</code> 开启或者重启，中断信号为 1     （整个任务会被丢弃）</li>
<li><code>worker</code>重新创建挖矿任务根据新的交易，中断信号为 2 （任务还是会被送入到共识引擎）</li>
</ul>
</li>
</ul>
<p>6.3开始执行交易</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logs, err := w.commitTransaction(tx, coinbase)</span><br></pre></td></tr></table></figure>

<p>6.4执行交易获取收据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;w.current.header.GasUsed, *w.chain.GetVMConfig())</span><br></pre></td></tr></table></figure>

<p>如果执行出错，直接回退上一个快照</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.current.state.RevertToSnapshot(snap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>出错的原因大概有以下几个：</p>
<ul>
<li>超出当前块的<code>gas limit</code></li>
<li><code>Nonce</code> 太低</li>
<li><code>Nonce</code> 太高</li>
</ul>
<p>执行成功的话讲交易和收据存入到<code>w.current</code>中。</p>
<p>⑦：执行交易的状态更改，并组装成最终块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.commit(uncles, w.fullTaskHook, <span class="literal">true</span>, tstart)</span><br></pre></td></tr></table></figure>

<p>执行交易的状态更改，并组装成最终块是由下面的共识引擎所完成的事情：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block, err := w.engine.FinalizeAndAssemble(w.chain, w.current.header, s, w.current.txs, uncles, w.current.receipts)</span><br></pre></td></tr></table></figure>

<p>底层会调用 <code>state.IntermediateRoot</code>执行状态更改。组装成最终块意味着到这打包任务完成。接着就是要提交新的挖矿任务。</p>
<hr>
<h2 id="提交新的挖矿任务"><a href="#提交新的挖矿任务" class="headerlink" title="提交新的挖矿任务"></a>提交新的挖矿任务</h2><p>①：获取<code>sealHash</code>（挖矿前的区块哈希），重复提交则跳过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sealHash := w.engine.SealHash(task.block.Header()) <span class="comment">// 返回挖矿前的块的哈希</span></span><br><span class="line">			<span class="keyword">if</span> sealHash == prev &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>②:生成新的挖矿请求，结果返回到<code>reultCh</code>或者<code>StopCh</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.engine.Seal(w.chain, task.block, w.resultCh, stopCh);</span><br></pre></td></tr></table></figure>

<p>挖矿的结果会返回到<code>resultCh</code>中或者<code>stopCh</code>中，<code>resultCh</code>有数据成功出块，<code>stopCh</code>不为空，则中断挖矿线程。</p>
<hr>
<h2 id="成功出块"><a href="#成功出块" class="headerlink" title="成功出块"></a>成功出块</h2><p><code>resultCh</code>有区块数据，则成功挖出了块，到最后的成功出块我们还需要进行相应的验证判断。</p>
<p>①：块为空或者链上已经有块或者<code>pendingTasks</code>不存在相关的<code>sealhash</code>,跳过处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> block == <span class="literal">nil</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> w.chain.HasBlock(block.Hash(), block.NumberU64()) &#123;&#125;</span><br><span class="line">task, exist := w.pendingTasks[sealhash] <span class="keyword">if</span> !exist &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>②：更新<code>receipts</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> task.receipts &#123;</span><br><span class="line">  receipt.BlockHash = hash</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：提交块和状态到数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := w.chain.WriteBlockWithState(block, receipts, logs, task.state, <span class="literal">true</span>) <span class="comment">// 互斥</span></span><br></pre></td></tr></table></figure>

<p>④：广播区块并宣布链插入事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.mux.Post(core.NewMinedBlockEvent&#123;Block: block&#125;)</span><br></pre></td></tr></table></figure>

<p>⑤：等待规范确认本地挖出的块</p>
<p>新区块并非立即稳定，暂时存入到未确认区块集中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">w.unconfirmed.Insert(block.NumberU64(), block.Hash())</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结-参考"><a href="#总结-参考" class="headerlink" title="总结&amp;参考"></a>总结&amp;参考</h2><p>整个挖矿流程还是比较的简单，通过 4 个<code>Loop</code>互相工作，从开启挖矿到生成新的挖矿任务到提交新的挖矿任务到最后的成功出块，这里面的共识处理细节不会提到，接下来的文章会说到。</p>
<blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p><a href="https://learnblockchain.cn/books/geth/part2/mine/design.html">https://learnblockchain.cn/books/geth/part2/mine/design.html</a></p>
<p><a href="https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8">https://yangzhe.me/2019/02/25/ethereum-miner/#%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E5%87%BA%E5%9D%97%E9%A2%91%E7%8E%8</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之区块和交易广播</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%A4%E6%98%93%E5%B9%BF%E6%92%AD-5/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之区块和交易广播</p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a>  (文章及学习资料，给个star哦)</p>
</blockquote>
<h2 id="ProtocolManager详解"><a href="#ProtocolManager详解" class="headerlink" title="ProtocolManager详解"></a>ProtocolManager详解</h2><p><code>ProtocolManager</code>，从字面上看是协议管理器，负责着<code>p2p</code>通信协议的管理。它连接了<code>p2p</code>的逻辑层<code>peer</code>与顶层<code>peer</code>之间的调用，从顶层将协议传递至逻辑层，再从逻辑层得到<code>message</code>传递到顶层。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9hs30wqfj30zw0rodox.jpg" alt="image-20201202142450663"></p>
<ol>
<li><code>fastSync</code>规定了同步的模式 ；</li>
<li><code>acceptTxs</code>是节点是否接受交易的阀门，只有当<code>pm.acceptTxs == 1</code>时，节点才会接受交易。这个操作只会在同步结束后再开始，即同步的时候节点是不会接受交易的；</li>
<li><code>SubProtocols</code>中是以太坊的通讯协议，通常只有一个值，即<code>eth63</code>。</li>
<li><code>downloader</code>是一个下载器，用于主动从远程节点中获取<code>hashes</code>和<code>blocks</code>。</li>
<li><code>fetcher</code>则被动的收集网络其他以太坊节点发过来的同步通知，进行验证，并做出相应的处理。</li>
</ol>
<hr>
<p><code>ProtocolManager.Start()</code>启动了四条<code>go</code>程，分别是交易订阅广播协程（<code>txBroadcastLoop</code>）、挖矿订阅协程（<code>minedBroadcastLoop</code>）、节点定期同步协程（<code>syncer</code>）和交易同步协程（txsyncLoop）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9hyirjjaj31io0rck40.jpg" alt="image-20201202143101376"></p>
<ol>
<li>&#x3D;&#x3D;txBroadcastLoop&#x3D;&#x3D;:广播新出现的交易对象。<code>txBroadcastLoop()</code>会在<code>txCh</code>通道的收端持续等待，一旦接收到有关新交易的事件，会立即调用<code>BroadcastTx()</code>函数广播给那些尚无该交易对象的相邻个体。</li>
<li>&#x3D;&#x3D;minedBroadcastLoop&#x3D;&#x3D;:广播新挖掘出的区块。<code>minedBroadcastLoop()</code>持续等待本节点的新挖掘出区块事件，然后立即广播给需要的相邻个体。当不再订阅新挖掘区块事件时，这个函数才会结束等待并返回。</li>
<li>&#x3D;&#x3D;syncer&#x3D;&#x3D;:<strong>定时的和网络其他节点同步，并处理网络节点的相关通知</strong>。定时与相邻个体进行区块全链的强制同步。syncer()首先启动fetcher成员，然后进入一个无限循环，每次循环中都会向相邻peer列表中“最优”的那个peer作一次区块全链同步。发起上述同步的理由分两种：如果有新登记(加入)的相邻个体，则在整个peer列表数目大于5时，发起之；如果没有新peer到达，则以10s为间隔定时的发起之。这里所谓”最优”指的是peer中所维护区块链的TotalDifficulty(td)最高，由于Td是全链中从创世块到最新头块的Difficulty值总和，所以Td值最高就意味着它的区块链是最新的，跟这样的peer作区块全链同步，显然改动量是最小的，此即”最优”。</li>
<li>&#x3D;&#x3D;txsyncLoop&#x3D;&#x3D;：<strong>把新的交易均匀的同步给网路节点</strong>。</li>
</ol>
<hr>
<h2 id="广播的情形"><a href="#广播的情形" class="headerlink" title="广播的情形"></a>广播的情形</h2><ol>
<li><code>minedBroadcastLoop()</code>监听到新区块事件后，把新区块和区块<code>hash</code>分别广播出去；</li>
<li>从远程节点同步完成后，将<code>CurrentBlock</code>广播出去，此时广播的是区块<code>hash</code>；</li>
<li><code>txBlockcastLoop()</code>监听到区块池的新增交易事件时会广播交易；</li>
</ol>
<hr>
<h2 id="广播区块及区块哈希"><a href="#广播区块及区块哈希" class="headerlink" title="广播区块及区块哈希"></a>广播区块及区块哈希</h2><p>广播区块的入口在<code>pm.minedBroadcastLoop()</code>,进入到<code>BroadcastBlock</code>,这里的参数为<code>bool</code>值，如果传入的为true，则将区块block和总难度td发送给一部分节点，节点数为根号n；如果传入的为false，则将区块的hash发送给所有的节点。<strong>需要注意的是两个广播函数都执行</strong>。</p>
<p>进入到<code>true</code>分支：<strong>代表只传播区块给一部分节点</strong></p>
<p>①：首先计算一个临时的TD</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">			td = <span class="built_in">new</span>(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>))</span><br><span class="line">		&#125; </span><br></pre></td></tr></table></figure>

<p>②：发送块到peers的子集</p>
<p>对节点数进行开方，16开方得4，然后取前4个节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transferLen := <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(<span class="built_in">len</span>(peers))))</span><br><span class="line">		<span class="keyword">if</span> transferLen &lt; minBroadcastPeers &#123;</span><br><span class="line">			transferLen = minBroadcastPeers</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> transferLen &gt; <span class="built_in">len</span>(peers) &#123;</span><br><span class="line">			transferLen = <span class="built_in">len</span>(peers)</span><br><span class="line">		&#125;</span><br><span class="line">		transfer := peers[:transferLen]</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">			peer.AsyncSendNewBlock(block, td) <span class="comment">// 块传播</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>执行完之后直接return出去，再次执行此函数，此时不会走ture分支，直接判断判断本地是否有区块，如果有则发送区区块哈希给剩下的节点，如果没有，则不做发送哈希的操作。</p>
<blockquote>
<p>如果本地存在这个要广播的区块(很可能就是出块节点，或者接受块的节点已经插入到区块链中),那就还要像其他没有被广播到区块的节点发送区块哈希。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fp0u7e3j31bw0hkthh.jpg" alt="image-20201125150810051"></p>
<blockquote>
<p>如果本地不存在这个要广播的区块哈希(应该是还没接收到区块或者区块哈希的节点)，那它只要向它的节点列表里发送区块即可。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1fwwxfh2j31bi0e4tfv.jpg" alt="image-20201125151546035"></p>
<hr>
<p>接下来就是重点分析<code>AsyncSendNewBlock</code>和<code>AsyncSendNewBlockHash</code>两个函数了。</p>
<h3 id="AsyncSendNewBlock"><a href="#AsyncSendNewBlock" class="headerlink" title="AsyncSendNewBlock"></a>AsyncSendNewBlock</h3><blockquote>
<p>发送块到需要广播的节点的广播队列中</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.queuedProps &lt;- &amp;propEvent&#123;block: block, td: td&#125;:</span><br><span class="line">		p.knownBlocks.Add(block.Hash())</span><br><span class="line">		<span class="keyword">for</span> p.knownBlocks.Cardinality() &gt;= maxKnownBlocks &#123;</span><br><span class="line">			p.knownBlocks.Pop()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>queuedProps</code>是用来存放要广播的块的队列，同时，要把广播的块标记为已知，还不能超过1024（<strong>maxKnownBlocks</strong>）个。超过就会弹出队列第一个<code>propEvent()</code> 。接下来就是处理队列中的块了。</p>
<p>在<code>eth/peer.go</code>中，有个专门处理广播的循环<code>brodcast</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span></span> broadcast() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Broadcast transactions&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="built_in">len</span>(txs))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> prop := &lt;-p.queuedProps:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlock(prop.block, prop.td); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Propagated block&quot;</span>, <span class="string">&quot;number&quot;</span>, prop.block.Number(), <span class="string">&quot;hash&quot;</span>, prop.block.Hash(), <span class="string">&quot;td&quot;</span>, prop.td)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> block := &lt;-p.queuedAnns:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlockHashes([]common.Hash&#123;block.Hash()&#125;, []<span class="type">uint64</span>&#123;block.NumberU64()&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Announced block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-p.term:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>广播新块到远程节点</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.SendNewBlock(prop.block, prop.td);</span><br></pre></td></tr></table></figure>

<p>远程节点收到块后同样也会标记哈希存入队列，并且不会超过最大，同时发送一个<code>NewBlockMsg</code>，<code>msgcode</code>为<code>0x07</code>,同时数据会被RLP编码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.knownBlocks.Add(block.Hash())</span><br><span class="line">	<span class="keyword">for</span> p.knownBlocks.Cardinality() &gt;= maxKnownBlocks &#123;</span><br><span class="line">		p.knownBlocks.Pop()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p2p.Send(p.rw, NewBlockMsg, []<span class="keyword">interface</span>&#123;&#125;&#123;block, td&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Send</span><span class="params">(w MsgWriter, msgcode <span class="type">uint64</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	size, r, err := rlp.EncodeToReader(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w.WriteMsg(Msg&#123;Code: msgcode, Size: <span class="type">uint32</span>(size), Payload: r&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此广播区块的过程结束，交由远程节点去处理<code>NewBlockMsg</code>消息。</p>
<hr>
<h3 id="AsyncSendNewBlockHash"><a href="#AsyncSendNewBlockHash" class="headerlink" title="AsyncSendNewBlockHash"></a>AsyncSendNewBlockHash</h3><p>广播哈希的过程跟广播区块的过程非常的类似，最终是由远程节点去处理<code>NewBlockHashesMsg</code>消息。</p>
<p>广播区块的过程完毕之后，会直接进入下一个阶段，调用<code>fetcher</code>模块去同步这些广播的区块，接下的文章会讲到。</p>
<hr>
<h2 id="广播交易"><a href="#广播交易" class="headerlink" title="广播交易"></a>广播交易</h2><p>广播交易的入口在<code>pm.txBroadcastLoop()</code>，直接进入到<code>pm.BroadcastTxs(event.Txs)</code>，大概做了以下几件事：</p>
<p>①：将交易广播给一批没有这个交易的节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">		peers := pm.peers.PeersWithoutTx(tx.Hash())</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">			txset[peer] = <span class="built_in">append</span>(txset[peer], tx)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">&quot;Broadcast transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.Hash(), <span class="string">&quot;recipients&quot;</span>, <span class="built_in">len</span>(peers))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：异步发送交易给这些节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> peer, txs := <span class="keyword">range</span> txset &#123;</span><br><span class="line">		peer.AsyncSendTransactions(txs)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入到<code>AsyncSendTransactions</code>:</p>
<p>将所有交易标记为已知交易，同时还要保证没有超过最大的已知交易（32768笔）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> p.queuedTxs &lt;- txs:</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">			p.knownTxs.Add(tx.Hash())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> p.knownTxs.Cardinality() &gt;= maxKnownTxs &#123;</span><br><span class="line">			p.knownTxs.Pop()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">		<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span></span> SendTransactions(txs types.Transactions) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> p2p.Send(p.rw, TxMsg, txs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送交易最终会发送一个<code>TxMsg</code>消息，接收到这个消息的节点会通过<code>pm.txpool.AddRemotes(txs)</code>处理交易。</p>
<hr>
<h2 id="消息处理（handleMsg）"><a href="#消息处理（handleMsg）" class="headerlink" title="消息处理（handleMsg）"></a>消息处理（handleMsg）</h2><p><code>handleMsg</code>从对方连接中读取消息，根据消息码的不同进行处理,从而将广播和同步之间来回的消息进行处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span></span> handleMsg(p *peer) <span class="type">error</span> &#123;</span><br><span class="line">    msg, err := p.rw.ReadMsg()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> msg.Size &gt; ProtocolMaxMsgSize &#123;</span><br><span class="line">        <span class="keyword">return</span> errResp(ErrMsgTooLarge, <span class="string">&quot;%v &gt; %v&quot;</span>, msg.Size, ProtocolMaxMsgSize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> msg.Discard()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg.Code == StatusMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == GetBlockHeadersMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == BlockHeadersMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == GetBlockBodiesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == BlockBodiesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == GetNodeDataMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == NodeDataMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == GetReceiptsMsg: ......</span><br><span class="line">    <span class="keyword">case</span> p.version &gt;= eth63 &amp;&amp; msg.Code == ReceiptsMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == NewBlockHashesMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == NewBlockMsg: ......</span><br><span class="line">    <span class="keyword">case</span> msg.Code == TxMsg: ......</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> errResp(ErrInvalidMsgCode, <span class="string">&quot;%v&quot;</span>, msg.Code)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a> 最新发布</p>
<p><a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a>  资料更新</p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕以太坊源码分析之区块上链入库</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8C%BA%E5%9D%97%E4%B8%8A%E9%93%BE%E5%85%A5%E5%BA%93-10/</url>
    <content><![CDATA[<blockquote>
<p>死磕以太坊源码分析之区块上链入库</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>不管是矿工挖矿还是<code>Fetcher</code>同步，<code>Downloader</code>同步，或者是导入本地文件等等，最中都是将区块上链入库。接下来我们就详细分析这部分的动作。</p>
<h2 id="几处可能调用的地方"><a href="#几处可能调用的地方" class="headerlink" title="几处可能调用的地方"></a>几处可能调用的地方</h2><p>①：在Downloader同步最后会将区块插入到区块链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> importBlockResults(results []*fetchResult) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> index, err := d.blockchain.InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②：创建一个新的以太坊协议管理器，也会将区块插入到链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProtocolManager</span><span class="params">(...)</span></span> (*ProtocolManager, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  n, err := manager.blockchain.InsertChain(blocks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③：插入侧链数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertSideChain(block *types.Block, it *insertIterator) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> _, err := bc.insertChain(blocks, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④：从本地文件导入链</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateAdminAPI)</span></span> ImportChain(file <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> _, err := api.eth.BlockChain().InsertChain(blocks); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤：fetcher同步导入块</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span></span> insert(peer <span class="type">string</span>, block *types.Block) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是比较常见的需要将区块上链的动作。调用的核心方法就是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> insertChain(chain types.Blocks, verifySeals <span class="type">bool</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>获取区块链所有相关文章以及资料，请参阅：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
</blockquote>
<h2 id="插入数据到blockchain中"><a href="#插入数据到blockchain中" class="headerlink" title="插入数据到blockchain中"></a>插入数据到blockchain中</h2><p>①：如果链正在中断，直接返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;bc.procInterrupt) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：开启并行的签名恢复</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">senderCacher.recoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[<span class="number">0</span>].Number()), chain)</span><br></pre></td></tr></table></figure>

<p>③：开启并行校验header</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">abort, results := bc.engine.VerifyHeaders(bc, headers, seals)</span><br></pre></td></tr></table></figure>

<p>校验<code>header</code>是共识引擎所要做的事情，我们这里只分析<code>ethash</code>它的实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> VerifyHeaders(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>) (<span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">  errors[index] = ethash.verifyHeaderWorker(chain, headers, seals, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> verifyHeaderWorker(chain consensus.ChainReader, headers []*types.Header, seals []<span class="type">bool</span>, index <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> parent *types.Header</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">		parent = chain.GetHeader(headers[<span class="number">0</span>].ParentHash, headers[<span class="number">0</span>].Number.Uint64()<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> headers[index<span class="number">-1</span>].Hash() == headers[index].ParentHash &#123;</span><br><span class="line">		parent = headers[index<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chain.GetHeader(headers[index].Hash(), headers[index].Number.Uint64()) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// known block</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ethash.verifyHeader(chain, headers[index], parent, <span class="literal">false</span>, seals[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用<code>verifyHeaderWorker</code>进行校验，主要检验块的祖先是否已知以及块是否已知，接着会调用<code>verifyHeader</code>进行更深的校验，也是最核心的校验，大概做了以下几件事：</p>
<ol>
<li>header.Extra<em>不可超过32字节</em></li>
<li>header.Time<em>不能超过15秒，15秒以后的就被认定为未来的块</em></li>
<li><em>当前header的时间戳不可以等于父块的时间戳</em></li>
<li><em>根据难度计算算法得出的expected必须和header.Difficulty 一致。</em></li>
<li><em>Gas limit 要 &lt;&#x3D; 2 ^ 63-1</em></li>
<li><em>gasUsed&lt;&#x3D; gasLimit</em></li>
<li><em>Gas limit 要在允许范围内</em></li>
<li><em>块号必须是父块加1</em></li>
<li><em>根据 ethash.VerifySeal去验证块是否满足POW难度要求</em></li>
</ol>
<p>到此验证header的事情就做完了。</p>
<p>④：循环校验body</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">block, err := it.next()</span><br><span class="line">	-&gt; ValidateBody</span><br><span class="line">		-&gt; VerifyUncles</span><br></pre></td></tr></table></figure>

<p>包括以下错误：</p>
<ul>
<li><strong>block</strong>已知</li>
<li><strong>uncle</strong>太多</li>
<li>重复的<strong>uncle</strong></li>
<li><strong>uncle</strong>是祖先块</li>
<li><strong>uncle</strong>哈希不匹配</li>
<li>交易哈希不匹配</li>
<li>未知祖先</li>
<li>祖先块的状态无法获取</li>
</ul>
<p>4.1 如果<code>block</code>存在，且是已知块，则写入已知块。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.writeKnownBlock(block)</span><br></pre></td></tr></table></figure>

<p>4.2 如果是祖先块的状态无法获取的错误，则作为侧链插入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.insertSideChain(block, it)</span><br></pre></td></tr></table></figure>

<p>4.3 如果是未来块或者未知祖先，则添加未来块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.addFutureBlock(block);</span><br></pre></td></tr></table></figure>

<p>注意这里的添加 futureBlock，会被扔进futureBlocks里面去，在NewBlockChain的时候会开启新的goroutine:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> bc.update()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> update() &#123;</span><br><span class="line">  futureTimer := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-futureTimer.C:</span><br><span class="line">			bc.procFutureBlocks()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> procFutureBlocks() &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">for</span> _, hash := <span class="keyword">range</span> bc.futureBlocks.Keys() &#123;</span><br><span class="line">		<span class="keyword">if</span> block, exist := bc.futureBlocks.Peek(hash); exist &#123;</span><br><span class="line">			blocks = <span class="built_in">append</span>(blocks, block.(*types.Block))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">			bc.InsertChain(blocks[i : i+<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会开启一个计时器，每5秒就会去执行插入这些未来的块。</p>
<p>4.4 如果是其他错误，直接中断，并且报告坏块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.futureBlocks.Remove(block.Hash())</span><br><span class="line">...</span><br><span class="line">bc.reportBlock(block, <span class="literal">nil</span>, err)</span><br></pre></td></tr></table></figure>

<p>⑤：没有校验错误</p>
<p>5.1 如果是坏块，则报告；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> BadHashes[block.Hash()] &#123;</span><br><span class="line">			bc.reportBlock(block, <span class="literal">nil</span>, ErrBlacklistedHash)</span><br><span class="line">			<span class="keyword">return</span> it.index, ErrBlacklistedHash</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.2 如果是未知块，则写入未知块；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrKnownBlock &#123;</span><br><span class="line">			logger := log.Debug</span><br><span class="line">			<span class="keyword">if</span> bc.chainConfig.Clique == <span class="literal">nil</span> &#123;</span><br><span class="line">				logger = log.Warn</span><br><span class="line">			&#125;</span><br><span class="line">		...</span><br><span class="line">			<span class="keyword">if</span> err := bc.writeKnownBlock(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> it.index, err</span><br><span class="line">			&#125;</span><br><span class="line">			stats.processed++</span><br><span class="line">			lastCanon = block</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>5.3 根据给定trie，创建状态；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">parent := it.previous()</span><br><span class="line">		<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">			parent = bc.GetHeader(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		statedb, err := state.New(parent.Root, bc.stateCache)</span><br></pre></td></tr></table></figure>

<p>5.4执行块中的交易： (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>5.5 使用默认的validator校验状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.validator.ValidateState(block, statedb, receipts, usedGas);</span><br></pre></td></tr></table></figure>

<p>5.6 将块写入到区块链中并获取状态：  (<strong>稍后会在下节对此进行详细分析</strong>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">status, err := bc.writeBlockWithState(block, receipts, logs, statedb, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：校验写入区块的状态</p>
<ul>
<li><code>CanonStatTy</code> ： 插入成功新的block</li>
<li><code>SideStatTy</code>：插入成功新的分叉区块</li>
<li><code>Default</code>：插入未知状态的block</li>
</ul>
<p>⑦：如果还有块，并且是未来块的话，那么将块添加到未来块的缓存中去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.addFutureBlock(block)</span><br></pre></td></tr></table></figure>

<p>至此<code>insertChain</code> 大概介绍清楚。</p>
<hr>
<h3 id="执行块中交易"><a href="#执行块中交易" class="headerlink" title="执行块中交易"></a>执行块中交易</h3><p>在我们将区块上链，有一个关键步骤就是执行区块交易：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)</span><br></pre></td></tr></table></figure>

<p>进入函数，具体分析：</p>
<p>①：准备要用的字段，循环执行交易</p>
<p>关键函数：<code>ApplyTransaction</code>,根据此函数返回收据。</p>
<p>1.1 将交易结构转成<code>Message</code>结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg, err := tx.AsMessage(types.MakeSigner(config, header.Number))</span><br></pre></td></tr></table></figure>

<p>1.2 创建要在EVM环境中使用的新上下文</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">context := NewEVMContext(msg, header, bc, author)</span><br></pre></td></tr></table></figure>

<p>1.3 创建一个新环境，其中包含有关事务和调用机制的所有相关信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">vmenv := vm.NewEVM(context, statedb, config, cfg)</span><br></pre></td></tr></table></figure>

<p>1.4 将交易应用到当前状态(包含在env中)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, gas, failed, err := ApplyMessage(vmenv, msg, gp)</span><br></pre></td></tr></table></figure>

<p>这部分代码继续跟进：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApplyMessage</span><span class="params">(evm *vm.EVM, msg Message, gp *GasPool)</span></span> ([]<span class="type">byte</span>, <span class="type">uint64</span>, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> NewStateTransition(evm, msg, gp).TransitionDb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewStateTransition</code> 是一个状态转换对象，<code>TransitionDb()</code> 负责转换交易状态，继续跟进：<br>先进行<code>preCheck</code>，用来校验<code>nonce</code>是否正确</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.preCheck()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> st.msg.CheckNonce() &#123;</span><br><span class="line">		nonce := st.state.GetNonce(st.msg.From())</span><br><span class="line">		<span class="keyword">if</span> nonce &lt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooHigh</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nonce &gt; st.msg.Nonce() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrNonceTooLow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>计算所需<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gas, err := IntrinsicGas(st.data, contractCreation, homestead, istanbul)</span><br></pre></td></tr></table></figure>

<p>扣除<code>gas</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err = st.useGas(gas); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span></span> useGas(amount <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> st.gas &lt; amount &#123;</span><br><span class="line">		<span class="keyword">return</span> vm.ErrOutOfGas</span><br><span class="line">	&#125;</span><br><span class="line">	st.gas -= amount</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是合约交易,则新建一个合约</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>如果不是合约交易，则增加<code>nonce</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br></pre></td></tr></table></figure>

<p>重点关注<code>evm.call</code>方法：</p>
<p><em>检查账户是否有足够的气体进行转账</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果stateDb不存在此账户，则新建账户</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">  evm.StateDB.CreateAccount(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>执行转账操作</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br></pre></td></tr></table></figure>

<p><em>创建合约</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contract := NewContract(caller, to, value, gas)</span><br></pre></td></tr></table></figure>

<p><em>执行合约</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ret, err = run(evm, contract, input, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>添加余额</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">st.state.AddBalance(st.evm.Coinbase, <span class="built_in">new</span>(big.Int).Mul(<span class="built_in">new</span>(big.Int).SetUint64(st.gasUsed()), st.gasPrice))</span><br></pre></td></tr></table></figure>

<p>回到<code>ApplyTransaction</code></p>
<p>1.5 调用<code>IntermediateRoot</code>计算状态<code>trie</code>的当前根哈希值。</p>
<p>最终确定所有肮脏的存储状态，并把它们写进<code>trie</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.Finalise(deleteEmptyObjects)</span><br></pre></td></tr></table></figure>

<p>将trie根设置为当前的根哈希并将给定的<code>object</code>写入到<code>trie</code>中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj.updateRoot(s.db)</span><br><span class="line">s.updateStateObject(obj)</span><br></pre></td></tr></table></figure>

<p>1.6 创建收据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receipt := types.NewReceipt(root, failed, *usedGas)</span><br><span class="line">	receipt.TxHash = tx.Hash()</span><br><span class="line">	receipt.GasUsed = gas</span><br><span class="line">	<span class="keyword">if</span> msg.To() == <span class="literal">nil</span> &#123;</span><br><span class="line">		receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Set the receipt logs and create a bloom for filtering</span></span><br><span class="line">	receipt.Logs = statedb.GetLogs(tx.Hash())</span><br><span class="line">	receipt.Bloom = types.CreateBloom(types.Receipts&#123;receipt&#125;)</span><br><span class="line">	receipt.BlockHash = statedb.BlockHash()</span><br><span class="line">	receipt.BlockNumber = header.Number</span><br><span class="line">	receipt.TransactionIndex = <span class="type">uint</span>(statedb.TxIndex())</span><br></pre></td></tr></table></figure>

<p>②：最后完成区块，应用任何共识引擎特定的额外功能(例如区块奖励)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p.engine.Finalize(p.bc, header, statedb, block.Transactions(), block.Uncles())</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ethash *Ethash)</span></span> Finalize(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header) &#123;</span><br><span class="line">	<span class="comment">// Accumulate any block and uncle rewards and commit the final state root</span></span><br><span class="line">	<span class="comment">//累积任何块和叔叔的奖励并提交最终状态树根</span></span><br><span class="line">	accumulateRewards(chain.Config(), state, header, uncles)</span><br><span class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止<code>bc.processor.Process</code>执行完毕，返回<code>receipts</code>.</p>
<hr>
<h3 id="校验状态"><a href="#校验状态" class="headerlink" title="校验状态"></a>校验状态</h3><p>大致包括4部分的校验：</p>
<p>①：校验使用的<code>gas</code>是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> block.GasUsed() != usedGas &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid gas used (remote: %d local: %d)&quot;</span>, block.GasUsed(), usedGas)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>②：校验bloom是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rbloom := types.CreateBloom(receipts)</span><br><span class="line">	<span class="keyword">if</span> rbloom != header.Bloom &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid bloom (remote: %x  local: %x)&quot;</span>, header.Bloom, rbloom)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>③：校验收据哈希是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line">	<span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>, header.ReceiptHash, receiptSha)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>④：校验merkleroot 是否相等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root := statedb.IntermediateRoot(v.config.IsEIP158(header.Number)); header.Root != root &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid merkle root (remote: %x local: %x)&quot;</span>, header.Root, root)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将块和关联状态写入到数据库"><a href="#将块和关联状态写入到数据库" class="headerlink" title="将块和关联状态写入到数据库"></a>将块和关联状态写入到数据库</h3><p>函数：<strong>WriteBlockWithState</strong></p>
<p>①：计算块的<code>total td</code> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptd := bc.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>②：添加待插入块本身的<code>td</code> ,并将此时最新的<code>total td</code> 存储到数据库中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bc.hc.WriteTd(block.Hash(), block.NumberU64(), externTd)</span><br></pre></td></tr></table></figure>

<p>③：将块的<code>header</code>和<code>body</code>分别序列化到数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rawdb.WriteBlock(bc.db, block)</span><br><span class="line">	-&gt;WriteBody(db, block.Hash(), block.NumberU64(), block.Body())</span><br><span class="line">	-&gt;WriteHeader(db, block.Header())</span><br></pre></td></tr></table></figure>

<p>④：将状态写入底层内存<code>Trie</code>数据库</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">state.Commit(bc.chainConfig.IsEIP158(block.Number()))</span><br></pre></td></tr></table></figure>

<p>⑤：遍历节点数据写入到磁盘</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">triedb.Commit(header.Root, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>⑥：存储一个块的所有交易数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rawdb.WriteReceipts(batch, block.Hash(), block.NumberU64(), receipts)</span><br></pre></td></tr></table></figure>

<p>⑦：将新的<code>head</code>块注入到当前链中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.insert(block)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储分配给规范块的哈希</li>
<li>存储头块的哈希</li>
<li>存储最新的快</li>
<li>更新<code>currentFastBlock</code></li>
</ul>
<p>⑧：发送<code>chainEvent</code>事件或者<code>ChainSideEvent</code>事件或者<code>ChainHeadEvent</code>事件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> status == CanonStatTy &#123;</span><br><span class="line">		bc.chainFeed.Send(ChainEvent&#123;Block: block, Hash: block.Hash(), Logs: logs&#125;)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(logs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			bc.logsFeed.Send(logs)</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">if</span> emitHeadEvent &#123;</span><br><span class="line">			bc.chainHeadFeed.Send(ChainHeadEvent&#123;Block: block&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bc.chainSideFeed.Send(ChainSideEvent&#123;Block: block&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到此writeBlockWithState 结束，从上面可以知道，insertChain的最终还是调用了<code>writeBlockWithState</code>的insert方法完成了最终的上链入库动作。</p>
<p>最后整个<code>insertChain</code> <em>函数，如果已经完成了插入，就发送<code>chain head</code>事件</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lastCanon != <span class="literal">nil</span> &amp;&amp; bc.CurrentBlock().Hash() == lastCanon.Hash() &#123;</span><br><span class="line">		bc.chainHeadFeed.Send(ChainHeadEvent&#123;lastCanon&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>比较常见的有这么几处会进行订阅<code>chain head</code> 事件：</p>
<ol>
<li><p>在tx_pool.go中，收到此事件会进行换head的操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在worker.go中,其他节点的矿工收到此事件就会停止当前的挖矿，继续下一个挖矿任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">worker.chainHeadSub = eth.BlockChain().SubscribeChainHeadEvent(worker.chainHeadCh)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>到此整个区块上链入库就完成了，最后再送上一张总结的图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glyqxrr9p0j31530u0jz0.jpg" alt="image-20201224104046731"></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://mindcarver.cn/">https://mindcarver.cn</a></p>
<p><a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|DPOS(委托股权证明)算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_EOS_DPOS_BFT%E7%AE%97%E6%B3%95-5/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|DPOS(委托股权证明)算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna2p4ti6pj31c00u0ahv.jpg" alt="src=http___img.pconline.com.cn_images_upload_upc_tx_wallpaper_1207_09_c2_12276725_1341818508711.jpg&amp;refer=http___img.pconline.com"></p>
<h1 id="DPOS详解"><a href="#DPOS详解" class="headerlink" title="DPOS详解"></a>DPOS详解</h1><p>DPoS共识算法就是将PoS共识算法中的记账者转换为指定节点数组成的小圈子，而不是所有人都可以参与记账，这个圈子可能是21个节点，也有可能是101个节点，只有圈子内的节点才能获得记账权。这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。</p>
<p>DPOS的股东选举机制：</p>
<ul>
<li>DPoS机制中的股民（节点）根据自己持有的加密货币数量占总量的百分比（占股比例）来投票，不是一人一票；</li>
<li>选举出的股东代表（可信节点）完全对等，可理解为具有同等算力的101个矿池；</li>
<li>股东代表一旦无能、不作为、胡作为（提供的算力不稳定，计算机宕机、或者试图利用手中的权力作恶），将立刻被股民踢出整个系统，然后由其他后备代表顶上去；</li>
<li>决策完公司大事（记完账、出完块）有钱分，根据占股比例。</li>
</ul>
<h1 id="DPOS算法分析"><a href="#DPOS算法分析" class="headerlink" title="DPOS算法分析"></a>DPOS算法分析</h1><p>在DPoS共识算法中，区块链的正常运转依赖于见证人(Delegates)，见证人是由全网节点投票产生的，见证人也是记账节点的实际控制人，相当于咱们选课代表，课代表帮我们整理作业</p>
<p>见证人在完成打包交易的同时可以领取区块奖励和交易的手续费，并且可以执行社区投票的提案，所以DPoS共识算法不仅仅是算法，而是一个包含了协作治理关系的共识机制。</p>
<p>DPoS为了尽快确定交易顺序，过滤无效交易，所以规定了在正常情况下，所有记账节点轮流每3秒产生一个区块，轮到了某个记账节点出块时，必须在2秒内提交区块，否则就会错块。</p>
<p>假设一直没有记账节点错过自己顺序，那么他们生产的链条势必是最长的链条，如果记账节点在非指定时间生产区块被认为是无效的，每经过一轮，所有节点轮流出块的顺序就会发生重新洗牌。</p>
<p>下图就是一个理想的轮流记账状态：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnade58srjj316o05yju3.jpg" alt="image-20210203151915698"></p>
<p>DPoS算法白皮书还介绍了以下几种不正常的情况：</p>
<p>①：<strong>少数记账节点发起恶意分叉或者发生故障</strong></p>
<p>可以允许最多1&#x2F;3的节点是恶意或故障，从而导致出现分叉。在这种情形下，少数分支将只能在9秒内生产1个块，而大多数分支，由于数量多一倍，将预期能在9秒内生产2个块。再一次，诚实的2&#x2F;3的大多数可以比小的那一部分创建一个更长的链条。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadefucijj317u076tb7.jpg" alt="image-20210203151934597"></p>
<p>②：<strong>隔离环境下的重复块生产</strong></p>
<p>少数群体可能尝试创建一个无限数量的分叉，但所有分支都将比主链短，因为少数群体在链的成长上更慢。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadihh19bj316a096mxr.jpg" alt="image-20210203152323992"></p>
<p>③：<strong>网络碎片</strong></p>
<p>网络非常有可能碎片到，没有哪一个链上的区块生产者占到了所有区块生产者中的大多数。在此情景下，最长的那个链将变成最大的一个少数群体。当网络连接恢复正常后，相对较小的那些群体将自然的切换到最长的链，从而将恢复明确的共识。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadj14g6vj31600a0tc7.jpg" alt="image-20210203152359294"></p>
<p>还有一种非常可能的情况是，三个分支中，最大的两个分支一样大。此时，将由相对更小的第三个分支加入网络时来打破僵局。存在奇数个区块生产者，所以僵局一般不会持续很久。后面我们还将介绍区块生产者的清洗，会将生产者随机生成顺序，以确保即使两个分支具有相同数量的生产者，分支也将以不同的长度爆发增长，导致一个分支最终接管另一个分支。</p>
<p>④：<strong>少数群体重复生产</strong></p>
<p>在这种情景下，少数群体B在自己可以生产的时间节点，同时创建两条，或多条的区块链。下一个执行的生产者C，将选择B创建的可选链中的任一条。C选中的这条链将成为最长的链，当这发生是，所以如下图所示的B1链条上的结点都会转过来。所以，无论少数做恶结点制造多少的链，他们在下一轮中，肯定不会是最长的那个链。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadjozhpyj314y07ggo9.jpg" alt="image-20210203152437439"></p>
<p>⑤：<strong>最后的不可逆区块</strong></p>
<p>在网络碎片的情况下，多个分叉可能持续较长时间的隔离。长远来看，最长的链将最终受到认可。但观察者需要一种手段来确定某个块是否是在最长链条的一部分（确认共识）。这可以通过2&#x2F;3 + 1个区块生产者是否对某个块有确认。</p>
<p>下图中，块B被A、C确认了，这意味着2&#x2F;3 + 1都已经确认了。由此我们可以为不可能存在更长的链了，因为2&#x2F;3的区块链是诚实。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadk4gx1dj314y07amyy.jpg" alt="image-20210203152502221"></p>
<p>需要注意的是这个规则与比特币的6个区块确认类似。一些聪明的人可以设计一系列事件，其中两个节点可能会在不同的最后不可逆块上结束。这种极端情况需要一个攻击者，精确控制通信延迟，并需要在几分钟内实施不止一次，而是二次攻击。如果发生这种情况，那么最长链条这一长期规则仍然适用。 我们估计这种攻击的可能性足够接近0，经济后果也微不足道，不值得担心。</p>
<p>⑥：<strong>不足法定区块生产者</strong></p>
<p>在一些不太可能的情况下，生产者没有明确达到法定人数，少数人可能继续生产块。在继续生产的区块中，利益相关者可以包含一些改变投票的交易。这些投票会选举一组新的区块生产者，并将区块生产参与度恢复到100%。一旦发生这种情况，少数人链最终会超过其它低于100%参与链。</p>
<p>在这个流程发生时，所有的观察者必须要明白整个网络处于不稳定的状态，直到多于67%参与者出现后才会稳定下来。哪些选择在这种情景下发起交易的，与那些在比特币中接受低于6块就确认交易成功那样，冒着类似的风险。他们必须明白，存在某些情况下，共识最终会以另一个链为准。在实践中，这种情形比在比特币中接受少于3个块就确认更加安全。</p>
<p>⑦：<strong>大多数据区块生产者的腐败</strong></p>
<p>如果大多数区块生产者合谋变得腐败，他们制造无限数量的分支，每一个分支都有多于2&#x2F;3的大多数的签名。在这样的场景早，最后不可逆转块算法退化为最长链算法。此时最长的，获得了最大的群体认证的，将由少数的诚实节点的加入来确定。这样的情形不会持续很久，因为利益相关者会最终投票替换掉这些区块生产者。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadl0aqk8j314k08s44j.jpg" alt="image-20210203152553558"></p>
<h1 id="DPOS要解决的问题"><a href="#DPOS要解决的问题" class="headerlink" title="DPOS要解决的问题"></a>DPOS要解决的问题</h1><p>从名称上，我们也可以判断出<code>DPoS</code>与<code>PoS</code>共识是直接关联的。<code>DPoS</code>算法是BM根据当时PoW、PoS的不足而改进的共识算法，它的目的就是为了提高性能，也就是交易确认时间短。</p>
<p>在<code>PoS</code>共识中，人们使用财产证明来“挖矿”，也就是说，这是任何人都可以参与的，只要你持有币，你就可以参与挖矿。但是<code>PoS</code>并没有解决性能问题，在这里我们直接认为提高性能就是提高<code>TPS</code>，如下：</p>
<blockquote>
<p>　　　　<strong>TPS &#x3D; transactions &#x2F; block_time</strong></p>
</blockquote>
<p>TPS表示区块链每秒能确认的交易数， <code>transactions</code> 是由区块大小<code>block_size</code>和平均每笔交易大小决定的，而区块大小受全网网络状态<code>network_bandwidth</code> 限制，也是由记账节点之间物理带宽<code>witness_performance</code>决定的。</p>
<p>记账节点的个数<code>witness_count</code>直接决定了物理带宽的上限，因为记账节点数量越多，则对物理带宽要求越高，对网络的稳定性要求也越高。</p>
<p>要注意的一点是在<code>DPoS</code>中，记账节点不叫做矿工，而是改称为见证人，<code>Witness</code>。所以这个公式变成了下面的样子：</p>
<blockquote>
<p>TPS &#x3D; (block_size_network_bandwidth witness_performance)&#x2F;(block_time * witness_count)</p>
</blockquote>
<p>我们可以看到，要提高TPS，可以增大区块大小<code>block_size</code>、提升记账节点网络带宽<code>network_bandwidth</code>、提升记账节点处理性能witness_performance，减小区块时间<code>block_time</code>、减小记账节点数量<code>witness_count</code>。</p>
<p>分子项我们可以看到，它基本受限于物理资源的上限，目前工业水平制造的物理资源的使用上限基本就是整个项的上限了，所以可操作性不大。</p>
<p>而分母项是由共识算法决定的，所以我们从区块时间，以及记账节点数入手，DPoS算法便正是从这两项着手的。</p>
<p>首先改动的便是限制记账节点的数量，也就是见证人的数量。</p>
<p>我们在PoW和PoS中可以看到，成为记账节点是无需门槛的，你可以随时参与挖矿，随时退出。</p>
<p>那这会带来什么问题呢，首先无法确定记账节点的数量，其次无法确定记账节点之间的网络环境，记账节点数越多网络环境越复杂，这些不确定性会增大网络分区的概率，从而导致区块链分叉。</p>
<p>如果我们事先规定好记账节点的数量，接着让全网所有节点可以投票决定哪些节点可以成为记账节点，这样就限制并减小了分母项<code>witness_count</code>，这个过程我们也称作投票选举。</p>
<p>因为记账节点数量不多，那么我们可以在共识算法中可以<strong>规定出块时间</strong>为一个固定值，这个值可以很小，通过轮流出块的方式来进行记账。</p>
<p>以上思路基本就是DPoS的基本设计思路，BM还为DPoS算法确立两个原则：</p>
<ul>
<li>投票选举过程一定要保证最大权益所有者最终能控制全网，因为一旦出了问题，他们的损失最大；</li>
<li>与PoW、PoS一样，所有节点仅承认“最长”链。</li>
</ul>
<p>这两个原则确立了DPoS共识的基本特性，第一条放大了PoS共识使用者就是记账者的优点，第二点则规定了分叉时系统应该表现的行为。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/proof-of-stake-faqs">https://eth.wiki/en/concepts/proof-of-stake-faqs</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>DPOS</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|DPOS(委托股权证明)算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_DPOS%E7%AE%97%E6%B3%95-4/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|DPOS(委托股权证明)算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna2p4ti6pj31c00u0ahv.jpg" alt="src=http___img.pconline.com.cn_images_upload_upc_tx_wallpaper_1207_09_c2_12276725_1341818508711.jpg&amp;refer=http___img.pconline.com"></p>
<h1 id="DPOS详解"><a href="#DPOS详解" class="headerlink" title="DPOS详解"></a>DPOS详解</h1><p>DPoS共识算法就是将PoS共识算法中的记账者转换为指定节点数组成的小圈子，而不是所有人都可以参与记账，这个圈子可能是21个节点，也有可能是101个节点，只有圈子内的节点才能获得记账权。这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。</p>
<p>DPOS的股东选举机制：</p>
<ul>
<li>DPoS机制中的股民（节点）根据自己持有的加密货币数量占总量的百分比（占股比例）来投票，不是一人一票；</li>
<li>选举出的股东代表（可信节点）完全对等，可理解为具有同等算力的101个矿池；</li>
<li>股东代表一旦无能、不作为、胡作为（提供的算力不稳定，计算机宕机、或者试图利用手中的权力作恶），将立刻被股民踢出整个系统，然后由其他后备代表顶上去；</li>
<li>决策完公司大事（记完账、出完块）有钱分，根据占股比例。</li>
</ul>
<h1 id="DPOS算法分析"><a href="#DPOS算法分析" class="headerlink" title="DPOS算法分析"></a>DPOS算法分析</h1><p>在DPoS共识算法中，区块链的正常运转依赖于见证人(Delegates)，见证人是由全网节点投票产生的，见证人也是记账节点的实际控制人，相当于咱们选课代表，课代表帮我们整理作业</p>
<p>见证人在完成打包交易的同时可以领取区块奖励和交易的手续费，并且可以执行社区投票的提案，所以DPoS共识算法不仅仅是算法，而是一个包含了协作治理关系的共识机制。</p>
<p>DPoS为了尽快确定交易顺序，过滤无效交易，所以规定了在正常情况下，所有记账节点轮流每3秒产生一个区块，轮到了某个记账节点出块时，必须在2秒内提交区块，否则就会错块。</p>
<p>假设一直没有记账节点错过自己顺序，那么他们生产的链条势必是最长的链条，如果记账节点在非指定时间生产区块被认为是无效的，每经过一轮，所有节点轮流出块的顺序就会发生重新洗牌。</p>
<p>下图就是一个理想的轮流记账状态：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnade58srjj316o05yju3.jpg" alt="image-20210203151915698"></p>
<p>DPoS算法白皮书还介绍了以下几种不正常的情况：</p>
<p>①：<strong>少数记账节点发起恶意分叉或者发生故障</strong></p>
<p>可以允许最多1&#x2F;3的节点是恶意或故障，从而导致出现分叉。在这种情形下，少数分支将只能在9秒内生产1个块，而大多数分支，由于数量多一倍，将预期能在9秒内生产2个块。再一次，诚实的2&#x2F;3的大多数可以比小的那一部分创建一个更长的链条。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadefucijj317u076tb7.jpg" alt="image-20210203151934597"></p>
<p>②：<strong>隔离环境下的重复块生产</strong></p>
<p>少数群体可能尝试创建一个无限数量的分叉，但所有分支都将比主链短，因为少数群体在链的成长上更慢。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadihh19bj316a096mxr.jpg" alt="image-20210203152323992"></p>
<p>③：<strong>网络碎片</strong></p>
<p>网络非常有可能碎片到，没有哪一个链上的区块生产者占到了所有区块生产者中的大多数。在此情景下，最长的那个链将变成最大的一个少数群体。当网络连接恢复正常后，相对较小的那些群体将自然的切换到最长的链，从而将恢复明确的共识。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadj14g6vj31600a0tc7.jpg" alt="image-20210203152359294"></p>
<p>还有一种非常可能的情况是，三个分支中，最大的两个分支一样大。此时，将由相对更小的第三个分支加入网络时来打破僵局。存在奇数个区块生产者，所以僵局一般不会持续很久。后面我们还将介绍区块生产者的清洗，会将生产者随机生成顺序，以确保即使两个分支具有相同数量的生产者，分支也将以不同的长度爆发增长，导致一个分支最终接管另一个分支。</p>
<p>④：<strong>少数群体重复生产</strong></p>
<p>在这种情景下，少数群体B在自己可以生产的时间节点，同时创建两条，或多条的区块链。下一个执行的生产者C，将选择B创建的可选链中的任一条。C选中的这条链将成为最长的链，当这发生是，所以如下图所示的B1链条上的结点都会转过来。所以，无论少数做恶结点制造多少的链，他们在下一轮中，肯定不会是最长的那个链。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadjozhpyj314y07ggo9.jpg" alt="image-20210203152437439"></p>
<p>⑤：<strong>最后的不可逆区块</strong></p>
<p>在网络碎片的情况下，多个分叉可能持续较长时间的隔离。长远来看，最长的链将最终受到认可。但观察者需要一种手段来确定某个块是否是在最长链条的一部分（确认共识）。这可以通过2&#x2F;3 + 1个区块生产者是否对某个块有确认。</p>
<p>下图中，块B被A、C确认了，这意味着2&#x2F;3 + 1都已经确认了。由此我们可以为不可能存在更长的链了，因为2&#x2F;3的区块链是诚实。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadk4gx1dj314y07amyy.jpg" alt="image-20210203152502221"></p>
<p>需要注意的是这个规则与比特币的6个区块确认类似。一些聪明的人可以设计一系列事件，其中两个节点可能会在不同的最后不可逆块上结束。这种极端情况需要一个攻击者，精确控制通信延迟，并需要在几分钟内实施不止一次，而是二次攻击。如果发生这种情况，那么最长链条这一长期规则仍然适用。 我们估计这种攻击的可能性足够接近0，经济后果也微不足道，不值得担心。</p>
<p>⑥：<strong>不足法定区块生产者</strong></p>
<p>在一些不太可能的情况下，生产者没有明确达到法定人数，少数人可能继续生产块。在继续生产的区块中，利益相关者可以包含一些改变投票的交易。这些投票会选举一组新的区块生产者，并将区块生产参与度恢复到100%。一旦发生这种情况，少数人链最终会超过其它低于100%参与链。</p>
<p>在这个流程发生时，所有的观察者必须要明白整个网络处于不稳定的状态，直到多于67%参与者出现后才会稳定下来。哪些选择在这种情景下发起交易的，与那些在比特币中接受低于6块就确认交易成功那样，冒着类似的风险。他们必须明白，存在某些情况下，共识最终会以另一个链为准。在实践中，这种情形比在比特币中接受少于3个块就确认更加安全。</p>
<p>⑦：<strong>大多数据区块生产者的腐败</strong></p>
<p>如果大多数区块生产者合谋变得腐败，他们制造无限数量的分支，每一个分支都有多于2&#x2F;3的大多数的签名。在这样的场景早，最后不可逆转块算法退化为最长链算法。此时最长的，获得了最大的群体认证的，将由少数的诚实节点的加入来确定。这样的情形不会持续很久，因为利益相关者会最终投票替换掉这些区块生产者。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnadl0aqk8j314k08s44j.jpg" alt="image-20210203152553558"></p>
<h1 id="DPOS要解决的问题"><a href="#DPOS要解决的问题" class="headerlink" title="DPOS要解决的问题"></a>DPOS要解决的问题</h1><p>从名称上，我们也可以判断出<code>DPoS</code>与<code>PoS</code>共识是直接关联的。<code>DPoS</code>算法是BM根据当时PoW、PoS的不足而改进的共识算法，它的目的就是为了提高性能，也就是交易确认时间短。</p>
<p>在<code>PoS</code>共识中，人们使用财产证明来“挖矿”，也就是说，这是任何人都可以参与的，只要你持有币，你就可以参与挖矿。但是<code>PoS</code>并没有解决性能问题，在这里我们直接认为提高性能就是提高<code>TPS</code>，如下：</p>
<blockquote>
<p>　　　　<strong>TPS &#x3D; transactions &#x2F; block_time</strong></p>
</blockquote>
<p>TPS表示区块链每秒能确认的交易数， <code>transactions</code> 是由区块大小<code>block_size</code>和平均每笔交易大小决定的，而区块大小受全网网络状态<code>network_bandwidth</code> 限制，也是由记账节点之间物理带宽<code>witness_performance</code>决定的。</p>
<p>记账节点的个数<code>witness_count</code>直接决定了物理带宽的上限，因为记账节点数量越多，则对物理带宽要求越高，对网络的稳定性要求也越高。</p>
<p>要注意的一点是在<code>DPoS</code>中，记账节点不叫做矿工，而是改称为见证人，<code>Witness</code>。所以这个公式变成了下面的样子：</p>
<blockquote>
<p>TPS &#x3D; (block_size_network_bandwidth witness_performance)&#x2F;(block_time * witness_count)</p>
</blockquote>
<p>我们可以看到，要提高TPS，可以增大区块大小<code>block_size</code>、提升记账节点网络带宽<code>network_bandwidth</code>、提升记账节点处理性能witness_performance，减小区块时间<code>block_time</code>、减小记账节点数量<code>witness_count</code>。</p>
<p>分子项我们可以看到，它基本受限于物理资源的上限，目前工业水平制造的物理资源的使用上限基本就是整个项的上限了，所以可操作性不大。</p>
<p>而分母项是由共识算法决定的，所以我们从区块时间，以及记账节点数入手，DPoS算法便正是从这两项着手的。</p>
<p>首先改动的便是限制记账节点的数量，也就是见证人的数量。</p>
<p>我们在PoW和PoS中可以看到，成为记账节点是无需门槛的，你可以随时参与挖矿，随时退出。</p>
<p>那这会带来什么问题呢，首先无法确定记账节点的数量，其次无法确定记账节点之间的网络环境，记账节点数越多网络环境越复杂，这些不确定性会增大网络分区的概率，从而导致区块链分叉。</p>
<p>如果我们事先规定好记账节点的数量，接着让全网所有节点可以投票决定哪些节点可以成为记账节点，这样就限制并减小了分母项<code>witness_count</code>，这个过程我们也称作投票选举。</p>
<p>因为记账节点数量不多，那么我们可以在共识算法中可以<strong>规定出块时间</strong>为一个固定值，这个值可以很小，通过轮流出块的方式来进行记账。</p>
<p>以上思路基本就是DPoS的基本设计思路，BM还为DPoS算法确立两个原则：</p>
<ul>
<li>投票选举过程一定要保证最大权益所有者最终能控制全网，因为一旦出了问题，他们的损失最大；</li>
<li>与PoW、PoS一样，所有节点仅承认“最长”链。</li>
</ul>
<p>这两个原则确立了DPoS共识的基本特性，第一条放大了PoS共识使用者就是记账者的优点，第二点则规定了分叉时系统应该表现的行为。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/proof-of-stake-faqs">https://eth.wiki/en/concepts/proof-of-stake-faqs</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>DPOS</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|POS算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_POS%E7%AE%97%E6%B3%95-2/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|POS算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn96oqcxsyj30dw08pjs7.jpg" alt="u=2232051863,378698187&amp;fm=26&amp;gp=0"></p>
<h1 id="为什么会出现PoS"><a href="#为什么会出现PoS" class="headerlink" title="为什么会出现PoS?"></a>为什么会出现PoS?</h1><p>​    在比特币系统中采用了<code>PoW</code>(工作量证明）算法,<code>PoW</code>其实就是由所有的节点相互竞争，提交一个难于计算但是容易验证的计算结果，任何节点都可以验证这个这个结果的正确性，验证通过即算这个节点完成了大量的计算工作。</p>
<p>​    然而<code>PoW</code>机制存在明显的弊端。 一是算力不公平，矿场的竞争力比单个节点大，还有就是随着硬件的发展，特别是量子计算机的出现，可能几秒就破解了<code>Hash</code>。 二是<code>PoW</code>算法太浪费了，比特币网络每秒可完成数百万亿次<code>SHA256</code>计算， 但这些计算除了使恶意攻击者不能轻易地伪装成几百万个节点和打垮比特币网络，并没有更多实际或科学价值。</p>
<p>​    鉴于以上问题，POS<code>股权证明</code>诞生了。</p>
<h1 id="PoS股权证明"><a href="#PoS股权证明" class="headerlink" title="PoS股权证明"></a>PoS股权证明</h1><p>​    权益证明（ Proof of Stake，PoS） ，最早在 2013 年被提出，最早在 <code>Peercoin</code> 系统中被实现，类似现实生活中的股东机制，拥有股份越多的人越容易获取记账权（ 同时越倾向于维护网络的正常工作） 。</p>
<p>​    典型的过程是通过保证金（ <strong>代币、资产、名声等具备价值属性的物品</strong>） 来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费。提供证明的保证金（ 例如通过转账货币记录） 越多，则获得记账权的概率就越大。合法记账者可以获得收益。</p>
<p>​    恶意参与者将存在<strong>保证金</strong>被罚没的风险，即损失经济利益。一般的，对于 PoS 来说，需要掌握超过全网 <strong>1&#x2F;3</strong> 的资源，才有可能左右最终的结果。这个也很容易理解，三个人投票，前两人分别支持一方，这时候，第三方的投票将决定最终结果。</p>
<p>​    在股权证明模式下， 有一个名词叫<strong>币龄</strong>， 每个币每天产生1币龄， 例如，你持有 100 个币， 总共持有了 30 天， 那么， 此时你的币龄就为 3000， 这个时候， 如果你发现了一个<code>PoS</code>区块， 你的币龄就会被清空为 0。 你每被清空 365币龄， 你将会从区块中获得0.05个币的利息（ 可以理解为年利率5%） ， 那么在这个案例中， 利息<code>=3000×5%/365=0.41</code>个币。</p>
<p>​    以现有的比特币运行发展情况来看， 比特币每年的挖矿产量都在不断减半， 我们可以预计， 随着比特币产量的不断降低， 矿工人数也会越来越少， 这样就会<strong>导致整个比特币网络的稳定性出现问题</strong>。 PoS的解决方案是鼓励大家都去打开钱包客户端程序， 因为只有这样才可以发现PoS区块， 才会获得利息， 这也增加了网络的健壮性。还有当矿工数量变少的时候，比特币被51%算力攻击就越容易。</p>
<h1 id="PoS-的优缺点"><a href="#PoS-的优缺点" class="headerlink" title="PoS 的优缺点"></a>PoS 的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>省资源：不需要挖矿，不需要大量耗费电力和能源。</li>
<li>更加去中心化：相对于比特币等PoW类型的加密货币，更加去中心化，相比PoW算法的51%算力攻击，PoS需要购买51%的货币，成本更高，没有攻击意义。</li>
<li>避免通货膨胀：PoS机制的加密货币按一定的年利率新增货币，可以有效避免紧缩出现，保持基本稳定。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>POS会面临发币的问题，起初只有创世块上有币，意味着只有这个节点可以挖矿，所以让币分散出去才能让网络壮大，所以早期采取的是POW+POS，即第一阶段POW挖矿，第二阶段POS挖矿，后来ERC20合约代币出现后，可以只存在POS的挖矿形式。</li>
<li>开发者作恶：纯<code>PoS</code>机制的加密货币，只能通过<code>IPO</code>的方式发行，这就导致“少数人”（通常是开发者）获得大量成本极低的加密货币，很有可能造成大面积的抛售。</li>
<li>币龄其实就是时间，一旦挖矿者囤积一定的币，很久很久之后发起攻击，这样将很容易拿到记账权。</li>
<li>矿工可以囤积代币从而导致货币流通困难。</li>
<li>POS面临的最严重的一个问题就是无成本利益问题，在PoS系统中做任何事几乎没有成本，比如在PoS系统上挖矿几乎没有成本，这也就意味着分叉非常方便。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/casper-proof-of-stake-compendium">https://eth.wiki/en/concepts/casper-proof-of-stake-compendium</a></p>
<p> <a href="https://eth.wiki/en/concepts/proof-of-stake-faqs">https://eth.wiki/en/concepts/proof-of-stake-faqs</a></p>
<p> <a href="https://www.cnblogs.com/sueyyyy/articles/9726812.html">https://www.cnblogs.com/sueyyyy/articles/9726812.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>POS</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|实用拜占庭容错算法(PBFT)</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_PBFT%E7%AE%97%E6%B3%95-8/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|实用拜占庭容错算法(PBFT)</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7uqdgnmj31hc0u0wk5.jpg" alt="816246ba75a183d188bdd3bf9c5eed69"></p>
<h1 id="拜占庭容错BFT"><a href="#拜占庭容错BFT" class="headerlink" title="拜占庭容错BFT"></a>拜占庭容错BFT</h1><p>拜占庭容错是分布式协议的一种属性，如果这种协议可以解决不可信任环境下的分布式一致性问题，那么它就是拜占庭容错。</p>
<p>pbft 算法的提出主要是为了解决拜占庭将军问题。网上关于 pbft 的算法介绍基本上是基于 liskov 在 1999 年发表的论文《 Practical Byzantine Fault Tolerance 》来进行解释的。</p>
<h1 id="raft和pbft的最大容错节点数"><a href="#raft和pbft的最大容错节点数" class="headerlink" title="raft和pbft的最大容错节点数"></a>raft和pbft的最大容错节点数</h1><p>对于raft算法，raft算法只支持容错故障节点，不支持容错作恶节点。假设集群总节点数为n，故障节点为 f ，集群里正常节点只需要比 f 个节点再多一个节点，即 f+1 个节点，正确节点的数量就会比故障节点数量多，那么集群就能达成共识。因此 raft 算法支持的最大容错节点数量是（n-1）&#x2F;2。</p>
<p>对于 pbft 算法，因为 pbft 算法的除了需要支持容错故障节点之外，还需要支持容错作恶节点。假设集群节点数为 N，有问题的节点为 f。有问题的节点中，可以既是故障节点，也可以是作恶节点，或者只是故障节点或者只是作恶节点。那么会产生以下两种极端情况：</p>
<ol>
<li>第一种情况，f 个有问题节点既是故障节点，又是作恶节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。也就是说这种情况支持的最大容错节点数量是 （n-1）&#x2F;2。</li>
<li>第二种情况，故障节点和作恶节点都是不同的节点。那么就会有 f 个问题节点和 f 个故障节点，当发现节点是问题节点后，会被集群排除在外，剩下 f 个故障节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。所以，所有类型的节点数量加起来就是 f+1 个正确节点，f个故障节点和f个问题节点，即 3f+1&#x3D;n。</li>
</ol>
<p>结合上述两种情况，因此 pbft 算法支持的最大容错节点数量是（n-1）&#x2F;3。</p>
<h1 id="PBFT算法流程"><a href="#PBFT算法流程" class="headerlink" title="PBFT算法流程"></a>PBFT算法流程</h1><p>基本流程如下：</p>
<ol>
<li>客户端发送请求给主节点</li>
<li>主节点广播请求给其它节点，节点执行 pbft 算法的三阶段共识流程。</li>
<li>节点处理完三阶段流程后，返回消息给客户端。</li>
<li>客户端收到来自 f+1 个节点的相同消息后，代表共识已经正确完成。</li>
</ol>
<p>无论是最好的情况还是最坏的情况，如果客户端收到 f+1 个节点的相同消息，那么就代表有足够多的正确节点已全部达成共识并处理完毕了。</p>
<p>PBFT 算法中, 存在一个主节点(primary) 和其他的备份节点 (replica), PBFT 共识机制主要包含两部分: 第一部分是分布式共识达成,在主节点正常工作时, PBFT 通过预准备 (pre-prepare)、准备 (prepare) 和承诺 (commit) 三个步骤完成共识; 第二部分是视图转换 (view-change), 当主节点出现问题不能及时处理数据请求时, 其他备份节点发起视图转换, 转换成功后新的主节点开始工作. 主节点以轮转 (round robin) 的方式交替更换.</p>
<p>PBFT 的分布式共识达成过程如下:</p>
<ol>
<li>请求 (propose)：客户端 (client) 上传请求消息 <em>m</em> 至网络中的节点, 包括主节点和其他备份节点。</li>
<li>预准备 (pre-prepare)：主节点收到客户端上传的请求消息 <em>m</em>, 赋予消息序列号 <em>s</em>, 计算得到预准备消息 (pre-prepare*, H*(<em>m</em>)<em>, s, v</em>)，其中 <em>H</em>(m) 是单向哈希函数, <em>v</em> 代表的是此时的视图 (view),视图一般用于记录主节点的更替, 主节点发生更替时, 视图随之增加 1 。消息发送者节点在发送消息前需利用自身私钥对消息实施数字签名。主节点将预准备消息发送给其他备份节点.</li>
<li>准备 (prepare)：备份节点收到主节点的预准备消息, 验证 <em>H</em>(<em>m</em>) 的合法性。即对于视图 <em>v</em> 和序列号<em>s</em> 来说, 备份节点先前并未收到其他消息。验证通过后, 备份节点计算准备消息 (prepare*, H*(<em>m</em>)<em>, s, v</em>) 并将其在全网广播. 与此同时, 所有节点收集准备消息,如果收集到的合法准备消息数量大于等于 2<em>f</em> + 1(包含自身准备消息) 个, 则将其组成准备凭证 (prepared certificate)</li>
<li>承诺 (commit)：如果在准备阶段中, 节点收集到足够的准备消息并生成了准备凭证, 那么节点将计算承诺消息 (commit*, s, v*) 并广播，将消息 <em>m</em> 放入到本地日志中. 与此同时节点收集网络中的承诺消息,如果收集到的合法承诺消息数量大于等于 2<em>f</em> +1(包含自身承诺消息), 那么将其组成承诺凭证 (committedcertificate), 证明消息 <em>m</em> 完成最终承诺。</li>
<li>答复 (reply)：备份节点和主节点中任意收集到足够承诺消息并组成承诺凭证的节点, 将承诺凭证作为对消息 <em>m</em> 的答复发送给客户端, 客户端确认消息 <em>m</em> 的最终承诺.</li>
</ol>
<p>PBFT的共识过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnxgennnu6j31fu0g6aet.jpg" alt="image-20210223143130925"></p>
<h1 id="checkpoint机制"><a href="#checkpoint机制" class="headerlink" title="checkpoint机制"></a>checkpoint机制</h1><p>在 PBFT 中, 存在检查点 (checkpoint) 机制, 由于每个消息都被赋予了一定的序列号, 如消息 <em>m</em> 对应的序列号为 118, 当不少于 2<em>f</em> + 1 个节点组成消息 <em>m</em> 的承诺凭证, 完成消息承诺之后, 序列号 118 成为当前的稳定检查点 (stable checkpoint). 检查点机制被用于实现存储删减, 即当历史日志内容过多时, 节点可以选择清除稳定检查点之前的数据, 减少存储成本. 另外稳定检查点在 PBFT 的视图转换中也起到了关键作用.</p>
<h1 id="viewChange机制"><a href="#viewChange机制" class="headerlink" title="viewChange机制"></a>viewChange机制</h1><p>当主节点挂了（超时无响应）或者从节点集体认为主节点是问题节点时，就会触发 ViewChange 事件， ViewChange 完成后，视图编号将会加 1 。下图展示 ViewChange 的三个阶段流程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnxgw54qrsj31a00dw7be.jpg" alt="image-20210223144812547"></p>
<p>viewchange 会有三个阶段，分别是 <code>view-change</code> ， <code>view-change-ack</code> 和 <code>new-view</code> 阶段。从节点认为主节点有问题时，会向其它节点发送 view-change 消息，当前存活的节点编号最小的节点将成为新的主节点。当新的主节点收到 2f 个其它节点的 view-change 消息，则证明有足够多人的节点认为主节点有问题，于是就会向其它节点广播 New-view 消息。注意：从节点不会发起 new-view 事件。对于主节点，发送 new-view 消息后会继续执行上个视图未处理完的请求，从 pre-prepare 阶段开始。其它节点验证 new-view 消息通过后，就会处理主节点发来的 pre-prepare 消息，这时执行的过程就是前面描述的 pbft 过程。</p>
<p>最后一张图来了解一下PBFT算法：</p>
<p><img src="/Users/carver/Downloads/PBFT-PR.svg" alt="PBFT-PR"></p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">http://pmg.csail.mit.edu/papers/osdi99.pdf</a> </p>
<p> <a href="https://blog.csdn.net/shangsongwww/article/details/88942215">https://blog.csdn.net/shangsongwww/article/details/88942215</a></p>
<p> <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/thesis-mcastro.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/thesis-mcastro.pdf</a></p>
<p> <a href="https://www.comp.nus.edu.sg/~rahul/allfiles/cs6234-16-pbft.pdf">https://www.comp.nus.edu.sg/~rahul/allfiles/cs6234-16-pbft.pdf</a></p>
<p> <a href="https://zhuanlan.zhihu.com/p/35847127">https://zhuanlan.zhihu.com/p/35847127</a></p>
<p> <a href="https://www.jianshu.com/p/0bef4fb1662b">https://www.jianshu.com/p/0bef4fb1662b</a></p>
<p> <a href="https://learnblockchain.cn/article/781%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E9%98%B6%E6%AE%B5%E6%B6%88%E6%81%AF%EF%BC%89">https://learnblockchain.cn/article/781（为什么需要三阶段消息）</a></p>
<p> <a href="https://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/%EF%BC%88View">https://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/（View</a> Change的作用）</p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>PBTF</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|Raft算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_Raft%E7%AE%97%E6%B3%95-6/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|Raft算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv4oqutq9j311x0lcwgh.jpg" alt="a01214b9197eecac0e30d703597788f0"></p>
<hr>
<h1 id="Raft算法概述"><a href="#Raft算法概述" class="headerlink" title="Raft算法概述"></a>Raft算法概述</h1><p>不同于Paxos算法直接从分布式一致性问题出发推导出来，Raft算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。</p>
<h1 id="Raft算法角色"><a href="#Raft算法角色" class="headerlink" title="Raft算法角色"></a>Raft算法角色</h1><p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<ul>
<li><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li><strong>Candidate</strong>：Leader选举过程中的临时角色。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv5fibnnwj31bc0jgq4d.jpg" alt="image-20210221144024734"></p>
<p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p>
<p>Raft算法角色状态转换如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv77wcjjrj31fy0i8akh.jpg" alt="image-20210221154232947"></p>
<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv79etskij31c40f4ad7.jpg" alt="image-20210221154400705"></p>
<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p>
<p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC 。结果有以下三种情况：</p>
<ul>
<li>赢得了多数的选票，成功选举为Leader；</li>
<li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li>
<li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7bruxirj30xi0u0jsy.jpg" alt="v2-0471619d1b78ba6d57326d97825d9495_r"></p>
<p>选举出<code>Leader</code>后，<code>Leader</code>通过定期向所有<code>Followers</code>发送心跳信息维持其统治。若<code>Follower</code>一段时间未收到Leader的心跳则认为<code>Leader</code>可能已经挂了，再次发起<code>Leader</code>选举过程。</p>
<p><code>Raft</code>保证选举出的<code>Leader</code>上一定具有最新的已提交的日志。</p>
<h1 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h1><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC （RPC细节参见八、Raft算法总结）复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7dki1f3j31e60p6tfm.jpg" alt="image-20210221154800173"></p>
<p>某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。</p>
<p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7e5yoruj31h00skqm1.jpg" alt="image-20210221154824325"></p>
<p>Raft日志同步保证如下两点：</p>
<ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li>
</ul>
<p>第一条特性源于Leader在一个term内在给定的一个log index最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。</p>
<p>第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。</p>
<p>一般情况下，Leader和Followers的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，Leader崩溃可能会导致日志不一致：旧的Leader可能没有完全复制完日志中的所有条目。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7ejhdj4j31fu0p64fl.jpg" alt="image-20210221154856229"></p>
<p>上图阐述了一些Followers可能和新的Leader日志不同的情况。一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p>
<p>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。</p>
<p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</p>
<p>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Raft增加了如下两条限制以保证安全性：</p>
<ul>
<li>拥有最新的已提交的log entry的Follower才有资格成为Leader。</li>
</ul>
<p>这个保证是在RequestVote RPC中做的，Candidate在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。</p>
<ul>
<li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li>
</ul>
<p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7fah4fcj318k0kaar3.jpg" alt="image-20210221154938685"></p>
<p>在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；</p>
<p>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;</p>
<p>S5尚未将日志推送到Followers就离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被提交了。；</p>
<p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term &#x3D; 5 &gt; 4，2. 最新的日志为（3，2），比大多数节点（如S2&#x2F;S3&#x2F;S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。</p>
<p>增加上述限制后，即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被提交，因为它是来自之前term（2）的日志，直到S1在当前term（4）产生的日志（4， 4）被大多数Followers确认，S1方可提交日志（4，4）这条日志，当然，根据Raft定义，（4，4）之前的所有日志也会被提交。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，4）。</p>
<h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p>
<p>Snapshot中包含以下内容：</p>
<ul>
<li>日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</li>
<li>系统当前状态。</li>
</ul>
<p>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC（RPC细节参见八、Raft算法总结）。</p>
<p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p>
<p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p>
<h1 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h1><p>成员变更是在集群运行过程中副本发生变化，如增加&#x2F;减少副本数、节点替换等。</p>
<p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。</p>
<p>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置（Cold）切换到新成员配置（Cnew）。</p>
<p>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置（Cold）切换到新成员配置（Cnew）的时刻不同。</p>
<p>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7gvonaej31dq0teae6.jpg" alt="image-20210221155100462"></p>
<p>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。</p>
<p>为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致（joint consensus），共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7h61euxj319s0m2n1e.jpg" alt="image-20210221155126751"></p>
<p>Raft两阶段成员变更过程如下：</p>
<ol>
<li>Leader收到成员变更请求从Cold切成Cnew；</li>
<li>Leader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；</li>
<li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；</li>
<li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；</li>
<li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；</li>
<li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；</li>
<li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li>
</ol>
<p>异常分析：</p>
<ul>
<li>如果Leader的Cold U Cnew尚未推送到Follower，Leader就挂了，此后选出的新Leader并不包含这条日志，此时新Leader依然使用Cold作为自己的成员配置。</li>
<li>如果Leader的Cold U Cnew推送到大部分的Follower后就挂了，此后选出的新Leader可能是Cold也可能是Cnew中的某个Follower。</li>
<li>如果Leader在推送Cnew配置的过程中挂了，那么同样，新选出来的Leader可能是Cold也可能是Cnew中的某一个，此后客户端继续执行一次改变配置的命令即可。</li>
<li>如果大多数的Follower确认了Cnew这个消息后，那么接下来即使Leader挂了，新选出来的Leader肯定位于Cnew中。</li>
</ul>
<p>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。</p>
<p>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。</p>
<p>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。</p>
<p>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢？方法就是每次成员变更只允许增加或删除一个成员。</p>
<p>可从数学上严格证明，只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派。</p>
<p>一阶段成员变更：</p>
<ul>
<li>成员变更限制每次只能增加或删除一个成员（如果要变更多个成员，连续变更多次）。</li>
<li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li>
<li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li>
<li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li>
</ul>
<h1 id="Raft与Multi-Paxos的异同"><a href="#Raft与Multi-Paxos的异同" class="headerlink" title="Raft与Multi-Paxos的异同"></a>Raft与Multi-Paxos的异同</h1><p>Raft与Multi-Paxos都是基于领导者的一致性算法，乍一看有很多地方相同，下面总结一下Raft与Multi-Paxos的异同。</p>
<p>Raft与Multi-Paxos中相似的概念：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7hzg71cj31600iuq60.jpg" alt="image-20210221155202104"></p>
<p>Raft与Multi-Paxos的不同：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7iacddmj31780e2afb.jpg" alt="image-20210221155231875"></p>
<h1 id="关于Raft的一些面试题"><a href="#关于Raft的一些面试题" class="headerlink" title="关于Raft的一些面试题"></a>关于Raft的一些面试题</h1><h2 id="Raft分为哪几个部分？"><a href="#Raft分为哪几个部分？" class="headerlink" title="Raft分为哪几个部分？"></a>Raft分为哪几个部分？</h2><p>  <strong>主要是分为leader选举、日志复制、日志压缩、成员变更等</strong>。</p>
<h2 id="Raft中任何节点都可以发起选举吗？"><a href="#Raft中任何节点都可以发起选举吗？" class="headerlink" title="Raft中任何节点都可以发起选举吗？"></a>Raft中任何节点都可以发起选举吗？</h2><p>  Raft发起选举的情况有如下几种：</p>
<ul>
<li>刚启动时，所有节点都是follower，这个时候发起选举，选出一个leader；</li>
<li>当leader挂掉后，<strong>时钟最先跑完的follower发起重新选举操作</strong>，选出一个新的leader。</li>
<li>成员变更的时候会发起选举操作。</li>
</ul>
<h2 id="Raft中选举中给候选人投票的前提？"><a href="#Raft中选举中给候选人投票的前提？" class="headerlink" title="Raft中选举中给候选人投票的前提？"></a>Raft中选举中给候选人投票的前提？</h2><p>  <strong>Raft确保新当选的Leader包含所有已提交（集群中大多数成员中已提交）的日志条目</strong>。这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的<strong>last log entry的term_id和index</strong>，follower在接收到RequestVoteRPC消息时，<strong>如果发现自己的日志比RPC中的更新，就拒绝投票</strong>。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。</p>
<h2 id="Raft网络分区下的数据一致性怎么解决？"><a href="#Raft网络分区下的数据一致性怎么解决？" class="headerlink" title="Raft网络分区下的数据一致性怎么解决？"></a>Raft网络分区下的数据一致性怎么解决？</h2><p>  发生了网络分区或者网络通信故障，<strong>使得Leader不能访问大多数Follwer了，那么Leader只能正常更新它能访问的那些Follower，而大多数的Follower因为没有了Leader，他们重新选出一个Leader</strong>，然后这个 Leader来接受客户端的请求，如果客户端要求其添加新的日志，这个新的Leader会通知大多数Follower。<strong>如果这时网络故障修复 了，那么原先的Leader就变成Follower，在失联阶段这个老Leader的任何更新都不能算commit，都回滚，接受新的Leader的新的更新（递减查询匹配日志）</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv7jwqaoqj31fg0s444e.jpg" alt="image-20210221155356395"></p>
<h2 id="Raft数据一致性如何实现？"><a href="#Raft数据一致性如何实现？" class="headerlink" title="Raft数据一致性如何实现？"></a>Raft数据一致性如何实现？</h2><p>  <strong>主要是通过日志复制实现数据一致性，leader将请求指令作为一条新的日志条目添加到日志中，然后发起RPC 给所有的follower，进行日志复制，进而同步数据</strong>。</p>
<h2 id="Raft的日志有什么特点？"><a href="#Raft的日志有什么特点？" class="headerlink" title="Raft的日志有什么特点？"></a>Raft的日志有什么特点？</h2><p>  <strong>日志由有序编号（log index）的日志条目组成，每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令</strong>。</p>
<h2 id="Raft里面怎么保证数据被commit，leader宕机了会怎样，之前的没提交的数据会怎样？"><a href="#Raft里面怎么保证数据被commit，leader宕机了会怎样，之前的没提交的数据会怎样？" class="headerlink" title="Raft里面怎么保证数据被commit，leader宕机了会怎样，之前的没提交的数据会怎样？"></a>Raft里面怎么保证数据被commit，leader宕机了会怎样，之前的没提交的数据会怎样？</h2><p>  <strong>leader会通过RPC向follower发出日志复制，等待所有的follower复制完成，这个过程是阻塞的</strong>。</p>
<p>  <strong>老的leader里面没提交的数据会回滚，然后同步新leader的数据</strong>。</p>
<h2 id="Raft日志压缩是怎么实现的？增加或删除节点呢？？"><a href="#Raft日志压缩是怎么实现的？增加或删除节点呢？？" class="headerlink" title="Raft日志压缩是怎么实现的？增加或删除节点呢？？"></a>Raft日志压缩是怎么实现的？增加或删除节点呢？？</h2><p>  在实际的系统中，<strong>不能让日志无限增长</strong>，否则<strong>系统重启时需要花很长的时间进行回放</strong>，从而影响可用性。<strong>Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃（以前的数据已经落盘了）</strong>。</p>
<p>  <strong>snapshot里面主要记录的是日志元数据，即最后一条已提交的 log entry的 log index和term</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> 公号：区块链技术栈 （推荐）</p>
<p> <a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a></p>
<p> <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> （动画演示 推荐）</p>
<p> <a href="https://raft.github.io/">https://raft.github.io/</a> （raft资源）</p>
<p> <a href="https://zhuanlan.zhihu.com/p/32052223">https://zhuanlan.zhihu.com/p/32052223</a></p>
<p> <a href="https://github.com/goraft/raft">https://github.com/goraft/raft</a> （go语言实现）</p>
<p> <a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md%EF%BC%88%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E5%9C%B0%E5%9D%80%EF%BC%89">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md（中文翻译地址）</a></p>
<p> <a href="https://github.com/eliben/raft.git">https://github.com/eliben/raft.git</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|Istanbul BFT算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_Istanbul%20BFT%E7%AE%97%E6%B3%95-9/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|Istanbul BFT算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，上面给个star，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnximfy066j30oo0gs0vk.jpg" alt="931c0c9307f4692d69da24b7fe6e0bf3"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://github.com/ethereum/EIPs/issues/650">Istanbul BFT</a>作为BFT类算法的一种已经有过在以太坊上的实践。虽然Istanbul目前还存在一些<a href="https://blog.csdn.net/dianyangshu0904/article/details/102195413#%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98">潜在的问题</a>，但其算法思想和实现还是值得学习和借鉴的。</p>
<blockquote>
<p>源代码：<a href="https://github.com/jpmorganchase/quorum/tree/master/consensus/istanbul">https://github.com/jpmorganchase/quorum/tree/master/consensus/istanbul</a></p>
</blockquote>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul>
<li><strong>Validator</strong>：块的验证者</li>
<li><strong>Proposer</strong>：块验证者中被选择用来出块的</li>
<li><strong>Round</strong>: 共识的轮数。一轮中 Proposer 开始提出一个一个出块建议，然后以提交区块结束。</li>
<li><strong>Proposal</strong>：新的块生成提议</li>
<li><strong>Sequence</strong>：提议的序号。当前序列号大于先前的；块高就是此提议的序列号。</li>
<li><strong>Backlog</strong>：存储未来的共识消息</li>
<li><strong>Round state</strong>: 特定sequence和轮次的共识消息，包括 pre-prepare 消息, prepare 消息, and commit 消息.</li>
<li><strong>Consensus proof</strong>：用来证明块已经通过共识处理的块签名</li>
<li><strong>Snapshot</strong>：上一个时期的验证者投票状态</li>
</ul>
<h3 id="IBFT共识细节"><a href="#IBFT共识细节" class="headerlink" title="IBFT共识细节"></a>IBFT共识细节</h3><p>Proposer 必须在每个 round中连续不断的 生成 block prorosal。</p>
<p>istanbul BFT 包括 3 个阶段的共识：PRE-PREPARE，PREPARE，COMMIT。</p>
<p>容错机制： N &#x3D; 3F +1 ；N表示验证节点，F表示错误节点。</p>
<p>在每轮之前将会以循环的方式选择一个 validator 作为 proposer. 接着 proposer将会提出一个新的 block proposal 并且广播通过 pre-prepare 消息。一旦接受到 pre-prepare消息 ，validators将会进入到 pre-prepared 阶段并且广播 prepare  消息。这个步骤是为了确保 validators 运行在相同的 sequence 和相同的 round 中。当接收到2F+1 的Prepare消息时，validators 进入到 prepared并且广播 commit 消息。此步骤是通知其它节点接受建议的块并将块插入链。 最后，validator等待2F + 1 COMMIT消息进入COMMITTED状态，然后将块插入链。</p>
<p>注意：<strong>Istanbul中 的块是最终的，没有分叉，任何有效的块必须位于主链的某个位置</strong>。</p>
<p>为了防止故障节点从主链生成完全不同的链，每个验证器将2F + 1个接收到的COMMIT签名附加到标头中的extraData字段，然后将其插入链中， 因此，块是可自我验证的，并且也可以支持轻客户端。但是，动态extraData会导致块哈希计算出现问题。由于来自不同验证器的相同块可以具有不同的COMMIT签名集，因此同一块也可以具有不同的块散列。 为了解决这个问题，我们通过排除COMMIT签名部分来计算块哈希。 因此，我们仍然可以保持块&#x2F;块哈希一致性，并将共识证明放在块头中。</p>
<h4 id="共识状态"><a href="#共识状态" class="headerlink" title="共识状态"></a>共识状态</h4><p>Istanbul BFT是一种状态机复制算法。 每个验证器都维护一个状态机副本，以达到块一致性。</p>
<p>一共有以下几种状态：</p>
<ul>
<li><code>NEW ROUND</code>: Proposer发送新的 block proposal。 Validator等待PRE-PREPARE消息。</li>
<li><code>PRE-PREPARED</code>:验证器已收到PRE-PREPARE消息并广播PREPARE消息。 然后它等待2F + 1 个PREFARE或COMMIT消息。</li>
<li><code>PREPARED</code>: 验证器已收到2F + 1个PREPARE消息并广播COMMIT消息。 然后它等待2F + 1 COMMIT消息。</li>
<li><code>COMMITTED</code>:验证器已收到2F + 1个COMMIT消息，并能够将建议的块插入区块链。</li>
<li><code>FINAL COMMITTED</code>:新块已成功插入区块链，validator 已准备好进入下一轮。</li>
<li><code>ROUND CHANGE</code>:验证器正在等待同一个建议的轮数上的2F + 1个ROUND CHANGE消息。</li>
</ul>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g64qqy79jqj30z60najwf.jpg" alt="image-20190819094215511"></p>
<ul>
<li><code>NEW ROUND</code> -&gt; <code>PRE-PREPARED</code>:<ul>
<li><strong>Proposer</strong> 从txpool 中收集交易</li>
<li><strong>Proposer</strong>生成块提议并将其广播给验证者。 然后它进入PRE-PREPARED状态。</li>
<li>每个validator在收到具有以下条件的PRE-PREPARE消息后进入PRE-PREPARED：<ul>
<li>块提案来自有效的proposer。</li>
<li>块头有效</li>
<li>block proposal的sequence和round匹配validator的状态</li>
</ul>
</li>
<li><strong>Validator</strong>广播<code>PREPARE</code>消息给其他validators</li>
</ul>
</li>
<li><code>PRE-PREPARED</code> -&gt; <code>PREPARED</code>:<ul>
<li>Validator接收2F + 1个有效的PREPARE消息以进入PREPARED状态。 有效消息符合以下条件：<ul>
<li>sequence 和 round匹配</li>
<li>block hash匹配</li>
<li>消息来自于已知 validators</li>
</ul>
</li>
</ul>
</li>
<li><code>COMMITTED</code> -&gt; <code>FINAL COMMITTED</code>:<ul>
<li>validator 将 2F+1 个提交的签名放到 extraData中并且尝试将区块上链</li>
<li>插入成功后，Validator进入FINAL COMMITTED状态。</li>
</ul>
</li>
<li><code>FINAL COMMITTED</code> -&gt; <code>NEW ROUND</code>:<ul>
<li>验证器选择一个新的提议器并启动一个新的round timer 。</li>
</ul>
</li>
</ul>
<h4 id="Round-change-flow"><a href="#Round-change-flow" class="headerlink" title="Round change flow"></a>Round change flow</h4><ul>
<li>3 个条件将会触发 ROUND CHANGE<ul>
<li>Round change timer 过期</li>
<li>无效 <code>PREPREPARE</code> 消息</li>
<li>块插入失败</li>
</ul>
</li>
<li>当验证器注意到上述条件之一适用时，它会广播ROUND CHANGE消息以及建议的 round number，并等待来自其他验证器的ROUND CHANGE消息。 建议的round number 根据以下条件选择：<ul>
<li>如果验证器已从其peers接收到ROUND CHANGE消息，则它将选择具有F + 1个ROUND CHANGE消息的最大 round number。</li>
<li>否则，它会选择1 +当前的round number作为建议的轮数。</li>
</ul>
</li>
<li>每当验证器在同一个建议的轮数上收到F + 1个ROUND CHANGE消息时，它就会将收到的消息与它自己的一个进行比较。 如果接收的数量较大，验证器将再次使用收到的号码广播ROUND CHANGE消息。</li>
<li>在相同的建议round number上接收到2F + 1个ROUND CHANGE消息后，验证器退出round change loop，计算新的提议者，然后进入NEW ROUND状态。</li>
<li>验证器跳出round change loop的另一个条件是它通过对等同步接收验证的块。</li>
</ul>
<h4 id="Proposer-选择策略"><a href="#Proposer-选择策略" class="headerlink" title="Proposer 选择策略"></a>Proposer 选择策略</h4><p>目前我们支持两种策略：<strong>round robin</strong> 和 <strong>sticky proposer</strong>.。</p>
<ul>
<li>Round robin:在循环设置中，提议者将在每个块和round change中进行更改</li>
<li>Sticky proposer: 在 sticky proposer中, proposal只有在发生一轮变更时才会改变。</li>
</ul>
<h4 id="Validator-列表投票"><a href="#Validator-列表投票" class="headerlink" title="Validator 列表投票"></a>Validator 列表投票</h4><p>使用与Clique类似的验证器投票机制，并复制Clique EIP的大部分内容。 每个epoch交易都会重置验证器投票，这意味着如果授权或取消授权投票仍在进行中，则投票过程将被终止。</p>
<p>对于所有交易块：</p>
<ul>
<li>Proposer可以投一票来建议更改验证人名单。</li>
<li>每个目标受益人的最新提案仅保留一个验证人。</li>
<li>随着链条的进展，投票将被实时统计（允许同时提议）。</li>
<li>达到多数共识的proposals ,VALIDATOR_LIMIT立即生效。</li>
<li>无效的提案不会因客户端实现简单而受到惩罚。</li>
<li>一项生效的提案需要放弃该提案的所有未决投票（赞成和反对），并以 clean state 开始</li>
</ul>
<h4 id="未来的消息和backlog"><a href="#未来的消息和backlog" class="headerlink" title="未来的消息和backlog"></a>未来的消息和backlog</h4><p>在异步网络环境中，可以接收将来无法在当前状态下处理的消息。 例如，验证器可以在NEW ROUND上接收COMMIT消息。 我们将此类消息称为“未来消息”。 当验证程序收到将来的消息时，它会将消息放入其待办事项中，并尽可能在稍后尝试处理。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>为了加速共识过程，在接收PREFARE消息的2F + 1之前接收到2F + 1 COMMIT消息的验证器将跳转到COMMITTED状态，这样就不必等待进一步的PREPARE消息。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>我们定义以下常量：</p>
<ul>
<li><code>EPOCH_LENGTH</code>:检查点和重置待处理投票之后的块数。<ul>
<li>建议30000使testnet保持类似于主要网络ethash时代。</li>
</ul>
</li>
<li><code>REQUEST_TIMEOUT</code>: 在以毫秒为单位进行轮次更改之前，每个达成一致的超时。</li>
<li><code>BLOCK_PERIOD</code>: 两个连续块之间的最小时间戳差异（秒）。</li>
<li><code>PROPOSER_POLICY</code>:提议者选择策略，默认为round robin.。</li>
<li><code>ISTANBUL_DIGEST</code>:固定的 magic number， 0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365用于Istanbul块识别的块头中的mixDigest。</li>
<li><code>DEFAULT_DIFFICULTY</code>: 默认块难度，设置为0x0000000000000001。</li>
<li><code>EXTRA_VANITY</code>: 固定数量的额外数据前缀字节预留给提议者。<ul>
<li>建议保留当前额外数据容量和&#x2F;或使用的32个字节。</li>
</ul>
</li>
<li><code>NONCE_AUTH</code>: magic nonce number 0xffffffffffffffff投票添加验证器。</li>
<li><code>NONCE_DROP</code>:magic nonce number 0x0000000000000000 投票移除验证器</li>
<li><code>UNCLE_HASH</code>:总是Keccak256（RLP（[]））作为叔叔在PoW之外没有意义。</li>
<li><code>PREPREPARE_MSG_CODE</code>: 固定编号0. PREPREPARE消息的消息代码。</li>
<li><code>COMMIT_MSG_CODE</code>: 固定编号1. COMMIT消息的消息代码。</li>
<li><code>ROUND_CHANGE_MSG_CODE</code>:固定号码2. ROUND CHANGE消息的消息代码。</li>
</ul>
<p>我们还定义了以下每块常量：</p>
<ul>
<li><code>BLOCK_NUMBER</code>: 链中的块高度，其中生成块的高度为0。</li>
<li><code>N</code>: 授权验证人数。</li>
<li><code>F</code>:允许的错误验证器数量。</li>
<li><code>VALIDATOR_INDEX</code>:当前授权验证器的排序列表中的块验证器的索引。</li>
<li><code>VALIDATOR_LIMIT</code>: 传递授权或取消授权提议的验证者数量。<ul>
<li>必须是最低限额（N &#x2F; 2）+ 1才能对链条达成多数共识。</li>
</ul>
</li>
</ul>
<h4 id="块头"><a href="#块头" class="headerlink" title="块头"></a>块头</h4><p>我们没有为伊斯坦布尔BFT发明新的块头。 相反，我们跟随Clique重新调整ethash标头字段，如下所示：</p>
<ul>
<li><p><code>beneficiary</code>: 建议修改验证器列表的地址。</p>
<ul>
<li>应该通常用零填充，仅在投票时修改。</li>
<li>尽管如此，允许使用任意值（即使是无意义的值，例如投票给非验证者），以避免投票机制实施中的额外复杂性。</li>
</ul>
</li>
<li><p><code>nonce</code>:关于受益人领域定义的帐户的提议者提案。</p>
<ul>
<li>应该是NONCE_DROP建议取消授权受益人作为现有验证人。</li>
<li>应该是NONCE_AUTH建议授权受益人作为新的验证人。</li>
<li>必须填充零，NONCE_DROP或NONCE_AUTH</li>
</ul>
</li>
<li><p><code>mixHash</code>: 固定 magic number 0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365 用于伊斯坦布尔区块识别</p>
</li>
<li><p><code>ommersHash</code>:必须是UNCLE_HASH，因为在PoW之外，叔叔没有意义。</p>
</li>
<li><p><code>timestamp</code>:必须至少是父时间戳+ BLOCK_PERIOD</p>
</li>
<li><p><code>difficulty</code>:必须填写0x0000000000000001。</p>
</li>
<li><p><code>extraData</code>: 签名者和RLP编码的伊斯坦布尔额外数据的组合字段，其中伊斯坦布尔额外数据包含验证器列表，proposer seal和 commit seal。 伊斯坦布尔的额外数据定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IstanbulExtra <span class="keyword">struct</span> &#123;</span><br><span class="line">	Validators    []common.Address 	<span class="comment">//Validator addresses</span></span><br><span class="line">	Seal          []<span class="type">byte</span>			<span class="comment">//Proposer seal 65 bytes</span></span><br><span class="line">	CommittedSeal [][]<span class="type">byte</span>			<span class="comment">//Committed seal, 65 * len(Validators) bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此extraData将采用EXTRA_VANITY |的形式 ISTANBUL_EXTRA其中| 表示用于分隔vanity和伊斯坦布尔额外数据的固定索引（不是分隔符的实际字符）。</p>
<ul>
<li>第一个EXTRA_VANITY字节（固定）可以包含任意提议者vanity数据。</li>
<li>ISTANBUL_EXTRA字节是从RLP（IstanbulExtra）计算的RLP编码的伊斯坦布尔额外数据，其中RLP（）是RLP编码功能，而IstanbulExtra是伊斯坦布尔额外数据。<ul>
<li><code>Validators</code>: 验证器列表，必须按升序排序。</li>
<li><code>Seal</code>: 提议者的header seal 签名。</li>
<li><code>CommittedSeal</code>:提交的签名列表作为共识证明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Block-hash-proposer-seal-and-committed-seals"><a href="#Block-hash-proposer-seal-and-committed-seals" class="headerlink" title="Block hash, proposer seal, and committed seals"></a>Block hash, proposer seal, and committed seals</h3><p>由于以下原因，Istanbul块哈希计算与ethash块哈希计算不同：</p>
<ol>
<li>提议者需要将提议者密封在extraData中以证明该块由所选提议者签名。</li>
<li>验证者需要将2F + 1个已提交的密封作为extraData中的共识证明，以证明该块已经达成共识。</li>
</ol>
<p>计算仍然类似于ethash块哈希计算，但我们需要处理extraData。 我们按如下方式计算字段：</p>
<h5 id="计算提议者seal"><a href="#计算提议者seal" class="headerlink" title="计算提议者seal"></a>计算提议者seal</h5><p>在提议者密封计算时，committed的密封仍然是未知的，因此我们计算密封与那些未知的密封空。 计算如下：</p>
<ul>
<li><code>Proposer seal</code>: <code>SignECDSA(Keccak256(RLP(Header)), PrivateKey)</code></li>
<li><code>PrivateKey</code>: Proposer’s的私钥</li>
<li><code>Header</code>: 和ethash 的header一样，只不过extradata不一样</li>
<li><code>extraData</code>: <code>vanity | RLP(IstanbulExtra)</code>, 在IstanbulExtra<code>, </code>CommittedSeal<code>and </code>Seal&#96; 是空数组.</li>
</ul>
<h5 id="计算块哈希"><a href="#计算块哈希" class="headerlink" title="计算块哈希"></a>计算块哈希</h5><p>在计算块哈希时，我们需要排除已提交的密封，因为该数据在不同的验证器之间是动态的。 因此，我们在计算哈希时使CommittedSeal为空数组。 计算如下：</p>
<ul>
<li><code>Header</code>: 和ethash 的header一样，只不过extradata不一样</li>
<li><code>extraData</code>: <code>vanity | RLP(IstanbulExtra)</code>, 在IstanbulExtra<code>, </code>CommittedSeal<code>and </code>Seal&#96; 是空数组.</li>
</ul>
<h5 id="共识证明"><a href="#共识证明" class="headerlink" title="共识证明"></a>共识证明</h5><p>在将块插入区块链之前，每个验证器需要从其他验证器收集2F + 1个已提交的密封以构成共识证明。 一旦它收到足够的提交密封，它将填充IstanbulExtra中的CommittedSeal，重新计算extraData，然后将块插入区块链。 请注意，由于已提交的密封可能因不同的来源而不同，因此我们会在计算块哈希时排除该部分，如上一节所述。</p>
<p>Committed seal calculation:</p>
<p>committed seal由每个签名哈希的验证器以及其私钥的COMMIT_MSG_CODE消息代码计算。 计算如下：</p>
<ul>
<li><code>Committed seal</code>: <code>SignECDSA(Keccak256(CONCAT(Hash, COMMIT_MSG_CODE)), PrivateKey)</code>.</li>
<li><code>CONCAT(Hash, COMMIT_MSG_CODE)</code>: 连接 block hash and <code>COMMIT_MSG_CODE</code> bytes.</li>
<li><code>PrivateKey</code>: 签署验证者的私钥。</li>
</ul>
<h3 id="块锁定机制"><a href="#块锁定机制" class="headerlink" title="块锁定机制"></a>块锁定机制</h3><p>引入锁定机制以解决安全问题。 通常，当提议者用块B锁定在某个高度H时，它只能为高度H提出B.另一方面，当验证器被锁定时，它只能在B上投票选择高度H.</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>锁定锁（B，H）包含一个块及其高度，这意味着它的所有验证器当前被锁定在某个块B和高度H.在下面，我们还使用+表示多于和 - 表示小于。 例如，+ 2&#x2F;3验证器表示超过三分之二的验证器，而-1&#x2F;3验证器表示不到三分之一的验证器。</p>
<h4 id="Lock-and-unlock"><a href="#Lock-and-unlock" class="headerlink" title="Lock and unlock"></a>Lock and unlock</h4><ul>
<li>Lock:验证器在高度为“H”的块“B”上接收到“2F + 1”“PREPARE”消息时被锁定。</li>
<li>Unlock: 验证器在高度“H”处解锁，并在未能将块“B”插入块链时阻止“B”。</li>
</ul>
<h4 id="Protocol-2-3-validators-are-locked-with-Lock-B-H"><a href="#Protocol-2-3-validators-are-locked-with-Lock-B-H" class="headerlink" title="Protocol (+2/3 validators are locked with Lock(B,H))"></a>Protocol (<code>+2/3</code> validators are locked with <code>Lock(B,H)</code>)</h4><ul>
<li><p><code>PRE-PREPARE</code>:</p>
<ul>
<li><p><strong>Proposer</strong>:</p>
<ul>
<li><p>情况1，提议者被锁定：在B上广播PRE-PREPARE，并进入PREPARED状态。</p>
</li>
<li><p>情况2，提议者未被锁定：在块B’上广播PRE-PREPARE。</p>
</li>
</ul>
</li>
<li><p><strong>Validator</strong>:</p>
<ul>
<li>情况1，在现有块上接收PRE-PREPARE：忽略。<ul>
<li>注意：它最终会导致轮次更改，并且提议者将通过同步获得旧块。</li>
</ul>
</li>
<li>情况2，验证器被锁定：<ul>
<li>案例2.1，在B上收到PRE-PREPARE：在B上广播PREPARE</li>
<li>案例2.2，在B’上接收PRE-PREPARE：广播ROUND CHANGE。</li>
</ul>
</li>
<li>情况3，验证器未锁定：<ul>
<li>情况3.1，在B上接收PRE-PREPARE：在B上广播PREPARE</li>
<li>案例3.2，在B’上接收PRE-PREPARE：在B’上广播PREPARE。<ul>
<li>注意：由于+2&#x2F;3被锁定在B并且这将导致全面更改，因此此共识轮将最终进行全面更改。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PREPARE</code>:</p>
<ul>
<li>案例1，验证器被锁定：<ul>
<li>情况1.1，在B上接收PREPARE：在B上广播COMMIT，并进入PREPARED状态。<ul>
<li>注意：这不应该发生，它应该跳过这一步并在PRE-PREPARE阶段输入PREPARED。</li>
</ul>
</li>
<li>案例1.2，在B’上收到PREPARE：忽略。<ul>
<li>注意：B’上不应该有+1&#x2F;3 PREPARE，因为+2&#x2F;3被锁定在B.因此B’上的共识轮将导致轮次更改。 验证器不能直接在此广播ROUND CHANGE，因为此PREPARE消息可能来自故障节点。</li>
</ul>
</li>
</ul>
</li>
<li>情况2，验证器未锁定：<ul>
<li>情况2.1，在B上收到PREPARE：在B上等待2F + 1 PREPARE消息<ul>
<li>注意：在接收2F + 1 PREPARE消息之前，它很可能会收到2F + 1 COMMIT消息，因为有+2&#x2F;3验证器被锁定在B.在这种情况下，它将直接跳转到COMMITTED状态。</li>
</ul>
</li>
<li>情况2.2，在B’上收到PREPARE：在B’上等待2F + 1 PREPARE消息。<ul>
<li>Note: This consensus will eventually get into round change since <code>+2/3</code> validators are locked on <code>B</code> and which would lead to round change.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>COMMIT</code>:</p>
<ul>
<li>验证者必须被锁定：<ul>
<li>情况1，在B上收到COMMIT：等待2F + 1 COMMIT消息。</li>
<li>案例2，B’收到COMMIT：不应该发生。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="锁定情况下"><a href="#锁定情况下" class="headerlink" title="锁定情况下"></a>锁定情况下</h4><ul>
<li>Round change:<ul>
<li>Case 1, <code>+2/3</code> are locked:<ul>
<li>如果提议者被锁定，则建议B.</li>
<li>否则它会提出B’，但这将导致另一轮变革。</li>
<li>结论：最终B将由诚实的验证者承诺。</li>
</ul>
</li>
<li>Case 2, <code>+1/3 ~ 2/3</code> are locked:<ul>
<li>如果提议者被锁定，则建议B.</li>
<li>否则它会提出B’。 但是，由于+1 &#x2F; 3被锁定在B，因此没有验证器可以在B’上接收2F + 1 PREPARE，这意味着没有验证器可以锁定在B’。 此外，那些+1 &#x2F; 3锁定验证器将不会响应B’并最终导致全面更改。</li>
<li>结论：最终B将由诚实的验证者承诺。</li>
</ul>
</li>
<li>Case 3, <code>-1/3</code> are locked:<ul>
<li>如果提议被锁定，则建议B.</li>
<li>否则它会提出B’。 如果+2&#x2F;3在B’上达成共识，那些锁定的-1&#x2F;3将通过同步获得B’并移动到下一个高度。 否则，将会有另一轮变更。</li>
<li>结论：它可以是B或其他块B’最终提交。</li>
</ul>
</li>
</ul>
</li>
<li>插入失败导致的round change：<ul>
<li>它将属于上述一轮变更案例之一。<ul>
<li>如果块实际上是坏的（不能插入区块链），最终+2&#x2F;3验证器将在H处解锁块B并尝试建议新的块B’。</li>
<li>如果块是好的（可以插入区块链），那么它仍然是上述圆形更改案例之一。</li>
</ul>
</li>
</ul>
</li>
<li>-1&#x2F;3验证器成功插入块，但其他验证器成功触发循环更改，这意味着+1 &#x2F; 3仍锁定在锁定（B，H）<ul>
<li>案例1，提议者已插入B：提议者将在H’提出B’，但+1 &#x2F; 3被锁定在B，因此B’将不会通过共识，这最终将导致轮次更改。 其他验证器将对B执行共识或通过同步获得B.</li>
<li>案例2，提议者未插入B：<ul>
<li>案例2.1，提议者被锁定：提议者提出B.</li>
<li>案例2.2，提议者未被锁定：提议者将在H处提出B’。其余与上述案例1相同。</li>
</ul>
</li>
</ul>
</li>
<li>+1&#x2F;3验证器成功插入块，-2 &#x2F; 3试图在H处触发圆形更改<ul>
<li>案例1，提议者已插入B：提议者将在H’提出B’，但在+1&#x2F;3通过同步获得B之前不会通过共识。</li>
<li>案例2，提议者未插入B：<ul>
<li>案例2.1，提议者被锁定：提议者提出B.</li>
<li>案例2.2，提议者未被锁定：提议者在H处提出B’。其余与上述案例1相同。</li>
</ul>
</li>
</ul>
</li>
<li>+2&#x2F;3验证器成功插入块，-1 &#x2F; 3试图在H处触发圆形更改<ul>
<li>案例1，提议者已插入B：提议者将在H’提出B’，这可能会导致成功的共识。 然后那些-1&#x2F;3需要通过同步获得B.</li>
<li>案例2，提议者未插入B：<ul>
<li>案例2.1，提议者被锁定：提议者提出B.</li>
<li>案例2.2，提议者没有被锁定：提议者在H处建议B’。因为+2&#x2F;3已经在H处有B，所以这一轮将导致轮次改变。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul>
<li><a href="https://github.com/jpmorganchase/quorum/issues/305">Fail-Stop failures</a></li>
<li><a href="https://arxiv.org/pdf/1901.07160.pdf">这篇文章详细分析了IBFT</a></li>
<li>没有激励机制</li>
</ul>
<p>传统上，验证者需要紧密连接才能达到稳定的共识结果，这意味着所有验证者需要彼此直接连接; 但是，在实际的网络环境中，很难实现稳定和恒定的p2p连接。 为了解决这个问题，伊斯坦布尔BFT实施了八卦网络来克服这种限制。 在八卦网络环境中，所有验证器只需要弱连接，这意味着当它们直接连接或者它们之间连接有一个或多个验证器时，任何两个验证器都会被连接。 共识消息将在验证器之间中继。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a> （文章合集最终修订版，会因为文章内容勘误不断更新，建议关注）</p>
<p> <a href="https://arxiv.org/pdf/1901.07160.pdf">https://arxiv.org/pdf/1901.07160.pdf</a> （IBFT论文）</p>
<p> <a href="https://github.com/ethereum/EIPs/issues/650">https://github.com/ethereum/EIPs/issues/650</a> </p>
<p> <a href="https://github.com/ConsenSys/quorum/issues/305">https://github.com/ConsenSys/quorum/issues/305</a> </p>
<p> <a href="https://docs.goquorum.consensys.net/en/stable/Concepts/Consensus/IBFT/">https://docs.goquorum.consensys.net/en/stable/Concepts/Consensus/IBFT/</a> （quorum的官方的文档）</p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>IBFT</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|拜占庭将军问题</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98-7/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|拜占庭将军问题</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个star，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbavodnjoj31hc0u0dqd.jpg" alt="src=http___pic1.win4000.com_wallpaper_2018-08-15_5b739514a72cf.jpg&amp;refer=http___pic1.win4000"></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>拜占庭帝国想要进攻一个强大的敌人，为此派出了7支军队去包围这个敌人。这个敌人足以抵御3支常规拜占庭军队的同时袭击。基于一些原因，这支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少4支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有<code>叛徒</code>，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种<code>分布式的协议</code>来让他们能够远程协商，从而赢取战斗？这就是著名的拜占庭将军问题。</p>
<p>在拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问。<code>Lamport</code>已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，我们已经<strong>假定了信道是没有问题</strong>的，并在这个前提下，去做一致性和容错性相关研究。</p>
<p>根据如下例子，大致的对问题有个形象的理解：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrrulf2kvj31gk0l2gn5.jpg" alt="image-20210218163356814"></p>
<p>恶意将军分别发送进攻命令和撤退命令，进攻的善良将军则会以为是4票，大于撤退的3票，他们就会进攻，撤退的善良将军也会以为是4票，他们就会撤退，则导致了最终的任务失败。</p>
<h1 id="问题实质"><a href="#问题实质" class="headerlink" title="问题实质"></a>问题实质</h1><p>首先我们明白一群<strong>忠实将军</strong>需要实现<strong>某一个目标</strong>（这里为一致进攻或者一致撤退）（最终的共识结果），这里两个侧重点，一个是某一个目标，第二个是忠实将军，这个目标讲述了两个特性：<strong>一致性</strong>和<strong>正确性</strong>。</p>
<ul>
<li>一致性：所有忠实将军们<code>基于相同的行动计划</code>（一致进攻或者一致撤退）都达成了一致性。</li>
<li>正确性：保证了一致性的前提下（只有进攻和撤退这两个选项），也要保证行动的正确性(即遵守<strong>忠实将军</strong>的命令)。</li>
</ul>
<p>那么拜占庭将军问题可以抽象如下：</p>
<p>设计一个协议，一个发送消息的将军（以下简称<strong>司令官</strong>）发送指令给所有其他将军，使得：</p>
<p>IC1. 所有<strong>忠诚的</strong>将军<strong>遵守同一个命令</strong>（一致性）</p>
<p>IC2. 假如<strong>司令官是忠诚的</strong>，则其他每个将军遵守他的命令（正确性）</p>
<p>约定：忠诚将军遵守协议，叛徒破坏协议，且叛徒是匿名的。</p>
<h1 id="口头协议"><a href="#口头协议" class="headerlink" title="口头协议"></a>口头协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为定义口头消息，拜占庭将军消息系统具有以下假设：</p>
<p>A1. 每个被发送的消息能够被<strong>正确的</strong>发出</p>
<p>A2. 消息接收者知道谁发送的消息</p>
<p>A3. 能够知道缺少的消息</p>
<p>假设 A1和A2防止叛徒干扰其他将军的通信，假设 A3 防止叛徒通过不发消息干扰一致性达成 。</p>
<blockquote>
<p>先出结论，如果有m个叛军，必须至少有 3m+1位将军才能保证口头协议算法能解“拜占庭将军问题”。否则问题不可解。</p>
</blockquote>
<h2 id="口头协议算法OM-m"><a href="#口头协议算法OM-m" class="headerlink" title="口头协议算法OM(m)"></a>口头协议算法OM(m)</h2><p>假设有m个叛徒，n个将军</p>
<p>①：OM(m)算法，m&#x3D;0</p>
<p>a. 一开始发送消息的将军（以下简称<strong>司令官</strong>）发送指令给所有其他将军;</p>
<p>b. 将军接受指令，或者用默认值如果消息未收到的话；</p>
<p>②：OM(m)算法，m&gt;0 </p>
<p>a. 司令官发送指令给所有其他将军;</p>
<p>b. 对于每个将军i，Vi的值从司令官获得，并且将军i执行新一轮OM(m-1)算法，作为OM(m-1)算法中的司令官向剩下的n-2个将军发送Vi(除去OM(m)中司令官和自己)；或者用默认值如果消息未收到的话；</p>
<p>c.对于每个将军i (即收到指令的将军),并且j不等于i, Vj 的值从将军 j在上面 b 步骤中获得的值，或者用默认值如果未收到将军j的消息的话，这样就可以得到V1,…Vn-1个值，最后执行Majority(V1,…Vn-1)取得将军i的最终确认指令V；</p>
<p><strong>详细解释：</strong></p>
<p>OM算法里面有个Majority()函数，用来判断忠诚的将军最终应该是执行什么指令，逻辑为： 在输入的一系列V1,V2…Vn 中，找到最多相同数量的值作为输出，如果找不到，用默认值替代。 比如： V1&#x3D;进攻，V2&#x3D;进攻，V3&#x3D;撤退，Majority(v1, V2, v3)&#x3D;进攻。为什么要加这一步呢，由于司令官也有可能是叛军，所以单纯的把司令官的指令当做最终指令肯定是不行的。Vi代表从其他将军那里获得的关于司令官的指令，假设司令官告诉将军B的指令是”进攻”，如果将军B是忠诚的话，将军B会如实通知将军A“司令官告诉我的指令是进攻”，如果将军B是叛军的话，将军B可能会说“司令官告诉我的指令是撤退”或者干脆不发信息。通过Majority()函数，在忠诚的将军多于叛军（n&gt;&#x3D;3m+1）的情况下，可以保证忠诚的将军得到相同的结论，即满足条件IC1。</p>
<h2 id="口头协议推演"><a href="#口头协议推演" class="headerlink" title="口头协议推演"></a>口头协议推演</h2><p>OM(m)算法中的第b步使用了递归，这个确实很难理解，下面举实例来说明：</p>
<p>a. 当m&#x3D;1,n&#x3D;4并且叛军不是司令官时，根据OM(m)算法, 将军A的最终指令V &#x3D; Majority(V1, V2, V3)&#x3D; Majority(“进攻”，进攻，“撤退”）&#x3D; 进攻，其中V1来自司令官的通知，V2来自将军B告诉将军A的司令官的指令，V3由于是叛军，其实发出什么指令已经无所谓，Majority函数必能让将军A和将军B获得一致的并且是正确的指令，即满足条件IC1和CI2;</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gns0cbjalxj31gs0m440w.jpg" alt="image-20210218212754971"></p>
<p>b.<strong>当m&#x3D;1,n&#x3D;4，并且叛军是司令官时</strong>，每位将军的Majority(V1,V2,V3)&#x3D;Majority(x,y,z)，满足条件IC1.</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gns0gzfmv2j31fw0k6aby.jpg" alt="image-20210218213214835"></p>
<p>c. <strong>当m&#x3D;2, n&#x3D;7,并且司令官是忠诚</strong>，虽然只是多了一个叛徒，但是会出现递归过程</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gns1qbz617j31920rwq5t.jpg" alt="image-20210218221557148"></p>
<p>上图描述了司令官发送进攻消息给其他6位将军，我们只讨论将军1的决策过程：</p>
<ol>
<li>首先将军1从司令官接收到 A 命令</li>
<li>将军1会询问 （3，4，5，6）关于2号将军接收的是什么命令</li>
<li>（3，4，5，6）中3和4会如实转述2号将军的命令是A，而5和 6号将军是作恶节点，会说2号将军告诉他们的是O命令，最后得出结论（A，A，A，O，O）（多数原则）,所以得出结论2号将军接收的是A命令，即V2&#x3D;A</li>
<li>同理可得V3、V4、V5、V6</li>
<li>最后将军1知道了2、3、4、5、6的命令为（A，A，A，O，O），最后将军1会采取A命令策略</li>
</ol>
<p>同理可以得出2，3，4，5，6将军的策略分别为（A，A，A，O，O）,所以最终1-6的将军策略为（A，A，A，A，O，O）,所以忠诚的将军最终保持了一致性，同时选择了A，同时司令官是忠诚的，所有的将军都执行了司令官的命令，保证了准确性。</p>
<p>当m的值越大，这个算法的复杂度会越高。</p>
<h1 id="书面协议"><a href="#书面协议" class="headerlink" title="书面协议"></a>书面协议</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>口头协议中我们讨论了很多，揭示了口头协议的缺点是消息不能追本溯源，这使得口头协议必须在四模冗余的情况下才能保证正确。但是，若能引入一种方法让消息能够追本溯源，情况会不会有所改变呢？这就是书面协议引入的灵感。</p>
<p>这里通过签名就是为了防止说谎，可以追本溯源。除了满足口头消息A1-A3 三点要求外还应该满足下面A4:</p>
<p>a. 签名不可被伪造，一旦被篡改即可发现</p>
<p>b. 任何人都可以验证将军签名的可靠性</p>
<blockquote>
<p>结论：对于任意n ，最多只有m个背叛者情况下，算法SM(m)能解决拜占庭将军问题。也就是说，在使用签名的情况下，书面协议可以打破三模冗余的僵局，使用了签名的情况下，只要知道了叛徒数量，我们就可以利用SM(m)算法解决拜占庭将军问题</p>
</blockquote>
<h2 id="书面协议算法SM-m"><a href="#书面协议算法SM-m" class="headerlink" title="书面协议算法SM(m)"></a>书面协议算法SM(m)</h2><p>算法SM(m)，不管将军总数n和叛徒数量m，只要采用该算法，忠诚的将军总能达到一致（满足IC1和IC2）。</p>
<p>我们用集合Vi来表示i将军收到的命令集，这是一个集合，也就是满足互异性（没有重复的元素）。</p>
<p>我们定义choice(V)函数来决定各个将军的选择，这个函数可以有非常多种形式，他只要满足了以下两个条件：</p>
<ul>
<li>如果集合V只包含了一个元素v，那么choice(V)&#x3D;v</li>
<li>choice(o)&#x3D;RETREAT，其中o是空集</li>
</ul>
<p>算法解释如下：</p>
<p>初始化Vi&#x3D;空集合。</p>
<p>①：司令官签署命令并发给每个将军</p>
<p>②：对于每个将军i :</p>
<p>​		A：如果将军i从发令者收到v:0的消息，且还没有收到其他命令序列，那么他</p>
<p>​			a:使Vi为{v}；</p>
<p>​			b:发送v:0:i给其他所有副官。</p>
<p>​		B：如果副官i收到了形如v:0:j1:…:jk的消息且v不在集合Vi中，那么他</p>
<p>​			a:添加v到Vi；</p>
<p>​			b:如果k&lt;m，那么发送v:0:j1:…:jk:i 给每个不在j1,..,jk 中的副官。</p>
<p>③：对于每个副官i，当他不再收到任何消息，则遵守命令choive(Vi)</p>
<p>值得注意的是，如果司令忠诚，由于其签名不可伪造，所有忠诚的副官都将得到一个单点集{v}，他们采用的命令集Vi相同，得到的choive(Vi)也为v，满足了IC1和IC2。</p>
<p>如果司令并非忠诚，只需要满足IC1，但是算法SM(m)使得所有忠诚的副官得到相同的Vi，使用choice()函数后采用的命令也就一定相同。</p>
<h2 id="书面协议推演"><a href="#书面协议推演" class="headerlink" title="书面协议推演"></a>书面协议推演</h2><p>司令是叛徒的状况稍难想象，举个例子，n&#x3D;3，m&#x3D;1，其中司令是叛徒，这是口头协议不能解决的状况。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnsks96hs5j31d40lgtai.jpg" alt="image-20210219091512270"></p>
<p>很显然，副官1得到的V1&#x3D;{A,R}，副官2得到相同的V2&#x3D;{A,R}。他们采用choice函数后得到的命令一定相同。</p>
<p>n&#x3D;4，m&#x3D;2，其中司令是叛徒，这同样是口头协议不能解决的状况。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnsl1kah3gj31ha0u0q6e.jpg" alt="image-20210219092409170"></p>
<p>副官1和副官2得到的V1&#x3D;V2&#x3D;{A,R}，他们采用choice函数后得到的命令也相同。</p>
<p>书面协议的本质就是引入了签名系统，这使得所有消息都可追本溯源。这一优势，大大节省了成本，他化解了口头协议中1&#x2F;3要求，只要采用了书面协议，忠诚的将军就可以达到一致（实现IC1和IC2）。这个效果是惊人的，相较之下口头协议则明显有一些缺陷。</p>
<p>书面协议的结论非常令人兴奋，这不是解决了拜占庭将军问题了吗？但请注意我们在A1-A4中实际上是添加了一些条件的，这使得拜占庭将军问题在这些假设下能够解决，但是在实际状况中却会有一些问题。观察A1~A4，我们做了一些在现实中比较难以完成的假设，比如没考虑传输信息的延迟时间，书面协议的签名体系难以实现，而且签名消息记录的保存难以摆脱一个中心化机构而独立存在。事实上，存在能够完美解决书面协议实际局限的方法就是区块链。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> <a href="https://people.eecs.berkeley.edu/~luca/cs174/byzantine.pdf">https://people.eecs.berkeley.edu/~luca/cs174/byzantine.pdf</a></p>
<p> <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">http://pmg.csail.mit.edu/papers/osdi99.pdf</a> </p>
<p> <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/thesis-mcastro.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2017/01/thesis-mcastro.pdf</a></p>
<p> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals.pdf</a></p>
<p> <a href="https://www.bilibili.com/video/BV1yJ411v7xV?from=search&seid=15267710534844183735">https://www.bilibili.com/video/BV1yJ411v7xV?from=search&amp;seid=15267710534844183735</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|pow算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_pow%E7%AE%97%E6%B3%95-1/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|pow算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn80djrtwej30d606tmxc.jpg" alt="f1"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工作量证明(<code>Proof Of Work</code>，简称<code>POW</code>)，简单理解就是一份证明，用来确认你做过一定量的工作。监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。比如现实生活中的毕业证、驾驶证等等，也是通过检验结果的方式（通过相关的考试）所取得的证明。</p>
<p>工作量证明系统（或者说协议、函数），是一种应对拒绝服务攻击和其他服务滥用的经济对策。它要求发起者进行一定量的运算，也就意味着需要消耗计算机一定的时间。这个概念由<strong>Cynthia Dwork</strong> 和<strong>Moni Naor</strong> 1993年在学术论文中首次提出。而工作量证明（<code>POW</code>）这个名词，则是在 1999 年 <strong>Markus Jakobsson</strong> 和<strong>Ari Juels</strong>的文章中才被真正提出。</p>
<h1 id="主流POW共识使用的哈希算法"><a href="#主流POW共识使用的哈希算法" class="headerlink" title="主流POW共识使用的哈希算法"></a>主流POW共识使用的哈希算法</h1><p>实际不同的<code>POW</code>共识的核心就是<strong>不同的哈希算法</strong>，已经有很多<code>Hash</code>函数被设计出来并广泛应用，不过Hash函数一般安全寿命都不长，被认为安全的算法往往没能使用多久就被成功攻击，新的更安全的算法相继被设计出来，而每一个被公认为安全可靠的算法都有及其严格的审计过程。在币圈中我们经常说某某币发明了某种算法，其实主要都是使用那些被认证过的安全算法，或是单独使用，或是排列组合使用。</p>
<h2 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h2><p><code>SHA-2</code>，名称来自于安全散列算法2（英语：<code>Secure Hash Algorithm 2</code>）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于<code>SHA</code>算法之一，是<code>SHA-1</code>的后继者。<code>SHA-2</code>下又可再分为六个不同的算法标准。包括了：<code>SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</code> </p>
<p>具体的算法解释请查看此文：<a href="https://github.com/blockchainGuide">区块链技术栈全景分析</a></p>
<h2 id="SCRYPT"><a href="#SCRYPT" class="headerlink" title="SCRYPT"></a>SCRYPT</h2><p><code>Scrypt</code>是内存依赖型的<code>POW</code>算法，莱特币采用此算法。第一个使用<code>Scrypt</code>算法的数字货币是<code>Tenebrix</code>，而后该算法被<strong>莱特币</strong>使用。莱特币创始人在莱特币创世帖中介绍了莱特币采用的共识机制，挖矿算法，发行总量，挖矿难度等相关重要信息。李启威说明了莱特币所使用的挖矿算法为数字货币<code>Tenebrix</code>所使用的<code>Scrypt</code>算法，是一种符合<code>PoW</code>共识机制的算法。<code>Scrypt</code>算法过程中也需要计算哈希值，但是，<code>Scrypt</code>计算过程中需要使用较多的内存资源。</p>
<p>其它使用Scrypt算法的数字货币还有数码币（<code>DigitalCoin</code>）、狗狗币（<code>DogeCoin</code>）、幸运币（<code>LuckyCoin</code>）、世界币（<code>WorldCoin</code>）等。</p>
<p>算法实现：<a href="https://www.imooc.com/article/50372">https://www.imooc.com/article/50372</a></p>
<h2 id="串联算法"><a href="#串联算法" class="headerlink" title="串联算法"></a>串联算法</h2><p>重新排列组合是人类一贯以来最常用的创新发明方法。很快，有人不满足于使用单一<code>Hash</code>函数，2013年7月，夸克币（<code>Quark</code>）发布，首创使用多轮<code>Hash</code>算法，看似高大上，其实很简单，就是对输入数据运算了9次<code>hash</code>函数，前一轮运算结果作为后一轮运算的输入。这9轮Hash共使用6种加密算法，分别为<code>BLAKE, BMW, GROESTL, JH, KECCAK和SKEIN</code>，这些都是公认的安全<code>Hash</code>算法，并且早已存在现成的实现代码。</p>
<p>这种多轮Hash一出现就给人造成直观上很安全很强大的感觉，追捧者无数。现今价格依然坚挺的达世币率先使用11种加密算法（<code>BLAKE, BMW, GROESTL, JH, KECCAK, SKEIN, LUFFA, CUBEHASH, SHAVITE, SIMD, ECHO</code>），美其名曰X11，紧接着X13，X15这一系列就有人开发出来了。</p>
<p>S系列算法实际是一种串联思路，只要其中一种算法被破解，整个算法就被破解了，好比一根链条，环环相扣，只要其中一环断裂，整个链条就一分为二。</p>
<h2 id="并联算法"><a href="#并联算法" class="headerlink" title="并联算法"></a>并联算法</h2><p><code>Heavycoin（HVC）</code>是第一个做了尝试的并联算法，其原理如下：</p>
<ol>
<li>对输入数据首先运行一次<code>HEFTY1</code>（一种<code>Hash</code>算法）运算，得到结果d1</li>
<li>以<code>d1</code>为输入，依次进行<code>SHA256</code>、<code>KECCAK512</code>、<code>GROESTL512</code>、<code>BLAKE512</code>运算，分别获得输出<code>d2</code>,<code>d3</code>,<code>d4</code>和<code>d5</code></li>
<li>分别提取<code>d2-d5</code>前64位，混淆后形成最终的<code>256</code>位Hash结果，作为区块ID。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn950ksww1j31e60fetfh.jpg" alt="image-20210202134353334"></p>
<p>之所以首先进行一轮<code>HEFTY1</code> 哈希，是因为HEFTY1 运算起来极其困难，其抵御矿机性能远超于<code>SCRYPT</code>。但与<code>SCRYPT</code>一样，安全性没有得到某个官方机构论证，于是加入后面的四种安全性已经得到公认的算法增强安全。</p>
<p>对比串联和并联的方法，<code>Quark、X11，X13</code>等虽使用了多种<code>HASH</code>函数，但这些算法都是简单的将多种<code>HASH</code>函数串联在一起，仔细思考，其实没有提高整体的抗碰撞性，其安全性更是因木桶效应而由其中安全最弱的算法支撑，其中任何一种<code>Hash</code>函数遭遇碰撞性攻击，都会危及货币系统的安全性。</p>
<p><code>HVC</code>从以上每种算法提取<code>64</code>位，经过融合成为最后的结果，实际上是将四种算法并联在一起，其中一种算法被破解只会危及其中<code>64</code>位，四中算法同时被破解才会危及货币系统的安全性。</p>
<h2 id="ETHASH"><a href="#ETHASH" class="headerlink" title="ETHASH"></a>ETHASH</h2><p>Ethash是以太坊上面使用的POW算法，具体的介绍可以查看此文（<strong>建议关注此公号</strong>）：<a href="https://mp.weixin.qq.com/s?__biz=MzU2MjY5MzcyMQ==&mid=2247484167&idx=1&sn=1cbec62883c0200c7be39e6986cd53e4&scene=19#wechat_redirect">死磕以太坊源码分析之ETHASH算法</a></p>
<h1 id="POW算法存在的问题"><a href="#POW算法存在的问题" class="headerlink" title="POW算法存在的问题"></a>POW算法存在的问题</h1><ol>
<li>算力竞争的设计导致了集中化的矿池：尽管PoW的目的是为了保证系统可以去中心化的运行，然而系统运行到现在，却事实上形成中心化程度很高的五大矿池。五大矿池垄断了世界上90%以上的算力，这可能导致大矿池破坏整个网络的行为</li>
<li>算力竞争的设计导致了大量的能源消耗： 另外，PoW系统需要产生大量的能源消耗：比特币挖矿比159个国家消耗的能源还多；目前77.7%的全球比特币网络算力仍在中国境内；受益于内蒙古和四川两地充沛的电力资源，中国拥有世界上最多的比特币矿场；到2019年7月，比特币网络将需要比美国目前的用电量更多的电力；到2020年2月，它将使用和今天全世界一样多的电力</li>
<li>业务处理性能低下：尽管投入了大量的能源支持系统的运行，但这些能源消耗绝大部份是用于工作量证明中的hash运算，处理交易业务的性能则非常低，例如比特币每秒只能进行大约7笔交易；以太坊每秒10-20笔。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://web.xidian.edu.cn/qqpei/files/Blockchain/2Crypto.pdf">https://web.xidian.edu.cn/qqpei/files/Blockchain/2Crypto.pdf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>POW</tag>
      </tags>
  </entry>
  <entry>
    <title>死磕共识算法|Paxos算法</title>
    <url>/2024/08/26/%E6%AD%BB%E7%A3%95%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95_Paxos%E7%AE%97%E6%B3%95-5/</url>
    <content><![CDATA[<blockquote>
<p>死磕共识算法|Paxos算法</p>
<p>配合以下代码进行阅读：<a href="https://github.com/blockchainGuide/">https://github.com/blockchainGuide/</a></p>
<p>写文不易，给个小关注，有什么问题可以指出，便于大家交流学习。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnuvfqrojoj312w0m8119.jpg" alt="b9a24d7b935c61ba4555b1ddc8159413"></p>
<h1 id="Paxos是什么"><a href="#Paxos是什么" class="headerlink" title="Paxos是什么"></a>Paxos是什么</h1><blockquote>
<p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p>
</blockquote>
<p><code>Paxos</code>由<code>Lamport</code>于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛<code>Paxos</code>作为比喻，描述了<code>Paxos</code>小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战性。后来在2001年，<code>Lamport</code>觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos Made Simple》。</p>
<p>自<code>Paxos</code>问世以来就持续垄断了分布式一致性算法，<code>Paxos</code>这个名词几乎等同于分布式一致性。<code>Google</code>的很多大型分布式系统都采用了<code>Paxos</code>算法来解决分布式一致性问题。</p>
<h1 id="Paxos相关概念"><a href="#Paxos相关概念" class="headerlink" title="Paxos相关概念"></a>Paxos相关概念</h1><p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即<strong>2F+1</strong>个节点的系统最多允许<strong>F</strong>个节点同时出现故障。</p>
<p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p>
<p>Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</p>
<ul>
<li><strong>Proposer</strong>: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>Acceptor</strong>：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li>
<li><strong>Learner</strong>：不参与决策，从Proposers&#x2F;Acceptors学习最新达成一致的提案（Value）。</li>
</ul>
<p>在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnuydua826j31gg0i6q5j.jpg" alt="image-20210221103652296"></p>
<h1 id="paxos算法流程"><a href="#paxos算法流程" class="headerlink" title="paxos算法流程"></a>paxos算法流程</h1><p>Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：</p>
<ol>
<li>第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</li>
<li>第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</li>
<li>第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnuyoi6keij318e0isady.jpg" alt="image-20210221104706981"></p>
<p>Paxos算法流程中的每条消息描述如下：</p>
<ul>
<li><strong>Prepare</strong>: Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。</li>
<li><strong>Promise</strong>: Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。</li>
</ul>
<p><strong>两个承诺：</strong></p>
<ol>
<li><p>不再接受Proposal ID小于等于（注意：这里是&lt;&#x3D; ）当前请求的Prepare请求。</p>
</li>
<li><p>不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。</p>
</li>
</ol>
<p><strong>一个应答：</strong></p>
<p>不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</p>
<ul>
<li><strong>Propose</strong>: Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。</li>
<li><strong>Accept</strong>: Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。</li>
<li><strong>Learn</strong>: Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。</li>
</ul>
<p>伪代码流程如下：</p>
<ol>
<li>获取一个Proposal ID n，为了<strong>保证Proposal ID唯一</strong>，可采用时间戳+Server ID生成；</li>
<li>Proposer向所有Acceptors广播Prepare(n)请求；</li>
<li>Acceptor比较n和minProposal，如果n&gt;minProposal，minProposal&#x3D;n，并且将 acceptedProposal 和 acceptedValue 返回；</li>
<li>Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value；</li>
<li>到这里可以进入第二阶段，广播Accept (n,value) 到所有节点；</li>
<li>Acceptor比较n和minProposal，如果n&gt;&#x3D;minProposal，则acceptedProposal&#x3D;minProposal&#x3D;n，acceptedValue&#x3D;value，本地持久化后，返回；否则，返回minProposal。</li>
<li>提议者接收到过半数请求后，如果发现有返回值result &gt;n，表示有更新的提议，跳转到1；否则value达成一致。</li>
</ol>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p><strong>案例①：</strong></p>
<p>图中P代表Prepare阶段，A代表Accept阶段。3.1代表Proposal ID为3.1，其中3为时间戳，1为Server ID。X和Y代表提议Value。</p>
<p>实例1中P 3.1达成多数派，其Value(X)被Accept，然后P 4.5学习到Value(X)，并Accept。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv264l27aj31ce0l4jy9.jpg" alt="image-20210221124740017"></p>
<p><strong>案例②：</strong></p>
<p>实例2中P 3.1没有被多数派Accept（只有S3 Accept），但是被P 4.5学习到，P 4.5将自己的Value由Y替换为X，Accept（X）。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv283ux5xj31bi0gydkn.jpg" alt="image-20210221124945254"></p>
<p><strong>案例③：</strong></p>
<p>实例3中P 3.1没有被多数派Accept（只有S1 Accept），同时也没有被P 4.5学习到。由于P 4.5 Propose的所有应答，均未返回Value，则P 4.5可以Accept自己的Value (Y)。后续P 3.1的Accept (X) 会失败，已经Accept的S1，会被覆盖。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv28vsafmj318q0fsjw8.jpg" alt="image-20210221125030450"></p>
<p>Paxos算法可能形成活锁而永远不会结束，如下图实例所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv29ol30oj319y0fyafm.jpg" alt="image-20210221125102677"></p>
<p>回顾两个承诺之一，Acceptor不再应答Proposal ID小于等于当前请求的Prepare请求。意味着需要应答Proposal ID大于当前请求的Prepare请求。</p>
<p>两个Proposers交替Prepare成功，而Accept失败，形成活锁（Livelock）。</p>
<h1 id="Multi-Paxos算法"><a href="#Multi-Paxos算法" class="headerlink" title="Multi-Paxos算法"></a>Multi-Paxos算法</h1><p>原始的Paxos算法（Basic Paxos）<strong>只能对一个值形成决议</strong>，决议的形成至少需要两次网络来回，在高并发情况下可能需要更多的网络来回，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos搞不定了。因此Basic Paxos几乎只是用来做理论研究，并不直接应用在实际工程中。</p>
<p><strong>实际应用中几乎都需要连续确定多个值，而且希望能有更高的效率。Multi-Paxos正是为解决此问题而提出</strong>。Multi-Paxos基于Basic Paxos做了两点改进：</p>
<ol>
<li>针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。</li>
<li>在所有Proposers中选举一个Leader，由Leader唯一地提交Proposal给Acceptors进行表决。这样<strong>没有Proposer竞争</strong>，解决了活锁问题。在系统中仅有一个Leader进行Value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv2e0hvd4j31bs0i00wn.jpg" alt="image-20210221125526065"></p>
<p>Multi-Paxos首先需要选举Leader，Leader的确定也是一次决议的形成，所以可执行一次Basic Paxos实例来选举出一个Leader。选出Leader之后只能由Leader提交Proposal，在Leader宕机之后服务临时不可用，需要重新选举Leader继续服务。在系统中仅有一个Leader进行Proposal提交的情况下，Prepare阶段可以跳过。</p>
<p>Multi-Paxos通过改变Prepare阶段的作用范围至后面Leader提交的所有实例，从而使得Leader的连续提交只需要执行一次Prepare阶段，后续只需要执行Accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个Instance ID标识，Instance ID由Leader本地递增生成即可。</p>
<p>Multi-Paxos允许有多个自认为是Leader的节点并发提交Proposal而不影响其安全性，这样的场景即退化为Basic Paxos。</p>
<h1 id="Paxos推导过程"><a href="#Paxos推导过程" class="headerlink" title="Paxos推导过程"></a>Paxos推导过程</h1><h2 id="只有一个Acceptor"><a href="#只有一个Acceptor" class="headerlink" title="只有一个Acceptor"></a>只有一个Acceptor</h2><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。</p>
<p>但是，如果这个唯一的Acceptor宕机了，那么整个系统就<strong>无法工作</strong>了！</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv2lac3xej313w0gowge.jpg" alt="image-20210221130224968"></p>
<h2 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h2><p>多个<code>Acceptor</code>需要保证在多个<code>Proposer</code>和多个<code>Acceptor</code>的情况下选定一个<code>value</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv2q6ctcqj31b80i8415.jpg" alt="image-20210221130706677"></p>
<p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。</p>
<p>那么，就得到下面的约束：</p>
<blockquote>
<p>P1：一个Acceptor必须接受它收到的第一个提案。</p>
</blockquote>
<p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv30tvh7ij31dy0pcju7.jpg" alt="image-20210221131721430"></p>
<p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>规定：一个提案被选定需要被<strong>半数以上</strong>的Acceptor接受</p>
</blockquote>
<p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。</p>
<p>最开始讲的『<strong>提案&#x3D;value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案&#x3D;提案编号+value</strong>』。</p>
<p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。</p>
<p>于是有了下面的约束：</p>
<blockquote>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor25（半数以上）均接受了该提案，于是对于Acceptor25和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p>
<ol>
<li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li>
<li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnv3f3co1cj31gs0pk77y.jpg" alt="image-20210221133102803"></p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
</blockquote>
<p>由P2b可以推出P2a进而推出P2。</p>
<p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p>
<p>只要满足P2c即可：</p>
<blockquote>
<p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p>
</blockquote>
<ul>
<li>S中每个Acceptor都没有接受过编号小于N的提案。</li>
<li>S中Acceptor接受过的最大编号的提案的value为V。</li>
</ul>
<h2 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h2><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p>
<p>于是我们得到了如下的<strong>提案生成算法</strong>：</p>
<ol>
<li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。<br>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</p>
<p>我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。</p>
</li>
<li><p>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]<strong>。这里的V是所有的响应中</strong>编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>。<br>生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</p>
</li>
</ol>
<h2 id="为什么需要-Propose-阶段"><a href="#为什么需要-Propose-阶段" class="headerlink" title="为什么需要 Propose 阶段"></a>为什么需要 Propose 阶段</h2><p>因为对 paxos 来说，是假定一个集群中会有多个paxos instance（也就是多个提案）同时存在竞争的（并发冲突）。那么 propose 阶段就是选择出需要进行投票的paxos instance。如果能够保证只有一个paxos instance，那么就无需 propose 阶段了，直接进行accept即可。所以对于multi-paxos中，存在一个leader，可以控制每个时刻只有一个paxos instance在集群中，所以不需要propose阶段，只需要执行accept阶段即可。</p>
<p>这里就相当于一个add 1 的paxos instance，一个 delete key 的paxos instance。只有当整个集群指定的 paxos instance 的顺序是相同的，也就是，也就是每个节点都是先add 1，然后在 delete key，或者先delete key，再add 1，最后的数据才会一致。它本质上解决的就是有多个议案的情况下， 达成一个一致的议案，例如，一群人决定聚餐，有想吃鱼的，想吃火锅的，这样多个决议进行 paxos 提案投票，就会得到一个一致的聚餐结果。如果没有多个决议，只有一个决议，那就不会冲突，直接accept投票即可。</p>
<p><strong>Paxos Propose 的意义</strong></p>
<ol>
<li><strong>Block old proposals</strong></li>
<li><strong>Find out about (possibly) accepted values</strong></li>
</ol>
<h2 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h2><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p>
<p>我们对Acceptor接受提案给出如下约束：</p>
<blockquote>
<p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p>
</blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p>
<p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p> <a href="https://github.com/blockchainGuide">https://github.com/blockchainGuide</a></p>
<p> 公号：区块链技术栈</p>
<p> <a href="http://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95">http://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95</a></p>
<p> <a href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a></p>
<p> <a href="https://zhuanlan.zhihu.com/p/31780743">https://zhuanlan.zhihu.com/p/31780743</a></p>
<p> <a href="https://www.jianshu.com/go-wild?ac=2&url=https://blog.csdn.net/sparkliang/article/details/5740882">https://www.jianshu.com/go-wild?ac=2&amp;url=https%3A%2F%2Fblog.csdn.net%2Fsparkliang%2Farticle%2Fdetails%2F5740882</a></p>
<p> <a href="https://www.jianshu.com/go-wild?ac=2&url=http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">https://www.jianshu.com/go-wild?ac=2&amp;url=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Fpaxos-simple.pdf</a></p>
<p> <a href="https://www.jianshu.com/go-wild?ac=2&url=https://en.wikipedia.org/wiki/Paxos_(computer_science)">https://www.jianshu.com/go-wild?ac=2&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPaxos_%28computer_science%29</a></p>
<p> <a href="https://www.jianshu.com/p/06a477a576bf">https://www.jianshu.com/p/06a477a576bf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>共识算法</category>
      </categories>
      <tags>
        <tag>共识算法</tag>
        <tag>Paxos</tag>
      </tags>
  </entry>
</search>
