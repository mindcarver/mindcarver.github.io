---
layout: default
section: Week6
title: 01-滚动重训练基础
---

# 01. 滚动重训练基础 🔄

> "模型不是一劳永逸的神器，而是需要持续陪伴的伙伴！" ~ 某位量化老法师

## 🤔 为什么需要滚动重训练？

想象一下，你用2018-2020年的数据训练了一个模型，然后一直用它预测2024年的市场...

```python
# 😱 危险操作示例
def dangerous_model():
    # 只训练一次，就用一辈子
    model = train(data_2018_2020)
    
    # 2024年还在用老模型...
    prediction_2024 = model.predict(market_2024)  # 💥 悲剧发生了
```

结果会怎样？

### 市场在变，模型也要变！🌊

**1. 市场环境变化**
```
2019年: 美股牛市，科技股一飞冲天 🚀
2020年: 疫情恐慌，市场大起大落 📉📈
2021年: 通胀担忧，风格切换 🔄
2022年: 加息周期，成长股受挫 📉
2023年: AI爆发，科技股复活 🤖
2024年: ... (谁知道呢？🤷)
```

每个时期的市场特征都不一样，老模型能适应新市场吗？❌

**2. 概念漂移 (Concept Drift)**

什么是概念漂移？简单说就是：**过去有效的方法，现在不一定有效了**。

```python
# 概念漂移的数学表达
$$ P(Y|X, t_1) \neq P(Y|X, t_2) $$

# t1时刻的X和Y的关系 ≠ t2时刻的X和Y的关系
```

**举个栗子** 🌰：
- 2019年：动量因子非常有效
- 2022年：动量因子失效，反而反转因子有效
- 如果一直用2019年的模型，2022年就会亏得很惨

**3. 新数据出现**

市场永远有新鲜事：

```python
new_phenomena = [
    "ChatGPT横空出世 🤖",
    "FTX暴雷事件 💥",
    "中国版ChatGPT上线 🇨🇳",
    "美联储政策转向 📊",
    "ESG投资兴起 🌱"
]
```

老模型从来没见过这些新数据，预测能准吗？🤔

**4. 模型老化**

就像人会变老一样，模型也会"老化"：

```python
# 模型生命周期的比喻
def model_lifecycle():
    birth = "训练完成"      # 新生儿，潜力无限 👶
    peak = "发布初期"      # 青年，意气风发 💪
    plateau = "使用中期"   # 中年，开始衰退 📉
    decline = "使用后期"   # 老年，力不从心 👴
    death = "完全失效"    # 终结，需要重训 💀
```

**总结**：固定模型 = 等死 ❌
**滚动重训练** = 持续进化 ✅

---

## 🧠 滚动训练原理

### 时间轴的概念

让我们用时间线来理解滚动重训练：

```
时间轴: ───────────────────────────────────────→ t
        |-------|-------|-------|-------|-------|
       W1      W2      W3      W4      W5      W6
        ↑       ↑       ↑       ↑       ↑
       训练   训练    训练    训练    训练
       窗口   窗口    窗口    窗口    窗口
       
预测期: ────────────────→
        |-------|-------|-------|
        预测   预测    预测
        W1→W2  W2→W3  W3→W4
```

### 滚动窗口示意图

```python
# 训练窗口 + 预测窗口
Training Window (W) = [t-start, t-end]
Prediction Window (P) = [t-end, t-end+P]

# 滚动过程
Round 1: Train[t0:t1] → Predict[t1:t2]
Round 2: Train[t1:t2] → Predict[t2:t3]
Round 3: Train[t2:t3] → Predict[t3:t4]
...
```

### 关键参数

**1. 训练窗口大小 (Window Size, W)**
```python
window_size = "历史数据长度"
# W大: 包含更多信息，但可能包含过时的模式
# W小: 反应更灵敏，但可能不稳定
```

**2. 滚动步长 (Rolling Step, S)**
```python
rolling_step = "每次移动的距离"
# S = P: 每次预测后重新训练（最常见）
# S < P: 可以覆盖预测期（用于实时交易）
# S > P: 有跳过的时间段
```

**3. 预测期长度 (Prediction Horizon, P)**
```python
prediction_horizon = "模型有效期"
# P长: 减少训练频率，降低计算成本
# P短: 更频繁重训，适应市场变化更快
```

---

## 🎛️ 训练窗口设计

### 窗口大小选择原则

这是一个艺术和科学的结合！🎨🔬

**经验法则**：

```python
# 不同策略的建议窗口大小
window_guidelines = {
    "高频交易": "1-3个月",     # 市场变化快，窗口要短
    "中频交易": "6-12个月",   # 平衡
    "低频交易": "1-2年",      # 捕捉长期模式
    "宏观策略": "3-5年",      # 经济周期长
}

# 数学表达
$$ W = f(\text{市场波动率}, \text{策略周期}, \text{计算资源}) $$
```

### 影响因素分析

**1. 市场变化速度** 🏃💨

```python
def adjust_window_speed(market_regime):
    if market_regime == "高速变化期":
        window = 6  # 6个月，快速适应
    elif market_regime == "平稳期":
        window = 24 # 24个月，学习长期模式
    else:
        window = 12 # 默认12个月
    return window
```

**2. 策略类型差异** ♟️

| 策略类型 | 推荐窗口 | 原因 |
|---------|---------|------|
| 动量策略 | 6-12个月 | 动量效应是中短期现象 |
| 价值策略 | 12-24个月 | 价值回归需要时间 |
| 事件驱动 | 3-6个月 | 事件影响短期有效 |
| 统计套利 | 3-6个月 | 价差回归较快 |

**3. 计算资源限制** 💻

```python
# 计算成本与窗口大小的关系
def training_cost(window_size):
    return window_size * cost_per_data_point

# 实际考虑
- 窗口越大 = 训练越慢 = 重训间隔越长
- 如果训练需要2小时，你不可能每天重训
- 需要在"反应速度"和"计算成本"间平衡 ⚖️
```

**4. 过拟合风险** 🚨

```python
# 窗口大小与过拟合的关系
window_size = 60 # 60个月数据
model_params = 1000 # 1000个参数

ratio = window_size * 252 / model_params
# ratio < 20: 过拟合风险高 ❌
# ratio > 100: 过拟合风险低 ✅
```

### 实际案例

**案例1：A股市场**

```python
# A股特征
# - 年化波动率: 20-30%
# - 牛熊周期: 2-4年
# - 政策影响大

# 推荐配置
window_size = 12   # 12个月
rolling_step = 1   # 每月重训
prediction_horizon = 1 # 预测1个月
```

**案例2：美股市场**

```python
# 美股特征
# - 年化波动率: 15-20%
# - 牛熊周期: 5-7年
# - 相对稳定

# 推荐配置
window_size = 24   # 24个月
rolling_step = 1   # 每月重训
prediction_horizon = 1 # 预测1个月
```

**案例3：加密货币市场**

```python
# 加密货币特征
# - 年化波动率: 80-150%
# - 没有传统周期
# - 极度不稳定

# 推荐配置
window_size = 3    # 3个月
rolling_step = 0.5 # 每半个月重训
prediction_horizon = 0.5 # 预测半个月
```

---

## 📊 滚动重训练的类型

### 1. 固定窗口滚动训练 (Fixed Window)

```python
# 最常见的方式
def fixed_window_rolling(train_data):
    window_size = 12  # 固定12个月
    
    for i in range(start, end, step):
        # 每次使用固定大小的窗口
        train_window = train_data[i:i+window_size]
        model = train(train_window)
        predictions = model.predict(test_data)
```

**优点**：简单，稳定，容易理解
**缺点**：窗口边界可能截断重要模式

### 2. 扩展窗口滚动训练 (Expanding Window)

```python
# 每次窗口变长
def expanding_window_rolling(train_data):
    for i in range(start, end, step):
        # 每次从起点开始，包含所有历史数据
        train_window = train_data[start:i]
        model = train(train_window)
        predictions = model.predict(test_data)
```

**优点**：利用所有历史信息
**缺点**：计算成本越来越高，早期数据可能过时

### 3. 混合窗口滚动训练 (Hybrid Window)

```python
# 结合两者的优点
def hybrid_window_rolling(train_data):
    min_size = 12
    max_size = 36
    
    for i in range(start, end, step):
        # 窗口在min_size和max_size之间
        window_start = max(start, i - max_size)
        train_window = train_data[window_start:i]
        
        # 确保至少有min_size的数据
        if len(train_window) >= min_size:
            model = train(train_window)
            predictions = model.predict(test_data)
```

**优点**：平衡了"信息量"和"时效性"
**缺点**：需要调整两个参数，稍微复杂

---

## 💡 最佳实践建议

### 🎯 黄金法则

```python
# 1. 从简单开始
start_with_fixed_window = True  # 先用固定窗口

# 2. 定期评估窗口效果
evaluate_every = "每个月"
metrics_to_check = ["IC", "RankIC", "收益"]

# 3. 动态调整窗口
def adaptive_window(performance):
    if performance < threshold:
        # 效果不好，缩短窗口，更快适应
        return window_size * 0.8
    else:
        # 效果好，保持或略微延长
        return window_size * 1.0

# 4. 记录所有实验
log_experiments = {
    "window_size": window_size,
    "ic": ic_values,
    "returns": returns,
    "timestamp": now()
}
```

### ⚠️ 常见陷阱

**陷阱1：窗口太小**
```python
window_size = 1  # 太小了！
# 问题：数据不够，模型学不到东西
# 后果：模型不稳定，预测随机
```

**陷阱2：窗口太大**
```python
window_size = 120  # 10年，太大了！
# 问题：包含太多过时信息
# 后果：模型反应迟钝，错过新机会
```

**陷阱3：固定窗口从不调整**
```python
# 一成不变
window_size = 12
for year in range(2010, 2024):
    # 不管市场怎么变，都用12个月窗口
    train(data[:12])
# 问题：市场环境变了，窗口也该变
```

**陷阱4：忽略数据质量**
```python
# 暴力使用所有数据
window = data[start:end]  # 包含错误数据？
# 问题：脏数据影响模型
# 解决：数据清洗 + 异常值处理
```

---

## 🎬 本节小结

**核心要点**：

1. ✅ 市场在变，模型必须跟着变
2. ✅ 滚动重训练是保持模型活力的关键
3. ✅ 窗口大小需要根据市场、策略、资源综合考虑
4. ✅ 没有万能的窗口大小，需要持续优化

**关键公式**：

$$ \text{最佳窗口} = f(\text{市场波动率}, \text{策略周期}, \text{计算资源}) $$

**下一步**：理论明白了，接下来看看怎么**实现**滚动重训练！

[→ 前往 02-滚动重训练实现](02-滚动重训练实现.md)

---

**💪 加油！你已经掌握了滚动重训练的核心思想，下节课就要动手写代码了！**
