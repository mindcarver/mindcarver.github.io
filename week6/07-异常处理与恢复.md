---
layout: default
section: Week6
title: 07-å¼‚å¸¸å¤„ç†ä¸æ¢å¤
---

# 07. å¼‚å¸¸å¤„ç†ä¸æ¢å¤ ğŸš¨

> "ä¸æ€•ä¸€ä¸‡ï¼Œå°±æ€•ä¸‡ä¸€" ~ ä¸­å›½è°šè¯­

åœ¨é‡åŒ–äº¤æ˜“ä¸­ï¼Œ**å¼‚å¸¸æƒ…å†µéšæ—¶å¯èƒ½å‘ç”Ÿ**ã€‚ä¸€ä¸ªå¥å£®çš„ç³»ç»Ÿå¿…é¡»èƒ½å¤Ÿ**è¯†åˆ«ã€å¤„ç†å’Œä»å¼‚å¸¸ä¸­æ¢å¤**ï¼

---

## ğŸ” å¼‚å¸¸ç±»å‹è¯†åˆ«

### æ•°æ®å¼‚å¸¸

```python
import numpy as np
import pandas as pd
from typing import Tuple, List

class DataAnomalyDetector:
    """æ•°æ®å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self, thresholds: dict = None):
        """
        åˆå§‹åŒ–å¼‚å¸¸æ£€æµ‹å™¨
        
        Args:
            thresholds: å¼‚å¸¸é˜ˆå€¼å­—å…¸
        """
        self.thresholds = thresholds or {
            'missing_rate': 0.5,      # ç¼ºå¤±ç‡é˜ˆå€¼
            'outlier_ratio': 0.3,     # å¼‚å¸¸å€¼æ¯”ä¾‹é˜ˆå€¼
            'zero_ratio': 0.9,        # é›¶å€¼æ¯”ä¾‹é˜ˆå€¼
            'constant_ratio': 0.95    # å¸¸æ•°æ¯”ä¾‹é˜ˆå€¼
        }
        self.anomaly_history = []
    
    def detect_missing(self, data: pd.DataFrame) -> Tuple[bool, pd.Series]:
        """
        æ£€æµ‹ç¼ºå¤±å€¼
        
        Args:
            data: æ•°æ®
            
        Returns:
            æ˜¯å¦å¼‚å¸¸, ç¼ºå¤±ç‡Series
        """
        missing_rate = data.isna().sum() / len(data)
        
        is_anomaly = (missing_rate > self.thresholds['missing_rate']).any()
        
        if is_anomaly:
            print(f"âš ï¸ ç¼ºå¤±å€¼å¼‚å¸¸æ£€æµ‹:")
            print(f"  ç¼ºå¤±ç‡é˜ˆå€¼: {self.thresholds['missing_rate']:.1%}")
            for col, rate in missing_rate.items():
                if rate > self.thresholds['missing_rate']:
                    print(f"  {col}: {rate:.1%} (è¶…è¿‡é˜ˆå€¼)")
        
        return is_anomaly, missing_rate
    
    def detect_outliers(self, data: pd.Series, 
                       method: str = 'iqr') -> Tuple[bool, np.ndarray]:
        """
        æ£€æµ‹å¼‚å¸¸å€¼
        
        Args:
            data: æ•°æ®Series
            method: æ£€æµ‹æ–¹æ³• ('iqr', 'zscore')
            
        Returns:
            æ˜¯å¦å¼‚å¸¸, å¼‚å¸¸å€¼ç´¢å¼•æ•°ç»„
        """
        if method == 'iqr':
            # IQRæ–¹æ³•
            Q1 = data.quantile(0.25)
            Q3 = data.quantile(0.75)
            IQR = Q3 - Q1
            
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            
            outlier_mask = (data < lower_bound) | (data > upper_bound)
        
        elif method == 'zscore':
            # Z-scoreæ–¹æ³•
            z_scores = np.abs((data - data.mean()) / data.std())
            outlier_mask = z_scores > 3
        
        else:
            raise ValueError(f"æœªçŸ¥çš„æ£€æµ‹æ–¹æ³•: {method}")
        
        outlier_ratio = outlier_mask.sum() / len(data)
        is_anomaly = outlier_ratio > self.thresholds['outlier_ratio']
        
        if is_anomaly:
            print(f"âš ï¸ å¼‚å¸¸å€¼æ£€æµ‹ ({method}):")
            print(f"  å¼‚å¸¸å€¼æ¯”ä¾‹: {outlier_ratio:.1%}")
            print(f"  å¼‚å¸¸å€¼æ•°é‡: {outlier_mask.sum()}")
        
        return is_anomaly, outlier_mask
    
    def detect_zeros(self, data: pd.Series) -> Tuple[bool, float]:
        """
        æ£€æµ‹è¿‡å¤šé›¶å€¼
        
        Args:
            data: æ•°æ®Series
            
        Returns:
            æ˜¯å¦å¼‚å¸¸, é›¶å€¼æ¯”ä¾‹
        """
        zero_ratio = (data == 0).sum() / len(data)
        is_anomaly = zero_ratio > self.thresholds['zero_ratio']
        
        if is_anomaly:
            print(f"âš ï¸ é›¶å€¼å¼‚å¸¸æ£€æµ‹:")
            print(f"  é›¶å€¼æ¯”ä¾‹: {zero_ratio:.1%}")
        
        return is_anomaly, zero_ratio
    
    def detect_constant(self, data: pd.Series) -> Tuple[bool, bool]:
        """
        æ£€æµ‹å¸¸æ•°å€¼
        
        Args:
            data: æ•°æ®Series
            
        Returns:
            æ˜¯å¦å¼‚å¸¸, æ˜¯å¦æ˜¯å¸¸æ•°
        """
        n_unique = data.nunique()
        is_constant = n_unique == 1
        
        constant_ratio = (data == data.iloc[0]).sum() / len(data)
        is_anomaly = constant_ratio > self.thresholds['constant_ratio']
        
        if is_anomaly:
            print(f"âš ï¸ å¸¸æ•°å€¼æ£€æµ‹:")
            print(f"  å”¯ä¸€å€¼æ•°é‡: {n_unique}")
            print(f"  å¸¸æ•°æ¯”ä¾‹: {constant_ratio:.1%}")
        
        return is_anomaly, is_constant
    
    def detect_all(self, data: pd.DataFrame) -> dict:
        """
        æ£€æµ‹æ‰€æœ‰æ•°æ®å¼‚å¸¸
        
        Args:
            data: æ•°æ®
            
        Returns:
            å¼‚å¸¸æ£€æµ‹ç»“æœå­—å…¸
        """
        results = {
            'has_anomaly': False,
            'anomalies': []
        }
        
        # æ£€æµ‹ç¼ºå¤±å€¼
        has_missing, missing_rate = self.detect_missing(data)
        if has_missing:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'missing',
                'details': missing_rate.to_dict()
            })
        
        # æ£€æµ‹æ¯åˆ—çš„å¼‚å¸¸
        for col in data.columns:
            series = data[col].dropna()
            
            # æ£€æµ‹å¼‚å¸¸å€¼
            has_outliers, outlier_mask = self.detect_outliers(series)
            if has_outliers:
                results['has_anomaly'] = True
                results['anomalies'].append({
                    'type': 'outlier',
                    'column': col,
                    'count': outlier_mask.sum()
                })
            
            # æ£€æµ‹é›¶å€¼
            has_zeros, zero_ratio = self.detect_zeros(series)
            if has_zeros:
                results['has_anomaly'] = True
                results['anomalies'].append({
                    'type': 'zeros',
                    'column': col,
                    'ratio': zero_ratio
                })
            
            # æ£€æµ‹å¸¸æ•°å€¼
            is_constant_anomaly, is_constant = self.detect_constant(series)
            if is_constant_anomaly:
                results['has_anomaly'] = True
                results['anomalies'].append({
                    'type': 'constant',
                    'column': col
                })
        
        # è®°å½•å†å²
        self.anomaly_history.append({
            'timestamp': pd.Timestamp.now(),
            'results': results
        })
        
        return results
```

### æ¨¡å‹å¼‚å¸¸

```python
class ModelAnomalyDetector:
    """æ¨¡å‹å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self, ic_threshold=0.02, rank_ic_threshold=0.03):
        """
        åˆå§‹åŒ–æ¨¡å‹å¼‚å¸¸æ£€æµ‹å™¨
        
        Args:
            ic_threshold: ICé˜ˆå€¼
            rank_ic_threshold: Rank ICé˜ˆå€¼
        """
        self.ic_threshold = ic_threshold
        self.rank_ic_threshold = rank_ic_threshold
        self.history = []
    
    def detect_performance_degradation(self, 
                                       current_ic: float,
                                       current_rank_ic: float,
                                       window_ic: list) -> dict:
        """
        æ£€æµ‹æ€§èƒ½ä¸‹é™
        
        Args:
            current_ic: å½“å‰IC
            current_rank_ic: å½“å‰Rank IC
            window_ic: çª—å£ICåˆ—è¡¨
            
        Returns:
            å¼‚å¸¸æ£€æµ‹ç»“æœ
        """
        results = {
            'has_anomaly': False,
            'anomalies': []
        }
        
        # æ£€æµ‹ICè¿‡ä½
        if current_ic < self.ic_threshold:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'ic_too_low',
                'current_ic': current_ic,
                'threshold': self.ic_threshold
            })
            print(f"âš ï¸ ICè¿‡ä½: {current_ic:.4f} < {self.ic_threshold}")
        
        # æ£€æµ‹Rank ICè¿‡ä½
        if current_rank_ic < self.rank_ic_threshold:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'rank_ic_too_low',
                'current_rank_ic': current_rank_ic,
                'threshold': self.rank_ic_threshold
            })
            print(f"âš ï¸ Rank ICè¿‡ä½: {current_rank_ic:.4f} < {self.rank_ic_threshold}")
        
        # æ£€æµ‹ICæŒç»­ä¸‹é™
        if len(window_ic) >= 5:
            recent_trend = np.polyfit(range(len(window_ic)), window_ic, 1)[0]
            if recent_trend < -0.01:  # ICæŒç»­å¿«é€Ÿä¸‹é™
                results['has_anomaly'] = True
                results['anomalies'].append({
                    'type': 'ic_declining',
                    'trend': recent_trend
                })
                print(f"âš ï¸ ICæŒç»­ä¸‹é™: è¶‹åŠ¿={recent_trend:.4f}")
        
        # è®°å½•å†å²
        self.history.append({
            'timestamp': pd.Timestamp.now(),
            'current_ic': current_ic,
            'current_rank_ic': current_rank_ic,
            'results': results
        })
        
        return results
    
    def detect_prediction_anomaly(self, predictions: np.ndarray,
                                  historical_preds: list) -> dict:
        """
        æ£€æµ‹é¢„æµ‹å¼‚å¸¸
        
        Args:
            predictions: å½“å‰é¢„æµ‹
            historical_preds: å†å²é¢„æµ‹åˆ—è¡¨
            
        Returns:
            å¼‚å¸¸æ£€æµ‹ç»“æœ
        """
        results = {
            'has_anomaly': False,
            'anomalies': []
        }
        
        # æ£€æµ‹é¢„æµ‹åˆ†å¸ƒçªå˜
        if len(historical_preds) > 0:
            historical_mean = np.mean([np.mean(pred) for pred in historical_preds])
            current_mean = np.mean(predictions)
            
            # å¦‚æœå‡å€¼åç¦»è¶…è¿‡3ä¸ªæ ‡å‡†å·®
            historical_std = np.std([np.mean(pred) for pred in historical_preds])
            
            if historical_std > 0:
                z_score = abs(current_mean - historical_mean) / historical_std
                if z_score > 3:
                    results['has_anomaly'] = True
                    results['anomalies'].append({
                        'type': 'prediction_mean_shift',
                        'current_mean': current_mean,
                        'historical_mean': historical_mean,
                        'z_score': z_score
                    })
                    print(f"âš ï¸ é¢„æµ‹å‡å€¼çªå˜: z-score={z_score:.2f}")
        
        # æ£€æµ‹é¢„æµ‹æ–¹å·®å¼‚å¸¸
        pred_std = np.std(predictions)
        if pred_std < 0.001:  # æ–¹å·®è¿‡å°ï¼ˆé¢„æµ‹å‡ ä¹ç›¸åŒï¼‰
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'prediction_variance_too_low',
                'std': pred_std
            })
            print(f"âš ï¸ é¢„æµ‹æ–¹å·®è¿‡å°: {pred_std:.6f}")
        
        return results
```

### ç³»ç»Ÿå¼‚å¸¸

```python
class SystemAnomalyDetector:
    """ç³»ç»Ÿå¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self, latency_threshold=5.0, 
                 memory_threshold=8192,  # MB
                 cpu_threshold=90):  # %
        """
        åˆå§‹åŒ–ç³»ç»Ÿå¼‚å¸¸æ£€æµ‹å™¨
        
        Args:
            latency_threshold: å»¶è¿Ÿé˜ˆå€¼ï¼ˆç§’ï¼‰
            memory_threshold: å†…å­˜é˜ˆå€¼ï¼ˆMBï¼‰
            cpu_threshold: CPUé˜ˆå€¼ï¼ˆ%ï¼‰
        """
        self.latency_threshold = latency_threshold
        self.memory_threshold = memory_threshold
        self.cpu_threshold = cpu_threshold
        self.history = []
    
    def detect_latency_anomaly(self, latency: float) -> dict:
        """
        æ£€æµ‹å»¶è¿Ÿå¼‚å¸¸
        
        Args:
            latency: å»¶è¿Ÿï¼ˆç§’ï¼‰
            
        Returns:
            å¼‚å¸¸æ£€æµ‹ç»“æœ
        """
        results = {
            'has_anomaly': False,
            'anomalies': []
        }
        
        if latency > self.latency_threshold:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'latency_too_high',
                'latency': latency,
                'threshold': self.latency_threshold
            })
            print(f"âš ï¸ å»¶è¿Ÿè¿‡é«˜: {latency:.2f}s > {self.latency_threshold}s")
        
        return results
    
    def detect_resource_anomaly(self) -> dict:
        """
        æ£€æµ‹èµ„æºå¼‚å¸¸ï¼ˆCPUã€å†…å­˜ï¼‰
        
        Returns:
            å¼‚å¸¸æ£€æµ‹ç»“æœ
        """
        import psutil
        
        results = {
            'has_anomaly': False,
            'anomalies': []
        }
        
        # æ£€æµ‹CPUä½¿ç”¨ç‡
        cpu_percent = psutil.cpu_percent(interval=1)
        if cpu_percent > self.cpu_threshold:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'cpu_too_high',
                'cpu_percent': cpu_percent,
                'threshold': self.cpu_threshold
            })
            print(f"âš ï¸ CPUä½¿ç”¨ç‡è¿‡é«˜: {cpu_percent}% > {self.cpu_threshold}%")
        
        # æ£€æµ‹å†…å­˜ä½¿ç”¨
        memory_info = psutil.virtual_memory()
        memory_used_mb = memory_info.used / 1024 / 1024
        
        if memory_used_mb > self.memory_threshold:
            results['has_anomaly'] = True
            results['anomalies'].append({
                'type': 'memory_too_high',
                'memory_mb': memory_used_mb,
                'threshold': self.memory_threshold
            })
            print(f"âš ï¸ å†…å­˜ä½¿ç”¨è¿‡é«˜: {memory_used_mb:.0f}MB > {self.memory_threshold}MB")
        
        return results
```

---

## ğŸ› ï¸ å¼‚å¸¸å¤„ç†ç­–ç•¥

### é‡è¯•æœºåˆ¶ (Retry Mechanism)

```python
import time
from functools import wraps

def retry(max_attempts=3, delay=1, backoff=2, 
          exceptions=(Exception,)):
    """
    é‡è¯•è£…é¥°å™¨
    
    Args:
        max_attempts: æœ€å¤§å°è¯•æ¬¡æ•°
        delay: åˆå§‹å»¶è¿Ÿï¼ˆç§’ï¼‰
        backoff: å»¶è¿Ÿå€æ•°
        exceptions: éœ€è¦é‡è¯•çš„å¼‚å¸¸ç±»å‹
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            current_delay = delay
            
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                
                except exceptions as e:
                    attempts += 1
                    
                    if attempts >= max_attempts:
                        print(f"âŒ é‡è¯•å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§å°è¯•æ¬¡æ•°: {max_attempts}")
                        raise
                    
                    print(f"âš ï¸ å°è¯• {attempts}/{max_attempts} å¤±è´¥ï¼Œ{current_delay}ç§’åé‡è¯•...")
                    time.sleep(current_delay)
                    current_delay *= backoff
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@retry(max_attempts=3, delay=1, backoff=2, exceptions=(ConnectionError, TimeoutError))
def fetch_data_with_retry(url):
    """å¸¦é‡è¯•çš„æ•°æ®è·å–"""
    import requests
    
    response = requests.get(url, timeout=10)
    response.raise_for_status()
    
    return response.json()
```

### é™çº§ç­–ç•¥ (Fallback Strategy)

```python
class FallbackStrategy:
    """é™çº§ç­–ç•¥"""
    
    def __init__(self):
        """åˆå§‹åŒ–é™çº§ç­–ç•¥"""
        self.primary_function = None
        self.fallback_function = None
    
    def set_primary(self, func):
        """è®¾ç½®ä¸»è¦å‡½æ•°"""
        self.primary_function = func
        return self
    
    def set_fallback(self, func):
        """è®¾ç½®é™çº§å‡½æ•°"""
        self.fallback_function = func
        return self
    
    def execute(self, *args, **kwargs):
        """
        æ‰§è¡Œå‡½æ•°ï¼Œå¦‚æœå¤±è´¥åˆ™é™çº§
        
        Args:
            args: ä½ç½®å‚æ•°
            kwargs: å…³é”®å­—å‚æ•°
            
        Returns:
            æ‰§è¡Œç»“æœ
        """
        if self.primary_function is None:
            raise ValueError("æœªè®¾ç½®ä¸»è¦å‡½æ•°")
        
        try:
            # å°è¯•æ‰§è¡Œä¸»è¦å‡½æ•°
            print("ğŸ”„ æ‰§è¡Œä¸»è¦å‡½æ•°...")
            result = self.primary_function(*args, **kwargs)
            print("âœ… ä¸»è¦å‡½æ•°æ‰§è¡ŒæˆåŠŸ")
            return result
        
        except Exception as e:
            # ä¸»è¦å‡½æ•°å¤±è´¥ï¼Œæ‰§è¡Œé™çº§å‡½æ•°
            if self.fallback_function is None:
                raise ValueError("æœªè®¾ç½®é™çº§å‡½æ•°")
            
            print(f"âš ï¸ ä¸»è¦å‡½æ•°å¤±è´¥: {e}")
            print("ğŸ”„ æ‰§è¡Œé™çº§å‡½æ•°...")
            
            result = self.fallback_function(*args, **kwargs)
            print("âœ… é™çº§å‡½æ•°æ‰§è¡ŒæˆåŠŸ")
            
            return result

# ä½¿ç”¨ç¤ºä¾‹
def primary_data_source():
    """ä¸»è¦æ•°æ®æºï¼ˆå¯èƒ½å¤±è´¥ï¼‰"""
    # æ¨¡æ‹Ÿå¤±è´¥
    raise ConnectionError("æ•°æ®åº“è¿æ¥å¤±è´¥")

def fallback_data_source():
    """é™çº§æ•°æ®æº"""
    return {'data': [1, 2, 3, 4, 5]}

# åˆ›å»ºé™çº§ç­–ç•¥
strategy = FallbackStrategy()
strategy.set_primary(primary_data_source)
strategy.set_fallback(fallback_data_source)

# æ‰§è¡Œ
result = strategy.execute()
```

### ç†”æ–­æœºåˆ¶ (Circuit Breaker)

```python
from enum import Enum

class CircuitState(Enum):
    """ç†”æ–­å™¨çŠ¶æ€"""
    CLOSED = "closed"      # æ­£å¸¸
    OPEN = "open"          # ç†”æ–­
    HALF_OPEN = "half_open"  # åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼‰

class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(self, failure_threshold=5, 
                 success_threshold=2,
                 timeout=60):
        """
        åˆå§‹åŒ–ç†”æ–­å™¨
        
        Args:
            failure_threshold: å¤±è´¥é˜ˆå€¼ï¼ˆè¿ç»­å¤±è´¥å¤šå°‘æ¬¡åç†”æ–­ï¼‰
            success_threshold: æˆåŠŸé˜ˆå€¼ï¼ˆåŠå¼€çŠ¶æ€ä¸‹è¿ç»­æˆåŠŸå¤šå°‘æ¬¡åæ¢å¤ï¼‰
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.failure_threshold = failure_threshold
        self.success_threshold = success_threshold
        self.timeout = timeout
        
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
    
    def call(self, func, *args, **kwargs):
        """
        è°ƒç”¨å‡½æ•°ï¼ˆå¸¦ç†”æ–­ä¿æŠ¤ï¼‰
        
        Args:
            func: å‡½æ•°
            args: ä½ç½®å‚æ•°
            kwargs: å…³é”®å­—å‚æ•°
            
        Returns:
            å‡½æ•°ç»“æœ
        """
        # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        if self.state == CircuitState.OPEN:
            # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if time.time() - self.last_failure_time > self.timeout:
                # è¶…æ—¶ï¼Œè¿›å…¥åŠå¼€çŠ¶æ€
                print("ğŸ”„ ç†”æ–­å™¨è¶…æ—¶ï¼Œè¿›å…¥åŠå¼€çŠ¶æ€...")
                self.state = CircuitState.HALF_OPEN
            else:
                raise Exception("ç†”æ–­å™¨å·²æ‰“å¼€ï¼Œæ‹’ç»è°ƒç”¨")
        
        # æ‰§è¡Œå‡½æ•°
        try:
            result = func(*args, **kwargs)
            
            # æˆåŠŸ
            if self.state == CircuitState.HALF_OPEN:
                self.success_count += 1
                
                if self.success_count >= self.success_threshold:
                    # æ¢å¤
                    print("âœ… ç†”æ–­å™¨æ¢å¤")
                    self.state = CircuitState.CLOSED
                    self.success_count = 0
                    self.failure_count = 0
            else:
                # é‡ç½®å¤±è´¥è®¡æ•°
                self.failure_count = 0
            
            return result
        
        except Exception as e:
            # å¤±è´¥
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            if self.state == CircuitState.HALF_OPEN:
                # åŠå¼€çŠ¶æ€ä¸‹å¤±è´¥ï¼Œé‡æ–°ç†”æ–­
                print("ğŸ”¥ åŠå¼€çŠ¶æ€å¤±è´¥ï¼Œé‡æ–°ç†”æ–­")
                self.state = CircuitState.OPEN
                self.success_count = 0
            
            elif self.failure_count >= self.failure_threshold:
                # è¾¾åˆ°å¤±è´¥é˜ˆå€¼ï¼Œç†”æ–­
                print(f"ğŸ”¥ è¿ç»­å¤±è´¥ {self.failure_count} æ¬¡ï¼Œç†”æ–­å™¨æ‰“å¼€")
                self.state = CircuitState.OPEN
            
            raise

# ä½¿ç”¨ç¤ºä¾‹
circuit_breaker = CircuitBreaker(
    failure_threshold=5,
    success_threshold=2,
    timeout=60
)

def risky_function():
    """å¯èƒ½æœ‰é£é™©çš„å‡½æ•°"""
    # æ¨¡æ‹Ÿå¤±è´¥
    import random
    if random.random() < 0.7:
        raise Exception("æ“ä½œå¤±è´¥")
    return "æˆåŠŸ"

# æ‰§è¡Œï¼ˆå¸¦ç†”æ–­ä¿æŠ¤ï¼‰
try:
    result = circuit_breaker.call(risky_function)
    print(f"ç»“æœ: {result}")
except Exception as e:
    print(f"ç†”æ–­å™¨æ‹¦æˆª: {e}")
```

---

## ğŸ”„ ç³»ç»Ÿæ¢å¤æœºåˆ¶

### æ£€æŸ¥ç‚¹æ¢å¤ (Checkpoint & Restore)

```python
import pickle
import json
from pathlib import Path
from typing import Any

class CheckpointManager:
    """æ£€æŸ¥ç‚¹ç®¡ç†å™¨"""
    
    def __init__(self, checkpoint_dir='./checkpoints'):
        """
        åˆå§‹åŒ–æ£€æŸ¥ç‚¹ç®¡ç†å™¨
        
        Args:
            checkpoint_dir: æ£€æŸ¥ç‚¹ç›®å½•
        """
        self.checkpoint_dir = Path(checkpoint_dir)
        self.checkpoint_dir.mkdir(parents=True, exist_ok=True)
    
    def save_checkpoint(self, name: str, state: dict):
        """
        ä¿å­˜æ£€æŸ¥ç‚¹
        
        Args:
            name: æ£€æŸ¥ç‚¹åç§°
            state: çŠ¶æ€å­—å…¸
        """
        timestamp = pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')
        checkpoint_dir = self.checkpoint_dir / f"{name}_{timestamp}"
        checkpoint_dir.mkdir(exist_ok=True)
        
        # ä¿å­˜çŠ¶æ€
        with open(checkpoint_dir / 'state.pkl', 'wb') as f:
            pickle.dump(state, f)
        
        # ä¿å­˜å…ƒæ•°æ®
        metadata = {
            'name': name,
            'timestamp': timestamp,
            'state_keys': list(state.keys())
        }
        
        with open(checkpoint_dir / 'metadata.json', 'w') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
        
        print(f"âœ… æ£€æŸ¥ç‚¹å·²ä¿å­˜: {checkpoint_dir}")
    
    def load_checkpoint(self, name: str = None, 
                       checkpoint_dir: str = None) -> dict:
        """
        åŠ è½½æ£€æŸ¥ç‚¹
        
        Args:
            name: æ£€æŸ¥ç‚¹åç§°ï¼ˆå¯é€‰ï¼‰
            checkpoint_dir: æ£€æŸ¥ç‚¹ç›®å½•ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            çŠ¶æ€å­—å…¸
        """
        if checkpoint_dir:
            checkpoint_path = Path(checkpoint_dir)
        else:
            # æŸ¥æ‰¾æœ€æ–°çš„æ£€æŸ¥ç‚¹
            checkpoints = list(self.checkpoint_dir.glob(f"{name}_*"))
            if not checkpoints:
                raise FileNotFoundError(f"æ‰¾ä¸åˆ°æ£€æŸ¥ç‚¹: {name}")
            
            # æŒ‰æ—¶é—´æ’åºï¼Œå–æœ€æ–°çš„
            checkpoints.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            checkpoint_path = checkpoints[0]
        
        # åŠ è½½çŠ¶æ€
        with open(checkpoint_path / 'state.pkl', 'rb') as f:
            state = pickle.load(f)
        
        # åŠ è½½å…ƒæ•°æ®
        with open(checkpoint_path / 'metadata.json', 'r') as f:
            metadata = json.load(f)
        
        print(f"âœ… æ£€æŸ¥ç‚¹å·²åŠ è½½: {checkpoint_path}")
        print(f"  åç§°: {metadata['name']}")
        print(f"  æ—¶é—´: {metadata['timestamp']}")
        
        return state
    
    def list_checkpoints(self, name: str = None) -> list:
        """
        åˆ—å‡ºæ£€æŸ¥ç‚¹
        
        Args:
            name: æ£€æŸ¥ç‚¹åç§°ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            æ£€æŸ¥ç‚¹åˆ—è¡¨
        """
        if name:
            checkpoints = list(self.checkpoint_dir.glob(f"{name}_*"))
        else:
            checkpoints = list(self.checkpoint_dir.glob("*"))
        
        checkpoints.sort(key=lambda p: p.stat().st_mtime, reverse=True)
        
        print(f"ğŸ“‹ æ£€æŸ¥ç‚¹åˆ—è¡¨ ({len(checkpoints)} ä¸ª):")
        for i, checkpoint in enumerate(checkpoints, 1):
            # è¯»å–å…ƒæ•°æ®
            metadata_file = checkpoint / 'metadata.json'
            if metadata_file.exists():
                with open(metadata_file, 'r') as f:
                    metadata = json.load(f)
                print(f"  {i}. {checkpoint.name} ({metadata['timestamp']})")
        
        return checkpoints
    
    def delete_old_checkpoints(self, name: str = None, keep=5):
        """
        åˆ é™¤æ—§çš„æ£€æŸ¥ç‚¹
        
        Args:
            name: æ£€æŸ¥ç‚¹åç§°ï¼ˆå¯é€‰ï¼‰
            keep: ä¿ç•™çš„æ£€æŸ¥ç‚¹æ•°é‡
        """
        if name:
            checkpoints = list(self.checkpoint_dir.glob(f"{name}_*"))
        else:
            checkpoints = list(self.checkpoint_dir.glob("*"))
        
        checkpoints.sort(key=lambda p: p.stat().st_mtime, reverse=True)
        
        # åˆ é™¤æ—§çš„
        for checkpoint in checkpoints[keep:]:
            import shutil
            shutil.rmtree(checkpoint)
            print(f"ğŸ—‘ï¸ å·²åˆ é™¤: {checkpoint}")
        
        print(f"âœ… æ¸…ç†å®Œæˆï¼Œä¿ç•™äº†æœ€æ–°çš„ {keep} ä¸ªæ£€æŸ¥ç‚¹")
```

### å›æ»šæœºåˆ¶ (Rollback)

```python
class RollbackManager:
    """å›æ»šç®¡ç†å™¨"""
    
    def __init__(self, model_manager, checkpoint_manager):
        """
        åˆå§‹åŒ–å›æ»šç®¡ç†å™¨
        
        Args:
            model_manager: æ¨¡å‹ç®¡ç†å™¨
            checkpoint_manager: æ£€æŸ¥ç‚¹ç®¡ç†å™¨
        """
        self.model_manager = model_manager
        self.checkpoint_manager = checkpoint_manager
    
    def create_snapshot(self, name: str):
        """
        åˆ›å»ºå¿«ç…§ï¼ˆåŒ…å«æ¨¡å‹å’Œç³»ç»ŸçŠ¶æ€ï¼‰
        
        Args:
            name: å¿«ç…§åç§°
        """
        print(f"ğŸ“¸ åˆ›å»ºå¿«ç…§: {name}")
        
        # è·å–å½“å‰æ¨¡å‹
        model, metadata = self.model_manager.get_current_model('main')
        
        # ä¿å­˜ç³»ç»ŸçŠ¶æ€
        state = {
            'model': model,
            'model_metadata': metadata,
            'timestamp': pd.Timestamp.now().isoformat(),
            'other_state': {}  # å…¶ä»–ç³»ç»ŸçŠ¶æ€
        }
        
        # ä¿å­˜æ£€æŸ¥ç‚¹
        self.checkpoint_manager.save_checkpoint(name, state)
    
    def rollback(self, name: str):
        """
        å›æ»šåˆ°æŒ‡å®šå¿«ç…§
        
        Args:
            name: å¿«ç…§åç§°
        """
        print(f"ğŸ”„ å›æ»šåˆ°å¿«ç…§: {name}")
        
        # åŠ è½½æ£€æŸ¥ç‚¹
        state = self.checkpoint_manager.load_checkpoint(name)
        
        # æ¢å¤æ¨¡å‹
        model = state['model']
        self.model_manager.save_model(
            model=model,
            model_name='restored_model',
            metadata=state['model_metadata']
        )
        
        # æ¢å¤å…¶ä»–çŠ¶æ€
        other_state = state.get('other_state', {})
        
        print(f"âœ… å›æ»šå®Œæˆ")
        print(f"  å¿«ç…§æ—¶é—´: {state['timestamp']}")
```

### å†·å¯åŠ¨æ¢å¤ (Cold Start)

```python
class ColdStartRecovery:
    """å†·å¯åŠ¨æ¢å¤"""
    
    def __init__(self, data_manager, model_trainer):
        """
        åˆå§‹åŒ–å†·å¯åŠ¨æ¢å¤
        
        Args:
            data_manager: æ•°æ®ç®¡ç†å™¨
            model_trainer: æ¨¡å‹è®­ç»ƒå™¨
        """
        self.data_manager = data_manager
        self.model_trainer = model_trainer
    
    def recover(self, emergency_data: pd.DataFrame = None):
        """
        å†·å¯åŠ¨æ¢å¤
        
        Args:
            emergency_data: ç´§æ€¥æ•°æ®ï¼ˆå¦‚æœæ­£å¸¸æ•°æ®ä¸å¯ç”¨ï¼‰
        """
        print("ğŸš¨ å¼€å§‹å†·å¯åŠ¨æ¢å¤...")
        
        # 1. æ£€æŸ¥æ•°æ®
        try:
            # å°è¯•è·å–å†å²æ•°æ®
            print("  [1/4] è·å–å†å²æ•°æ®...")
            data = self.data_manager.fetch_historical_data(days=365)
            
            if data is None or len(data) == 0:
                raise ValueError("æ— æ³•è·å–å†å²æ•°æ®")
        
        except Exception as e:
            print(f"  âš ï¸ æ— æ³•è·å–å†å²æ•°æ®: {e}")
            
            if emergency_data is not None:
                print("  ğŸ”„ ä½¿ç”¨ç´§æ€¥æ•°æ®...")
                data = emergency_data
            else:
                raise Exception("å†·å¯åŠ¨å¤±è´¥ï¼šæ— æ³•è·å–æ•°æ®")
        
        # 2. æ•°æ®æ¸…æ´—
        print("  [2/4] æ•°æ®æ¸…æ´—...")
        data = self._clean_data(data)
        
        # 3. ç‰¹å¾å·¥ç¨‹
        print("  [3/4] ç‰¹å¾å·¥ç¨‹...")
        features = self._extract_features(data)
        
        # 4. è®­ç»ƒæ¨¡å‹
        print("  [4/4] è®­ç»ƒæ¨¡å‹...")
        model = self.model_trainer.train(features)
        
        print("âœ… å†·å¯åŠ¨æ¢å¤å®Œæˆ")
        
        return model
    
    def _clean_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """æ•°æ®æ¸…æ´—"""
        # åˆ é™¤ç¼ºå¤±å€¼è¿‡å¤šçš„åˆ—
        missing_rate = data.isna().sum() / len(data)
        data = data.drop(columns=missing_rate[missing_rate > 0.5].index)
        
        # å¡«å……ç¼ºå¤±å€¼
        data = data.fillna(method='ffill').fillna(method='bfill')
        
        return data
    
    def _extract_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """æå–ç‰¹å¾"""
        # ç®€å•ç‰¹å¾å·¥ç¨‹
        features = data.copy()
        
        # ä»·æ ¼ç›¸å…³ç‰¹å¾
        if 'close' in features.columns:
            features['returns'] = features['close'].pct_change()
            features['ma5'] = features['close'].rolling(5).mean()
            features['ma20'] = features['close'].rolling(20).mean()
        
        # åˆ é™¤ç¼ºå¤±å€¼
        features = features.dropna()
        
        return features
```

---

## ğŸ“ æœ¬èŠ‚å°ç»“

**æ ¸å¿ƒè¦ç‚¹**ï¼š

1. âœ… è¯†åˆ«æ•°æ®ã€æ¨¡å‹ã€ç³»ç»Ÿä¸‰ç±»å¼‚å¸¸
2. âœ… å®ç°é‡è¯•ã€é™çº§ã€ç†”æ–­ä¸‰ç§å¤„ç†ç­–ç•¥
3. âœ… æä¾›æ£€æŸ¥ç‚¹ã€å›æ»šã€å†·å¯åŠ¨ä¸‰ç§æ¢å¤æœºåˆ¶
4. âœ… å¼‚å¸¸å¤„ç†æ˜¯ç³»ç»Ÿå¥å£®æ€§çš„å…³é”®
5. âœ… æ¢å¤æœºåˆ¶ä¿è¯ç³»ç»ŸæŒç»­è¿è¡Œ

**å¼‚å¸¸å¤„ç†ä¸‰æ­¥èµ°**ï¼š

```python
exception_handling_steps = {
    "æ­¥éª¤1": "è¯†åˆ«å¼‚å¸¸",  # å®æ—¶ç›‘æ§
    "æ­¥éª¤2": "å¤„ç†å¼‚å¸¸",  # é™çº§ã€é‡è¯•ã€ç†”æ–­
    "æ­¥éª¤3": "æ¢å¤ç³»ç»Ÿ"   # æ£€æŸ¥ç‚¹ã€å›æ»šã€å†·å¯åŠ¨
}
```

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¼šäº†å¼‚å¸¸å¤„ç†ï¼Œæœ‰å“ªäº›**æœ€ä½³å®è·µ**å‘¢ï¼Ÿ

[â†’ å‰å¾€ 08-æœ€ä½³å®è·µ](08-æœ€ä½³å®è·µ.md)

---

**ğŸš¨ å¼‚å¸¸å¤„ç†è®©ç³»ç»Ÿæ›´ç¨³å¥ï¼Œä¸‹èŠ‚è¯¾å­¦ä¹ æœ€ä½³å®è·µï¼Œè®©ä½ çš„ç³»ç»Ÿæ›´ä¸“ä¸šï¼**
